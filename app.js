/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)
	var symbols = __webpack_require__(1)

	var tmpEl = document.createElement('div')
	tmpEl.innerHTML = symbols;
	document.body.appendChild(tmpEl.firstChild)


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" style=\"display: none;\">\n    <symbol id=\"add\" viewBox=\"0 0 32 32\">\n      <path d=\"M28 18v-4H18V4h-4v10H4v4h10v10h4V18z\"/>\n    </symbol>\n    <symbol id=\"align-center\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M28 6H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM24 14H8c-1.1 0-2-.9-2-2s.9-2 2-2h16c1.1 0 2 .9 2 2s-.9 2-2 2zM28 22H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM24 30H8c-1.1 0-2-.9-2-2s.9-2 2-2h16c1.1 0 2 .9 2 2s-.9 2-2 2z\"/></g>\n    </symbol>\n    <symbol id=\"align-justify\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M28 6H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM28 14H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM28 22H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM28 30H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2z\"/></g>\n    </symbol>\n    <symbol id=\"align-left\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M28 6H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM18 14H4c-1.1 0-2-.9-2-2s.9-2 2-2h14c1.1 0 2 .9 2 2s-.9 2-2 2zM28 22H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM18 30H4c-1.1 0-2-.9-2-2s.9-2 2-2h14c1.1 0 2 .9 2 2s-.9 2-2 2z\"/></g>\n    </symbol>\n    <symbol id=\"align-right\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M28 6H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM28 14H14c-1.1 0-2-.9-2-2s.9-2 2-2h14c1.1 0 2 .9 2 2s-.9 2-2 2zM28 22H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM28 30H14c-1.1 0-2-.9-2-2s.9-2 2-2h14c1.1 0 2 .9 2 2s-.9 2-2 2z\"/></g>\n    </symbol>\n    <symbol id=\"archive\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M30 4c0-1.3-.6-2-2-2H4c-1.3 0-2 .6-2 2v4h28V4zM4 10v18c0 1.3.6 2 2 2h20c1.3 0 2.1-.6 2.1-2V10H4z\"/><path fill=\"#fff\" d=\"M18 18v-8h-4v8H8l8 8 8-8z\"/></g>\n    </symbol>\n    <symbol id=\"audiences\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M11.5 11.4c0 1.9 1.2 3.6 2.8 4.3.6.2 1.2.4 1.8.4 2.6 0 4.7-2.1 4.7-4.7 0-1.9-1.2-3.6-2.8-4.3-.6-.2-1.2-.4-1.8-.4-2.6.1-4.7 2.1-4.7 4.7zM22.8 11.1c.4.1.7.1 1.1.1 2.6 0 4.7-2.1 4.7-4.7s-2.1-4.7-4.7-4.7c-2.2 0-4.1 1.6-4.5 3.6 2 1.3 3.3 3.3 3.4 5.7zM14.2 16C10.9 16 8 20.4 8 23.7V28.6l.3.1c3.1 1 3.8 1.2 7.6 1.2 4.4 0 7.6-1.5 7.7-1.6l.4-.3v-4.4c0-2.9-1.9-6.4-4.6-7.2-.4-.1-.8-.4-1.2-.4h-4zM8 11.3c.5 0 1-.1 1.5-.3.1-2.2 1.3-4.1 3.1-5.2-.4-2.2-2.3-3.9-4.6-3.9-2.6 0-4.6 2.1-4.6 4.7s2 4.7 4.6 4.7zM6 23.7c0-3.1 2-6.5 4.8-8.1C10 14.5 9.6 13 9.5 12H6c-3.3 0-6 2.3-6 5.6v6.3l.3.1c2.1.7 3.6 1 5.6 1.2v-1.5zM25.9 12h-3.1c0 1-.5 2.5-1.3 3.6.9.5 1.7 1.1 2.4 2.1 1.3 1.7 2.1 3.8 2.1 5.9V25c3.4-.2 5.4-.9 5.6-1h.4v-6.4c0-3.3-2.8-5.6-6.1-5.6z\"/></g>\n    </symbol>\n    <symbol id=\"calendar\" viewBox=\"0 0 32 32\">\n      <path d=\"M22 2V0h-4v2h-6V0H8v2H0v30h30V2h-8zM10 28H4v-6h6v6zm0-8H4v-6h6v6zm8 8h-6v-6h6v6zm0-8h-6v-6h6v6zm0-8H4V6h14v6zm8 16h-6v-6h6v6zm0-8h-6v-6h6v6zm0-8h-6V6h6v6z\"/>\n    </symbol>\n    <symbol id=\"clipboard\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M10 12h12v4H10zM10 20h12v4H10zM18 2V0h-4v2H2v30h28V2H18zm8 26H6V6h4v2h12V6h4v22z\"/></g>\n    </symbol>\n    <symbol id=\"close\" viewBox=\"0 0 32 32\">\n      <path d=\"M25.9 8.9l-2.8-2.8-7.1 7.1-7.1-7.1-2.8 2.8 7.1 7.1-7.1 7.1 2.8 2.8 7.1-7.1 7.1 7.1 2.8-2.8-7.1-7.1z\"/>\n    </symbol>\n    <symbol id=\"code\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M8 25.4c-.4 0-.8-.2-1.1-.5L.3 17c-.4-.5-.4-1.3 0-1.8l6.2-7.9c.5-.7 1.5-.9 2.1-.4.6.5.7 1.4.3 2L3.3 16l5.8 7c.5.6.4 1.5-.2 2-.3.2-.6.4-.9.4zM24 25.4c-.3 0-.7-.1-.9-.3-.6-.5-.7-1.4-.2-2l5.7-7.1-5.5-7c-.5-.6-.4-1.5.3-2 .6-.5 1.5-.4 2 .3l6.1 7.9c.4.5.4 1.3 0 1.8L25 24.9c-.2.3-.6.5-1 .5zM13.7 27.8c-.1 0-.2 0-.3-.1-.7-.2-1.2-.9-1.1-1.7l4.9-20.8c.2-.7 1-1.2 1.8-1 .7.2 1.2.9 1.1 1.7l-4.9 20.8c-.3.7-.9 1.1-1.5 1.1z\"/></g>\n    </symbol>\n    <symbol id=\"collaborators\" viewBox=\"0 0 32 32\">\n      <g><circle cx=\"9\" cy=\"7\" r=\"5\"/><circle cx=\"23\" cy=\"7\" r=\"5\"/><path d=\"M32 32v-.2L28 16c0-1.1-.9-2-2-2h-6c-1.1 0-2 .9-2 2v16h14zM13.9 32l.1-.2V15.9c0-1.1-1-1.9-2.1-1.9h-6c-1.1 0-1.9.8-1.9 1.9L0 31.8l-.1.2h14z\"/></g>\n    </symbol>\n    <symbol id=\"dimensions\" viewBox=\"0 0 32 32\">\n      <g><path fill=\"#fff\" d=\"M17 2L2 8l14.9 6L32 7.9 17 2z\"/><path d=\"M16 30L2 24V10l14 6zM30 12.6v9.8l-10 4.9v-9.8l10-4.9m2-2.7l-14 6v14l14-6v-14z\"/><path fill=\"#fff\" d=\"M30 12.6v9.8l-10 4.9v-9.8l10-4.9\"/><path stroke=\"#000\" stroke-width=\"2\" stroke-miterlimit=\"10\" d=\"M30 8M4 8\" fill=\"none\"/><path d=\"M17 4.1L27.2 8l-10.3 4L6.7 8 17 4.1M17 2L2 8l14.9 6L32 7.9 17 2z\"/></g>\n    </symbol>\n    <symbol id=\"duplicate\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M22 32H2c-1.1 0-2-.9-2-2V9.9c0-1.1.9-2 2-2h20c1.1 0 2 .9 2 2V30c0 1.1-.9 2-2 2zM30 0H10C8.9 0 8 .9 8 2v2h18c1.1 0 2 .8 2 1.9V24h2c1.1 0 2-.8 2-1.9V2c0-1.1-.9-2-2-2z\"/><path fill=\"#fff\" d=\"M18 18h-4v-4h-4v4H6v4h4v4h4v-4h4z\"/></g>\n    </symbol>\n    <symbol id=\"experiments\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M0 22v10h32V14l-10 6-12-4zM22 12.1l-12-4-10 6v-4L10 4l12 4 10-6.4V6z\"/></g>\n    </symbol>\n    <symbol id=\"goal\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M2 .1C3 .1 4 1 4 2v30H0V2C0 1 .9.1 2 .1zM25 6.2c2.4 0 5.5-1.3 6.9-2.3v18.6c-1.4 1-4.6 2.3-6.9 2.3s-4.5-.7-5.9-1.7c-1.4-1-2.8-1.7-5.1-1.7-2.4 0-4.5 1.5-6 2.5V5.3c1.4-1 3.6-2.5 6-2.5s3.7.7 5.1 1.7 3.5 1.7 5.9 1.7z\"/></g>\n    </symbol>\n    <symbol id=\"hamburger\" viewBox=\"0 0 32 32\">\n      <path d=\"M28 8H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM28 18H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2zM28 28H4c-1.1 0-2-.9-2-2s.9-2 2-2h24c1.1 0 2 .9 2 2s-.9 2-2 2z\"/>\n    </symbol>\n    <symbol id=\"history\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M18 2C10.9 2 5.1 7.2 4.2 14H0l6 6 6-6H7.2c.9-5.1 5.4-9 10.8-9 6.1 0 11 4.9 11 11s-4.9 11-11 11c-4 0-7.6-2.2-9.5-5.5l-2.2 2.2C8.8 27.5 13.1 30 18 30c7.7 0 14-6.3 14-14S25.7 2 18 2zM16 8h4v8h-4zM20.9 23.9L24 22l-4-6h-4z\"/></g>\n    </symbol>\n    <symbol id=\"inconclusive\" viewBox=\"0 0 32 32\">\n      <circle fill=\"#fff\" cx=\"16\" cy=\"15.9\" r=\"15.9\"/><path d=\"M16 3c7.1 0 12.9 5.8 12.9 12.9s-5.8 13-12.9 13-13-5.8-13-13S8.8 3 16 3m0-3C7.2 0 0 7.1 0 15.9s7.2 16 16 16S31.9 24.8 31.9 16 24.8 0 16 0zM14 6h4v12h-4zM14 14h10v4H14z\"/>\n    </symbol>\n    <symbol id=\"integrations\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M25.5 9.3c.1.4.2.8.2 1.2.1.8 0 1.8-.1 2.5 2.1 1.7 3.4 4.2 3.4 7 0 5-4 9-9 9s-9-4-9-9c0-4.6 3.4-8.3 7.8-8.9 0-.4-.1-1.1-.4-1.9-.2-.4-.3-.8-.5-1C12.3 9.2 8 14.1 8 20c0 6.6 5.4 12 12 12s12-5.4 12-12c0-4.6-2.6-8.7-6.5-10.7zM12 0C5.4 0 0 5.4 0 12c0 4.4 2.4 8.3 6 10.4-.1-.8-.2-1.6-.2-2 0-.4.1-1.2.2-1.7C4.1 17 3 14.6 3 12c0-5 4-9 9-9s9 4 9 9c0 4.5-3.3 8.3-7.7 8.9 0 .5 0 .9.3 1.5.3.7.4 1 .7 1.3 5.5-1.1 9.6-6 9.6-11.8C24 5.4 18.6 0 12 0z\"/></g>\n    </symbol>\n    <symbol id=\"live-variables\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M30 0h-6c-1.1 0-2 .9-2 2s.9 2 2 2h4v24h-4c-1.1 0-2 .9-2 2s.9 2 2 2h6c1.1 0 2-.9 2-2V2c0-1.1-.9-2-2-2zM2 32h6c1.1 0 2-.9 2-2s-.9-2-2-2H4V4h4c1.1 0 2-.9 2-2s-.9-2-2-2H2C.9 0 0 .9 0 2v28c0 1.1.9 2 2 2zM22.2 20.7c-.2 0-.6.1-.7.1-1.1 0-3.1-.5-3.9-3.9l5.8-5.9s1.2-1.2.4-2.3c-.3-.6-1.8-1-2.6-.2l-4.3 4.3C15 8.4 11.1 8 9.7 8S8 9.8 8 10.8c0 1 .9 2.1 2.2 2.2s3.2-.2 4.1 3.2l-5.6 5.3c-.3.3-.5.6-.5 1.1 0 .5.2.8.5 1.1.3.4.8.3 1.3.3s.9 0 1.4-.4l3.8-4.1c1.9 4.2 5.3 4.5 6.7 4.5 0 0 2.1-.1 2.1-2 0-1.2-1-1.3-1.8-1.3z\"/></g>\n    </symbol>\n    <symbol id=\"lock\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M26 12c0-5.5-4.5-10-10-10S6 6.5 6 12c-1.2 0-2 .9-2 2v16c0 1.1.8 2 1.9 2h20c1.1 0 2-.9 2-2V14c.1-1.1-.8-2-1.9-2zm-4.1 0h-13c0-3.9 3.1-7 7-7s7 3.1 7 7h-1z\"/><path fill=\"#fff\" d=\"M20 20c0-2.2-1.8-4-4-4s-4 1.8-4 4c0 1.5.8 2.8 2 3.4V26c0 1.1.9 2 2 2s2-.9 2-2v-2.6c1-.7 2-1.9 2-3.4z\"/></g>\n    </symbol>\n    <symbol id=\"loser\" viewBox=\"0 0 32 32\">\n      <circle cx=\"16\" cy=\"16\" r=\"16\"/><path fill=\"#fff\" d=\"M14 6h4v14h-4zM14 22h4v4h-4z\"/>\n    </symbol>\n    <symbol id=\"paperclip\" viewBox=\"0 0 32 32\">\n      <path d=\"M15.6 32c-4.1 0-8.2-2.4-8.2-7V6.8c0-4.5 2.9-6.8 5.8-6.8S19 2.4 19 6.8v15.8c0 2.6-1.7 3.9-3.4 3.9-.9 0-1.8-.4-2.4-1-.5-.5-1-1.4-1-2.9V8c0-.6.4-1 1-1s1 .4 1 1v14.6c0 1.3.7 1.9 1.4 1.9s1.4-.6 1.4-1.9V6.8C17 3.5 15 2 13.2 2S9.3 3.5 9.3 6.8V25c0 3.4 3.2 5 6.2 5s6.2-1.6 6.2-5V8c0-.6.4-1 1-1s1 .4 1 1v17c.1 4.6-4 7-8.1 7z\"/>\n    </symbol>\n    <symbol id=\"pause\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M6 4h8v24H6zM18 4h8v24h-8z\"/></g>\n    </symbol>\n    <symbol id=\"play\" viewBox=\"0 0 32 32\">\n      <path d=\"M4 4v24l23.9-12z\"/>\n    </symbol>\n    <symbol id=\"projects\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M2 4h4v4H2zM10 4h20v4H10zM2 14h4v4H2zM10 14h20v4H10zM2 24h4v4H2zM10 24h20v4H10z\"/></g>\n    </symbol>\n    <symbol id=\"refresh\" viewBox=\"0 0 32 32\">\n      <path d=\"M24.6 9.5l-2.2 2.2c.7 1.2 1.1 2.5 1.1 3.9 0 4.3-3.5 7.8-7.8 7.8s-7.8-3.5-7.8-7.8 3.5-7.8 7.8-7.8h.3V13l4.7-4.7 1.6-1.6L16 .5v4.4h-.3C9.8 4.9 5 9.7 5 15.6c0 5.9 4.8 10.8 10.8 10.8 5.9 0 10.8-4.8 10.8-10.8-.1-2.2-.8-4.4-2-6.1z\"/>\n    </symbol>\n    <symbol id=\"settings\" viewBox=\"0 0 32 32\">\n      <path d=\"M30.8 13.5l-3.1-.5c-.2-.9-.6-1.8-1-2.6l2-2.5c.4-.5.4-1.3 0-1.8l-1.2-1.4c-.5-.6-1.3-.7-1.8-.3L23 6.1c-1.2-.8-2.5-1.4-4-1.8l-.5-3.1C18.4.5 17.8 0 17.2 0h-1.9c-.7 0-1.3.5-1.4 1.2l-.5 3.1c-1.2.3-2.3.8-3.3 1.4L7.5 3.9c-.5-.4-1.3-.4-1.8.1L4.4 5.3c-.5.5-.5 1.3-.1 1.8l1.8 2.6c-.6 1-1.1 2.1-1.4 3.3l-3.2.5c-.7.1-1.2.7-1.2 1.4v1.9c0 .7.5 1.3 1.2 1.4l3.2.5c.2 1 .6 1.9 1 2.8l-2 2.5c-.4.5-.4 1.3 0 1.8l1.2 1.4c.5.5 1.2.6 1.8.3l2.7-1.7c1.1.8 2.4 1.4 3.8 1.7l.5 3.1c.1.7.7 1.2 1.4 1.2H17c.7 0 1.3-.5 1.4-1.2l.5-3.1c1.2-.3 2.3-.7 3.3-1.4l2.7 1.9c.5.4 1.3.3 1.8-.1l1.3-1.3c.5-.5.5-1.2.1-1.8l-1.9-2.6c.6-1 1.1-2.1 1.4-3.3l3.1-.5c.7-.1 1.2-.7 1.2-1.4v-1.9c.1-.9-.4-1.5-1.1-1.6zm-14.6 8.2c-3.3 0-5.9-2.7-5.9-5.9 0-3.3 2.7-5.9 5.9-5.9 3.3 0 5.9 2.7 5.9 5.9.1 3.3-2.6 5.9-5.9 5.9z\"/>\n    </symbol>\n    <symbol id=\"sync\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M24.6 9.5l-1.9 1.9c1.9 3.1 1.4 7.3-1.3 10-2 2-4.4 2.7-7.4 2.2v-5l-4.6 4.7-1.6 1.6 6.2 6.3v-4.8c3 .5 6.8-.5 9.3-3 3.7-3.9 4.2-9.8 1.3-13.9zM10.1 9.9C11.7 8.3 14 7.5 16 7.6v5.5l4.7-4.7 1.6-1.6L16 .5v4.4c-3 0-5.6 1-7.8 3.1-3.6 3.6-4.1 9-1.6 13.1l2-2c-1.5-2.9-1-6.7 1.5-9.2z\"/></g>\n    </symbol>\n    <symbol id=\"trash\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M8-.1h14V2H8zM2 2h26v6H2zM4 10h22v22H4z\"/></g>\n    </symbol>\n    <symbol id=\"variation-settings\" viewBox=\"0 0 32 32\">\n      <g><path d=\"M12 12.6v-.7c-.5-2.1-2-3.8-4-4.5V0H4v7.3c-2.3.8-4 3-4 5.7s1.7 4.8 4 5.7V32h4V18.7c2-.7 3.5-2.5 3.9-4.6V13s.1-.3.1-.4zM6 16c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3zM22 21.6v-.7c-.4-2.1-1.9-3.9-3.9-4.6V0h-4v16.3c-2.3.8-4 3-4 5.7s1.7 4.8 4 5.7V32h4v-4.3c2-.7 3.5-2.5 3.9-4.6v-1.5zM16 25c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3zM32 9.6v-.7c-.5-2.1-2-3.8-4-4.5V0h-4v4.3c-2 .8-4 3-4 5.7s2 4.8 4 5.7V32h4V15.7c2-.7 3.5-2.5 3.9-4.6V10s.1-.3.1-.4zM26 13c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.4 3-3 3z\"/></g>\n    </symbol>\n    <symbol id=\"winner\" viewBox=\"0 0 32 32\">\n      <circle cx=\"16\" cy=\"16\" r=\"16\"/><path fill=\"#fff\" d=\"M16.9 21.5l7.8-12.4-3.6-2.3L13.2 19l-3.6-2.3-2.3 3.6 6.8 4.5.4.3.5-.6z\"/>\n    </symbol></svg>"

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(3);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/Users/jordan/code/frontend-fork/node_modules/css-loader/index.js!/Users/jordan/code/frontend-fork/example/lego-desktop.css", function() {
			var newContent = require("!!/Users/jordan/code/frontend-fork/node_modules/css-loader/index.js!/Users/jordan/code/frontend-fork/example/lego-desktop.css");
			if(typeof newContent === 'string') newContent = [module.id, newContent, ''];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	exports.push([module.id, ".lego {\n  animation : none !important;\n  animation-delay : 0 !important;\n  animation-direction : normal !important;\n  animation-duration : 0 !important;\n  animation-fill-mode : none !important;\n  animation-iteration-count : 1 !important;\n  animation-name : none !important;\n  animation-play-state : running !important;\n  animation-timing-function : ease !important;\n  backface-visibility : visible !important;\n  background : 0 !important;\n  background-attachment : scroll !important;\n  background-clip : border-box !important;\n  background-color : transparent !important;\n  background-image : none !important;\n  background-origin : padding-box !important;\n  background-position : 0 0 !important;\n  background-position-x : 0 !important;\n  background-position-y : 0 !important;\n  background-repeat : repeat !important;\n  background-size : auto auto !important;\n  border : 0 !important;\n  border-style : none !important;\n  border-width : medium !important;\n  border-color : inherit !important;\n  border-bottom : 0 !important;\n  border-bottom-color : inherit !important;\n  border-bottom-left-radius : 0 !important;\n  border-bottom-right-radius : 0 !important;\n  border-bottom-style : none !important;\n  border-bottom-width : medium !important;\n  border-collapse : separate !important;\n  border-image : none !important;\n  border-left : 0 !important;\n  border-left-color : inherit !important;\n  border-left-style : none !important;\n  border-left-width : medium !important;\n  border-radius : 0 !important;\n  border-right : 0 !important;\n  border-right-color : inherit !important;\n  border-right-style : none !important;\n  border-right-width : medium !important;\n  border-spacing : 0 !important;\n  border-top : 0 !important;\n  border-top-color : inherit !important;\n  border-top-left-radius : 0 !important;\n  border-top-right-radius : 0 !important;\n  border-top-style : none !important;\n  border-top-width : medium !important;\n  bottom : auto !important;\n  box-shadow : none !important;\n  box-sizing : content-box !important;\n  caption-side : top !important;\n  clear : none !important;\n  clip : auto !important;\n  color : inherit !important;\n  columns : auto !important;\n  column-count : auto !important;\n  column-fill : balance !important;\n  column-gap : normal !important;\n  column-rule : medium none currentColor !important;\n  column-rule-color : currentColor !important;\n  column-rule-style : none !important;\n  column-rule-width : none !important;\n  column-span : 1 !important;\n  column-width : auto !important;\n  content : normal !important;\n  counter-increment : none !important;\n  counter-reset : none !important;\n  cursor : auto !important;\n  direction : ltr !important;\n  display : inline !important;\n  empty-cells : show !important;\n  float : none !important;\n  font : normal !important;\n  font-family : inherit !important;\n  font-size : medium !important;\n  font-style : normal !important;\n  font-variant : normal !important;\n  font-weight : normal !important;\n  height : auto !important;\n  hyphens : none !important;\n  left : auto !important;\n  letter-spacing : normal !important;\n  line-height : normal !important;\n  list-style : none !important;\n  list-style-image : none !important;\n  list-style-position : outside !important;\n  list-style-type : disc !important;\n  margin : 0 !important;\n  margin-bottom : 0 !important;\n  margin-left : 0 !important;\n  margin-right : 0 !important;\n  margin-top : 0 !important;\n  max-height : none !important;\n  max-width : none !important;\n  min-height : 0 !important;\n  min-width : 0 !important;\n  opacity : 1 !important;\n  orphans : 0 !important;\n  outline : 0 !important;\n  outline-color : invert !important;\n  outline-style : none !important;\n  outline-width : medium !important;\n  overflow : visible !important;\n  overflow-x : visible !important;\n  overflow-y : visible !important;\n  padding : 0 !important;\n  padding-bottom : 0 !important;\n  padding-left : 0 !important;\n  padding-right : 0 !important;\n  padding-top : 0 !important;\n  page-break-after : auto !important;\n  page-break-before : auto !important;\n  page-break-inside : auto !important;\n  perspective : none !important;\n  perspective-origin : 50% 50% !important;\n  position : static !important;\n  /* May need to alter quotes for different locales (e.g fr) */\n  quotes : '\\201C' '\\201D' '\\2018' '\\2019' !important;\n  right : auto !important;\n  tab-size : 8 !important;\n  table-layout : auto !important;\n  text-align : inherit !important;\n  text-align-last : auto !important;\n  text-decoration : none !important;\n  text-decoration-color : inherit !important;\n  text-decoration-line : none !important;\n  text-decoration-style : solid !important;\n  text-indent : 0 !important;\n  text-shadow : none !important;\n  text-transform : none !important;\n  top : auto !important;\n  transform : none !important;\n  transform-style : flat !important;\n  transition : none !important;\n  transition-delay : 0s !important;\n  transition-duration : 0s !important;\n  transition-property : none !important;\n  transition-timing-function : ease !important;\n  unicode-bidi : normal !important;\n  vertical-align : baseline !important;\n  visibility : visible !important;\n  white-space : normal !important;\n  widows : 0 !important;\n  width : auto !important;\n  word-spacing : normal !important;\n  z-index : auto !important;\n  font-size: 10px !important;\n  background: white !important;\n  display: flex !important;\n}\n\n.lego h1,\n.lego h2,\n.lego h3,\n.lego h4,\n.lego h5,\n.lego h6 {\n\n  color: #262626 !important;\n  letter-spacing: 0 !important;\n  text-transform: none !important;\n  text-shadow: none !important; }\n\n.reveal h1 {\n  text-shadow: 0px 0px 6px rgba(0, 0, 0, 0.2); }\n.lego ul li {\n  margin-bottom: 0 !important;\n}\n\n.lego ul.lego-sections {\n  list-style-type: none !important;\n  margin-left: 0 !important;\n}\n\n\n\n.lego html, .lego body, .lego div, .lego span, .lego applet, .lego object, .lego iframe,\n.lego h1, .lego h2, .lego h3, .lego h4, .lego h5, .lego h6, .lego p, .lego blockquote, .lego pre,\n.lego a, .lego abbr, .lego acronym, .lego address, .lego big, .lego cite, .lego code,\n.lego del, .lego dfn, .lego em, .lego img, .lego ins, .lego kbd, .lego q, .lego s, .lego samp,\n.lego small, .lego strike, .lego strong, .lego sub, .lego sup, .lego tt, .lego var,\n.lego b, .lego u, .lego i, .lego center,\n.lego dl, .lego dt, .lego dd, .lego ol, .lego ul, .lego li,\n.lego fieldset, .lego form, .lego label, .lego legend,\n.lego table, .lego caption, .lego tbody, .lego tfoot, .lego thead, .lego tr, .lego th, .lego td,\n.lego article, .lego aside, .lego canvas, .lego details, .lego embed,\n.lego figure, .lego figcaption, .lego footer, .lego header, .lego hgroup,\n.lego menu, .lego nav, .lego output, .lego ruby, .lego section, .lego summary,\n.lego time, .lego mark, .lego audio, .lego video {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font: inherit;\n  font-size: 100%;\n  vertical-align: baseline; }\n.lego html {\n  line-height: 1; }\n.lego ol, .lego ul {\n  list-style: none; }\n.lego table {\n  border-collapse: collapse;\n  border-spacing: 0; }\n.lego caption, .lego th, .lego td {\n  text-align: left;\n  font-weight: normal;\n  vertical-align: middle; }\n.lego q, .lego blockquote {\n  quotes: none; }\n  .lego q:before, .lego q:after, .lego blockquote:before, .lego blockquote:after {\n    content: \"\";\n    content: none; }\n.lego a img {\n  border: none; }\n.lego article, .lego aside, .lego details, .lego figcaption, .lego figure, .lego footer, .lego header, .lego hgroup, .lego main, .lego menu, .lego nav, .lego section, .lego summary {\n  display: block; }\n.lego .cf:after {\n  content: '';\n  display: table;\n  clear: both; }\n.lego .lego-matrix,\n.lego .lego-grid,\n.lego .lego-pane-group,\n.lego .lego-pane--flex,\n.lego .lego-pane--empty, .lego .lego-array, .lego .lego-icon-input, .lego .accordion, .lego .accordion__link, .lego .accordion__item,\n.lego .lego-button-group, .lego .lego-dialog__close,\n.lego .lego-media,\n.lego .lego-nav,\n.lego .lego-nav--fit, .lego .lego-overlay,\n.lego .lego-stat-group,\n.lego .lego-steps, .lego .lego-tabs-nav, .lego .lego-project-drawer, .lego .lego-top-nav,\n.lego .flex {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex; }\n.lego .lego-grid__cell,\n.lego .lego-pane--flex-1, .lego .lego-array__item, .lego .accordion__item--active, .lego .accordion__content-wrap,\n.lego .lego-button-group > .lego-text-input,\n.lego .lego-media__body,\n.lego .lego-nav--fit > li,\n.lego .lego-steps__item, .lego .lego-project-drawer .lego-block-list,\n.lego .flex-1 {\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1; }\n.lego .lego-matrix,\n.lego .lego-grid,\n.lego .flex-wrap--wrap {\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap; }\n.lego .flex-wrap--nowrap {\n  -webkit-flex-wrap: nowrap;\n  -ms-flex-wrap: nowrap;\n  flex-wrap: nowrap; }\n.lego .lego-pane-group--column, .lego .accordion, .lego .accordion__item, .lego .lego-project-drawer,\n.lego .flex-direction--column {\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column; }\n.lego .justify-content--space-between {\n  -webkit-justify-content: space-between;\n  -ms-flex-pack: justify;\n  justify-content: space-between; }\n.lego .lego-pane--empty, .lego .lego-dialog__close,\n.lego .lego-nav--center, .lego .lego-pagination, .lego .lego-overlay,\n.lego .lego-steps, .lego .lego-tabs--center .lego-tabs-nav,\n.lego .justify-content--center {\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center; }\n.lego .lego-grid--center,\n.lego .lego-pane--empty, .lego .lego-icon-input, .lego .accordion__link, .lego .lego-dialog__close, .lego .lego-overlay,\n.lego .align-items--center {\n  -webkit-align-items: center;\n  -ms-flex-align: center;\n  align-items: center; }\n.lego .lego-grid--bottom,\n.lego .align-items--flex-end {\n  -webkit-align-items: flex-end;\n  -ms-flex-align: end;\n  align-items: flex-end; }\n.lego .lego-media,\n.lego .align-items--flex-start {\n  -webkit-align-items: flex-start;\n  -ms-flex-align: start;\n  align-items: flex-start; }\n.lego .lego-matrix,\n.lego .lego-grid {\n  margin-left: -20px; }\n  .lego .lego-grid__cell {\n    padding-left: 20px; }\n  .lego .lego-grid--gutter--narrow {\n    margin-left: -10px; }\n    .lego .lego-grid--gutter--narrow > .lego-grid__cell {\n      padding-left: 10px; }\n  .lego .lego-grid--gutter--wide {\n    margin-left: -40px; }\n    .lego .lego-grid--gutter--wide > .lego-grid__cell {\n      padding-left: 40px; }\n  .lego .lego-grid--flush {\n    margin-left: 0; }\n    .lego .lego-grid--flush > .lego-grid__cell {\n      padding-left: 0; }\n  .lego .lego-grid__cell[class*=\"width-\"] {\n    -webkit-flex: none;\n    -ms-flex: none;\n    flex: none; }\n.lego .lego-pane--full {\n  height: 100%; }\n.lego .lego-pane--scroll-y {\n  overflow-y: auto; }\n.lego .lego-array__item {\n  border: 1px solid #e0e0e0;\n  padding: 20px;\n  margin-left: 10px;\n  margin-right: 10px; }\n  .lego .lego-array__item:first-child {\n    margin-left: 0; }\n  .lego .lego-array__item:last-child {\n    margin-right: 0; }\n.lego .lego-fence--soft {\n  padding-left: 20px;\n  padding-right: 20px; }\n.lego .lego-fence--push {\n  margin-left: 20px;\n  margin-right: 20px; }\n.lego .empty-state-message {\n  color: #a5a5a5;\n  font-size: 14px;\n  text-align: center; }\n.lego .full-screen {\n  position: absolute;\n  width: 100%;\n  height: 100%; }\n.lego .width-1 {\n  width: 100%; }\n.lego .width-2-4, .lego .width-3-6, .lego .width-4-8, .lego .width-5-10, .lego .width-6-12,\n.lego .lego-matrix--1-2 > li,\n.lego .width-1-2 {\n  width: 50%; }\n.lego .width-2-6, .lego .width-4-12,\n.lego .lego-matrix--1-3 > li,\n.lego .width-1-3 {\n  width: 33.333%; }\n.lego .width-4-6, .lego .width-8-12,\n.lego .width-2-3 {\n  width: 66.666%; }\n.lego .width-2-8, .lego .width-3-12,\n.lego .lego-matrix--1-4 > li,\n.lego .width-1-4 {\n  width: 25%; }\n.lego .width-6-8, .lego .width-9-12,\n.lego .width-3-4 {\n  width: 75%; }\n.lego .width-2-10,\n.lego .width-1-5 {\n  width: 20%; }\n.lego .width-4-10,\n.lego .width-2-5 {\n  width: 40%; }\n.lego .width-6-10,\n.lego .width-3-5 {\n  width: 60%; }\n.lego .width-8-10,\n.lego .width-4-5 {\n  width: 80%; }\n.lego .width-2-12,\n.lego .width-1-6 {\n  width: 16.666%; }\n.lego .width-ten-12,\n.lego .width-5-6 {\n  width: 83.333%; }\n.lego .width-1-8 {\n  width: 12.5%; }\n.lego .width-3-8 {\n  width: 37.5%; }\n.lego .width-5-8 {\n  width: 62.5%; }\n.lego .width-7-8 {\n  width: 87.5%; }\n.lego .width-1-10 {\n  width: 10%; }\n.lego .width-3-10 {\n  width: 30%; }\n.lego .width-7-10 {\n  width: 70%; }\n.lego .width-9-10 {\n  width: 90%; }\n.lego .width-1-12 {\n  width: 8.333%; }\n.lego .width-5-12 {\n  width: 41.666%; }\n.lego .width-7-12 {\n  width: 58.333%; }\n.lego .width-11-12 {\n  width: 91.666%; }\n.lego *, .lego *:before, .lego *:after {\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box; }\n.lego body {\n  margin: 0; }\n.lego h1,\n.lego h2,\n.lego h3,\n.lego h4,\n.lego h5,\n.lego h6,\n.lego p,\n.lego blockquote,\n.lego pre,\n.lego dl,\n.lego dd,\n.lego ol,\n.lego ul,\n.lego form,\n.lego fieldset,\n.lego legend,\n.lego table,\n.lego th,\n.lego td,\n.lego caption,\n.lego hr {\n  margin: 0;\n  padding: 0; }\n.lego ol,\n.lego ul {\n  list-style: none; }\n.lego h1,\n.lego h2,\n.lego h3,\n.lego h4,\n.lego h5,\n.lego h6 {\n  font-weight: 400; }\n.lego table {\n  border-collapse: collapse;\n  border-spacing: 0; }\n.lego abbr[title],\n.lego dfn[title] {\n  cursor: help; }\n.lego u,\n.lego ins {\n  text-decoration: none; }\n.lego ins {\n  border-bottom: 1px solid; }\n.lego img {\n  font-style: italic; }\n.lego button,\n.lego select,\n.lego option,\n.lego input[type=\"checkbox\"] + label,\n.lego input[type=\"radio\"] + label {\n  cursor: pointer; }\n.lego [type=text]:active,\n.lego [type=text]:focus,\n.lego [type=password]:active,\n.lego [type=password]:focus,\n.lego [type=email]:active,\n.lego [type=email]:focus,\n.lego textarea:active,\n.lego textarea:focus {\n  cursor: text;\n  outline: none; }\n.lego a {\n  text-decoration: none; }\n.lego a:active,\n.lego a:hover {\n  outline: 0; }\n.lego sub,\n.lego sup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline; }\n.lego sup {\n  top: -0.5em; }\n.lego sub {\n  bottom: -0.25em; }\n.lego em,\n.lego b,\n.lego strong {\n  font-style: normal;\n  font-weight: 500; }\n.lego fieldset {\n  border: 0; }\n.lego textarea {\n  vertical-align: top; }\n.lego input[type=\"search\"] {\n  -webkit-appearance: textfield;\n  -webkit-box-sizing: content-box;\n  box-sizing: content-box; }\n.lego button[disabled],\n.lego html input[disabled] {\n  cursor: default; }\n.lego button,\n.lego select {\n  text-transform: none; }\n.lego button,\n.lego input,\n.lego select,\n.lego textarea {\n  font-family: inherit;\n  font-size: 100%;\n  margin: 0; }\n.lego input[type=\"search\"]::-webkit-search-cancel-button,\n.lego input[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none; }\n.lego button,\n.lego html input[type=\"button\"],\n.lego input[type=\"reset\"],\n.lego input[type=\"submit\"] {\n  -webkit-appearance: button;\n  cursor: pointer; }\n.lego {\n  -webkit-font-smoothing: subpixel-antialiased;\n  -moz-osx-font-smoothing: auto;\n  color: #262626 !important;\n  background-color: white !important;}\n.lego p {\n  margin-bottom: 10px; }\n.lego b {\n  font-weight: 500; }\n.lego code {\n  font-family: monospace; }\n.lego .lego-pre {\n  margin-bottom: 10px; }\n  .lego .lego-pre code {\n    padding: 10px;\n    background: #f7f7f7;\n    overflow-x: auto;\n    display: block;\n    border-radius: 2px;\n    border: 1px solid #e0e0e0; }\n.lego .lego-code {\n  background: #f7f7f7;\n  border-radius: 2px;\n  border: 1px solid #e0e0e0;\n  padding: 1px 3px; }\n.lego .lego-form--small {\n  font-size: 10px; }\n.lego .lego-text-input,\n.lego .lego-textarea {\n  transition: border-color 0.3s;\n  transition: border-color 0.3s;\n  transition: border-color 0.3s;\n  transition: border-color 0.3s;\n  width: 100%;\n  border: 1px solid #e0e0e0;\n  border-radius: 2px;\n  padding: 7px;\n  vertical-align: middle;\n  line-height: 1.3; }\n  .lego .lego-text-input--small,\n  .lego .lego-textarea--small {\n    padding-top: 2px;\n    padding-bottom: 2px; }\n  .lego .lego-text-input:focus,\n  .lego .lego-textarea:focus {\n    border-color: #9acce2; }\n  .lego .lego-text-input[disabled],\n  .lego .lego-textarea[disabled] {\n    background: #f7f7f7; }\n.lego .lego-textarea {\n  height: 62px;\n  resize: vertical; }\n  .lego .lego-textarea--tall {\n    height: 100px; }\n.lego .lego-select {\n  display: inline-block;\n  height: 31px;\n  line-height: 31px;\n  background: white;\n  border: 1px solid #e0e0e0;\n  border-radius: 2px;\n  padding: 7px; }\n.lego .lego-form__header {\n  margin-bottom: 20px; }\n.lego .lego-form__footer {\n  margin-top: 30px; }\n.lego .lego-form__title {\n  font-size: 20px;\n  margin-bottom: 10px;\n  line-height: 1;\n  letter-spacing: -1px; }\n.lego .lego-form-fields {\n  list-style: none;\n  margin: 0; }\n.lego .lego-form-field__item {\n  margin-bottom: 15px; }\n.lego fieldset {\n  margin-bottom: 40px; }\n.lego .lego-label {\n  display: block;\n  margin-bottom: 5px;\n  font-weight: 500; }\n  .lego .lego-label--optional:after {\n    content: '(Optional)';\n    margin-left: 5px;\n    color: #a5a5a5;\n    font-size: 10px;\n    font-weight: 400; }\n  .lego .lego-label--rule {\n    border-bottom: 1px solid #e0e0e0;\n    padding-bottom: 5px; }\n  .lego .lego-label--disabled {\n    color: #a5a5a5;\n    cursor: default !important; }\n.lego .lego-check-label,\n.lego .lego-input-list .lego-label {\n  display: table-cell;\n  padding-left: 10px;\n  font-weight: 300; }\n.lego .lego-input-list {\n  list-style: none;\n  margin: 0; }\n  .lego .lego-input-list > li {\n    display: table;\n    margin-bottom: 5px; }\n  .lego .lego-input-list input {\n    display: table-cell; }\n  .lego .lego-input-list .lego-label {\n    width: 100%; }\n  .lego .lego-input-list--horizontal > li {\n    padding-right: 20px;\n    display: inline-block; }\n  .lego .lego-input-list--horizontal .lego-label {\n    display: inline;\n    padding-left: 6px; }\n.lego .lego-input--disabled {\n  background-color: #efefef; }\n.lego .lego-or {\n  text-align: center;\n  color: #262626;\n  text-transform: uppercase;\n  margin: 15px auto;\n  position: relative; }\n  .lego .lego-or:before, .lego .lego-or:after {\n    content: '';\n    border-top: 1px dotted #e0e0e0;\n    width: 40%;\n    position: absolute;\n    left: 0;\n    top: 50%; }\n  .lego .lego-or:after {\n    left: auto;\n    right: 0; }\n.lego .lego-icon-input > input {\n  z-index: 1;\n  background: transparent; }\n.lego .lego-icon-input .lego-icon-input__icon {\n  margin-left: -25px;\n  line-height: 1; }\n.lego .lego-form-bad-news .lego-label {\n  color: #c6400c; }\n.lego .lego-form-bad-news [type=text],\n.lego .lego-form-bad-news [type=password],\n.lego .lego-form-bad-news .lego-select,\n.lego .lego-form-bad-news .lego-textarea {\n  border-color: #c6400c; }\n.lego .lego-form-note {\n  padding-top: 5px;\n  font-size: 10px; }\n.lego .lego-form-note--bad-news {\n  color: #c6400c; }\n.lego img {\n  display: block;\n  max-width: 100%; }\n.lego figure > img {\n  display: block; }\n.lego a img {\n  border: 0; }\n.lego img[width],\n.lego img[height] {\n  max-width: none; }\n.lego .img--round {\n  border-radius: 2px; }\n.lego .img--circle {\n  border-radius: 100%; }\n.lego .img--border {\n  border: 1px solid #e0e0e0; }\n.lego .img--right {\n  float: right;\n  margin-bottom: 10px;\n  margin-left: 10px; }\n.lego .img--left {\n  float: left;\n  margin-right: 10px;\n  margin-bottom: 10px; }\n.lego .img--center {\n  display: block;\n  margin-right: auto;\n  margin-bottom: 10px;\n  margin-left: auto; }\n.lego a,\n.lego .link {\n  color: #0081ba !important;\n  cursor: pointer; }\n  .lego a:visited, .lego a:active,\n  .lego .link:visited,\n  .lego .link:active {\n    color: #0081ba !important; }\n  .lego a:hover,\n  .lego .link:hover {\n    color: #00a4ed !important; }\n.lego .link--dark {\n  color: #262626;\n  cursor: pointer; }\n  .lego .link--dark:visited,\n  .lego .link--dark:active {\n    color: #262626; }\n  .lego .link--dark:hover {\n    color: #0081ba; }\n.lego .link--bad-news {\n  color: #262626;\n  cursor: pointer; }\n  .lego .link--bad-news:visited,\n  .lego .link--bad-news:hover,\n  .lego .link--bad-news:active {\n    color: #c6400c; }\n.lego .lego-top-nav a,\n.lego .link--reverse {\n  color: white !important;\n  cursor: pointer; }\n  .lego .lego-top-nav a:hover,\n  .lego .link--reverse:hover {\n    color: #d5eaf3 !important; }\n.lego .link--disabled {\n  color: #a5a5a5; }\n  .lego .link--disabled:visited,\n  .lego .link--disabled:hover,\n  .lego .link--disabled:active {\n    color: #a5a5a5;\n    cursor: default; }\n.lego a:not([href]) {\n  color: #0081ba; }\n  .lego a:not([href]):visited, .lego a:not([href]):hover, .lego a:not([href]):active {\n    color: #0081ba;\n    cursor: default; }\n.lego .lego-list {\n  margin-bottom: 10px; }\n  .lego .lego-list--bullet {\n    margin-left: 20px;\n    list-style-type: disc; }\n  .lego .lego-list--numbered {\n    margin-left: 25px;\n    list-style-type: decimal; }\n  .lego .lego-list--lower-alpha {\n    margin-left: 25px;\n    list-style-type: lower-alpha; }\n  .lego .lego-list--spaced > li {\n    margin-bottom: 5px; }\n.lego li > ul,\n.lego li > ol {\n  margin-bottom: 0; }\n.lego .lego-table {\n  width: 100%;\n  font-size: inherit; }\n  .lego .lego-table th,\n  .lego .lego-table td {\n    padding-left: 20px;\n    padding-top: 5px;\n    padding-bottom: 5px; }\n    .lego .lego-table th:first-child,\n    .lego .lego-table td:first-child {\n      padding-left: 0; }\n  .lego .lego-table th {\n    text-transform: uppercase;\n    font-weight: 500;\n    font-size: 10px;\n    color: #a5a5a5;\n    text-align: left; }\n    .lego .lego-table th[field] {\n      cursor: pointer; }\n  .lego .lego-table td {\n    vertical-align: top; }\n  .lego .lego-table [rowspan] {\n    vertical-align: middle; }\n  .lego .lego-table [rowspan=\"1\"] {\n    vertical-align: top; }\n  .lego .lego-table [colspan] {\n    text-align: center; }\n  .lego .lego-table [colspan=\"1\"] {\n    text-align: left; }\n  .lego .lego-table .numerical {\n    text-align: right; }\n  .lego .lego-table .cell-collapse {\n    width: 1%; }\n  .lego .lego-table--dashboard > thead > th,\n  .lego .lego-table--rule > thead > th {\n    padding-bottom: 10px; }\n  .lego .lego-table--dashboard > thead > tr,\n  .lego .lego-table--rule > thead > tr {\n    border-bottom: 1px solid #e0e0e0; }\n  .lego .lego-table--dashboard > tbody > tr,\n  .lego .lego-table--rule > tbody > tr {\n    border-bottom: 1px solid #efefef; }\n    .lego .lego-table--dashboard > tbody > tr:first-child,\n    .lego .lego-table--rule > tbody > tr:first-child {\n      border-bottom: 1px solid #efefef; }\n  .lego .lego-table--wall > thead > tr > th,\n  .lego .lego-table--wall > tbody > tr > td {\n    border-left: 1px solid #efefef;\n    padding-right: 10px; }\n    .lego .lego-table--wall > thead > tr > th:first-child,\n    .lego .lego-table--wall > tbody > tr > td:first-child {\n      border-left: 0; }\n  .lego .lego-table--dashboard > tbody > tr:hover,\n  .lego .lego-table--hover > tbody > tr:hover {\n    background-color: #f2f7fc;\n    cursor: pointer; }\n  .lego .lego-table--dashboard > thead > tr > th:first-child,\n  .lego .lego-table--dashboard > tbody > tr > td:first-child,\n  .lego .lego-table--hover > thead > tr > th:first-child,\n  .lego .lego-table--hover > tbody > tr > td:first-child {\n    padding-left: 10px; }\n  .lego .lego-table--dashboard > thead > tr > th:last-child,\n  .lego .lego-table--dashboard > tbody > tr > td:last-child,\n  .lego .lego-table--hover > thead > tr > th:last-child,\n  .lego .lego-table--hover > tbody > tr > td:last-child {\n    padding-right: 10px; }\n.lego .lego-table-row--active {\n  background-color: #f7f7f7; }\n.lego .editable:hover {\n  color: #a5a5a5; }\n  .lego .editable:hover:after {\n    color: #a5a5a5;\n    content: '\\270E';\n    font-size: 1em;\n    padding-left: 5px; }\n.lego .monospace {\n  font-family: monospace; }\n.lego .accordion__link {\n  transition-property: height;\n  transition-property: height;\n  transition-property: height;\n  transition-property: height;\n  transition-duration: 0.3s;\n  transition-duration: 0.3s;\n  transition-duration: 0.3s;\n  transition-duration: 0.3s;\n  font-size: 11px;\n  padding: 0 20px;\n  background: #f7f7f7;\n  line-height: 1;\n  height: 26px;\n  box-shadow: inset 0 1px 0 #e0e0e0;\n  font-weight: 500;\n  text-transform: uppercase; }\n  .lego .accordion__link:hover {\n    background: #efefef;\n    color: #262626; }\n  .lego .accordion__link:before {\n    content: \"+\";\n    margin-left: -10px;\n    width: 10px;\n    display: inline-block; }\n.lego .accordion__item {\n  height: 26px;\n  overflow: hidden; }\n  .lego .accordion__item:first-child .accordion__link {\n    box-shadow: none; }\n  .lego .accordion__item--active .accordion__link {\n    height: 0;\n    overflow: hidden; }\n  .lego .accordion__item--empty .accordion__content-wrap {\n    display: flex;\n    justify-content: center;\n    align-items: center; }\n  .lego .accordion__item--empty .accordion__content {\n    flex: 1; }\n.lego .accordion__content-wrap {\n  overflow-y: auto; }\n.lego .accordion__content {\n  padding: 20px; }\n.lego .lego-notification,\n.lego .lego-attention {\n  padding: 10px;\n  border-radius: 2px;\n  border: 1px solid #e0e0e0;\n  background: #f7f7f7; }\n  .lego .lego-notification--brand,\n  .lego .lego-attention--brand {\n    border-color: #9acce2;\n    background-color: #f2f7fc; }\n  .lego .lego-notification--warning,\n  .lego .lego-attention--warning {\n    border-color: #ffd40c;\n    background-color: #fcf8e3; }\n  .lego .lego-notification--good-news,\n  .lego .lego-attention--good-news {\n    border-color: #97c70a;\n    background-color: #e9f6c3; }\n  .lego .lego-notification--bad-news,\n  .lego .lego-attention--bad-news {\n    border-color: #c6400c;\n    background-color: #f9e3e4; }\n.lego .lego-pop-tip--arrow-top-center, .lego .lego-pop-tip--arrow-top-left, .lego .lego-pop-tip--arrow-top-right,\n.lego .lego-popover--arrow-top, .lego .lego-pop-tip--arrow-left, .lego .lego-pop-tip--arrow-right,\n.lego .lego-popover--arrow-left,\n.lego .lego-popover--arrow-right, .lego .lego-pop-tip--arrow-bottom-center, .lego .lego-pop-tip--arrow-bottom-left, .lego .lego-pop-tip--arrow-bottom-right,\n.lego .lego-popover--arrow-bottom {\n  position: relative; }\n  .lego .lego-pop-tip--arrow-top-center:before, .lego .lego-pop-tip--arrow-top-left:before, .lego .lego-pop-tip--arrow-top-right:before,\n  .lego .lego-popover--arrow-top:before, .lego .lego-pop-tip--arrow-left:before, .lego .lego-pop-tip--arrow-right:before,\n  .lego .lego-popover--arrow-left:before,\n  .lego .lego-popover--arrow-right:before, .lego .lego-pop-tip--arrow-bottom-center:before, .lego .lego-pop-tip--arrow-bottom-left:before, .lego .lego-pop-tip--arrow-bottom-right:before,\n  .lego .lego-popover--arrow-bottom:before, .lego .lego-pop-tip--arrow-top-center:after, .lego .lego-pop-tip--arrow-top-left:after, .lego .lego-pop-tip--arrow-top-right:after,\n  .lego .lego-popover--arrow-top:after, .lego .lego-pop-tip--arrow-left:after, .lego .lego-pop-tip--arrow-right:after,\n  .lego .lego-popover--arrow-left:after,\n  .lego .lego-popover--arrow-right:after, .lego .lego-pop-tip--arrow-bottom-center:after, .lego .lego-pop-tip--arrow-bottom-left:after, .lego .lego-pop-tip--arrow-bottom-right:after,\n  .lego .lego-popover--arrow-bottom:after {\n    content: '';\n    position: absolute;\n    border-collapse: separate;\n    pointer-events: none; }\n  .lego .lego-pop-tip--arrow-top-center:before, .lego .lego-pop-tip--arrow-top-left:before, .lego .lego-pop-tip--arrow-top-right:before,\n  .lego .lego-popover--arrow-top:before, .lego .lego-pop-tip--arrow-left:before, .lego .lego-pop-tip--arrow-right:before,\n  .lego .lego-popover--arrow-left:before,\n  .lego .lego-popover--arrow-right:before, .lego .lego-pop-tip--arrow-bottom-center:before, .lego .lego-pop-tip--arrow-bottom-left:before, .lego .lego-pop-tip--arrow-bottom-right:before,\n  .lego .lego-popover--arrow-bottom:before {\n    border: 6px solid transparent; }\n  .lego .lego-pop-tip--arrow-top-center:after, .lego .lego-pop-tip--arrow-top-left:after, .lego .lego-pop-tip--arrow-top-right:after,\n  .lego .lego-popover--arrow-top:after, .lego .lego-pop-tip--arrow-left:after, .lego .lego-pop-tip--arrow-right:after,\n  .lego .lego-popover--arrow-left:after,\n  .lego .lego-popover--arrow-right:after, .lego .lego-pop-tip--arrow-bottom-center:after, .lego .lego-pop-tip--arrow-bottom-left:after, .lego .lego-pop-tip--arrow-bottom-right:after,\n  .lego .lego-popover--arrow-bottom:after {\n    border: 5px solid transparent; }\n.lego .lego-pop-tip--arrow-top-center:before, .lego .lego-pop-tip--arrow-top-left:before, .lego .lego-pop-tip--arrow-top-right:before,\n.lego .lego-popover--arrow-top:before, .lego .lego-pop-tip--arrow-top-center:after, .lego .lego-pop-tip--arrow-top-left:after, .lego .lego-pop-tip--arrow-top-right:after,\n.lego .lego-popover--arrow-top:after {\n  bottom: 100%; }\n.lego .lego-pop-tip--arrow-left:before, .lego .lego-pop-tip--arrow-right:before,\n.lego .lego-popover--arrow-left:before,\n.lego .lego-popover--arrow-right:before, .lego .lego-pop-tip--arrow-left:after, .lego .lego-pop-tip--arrow-right:after,\n.lego .lego-popover--arrow-left:after,\n.lego .lego-popover--arrow-right:after {\n  top: 50%;\n  margin-top: -6px; }\n.lego .lego-pop-tip--arrow-left:after, .lego .lego-pop-tip--arrow-right:after,\n.lego .lego-popover--arrow-left:after,\n.lego .lego-popover--arrow-right:after {\n  margin-top: -5px; }\n.lego .lego-pop-tip--arrow-bottom-center:before, .lego .lego-pop-tip--arrow-bottom-left:before, .lego .lego-pop-tip--arrow-bottom-right:before,\n.lego .lego-popover--arrow-bottom:before, .lego .lego-pop-tip--arrow-bottom-center:after, .lego .lego-pop-tip--arrow-bottom-left:after, .lego .lego-pop-tip--arrow-bottom-right:after,\n.lego .lego-popover--arrow-bottom:after {\n  top: 100%; }\n.lego .lego-pop-tip--arrow-left:before,\n.lego .lego-popover--arrow-left:before, .lego .lego-pop-tip--arrow-left:after,\n.lego .lego-popover--arrow-left:after {\n  right: 100%; }\n.lego .lego-pop-tip--arrow-top-left:before, .lego .lego-pop-tip--arrow-bottom-left:before {\n  left: 5px; }\n.lego .lego-pop-tip--arrow-top-left:after, .lego .lego-pop-tip--arrow-bottom-left:after {\n  left: 6px; }\n.lego .lego-pop-tip--arrow-top-center:before, .lego .lego-pop-tip--arrow-bottom-center:before,\n.lego .lego-popover--arrow-top:before,\n.lego .lego-popover--arrow-bottom:before, .lego .lego-pop-tip--arrow-top-center:after, .lego .lego-pop-tip--arrow-bottom-center:after,\n.lego .lego-popover--arrow-top:after,\n.lego .lego-popover--arrow-bottom:after {\n  left: 50%;\n  margin-left: -6px; }\n.lego .lego-pop-tip--arrow-top-center:after, .lego .lego-pop-tip--arrow-bottom-center:after,\n.lego .lego-popover--arrow-top:after,\n.lego .lego-popover--arrow-bottom:after {\n  margin-left: -5px; }\n.lego .lego-pop-tip--arrow-top-right:before, .lego .lego-pop-tip--arrow-bottom-right:before {\n  right: 5px; }\n.lego .lego-pop-tip--arrow-top-right:after, .lego .lego-pop-tip--arrow-bottom-right:after {\n  right: 6px; }\n.lego .lego-pop-tip--arrow-right:before,\n.lego .lego-popover--arrow-right:before, .lego .lego-pop-tip--arrow-right:after,\n.lego .lego-popover--arrow-right:after {\n  left: 100%; }\n.lego .lego-arrow-inline--up,\n.lego .lego-arrow-inline--down, .lego #ui-datepicker-div .ui-datepicker-next:before,\n.lego .lego-arrow-inline--right, .lego #ui-datepicker-div .ui-datepicker-prev:before,\n.lego .lego-arrow-inline--left,\n.lego .lego-arrow-inline {\n  display: inline-block;\n  width: 0;\n  height: 0;\n  margin-top: -2px;\n  margin-left: 2px;\n  vertical-align: middle; }\n  .lego .lego-arrow-inline--up {\n    border-bottom: 4px solid currentColor;\n    border-right: 4px solid transparent;\n    border-left: 4px solid transparent; }\n  .lego .lego-arrow-inline--down {\n    border-top: 4px solid currentColor;\n    border-right: 4px solid transparent;\n    border-left: 4px solid transparent; }\n  .lego #ui-datepicker-div .ui-datepicker-next:before,\n  .lego .lego-arrow-inline--right {\n    border-left: 4px solid currentColor;\n    border-top: 4px solid transparent;\n    border-bottom: 4px solid transparent; }\n  .lego #ui-datepicker-div .ui-datepicker-prev:before,\n  .lego .lego-arrow-inline--left {\n    border-right: 4px solid currentColor;\n    border-top: 4px solid transparent;\n    border-bottom: 4px solid transparent; }\n.lego .lego-dropdown,\n.lego .lego-popover,\n.lego .lego-block-list-group,\n.lego .lego-block-list {\n  list-style: none;\n  margin-left: 0; }\n  .lego .lego-dropdown > li,\n  .lego .lego-popover > li,\n  .lego .lego-block-list-group > li,\n  .lego .lego-block-list > li {\n    padding: 5px 10px;\n    border-top: 1px solid #efefef; }\n  .lego .lego-dropdown__block-link,\n  .lego .lego-block-list__link {\n    display: block;\n    padding: 5px 10px;\n    margin-left: -10px;\n    margin-right: -10px; }\n    .lego .lego-dropdown__block-link:hover,\n    .lego .lego-block-list__link:hover {\n      background-color: #f2f7fc; }\n    .lego .lego-block-list__link--active {\n      background-color: #f7f7f7; }\n    .lego .lego-dropdown__block-link:first-child,\n    .lego .lego-block-list__link:first-child {\n      margin-top: -5px; }\n    .lego .lego-dropdown__block-link:last-child,\n    .lego .lego-block-list__link:last-child {\n      margin-bottom: -5px; }\n  .lego .lego-block-list--flush li {\n    padding-left: 0;\n    padding-right: 0; }\n.lego .lego-dropdown,\n.lego .lego-popover,\n.lego .lego-block-list-group {\n  border: 1px solid #e0e0e0;\n  border-radius: 2px; }\n  .lego .lego-dropdown > li:first-child,\n  .lego .lego-popover > li:first-child,\n  .lego .lego-block-list-group > li:first-child {\n    border: 0; }\n.lego .border--all {\n  border: 1px solid #e0e0e0; }\n.lego .border--top {\n  border-top: 1px solid #e0e0e0; }\n.lego .border--bottom {\n  border-bottom: 1px solid #e0e0e0; }\n.lego .border--left {\n  border-left: 1px solid #e0e0e0; }\n.lego .border--right {\n  border-right: 1px solid #e0e0e0; }\n.lego .lego-button {\n  display: inline-block !important;\n  vertical-align: middle !important;\n  white-space: nowrap !important;\n  font-family: inherit !important;\n  font-size: 12px !important;\n  cursor: pointer !important;\n  border: 0 !important;\n  margin: 0 !important;\n  padding: 0 10px !important;\n  height: 31px !important;\n  font-weight: 400 !important;\n  border-radius: 2px !important;\n  border-style: solid !important;\n  border-width: 1px !important;\n  line-height: 1 !important;\n  background: linear-gradient(#ffffff, #eeeeee) !important;\n  color: #262626 !important;\n  border-color: #e0e0e0 !important; }\n  .lego .lego-button:hover,\n  .lego .lego-button:active,\n  .lego .lego-button:visited,\n  .lego .lego-button:focus {\n    outline: none !important;\n    color: #262626 !important; }\n  .lego .lego-button.lego-button--hover,\n  .lego .lego-button:hover {\n    background: linear-gradient(#ffffff, #e5e5e5) !important;\n    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1) !important; }\n  .lego .lego-button.lego-button--active,\n  .lego .lego-button:active {\n    box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.2) !important;\n    border-color: #bbb !important; }\n  .lego .lego-button:visited,\n  .lego .lego-button:focus {\n    color: #262626 !important; }\n  .lego .lego-button--brand {\n    background: linear-gradient(#147cc5, #1270b1) !important;\n    border-color: #00558d !important;\n    color: white !important; }\n    .lego .lego-button--brand.lego-button--hover,\n    .lego .lego-button--brand:hover {\n      background: linear-gradient(#038ae6, #1270b1) !important; }\n    .lego .lego-button--brand.lego-button--active,\n    .lego .lego-button--brand:active {\n      box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.3) !important;\n      border-color: #00558d !important; }\n    .lego .lego-button--brand:hover,\n    .lego .lego-button--brand:active,\n    .lego .lego-button--brand:visited,\n    .lego .lego-button--brand:focus {\n      color: white !important; }\n  .lego .lego-button--highlight {\n    background: linear-gradient(#a1cd1e, #91b81c) !important;\n    border-color: #719505 !important;\n    color: white !important; }\n    .lego .lego-button--highlight.lego-button--hover,\n    .lego .lego-button--highlight:hover {\n      background: linear-gradient(#a3d60c, #91b81c) !important; }\n    .lego .lego-button--highlight.lego-button--active,\n    .lego .lego-button--highlight:active {\n      box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.3) !important;\n      border-color: #719505 !important; }\n    .lego .lego-button--highlight:hover,\n    .lego .lego-button--highlight:active,\n    .lego .lego-button--highlight:visited,\n    .lego .lego-button--highlight:focus {\n      color: white !important; }\n  .lego .lego-button--danger {\n    background: linear-gradient(#aa280d, #991e04) !important;\n    border-color: #641100 !important;\n    color: white !important; }\n    .lego .lego-button--danger.lego-button--hover,\n    .lego .lego-button--danger:hover {\n      background: linear-gradient(#c02c0c, #991e04) !important; }\n    .lego .lego-button--danger.lego-button--active,\n    .lego .lego-button--danger:active {\n      box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.3) !important;\n      border-color: #641100 !important; }\n    .lego .lego-button--danger:hover,\n    .lego .lego-button--danger:active,\n    .lego .lego-button--danger:visited,\n    .lego .lego-button--danger:focus {\n      color: white !important; }\n  .lego .lego-button--small {\n    padding: 4px 10px !important;\n    height: 24px !important;\n    font-size: 10px !important;\n    line-height: 1 !important; }\n  .lego .lego-button--full {\n    width: 100% !important;\n    padding-right: 0 !important;\n    padding-left: 0 !important;\n    text-align: center !important; }\n  .lego .lego-button--icon {\n    line-height: 1.4 !important; }\n    .lego .lego-button--icon .lego-icon {\n      vertical-align: sub !important; }\n  .lego .lego-button[disabled],\n  .lego .lego-button[disabled]:hover,\n  .lego .lego-button[disabled]:active,\n  .lego .lego-button[disabled]:focus,\n  .lego .lego-button--disabled,\n  .lego .lego-button--disabled:hover,\n  .lego .lego-button--disabled:active,\n  .lego .lego-button--disabled:focus {\n    cursor: default !important;\n    box-shadow: none !important;\n    background: #f8f8f8 !important;\n    color: #7f7f7f !important;\n    border-color: #e0e0e0 !important;\n    opacity: 0.5 !important; }\n    .lego .lego-button[disabled] + .lego-button--brand,\n    .lego .lego-button[disabled]:hover + .lego-button--brand,\n    .lego .lego-button[disabled]:active + .lego-button--brand,\n    .lego .lego-button[disabled]:focus + .lego-button--brand,\n    .lego .lego-button--disabled + .lego-button--brand,\n    .lego .lego-button--disabled:hover + .lego-button--brand,\n    .lego .lego-button--disabled:active + .lego-button--brand,\n    .lego .lego-button--disabled:focus + .lego-button--brand {\n      border-color: #00558d !important;\n      background: #147cc5 !important;\n      color: #fff !important; }\n    .lego .lego-button[disabled] + .lego-button--highlight,\n    .lego .lego-button[disabled]:hover + .lego-button--highlight,\n    .lego .lego-button[disabled]:active + .lego-button--highlight,\n    .lego .lego-button[disabled]:focus + .lego-button--highlight,\n    .lego .lego-button--disabled + .lego-button--highlight,\n    .lego .lego-button--disabled:hover + .lego-button--highlight,\n    .lego .lego-button--disabled:active + .lego-button--highlight,\n    .lego .lego-button--disabled:focus + .lego-button--highlight {\n      border-color: #719505 !important;\n      background: #a1cd1e !important;\n      color: #fff !important; }\n    .lego .lego-button[disabled] + .lego-button--danger,\n    .lego .lego-button[disabled]:hover + .lego-button--danger,\n    .lego .lego-button[disabled]:active + .lego-button--danger,\n    .lego .lego-button[disabled]:focus + .lego-button--danger,\n    .lego .lego-button--disabled + .lego-button--danger,\n    .lego .lego-button--disabled:hover + .lego-button--danger,\n    .lego .lego-button--disabled:active + .lego-button--danger,\n    .lego .lego-button--disabled:focus + .lego-button--danger {\n      border-color: #641100 !important;\n      background: #aa280d !important;\n      color: #fff !important; }\n.lego a.lego-button {\n  padding-top: 8px !important; }\n  .lego a.lego-button--small {\n    padding-top: 6px !important; }\n.lego .lego-button-group > * {\n  margin-left: 0 !important;\n  border-radius: 0 !important; }\n  .lego .lego-button-group > *:not(:first-child) {\n    margin-left: -1px !important; }\n  .lego .lego-button-group > *:hover,\n  .lego .lego-button-group > *:focus {\n    position: relative !important; }\n  .lego .lego-button-group > *:first-child {\n    border-radius: 2px 0 0 2px !important; }\n  .lego .lego-button-group > *:last-child {\n    border-radius: 0 2px 2px 0 !important; }\n.lego .lego-button-group > .lego-button--brand {\n  position: relative !important; }\n.lego .lego-button-group > .lego-text-input {\n  width: auto !important; }\n.lego .lego-button-group .lego-button--highlight,\n.lego .lego-button-group .lego-button--danger,\n.lego .lego-button-group .lego-button--brand {\n  z-index: 1 !important; }\n.lego .lego-button-row--left .lego-button {\n  margin-right: 10px !important; }\n  .lego .lego-button-row--left .lego-button:last-child {\n    margin-right: 0 !important; }\n.lego .lego-button-row--right {\n  text-align: right; }\n  .lego .lego-button-row--right .lego-button {\n    margin-left: 10px; }\n    .lego .lego-button-row--right .lego-button:first-child {\n      margin-left: 0; }\n.lego .lego-button-row--center {\n  text-align: center; }\n  .lego .lego-button-row--center .lego-button {\n    margin-left: 5px;\n    margin-right: 5px; }\n.lego .lego-dropdown-group {\n  font-size: 12px;\n  display: inline-block;\n  position: relative;\n  vertical-align: top; }\n  .lego .lego-dropdown-group.shown .lego-dropdown {\n    visibility: visible; }\n.lego .lego-dropdown {\n  background: white;\n  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);\n  min-width: 100%;\n  position: absolute;\n  top: 100%;\n  left: auto;\n  z-index: 1;\n  margin-top: 2px;\n  text-align: left;\n  visibility: hidden; }\n  .lego .lego-dropdown__item {\n    white-space: nowrap;\n    color: #262626; }\n    .lego .lego-dropdown__item--active {\n      background: #f7f7f7; }\n  .lego .lego-dropdown--right {\n    right: 0;\n    left: auto; }\n.lego .lego-disclose__link {\n  display: block; }\n.lego .lego-disclose__symbol {\n  transition: transform 0.3s;\n  transition: transform 0.3s;\n  transition: transform 0.3s;\n  transition: transform 0.3s;\n  width: 10px;\n  display: inline-block; }\n  .lego .lego-disclose__symbol:before {\n    line-height: 1;\n    font-size: 10px;\n    content: '\\25B6'; }\n.lego .lego-disclose__content {\n  display: none; }\n.lego .lego-disclose__item {\n  margin-bottom: 10px; }\n  .lego .lego-disclose__item--active > .lego-disclose__content {\n    display: block; }\n  .lego .lego-disclose__item--active > .lego-disclose__link > .lego-disclose__symbol {\n    transform: rotate(90deg);\n    transform: rotate(90deg);\n    transform: rotate(90deg);\n    transform: rotate(90deg); }\n.lego .lego-dialog {\n  position: relative;\n  box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);\n  width: 700px; }\n  .lego .lego-dialog--narrow {\n    width: 500px; }\n  .lego .lego-dialog--wide {\n    width: 900px; }\n  .lego .lego-dialog__header, .lego .lego-dialog__body, .lego .lego-dialog__footer {\n    padding: 20px; }\n  .lego .lego-dialog__header, .lego .lego-dialog__footer {\n    background-color: #f7f7f7; }\n  .lego .lego-dialog__header {\n    border-bottom: 1px solid #efefef; }\n  .lego .lego-dialog__footer {\n    border-top: 1px solid #efefef; }\n  .lego .lego-dialog__title {\n    font-size: 20px;\n    letter-spacing: -1px;\n    color: #003366;\n    line-height: 1; }\n  .lego .lego-dialog__body {\n    padding-bottom: 30px; }\n  .lego .lego-dialog__close {\n    position: absolute;\n    top: -12px;\n    right: -12px;\n    width: 24px;\n    height: 24px;\n    border-radius: 50%;\n    cursor: pointer;\n    background: black;\n    color: white;\n    border: 2px solid white;\n    box-shadow: 0 0 8px rgba(0, 0, 0, 0.3); }\n.lego .lego-help-dot {\n  background: #a5a5a5;\n  color: white;\n  width: 16px;\n  height: 16px;\n  text-align: center;\n  display: inline-block;\n  border-radius: 50%;\n  font-size: 10px; }\n  .lego .lego-help-dot:after {\n    content: \"?\"; }\n.lego .lego-island {\n  border: 1px solid #efefef;\n  border-radius: 2px;\n  background: #f7f7f7;\n  padding: 10px; }\n  .lego .lego-island--center {\n    text-align: center; }\n.lego .lego-icon {\n  width: 16px;\n  height: 16px;\n  display: inline-block;\n  fill: currentColor; }\n  .lego .lego-icon--small {\n    width: 8px;\n    height: 8px; }\n  .lego .lego-icon--large {\n    width: 32px;\n    height: 32px; }\n.lego .lego-icon + [class^=\"lego-arrow-inline\"] {\n  vertical-align: super; }\n.lego .lego-button + .lego-icon {\n  vertical-align: middle; }\n.lego .lego-tabs-nav__item .lego-icon {\n  vertical-align: sub; }\n.lego .lego-matrix {\n  margin-left: -20px; }\n  .lego .lego-matrix > li {\n    padding-left: 20px; }\n.lego .lego-media__img {\n  margin-right: 10px; }\n.lego .lego-media__img--rev {\n  margin-left: 10px; }\n.lego .lego-nav > li {\n  margin-right: 10px; }\n  .lego .lego-nav > li > a {\n    display: block; }\n.lego .lego-nav--stacked {\n  display: block; }\n  .lego .lego-nav--stacked > li {\n    margin-right: 0; }\n.lego .lego-nav--center > li {\n  margin-left: 5px;\n  margin-right: 5px; }\n.lego .lego-nav--fit > li > a {\n  display: block; }\n.lego .lego-pagination > li {\n  padding: 5px; }\n.lego .lego-pagination__first a:before {\n  content: '\\00AB' '\\00A0'; }\n.lego .lego-pagination__last a:after {\n  content: '\\00A0' '\\00BB'; }\n.lego .lego-pagination__current > a {\n  color: #262626; }\n.lego .lego-pop-tip {\n  background: #262626;\n  color: white;\n  border-radius: 2px;\n  font-size: 10px;\n  padding: 5px 10px;\n  max-width: 250px;\n  display: inline-block;\n  z-index: 3001; }\n  .lego .lego-pop-tip--arrow-top-center:before {\n    border-bottom-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-top-center:after {\n    border-bottom-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-top-left:before {\n    border-bottom-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-top-left:after {\n    border-bottom-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-top-right:before {\n    border-bottom-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-top-right:after {\n    border-bottom-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-bottom-center:before {\n    border-top-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-bottom-center:after {\n    border-top-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-bottom-left:before {\n    border-top-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-bottom-left:after {\n    border-top-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-bottom-right:before {\n    border-top-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-bottom-right:after {\n    border-top-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-left:before {\n    border-right-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-left:after {\n    border-right-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-right:before {\n    border-left-color: #262626 !important; }\n  .lego .lego-pop-tip--arrow-right:after {\n    border-left-color: #262626 !important; }\n.lego .lego-popover {\n  max-width: 250px;\n  display: inline-block;\n  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1); }\n  .lego .lego-popover__title {\n    font-weight: 500; }\n  .lego .lego-popover--arrow-top:before {\n    border-bottom-color: #e0e0e0 !important; }\n  .lego .lego-popover--arrow-top:after {\n    border-bottom-color: white !important; }\n  .lego .lego-popover--arrow-bottom:before {\n    border-top-color: #e0e0e0 !important; }\n  .lego .lego-popover--arrow-bottom:after {\n    border-top-color: white !important; }\n  .lego .lego-popover--arrow-left:before {\n    border-right-color: #e0e0e0 !important; }\n  .lego .lego-popover--arrow-left:after {\n    border-right-color: white !important; }\n  .lego .lego-popover--arrow-right:before {\n    border-left-color: #e0e0e0 !important; }\n  .lego .lego-popover--arrow-right:after {\n    border-left-color: white !important; }\n.lego .lego-progress {\n  background: #f7f7f7;\n  height: 20px;\n  border-radius: 2px;\n  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);\n  overflow: hidden; }\n  .lego .lego-progress__bar {\n    transition: width 0.3s;\n    transition: width 0.3s;\n    transition: width 0.3s;\n    transition: width 0.3s;\n    height: 100%;\n    background: #0081ba;\n    box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.15);\n    line-height: 20px;\n    color: white;\n    font-size: 11px;\n    text-align: center;\n    min-width: 20px; }\n    .lego .lego-progress__bar[aria-valuenow=\"0\"] {\n      background: transparent;\n      box-shadow: none;\n      color: #7f7f7f; }\n.lego .lego-rule {\n  border: 0;\n  height: 0;\n  border-top: 1px solid #e0e0e0;\n  margin-top: 9px;\n  margin-bottom: 10px; }\n  .lego .lego-rule--dotted {\n    border-top-style: dotted; }\n  .lego .lego-rule--dashed {\n    border-top-style: dashed; }\n.lego .lego-search {\n  position: relative; }\n  .lego .lego-search .lego-text-input--search {\n    padding-left: 30px;\n    padding-right: 30px;\n    background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iNTEycHgiIGhlaWdodD0iNTEycHgiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MTIgNTEyIiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxwYXRoIGZpbGw9IiM4NDg0ODQiIGQ9Ik0zODQsMTkyQzM4NCw4NiwyOTgsMCwxOTIsMFMwLDg2LDAsMTkyczg2LDE5MiwxOTIsMTkyUzM4NCwyOTgsMzg0LDE5MnogTTE5MiwzMzYNCgkJYy03OS40LDAtMTQ0LTY0LjYtMTQ0LTE0NFMxMTIuNiw0OCwxOTIsNDhzMTQ0LDY0LjYsMTQ0LDE0NFMyNzEuNCwzMzYsMTkyLDMzNnoiLz4NCgk8cGF0aCBmaWxsPSIjODQ4NDg0IiBkPSJNNDk3LjksNDMwLjFMMzgwLjUsMzEyLjZjLTE3LjUsMjcuMi00MC43LDUwLjQtNjcuOSw2Ny45bDExNy41LDExNy41YzE4LjgsMTguOCw0OS4yLDE4LjgsNjcuOSwwDQoJCUM1MTYuNyw0NzkuMiw1MTYuNyw0NDguOCw0OTcuOSw0MzAuMXoiLz4NCjwvZz4NCjwvc3ZnPg0K);\n    background-repeat: no-repeat;\n    background-position: left 8px center;\n    background-size: 16px 16px; }\n  .lego .lego-search .lego-icon {\n    transform: translateY(-50%);\n    transform: translateY(-50%);\n    transform: translateY(-50%);\n    transform: translateY(-50%);\n    position: absolute;\n    top: 50%;\n    right: 10px;\n    cursor: pointer;\n    display: none; }\n.lego .lego-search--active .lego-icon {\n  display: block; }\n.lego .lego-overlay {\n  background: rgba(255, 255, 255, 0.6);\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  justify-content: center;\n  align-items: center; }\n@-webkit-keyframes lego-spin {\n  .lego 100%  {\n    -webkit-transform: rotate(360deg); } }\n@keyframes lego-spin {\n  .lego 100%  {\n    transform: rotate(360deg); } }\n.lego .lego-spinner {\n  display: inline-block;\n  width: 40px;\n  height: 40px;\n  border-radius: 50%;\n  border: 4px solid #d1e5f2;\n  position: relative;\n  -webkit-animation: lego-spin 800ms infinite linear;\n  animation: lego-spin 800ms infinite linear; }\n  .lego .lego-spinner:before {\n    content: \"\";\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    display: block;\n    position: absolute;\n    left: -4px;\n    top: -4px;\n    border-width: 4px;\n    border-style: solid;\n    border-right-color: #d1e5f2;\n    border-top-color: #d1e5f2;\n    border-left-color: #0081ba;\n    border-bottom-color: #d1e5f2; }\n  .lego .lego-spinner--small, .lego .lego-spinner--small:before {\n    width: 26px;\n    height: 26px;\n    border-width: 3px;\n    left: -3px;\n    top: -3px; }\n  .lego .lego-spinner--tiny, .lego .lego-spinner--tiny:before {\n    width: 16px;\n    height: 16px;\n    border-width: 2px;\n    left: -2px;\n    top: -2px; }\n.lego .lego-stat {\n  margin-right: 10px; }\n.lego .lego-steps {\n  margin-left: auto;\n  margin-right: auto; }\n  .lego .lego-steps__dot {\n    position: absolute;\n    width: 16px;\n    height: 16px;\n    top: -7px;\n    transform: translateX(-50%);\n    transform: translateX(-50%);\n    transform: translateX(-50%);\n    transform: translateX(-50%);\n    left: 50%;\n    border-radius: 50%;\n    background: #e0e0e0;\n    border: 3px solid #e0e0e0;\n    background: white;\n    z-index: 1; }\n  .lego .lego-steps__label {\n    text-align: center;\n    font-weight: 400;\n    color: #a5a5a5; }\n  .lego .lego-steps__item {\n    padding-top: 20px;\n    position: relative; }\n    .lego .lego-steps__item:before {\n      content: '';\n      height: 3px;\n      background: #e0e0e0;\n      width: 100%;\n      position: absolute;\n      top: 0;\n      right: 50%; }\n    .lego .lego-steps__item--active:before {\n      background: #0081ba; }\n    .lego .lego-steps__item--active .lego-steps__dot {\n      background: #0081ba;\n      border-color: #0081ba; }\n    .lego .lego-steps__item--active .lego-steps__label {\n      color: #0081ba; }\n    .lego .lego-steps__item--complete:before {\n      background: #0081ba; }\n    .lego .lego-steps__item--complete .lego-steps__dot {\n      border-color: #0081ba; }\n    .lego .lego-steps__item:first-child:before {\n      display: none; }\n.lego .lego-tabs-nav {\n  border-bottom: 3px solid #e0e0e0; }\n  .lego .lego-tabs-nav__item {\n    position: relative;\n    text-align: center;\n    padding: 10px 15px;\n    border: 1px solid #e0e0e0;\n    border-right: none;\n    border-bottom: 0;\n    color: #7f7f7f;\n    font-weight: 500;\n    background-color: #f7f7f7;\n    cursor: pointer; }\n    .lego .lego-tabs-nav__item:first-child {\n      border-radius: 4px 0 0 0; }\n    .lego .lego-tabs-nav__item:last-child {\n      border-radius: 0 4px 0 0;\n      border-right: 1px solid #e0e0e0; }\n    .lego .lego-tabs-nav__item:hover, .lego .lego-tabs-nav__item.tab-active {\n      color: #0081ba; }\n    .lego .lego-tabs-nav__item.tab-active {\n      background-color: white; }\n      .lego .lego-tabs-nav__item.tab-active:after {\n        content: '';\n        display: block;\n        height: 3px;\n        background: white;\n        position: absolute;\n        left: 0;\n        right: 0;\n        bottom: -3px; }\n.lego .lego-tabs--small .lego-tabs-nav {\n  border-width: 1px; }\n.lego .lego-tabs--small .lego-tabs-nav__item {\n  background-color: transparent;\n  padding: 5px 10px;\n  font-size: 11px; }\n.lego .lego-tabs--center .lego-tabs-nav__item:first-child {\n  margin-left: 5px; }\n.lego .lego-tabs--sub .lego-tabs-nav__item {\n  border: none; }\n  .lego .lego-tabs--sub .lego-tabs-nav__item.tab-active:after {\n    height: 2px;\n    background: #0081ba;\n    bottom: -1px; }\n.lego .lego-tabs-pane {\n  display: none; }\n  .lego .lego-tabs-pane.tab-active {\n    display: block; }\n.lego .lego-tabs-container {\n  margin-bottom: 20px; }\n  .lego .lego-tabs-container .lego-tabs-pane {\n    padding: 20px;\n    border: 1px solid #e0e0e0;\n    border-top: none; }\n.lego .lego-tag {\n  color: #a5a5a5; }\n.lego html {\n  font-size: 12px;\n  font-family: 'Gotham SSm A', 'Gotham SSm B', Helvetica, Verdana, sans-serif;\n  line-height: 1.6;\n  font-weight: 300; }\n.lego html,\n.lego body {\n  height: 100%; }\n.lego body {\n  min-width: 1120px; }\n.lego h1,\n.lego .alpha {\n  font-size: 28px;\n  line-height: 1.1; }\n.lego h2,\n.lego .beta {\n  font-size: 24px;\n  line-height: 1.1; }\n.lego h3,\n.lego .gamma {\n  font-size: 20px;\n  line-height: 1.2; }\n.lego h4,\n.lego .delta {\n  font-size: 16px;\n  line-height: 1.2; }\n.lego h5,\n.lego .epsilon {\n  font-size: 14px;\n  line-height: 1.2; }\n.lego h6,\n.lego .zeta {\n  font-size: 12px; }\n.lego h1 {\n  margin-bottom: 20px !important; }\n.lego h2 {\n  margin-bottom: 20px !important; }\n.lego h3 {\n  margin-bottom: 15px !important; }\n.lego h4 {\n  margin-bottom: 10px !important; }\n.lego h5 {\n  margin-bottom: 15px !important;\n  font-weight: 500 !important; }\n.lego h6 {\n  margin-bottom: 5px !important;\n  font-weight: 500 !important;\n  text-transform: none !important; }\n.lego hgroup .hn {\n  margin-bottom: 0; }\n.lego .milli {\n  font-size: 11px; }\n.lego .micro {\n  font-size: 10px; }\n.lego .giga {\n  font-size: 65px; }\n.lego .mega {\n  font-size: 50px; }\n.lego .kilo {\n  font-size: 40px; }\n.lego .lego-data-sidebar {\n  background: #f7f7f7;\n  width: 370px;\n  box-shadow: -1px 0 0 #e0e0e0; }\n  .lego .lego-data-sidebar .accordion {\n    width: 370px; }\n.lego .lego-layout--single-column {\n  margin-left: auto;\n  margin-right: auto;\n  max-width: 640px; }\n.lego .lego-sections__item {\n  margin-bottom: 25px !important; }\n.lego .lego-code-copy {\n  position: relative; }\n  .lego .lego-code-copy .lego-button {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    transition: opacity 0.1s;\n    transition: opacity 0.1s;\n    transition: opacity 0.1s;\n    transition: opacity 0.1s;\n    opacity: 0; }\n  .lego .lego-code-copy:hover .lego-button,\n  .lego .lego-code-copy .lego-button--hover,\n  .lego .lego-code-copy .lego-button--active {\n    opacity: 1; }\n.lego .cell-truncate {\n  position: relative; }\n  .lego .cell-truncate__text +\n  .lego .cell-truncate__title {\n    margin-bottom: 15px; }\n  .lego .cell-truncate__text {\n    position: absolute;\n    bottom: 5px;\n    left: 0;\n    right: 0; }\n  .lego .cell-truncate__title {\n    font-weight: 500; }\n.lego .lego-table--dashboard thead > tr > th:first-child,\n.lego .lego-table--dashboard tbody > tr > td:first-child {\n  padding-left: 20px; }\n.lego .lego-table--dashboard thead > tr > th:last-child,\n.lego .lego-table--dashboard tbody > tr > td:last-child {\n  padding-right: 20px; }\n.lego .lego-table--dashboard tbody > tr > td {\n  padding-top: 10px;\n  padding-bottom: 10px; }\n.lego .lego-table--dashboard .cell-truncate__text {\n  bottom: 10px;\n  left: 20px;\n  color: #a5a5a5;\n  font-size: 10px; }\n.lego .lego-table--dashboard .lego-table-row--active td:first-child {\n  position: relative; }\n  .lego .lego-table--dashboard .lego-table-row--active td:first-child:after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    width: 3px;\n    background: #0081ba; }\n.lego .lego-project-drawer {\n  transition: left 0.3s;\n  transition: left 0.3s;\n  transition: left 0.3s;\n  transition: left 0.3s;\n  background: white;\n  box-shadow: 1px 0 3px rgba(0, 0, 0, 0.1);\n  width: 320px;\n  position: absolute;\n  top: 40px;\n  left: -330px;\n  bottom: 0; }\n  .lego .lego-project-drawer--active {\n    left: 0; }\n  .lego .lego-project-drawer .lego-project-drawer__header {\n    padding: 20px;\n    position: relative; }\n    .lego .lego-project-drawer .lego-project-drawer__header .lego-icon {\n      position: absolute;\n      top: 20px;\n      right: 20px;\n      cursor: pointer; }\n  .lego .lego-project-drawer .lego-block-list {\n    overflow-y: auto; }\n    .lego .lego-project-drawer .lego-block-list li {\n      margin: 0;\n      padding: 0; }\n      .lego .lego-project-drawer .lego-block-list li:first-child {\n        border-top: none; }\n    .lego .lego-project-drawer .lego-block-list .lego-block-list__link {\n      margin: 0;\n      padding: 5px 20px; }\n.lego .lego-notification {\n  transition: opacity 0.1s;\n  transition: opacity 0.1s;\n  transition: opacity 0.1s;\n  transition: opacity 0.1s;\n  padding: 5px 10px;\n  font-size: 11px;\n  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);\n  text-align: center;\n  -webkit-transform: translateX(-50%);\n  transform: translateX(-50%);\n  opacity: 0; }\n  .lego .lego-notification--wrap {\n    position: fixed;\n    top: 30px;\n    left: 50%;\n    z-index: 1002; }\n  .lego .lego-notification + .lego-notification {\n    margin-top: 5px; }\n  .lego .lego-notification--active {\n    opacity: 1; }\n.lego .tagger {\n  font-style: italic;\n  font-size: 10px;\n  color: #a5a5a5;\n  letter-spacing: normal;\n  white-space: nowrap; }\n.lego .lego-top-nav {\n  background-color: #003366;\n  color: white;\n  padding: 0 20px; }\n  .lego .lego-top-nav__item {\n    margin-right: 20px; }\n    .lego .lego-top-nav__item:last-child {\n      margin-right: 0; }\n  .lego .lego-top-nav a {\n    display: block;\n    padding: 10px 0; }\n.lego #content.dashboard #project-container .box > .header,\n.lego #content.dashboard #project-container .callout > .header {\n  height: 95px; }\n.lego #content.dashboard #project-container .box .tabs li,\n.lego #content.dashboard #project-container .callout .tabs li {\n  font-size: 11px;\n  padding-bottom: 6px; }\n.lego #content.dashboard .lock {\n  display: inline-block; }\n.lego #content.dashboard .show-archive {\n  width: 333px !important; }\n.lego #content.dashboard #create-button {\n  font-size: 12px !important; }\n.lego #content.dashboard .list table tr.experiment td.goal span {\n  width: 34px; }\n.lego #content.dashboard #project-code-web {\n  margin-bottom: 10px; }\n.lego #content.dashboard #project-code {\n  width: 416px !important;\n  margin-bottom: 10px; }\n.lego #content.dashboard #projectcode-conatiner .button-group {\n  margin-bottom: 10px; }\n.lego .menu div.submenu div.content,\n.lego #changer-container div.change-menu div.submenu div.content {\n  padding-bottom: 30px !important; }\n.lego form.standard p,\n.lego .dialog .content p,\n.lego .message-dialog .content p {\n  font-size: 13px; }\n.lego .entity-list-item-description {\n  font-size: 12px !important; }\n.lego .url-validator-text {\n  font-weight: 300; }\n.lego .url-targeting .twisty-container div.twisty {\n  top: 0.4em; }\n.lego .dialog__header * + p {\n  margin-top: 10px; }\n.lego .dialog-backdrop .dialog-frame .dialog__title {\n  font-size: 24px; }\n.lego #create-dimensions-dialog label {\n  font-size: 12px; }\n.lego #settings-dialog #user-table thead td {\n  font-size: 12px; }\n.lego #settings-dialog .invite-container label {\n  font-size: 14px; }\n.lego #settings-dialog .invite-container #additional-projects label span {\n  font-size: 14px; }\n.lego .dialog .content .header h1,\n.lego .message-dialog .content .header h1,\n.lego .dialog .content .header h2,\n.lego .message-dialog .content .header h2 {\n  font-size: 30px;\n  font-weight: 100; }\n.lego .dialog .toggle-switch {\n  font-size: 14px !important; }\n.lego .dialog .content h3, .lego .message-dialog .content h3 {\n  font-size: 18px; }\n.lego #settings-dialog #user-table tbody td.user-email {\n  font-size: 14px; }\n.lego #settings-dialog .project-name div.right {\n  font-size: 16px; }\n.lego .log-viewer-datepicker-container {\n  font-size: 14px; }\n.lego #settings-dialog .invite-container input[type=\"text\"] {\n  font-size: 14px; }\n.lego #settings-dialog .invite-container #invite-message {\n  font-size: 12px; }\n.lego #settings-dialog #user-table .others-button a {\n  font-size: 12px;\n  font-weight: 200; }\n.lego #settings-dialog .invite-container span.error {\n  display: block; }\n.lego #settings-dialog #send-invite {\n  margin-bottom: 22px; }\n.lego #settings-dialog .invite-container #additional-projects-intro {\n  font-size: 12px; }\n.lego #container.edit {\n  font-size: 1.35em; }\n  .lego #container.edit .variations__list__item > a {\n    color: #6b6b6b !important; }\n  .lego #container.edit .variations__list__item--create a {\n    color: #AAA !important; }\n.lego .loading-message-container .loading-progress {\n  height: 13px; }\n.lego .loading-message-container .ui-progressbar .ui-progressbar-value {\n  height: 120%; }\n.lego .loading-message-container #load-fail-messages .alert-box {\n  font-size: 12px;\n  line-height: 17px; }\n.lego .loading-message-container pre#project-code {\n  margin-bottom: 10px; }\n.lego .loading-message-container code {\n  background: none;\n  border: none;\n  font-size: 12px; }\n.lego #variation-code-popup #show-variation-code-button {\n  padding-bottom: 17px; }\n.lego #changer-container.ui-draggable div.change-menu div.submenu div.content {\n  padding-bottom: 8px !important; }\n.lego #changer-container div.change-window div.footer a {\n  width: auto; }\n.lego #variation-menu .dropdown-item,\n.lego #option-menu .dropdown-item {\n  font-weight: 400; }\n  .lego #variation-menu .dropdown-item img,\n  .lego #option-menu .dropdown-item img {\n    display: inline; }\n.lego .toolbar__title.editable:hover {\n  color: #006eb6; }\n  .lego .toolbar__title.editable:hover:after {\n    content: ''; }\n.lego .help-button:hover div.help-bubble {\n  text-indent: 0; }\n.lego #goals-dialog.expanded > div.content div.shrink-message {\n  height: auto !important; }\n.lego #goals-dialog.expanded > div.content div.click-goal-controls {\n  height: 106px !important; }\n.lego #goals-dialog.expanded > div.content div.frame-container {\n  bottom: 27px !important; }\n.lego #upsell-subscribe > a > img {\n  display: inline; }\n.lego body {\n  color: inherit;\n  background: inherit;\n  line-height: inherit;\n  font-size: inherit;\n  font-weight: inherit;\n  font-family: inherit;\n  width: auto; }\n.lego li {\n  color: inherit;\n  font-size: inherit;\n  font-weight: inherit;\n  line-height: inherit;\n  list-style-position: inherit;\n  margin: 0; }\n.lego h1,\n.lego h2,\n.lego h3,\n.lego h4,\n.lego h5,\n.lego h6 {\n  font-family: inherit; }\n.lego p {\n  font-size: inherit;\n  line-height: inherit; }\n.lego #report-title {\n  font-size: 24px;\n  font-weight: 300; }\n.lego .titles .name {\n  font-weight: 300; }\n.lego .sub-header-nav > li {\n  font-size: inherit; }\n.lego .title-container {\n  font-size: 1.5em;\n  margin: 0;\n  font-weight: 300; }\n.lego body.results2 .conclusion-summary .conclusion-message {\n  margin-top: 8px; }\n.lego body.results2 .primary-metric {\n  font-size: 12px; }\n.lego .white-button.small {\n  height: 30px; }\n.lego li.white-button.small > * {\n  position: relative;\n  top: -2px; }\n.lego body.results2 #saved-reports h6 {\n  font-size: inherit;\n  text-transform: uppercase; }\n.lego #navigation-container h5 {\n  margin: 0; }\n.lego .page-loading-container img,\n.lego .viewer-loading-container img {\n  display: inline-block; }\n.lego #explorer-controls a {\n  cursor: pointer;\n  font-size: 16px; }\n.lego #top .logo {\n  margin-bottom: 0; }\n.lego #top .nav-top > li > a {\n  font-size: 13px;\n  padding-top: 10px;\n  padding-bottom: 10px; }\n  .lego #top .nav-top > li > a:hover {\n    color: #fff; }\n  .lego #top .nav-top > li > a img {\n    display: inline-block; }\n.lego #top .dropdown-menu-top a {\n  font-size: 12px;\n  color: #444; }\n  .lego #top .dropdown-menu-top a:hover {\n    color: #444;\n    text-decoration: underline; }\n.lego #top .dropdown-menu-top .account-header {\n  font-size: 12px;\n  color: #444;\n  padding-left: 8px 13px 8px; }\n.lego #ui-datepicker-div {\n  display: none;\n  background: white;\n  border: 1px solid #e0e0e0;\n  padding: 20px;\n  font-size: 14px;\n  overflow: hidden;\n  border-radius: 0 !important; }\n  .lego #ui-datepicker-div .ui-widget-header {\n    background: none;\n    border: none;\n    padding: 0; }\n  .lego #ui-datepicker-div .ui-datepicker-header {\n    position: relative; }\n  .lego #ui-datepicker-div.ui-datepicker-multi-2 .ui-datepicker-group {\n    width: 50%; }\n  .lego #ui-datepicker-div .ui-datepicker-row-break {\n    clear: both;\n    width: 100%;\n    font-size: 0; }\n  .lego #ui-datepicker-div .ui-datepicker-group {\n    float: left;\n    font-size: 12px; }\n  .lego #ui-datepicker-div .ui-datepicker-group-first {\n    padding-right: 20px;\n    border-right: 1px solid #e0e0e0; }\n  .lego #ui-datepicker-div .ui-datepicker-group-last {\n    padding-left: 20px; }\n  .lego #ui-datepicker-div .ui-datepicker-title {\n    font-weight: 500;\n    margin-bottom: 0;\n    text-align: center; }\n  .lego #ui-datepicker-div .ui-datepicker-calendar {\n    width: 100%;\n    margin: 0; }\n    .lego #ui-datepicker-div .ui-datepicker-calendar th {\n      color: #bfbfbf;\n      font-weight: 400;\n      font-size: 11px;\n      text-transform: uppercase; }\n    .lego #ui-datepicker-div .ui-datepicker-calendar td {\n      font-size: 11px; }\n      .lego #ui-datepicker-div .ui-datepicker-calendar td a, .lego #ui-datepicker-div .ui-datepicker-calendar td.ui-state-disabled span {\n        text-align: center;\n        display: block;\n        padding: 4px;\n        border: 1px solid transparent;\n        background: #fff !important;\n        color: #0081ba; }\n      .lego #ui-datepicker-div .ui-datepicker-calendar td.ui-state-disabled span {\n        color: #bfbfbf;\n        background: #fff !important; }\n    .lego #ui-datepicker-div .ui-datepicker-calendar .ui-state-active,\n    .lego #ui-datepicker-div .ui-datepicker-calendar .ui-state-hover {\n      border: 1px solid #0081ba;\n      background: #f2f7fc;\n      border-radius: 2px; }\n  .lego #ui-datepicker-div .ui-datepicker-buttonpane {\n    display: none; }\n  .lego #ui-datepicker-div .ui-datepicker-prev,\n  .lego #ui-datepicker-div .ui-datepicker-next {\n    position: absolute;\n    top: 2px;\n    cursor: pointer;\n    width: 16px;\n    height: 16px;\n    border: 1px solid transparent; }\n    .lego #ui-datepicker-div .ui-datepicker-prev:hover,\n    .lego #ui-datepicker-div .ui-datepicker-next:hover {\n      border: 1px solid #0081ba;\n      background: #f2f7fc;\n      border-radius: 2px; }\n    .lego #ui-datepicker-div .ui-datepicker-prev:before,\n    .lego #ui-datepicker-div .ui-datepicker-next:before {\n      position: absolute;\n      top: 5px;\n      content: \"\"; }\n    .lego #ui-datepicker-div .ui-datepicker-prev .ui-icon,\n    .lego #ui-datepicker-div .ui-datepicker-next .ui-icon {\n      display: block;\n      text-indent: -99999px;\n      overflow: hidden;\n      position: static;\n      background: none; }\n    .lego #ui-datepicker-div .ui-datepicker-prev.ui-state-disabled,\n    .lego #ui-datepicker-div .ui-datepicker-next.ui-state-disabled {\n      display: none; }\n  .lego #ui-datepicker-div .ui-datepicker-prev {\n    left: 0; }\n    .lego #ui-datepicker-div .ui-datepicker-prev:before {\n      left: 2px; }\n  .lego #ui-datepicker-div .ui-datepicker-next {\n    right: 0; }\n    .lego #ui-datepicker-div .ui-datepicker-next:before {\n      left: 3px; }\n.lego .background--white {\n  background-color: white !important; }\n.lego .background--faint {\n  background-color: #f7f7f7 !important; }\n.lego .background--light {\n  background-color: #efefef !important; }\n.lego .background--muted {\n  background-color: #a5a5a5 !important; }\n.lego .background--medium {\n  background-color: #7f7f7f !important; }\n.lego .background--brand {\n  background-color: #0081ba !important; }\n.lego .background--brand-dark {\n  background-color: #003366 !important; }\n.lego .background--warning {\n  background-color: #fcf8e3 !important; }\n.lego .background--bad-news {\n  background-color: #f9e3e4 !important; }\n.lego .background--good-news {\n  background-color: #e9f6c3 !important; }\n.lego .float--right {\n  float: right !important; }\n.lego .float--left {\n  float: left !important; }\n.lego .float--none {\n  float: none !important; }\n.lego .anchor--middle {\n  margin-right: auto !important;\n  margin-left: auto !important; }\n.lego .anchor--right {\n  margin-left: auto !important; }\n.lego .anchor--left {\n  margin-right: auto !important; }\n.lego .text--left {\n  text-align: left !important; }\n.lego .text--center {\n  text-align: center !important; }\n.lego .text--right {\n  text-align: right !important; }\n.lego .display--block {\n  display: block !important; }\n.lego .display--inline-block {\n  display: inline-block !important; }\n.lego .display--inline {\n  display: inline !important; }\n.lego .vertical-align--top {\n  vertical-align: top !important; }\n.lego .vertical-align--middle {\n  vertical-align: middle !important; }\n.lego .vertical-align--bottom {\n  vertical-align: bottom !important; }\n.lego .no-border {\n  border: 0 !important; }\n.lego .no-border--top {\n  border-top: none !important; }\n.lego .no-border--right {\n  border-right: none !important; }\n.lego .no-border--bottom {\n  border-bottom: none !important; }\n.lego .no-border--left {\n  border-left: none !important; }\n.lego .max-scroll--small {\n  max-height: 100px !important;\n  overflow-y: auto !important; }\n.lego .max-scroll--medium {\n  max-height: 200px !important;\n  overflow-y: auto !important; }\n.lego .max-scroll--large {\n  max-height: 300px !important;\n  overflow-y: auto !important; }\n.lego .max-width--large {\n  max-width: 800px !important; }\n.lego .cursor--pointer {\n  cursor: pointer !important; }\n.lego .no-resize {\n  resize: none !important; }\n.lego .push {\n  margin: 10px !important; }\n.lego .push--top {\n  margin-top: 10px !important; }\n.lego .push--right {\n  margin-right: 10px !important; }\n.lego .push--bottom {\n  margin-bottom: 10px !important; }\n.lego .push--left {\n  margin-left: 10px !important; }\n.lego .push--ends {\n  margin-top: 10px !important;\n  margin-bottom: 10px !important; }\n.lego .push--sides {\n  margin-right: 10px !important;\n  margin-left: 10px !important; }\n.lego .push-half {\n  margin: 5px !important; }\n.lego .push-half--top {\n  margin-top: 5px !important; }\n.lego .push-half--right {\n  margin-right: 5px !important; }\n.lego .push-half--bottom {\n  margin-bottom: 5px !important; }\n.lego .push-half--left {\n  margin-left: 5px !important; }\n.lego .push-half--ends {\n  margin-top: 5px !important;\n  margin-bottom: 5px !important; }\n.lego .push-half--sides {\n  margin-right: 5px !important;\n  margin-left: 5px !important; }\n.lego .push-double {\n  margin: 20px !important; }\n.lego .push-double--top {\n  margin-top: 20px !important; }\n.lego .push-double--right {\n  margin-right: 20px !important; }\n.lego .push-double--bottom {\n  margin-bottom: 20px !important; }\n.lego .push-double--left {\n  margin-left: 20px !important; }\n.lego .push-double--ends {\n  margin-top: 20px !important;\n  margin-bottom: 20px !important; }\n.lego .push-double--sides {\n  margin-right: 20px !important;\n  margin-left: 20px !important; }\n.lego .push-triple {\n  margin: 30px !important; }\n.lego .push-triple--top {\n  margin-top: 30px !important; }\n.lego .push-triple--right {\n  margin-right: 30px !important; }\n.lego .push-triple--bottom {\n  margin-bottom: 30px !important; }\n.lego .push-triple--left {\n  margin-left: 30px !important; }\n.lego .push-triple--ends {\n  margin-top: 30px !important;\n  margin-bottom: 30px !important; }\n.lego .push-triple--sides {\n  margin-right: 30px !important;\n  margin-left: 30px !important; }\n.lego .push-quad {\n  margin: 40px !important; }\n.lego .push-quad--top {\n  margin-top: 40px !important; }\n.lego .push-quad--right {\n  margin-right: 40px !important; }\n.lego .push-quad--bottom {\n  margin-bottom: 40px !important; }\n.lego .push-quad--left {\n  margin-left: 40px !important; }\n.lego .push-quad--ends {\n  margin-top: 40px !important;\n  margin-bottom: 40px !important; }\n.lego .push-quad--sides {\n  margin-right: 40px !important;\n  margin-left: 40px !important; }\n.lego .flush {\n  margin: 0 !important; }\n.lego .flush--top {\n  margin-top: 0 !important; }\n.lego .flush--right {\n  margin-right: 0 !important; }\n.lego .flush--bottom {\n  margin-bottom: 0 !important; }\n.lego .flush--left {\n  margin-left: 0 !important; }\n.lego .flush--ends {\n  margin-top: 0 !important;\n  margin-bottom: 0 !important; }\n.lego .flush--sides {\n  margin-right: 0 !important;\n  margin-left: 0 !important; }\n.lego .lego-form-fields > *:last-child, .lego .lego-notification > *:last-child,\n.lego .lego-attention > *:last-child, .lego .lego-disclose > *:last-child, .lego .lego-dialog__body > *:last-child,\n.lego .lego-island > *:last-child,\n.lego .lego-media__body > *:last-child,\n.lego .lego-popover__content > *:last-child, .lego .lego-form-fields > *:last-child > *:last-child, .lego .lego-notification > *:last-child > *:last-child,\n.lego .lego-attention > *:last-child > *:last-child, .lego .lego-disclose > *:last-child > *:last-child, .lego .lego-dialog__body > *:last-child > *:last-child,\n.lego .lego-island > *:last-child > *:last-child,\n.lego .lego-media__body > *:last-child > *:last-child,\n.lego .lego-popover__content > *:last-child > *:last-child, .lego .lego-form-fields > *:last-child > *:last-child > *:last-child, .lego .lego-notification > *:last-child > *:last-child > *:last-child,\n.lego .lego-attention > *:last-child > *:last-child > *:last-child, .lego .lego-disclose > *:last-child > *:last-child > *:last-child, .lego .lego-dialog__body > *:last-child > *:last-child > *:last-child,\n.lego .lego-island > *:last-child > *:last-child > *:last-child,\n.lego .lego-media__body > *:last-child > *:last-child > *:last-child,\n.lego .lego-popover__content > *:last-child > *:last-child > *:last-child {\n  margin-bottom: 0; }\n.lego .soft {\n  padding: 10px !important; }\n.lego .soft--top {\n  padding-top: 10px !important; }\n.lego .soft--right {\n  padding-right: 10px !important; }\n.lego .soft--bottom {\n  padding-bottom: 10px !important; }\n.lego .soft--left {\n  padding-left: 10px !important; }\n.lego .soft--ends {\n  padding-top: 10px !important;\n  padding-bottom: 10px !important; }\n.lego .soft--sides {\n  padding-right: 10px !important;\n  padding-left: 10px !important; }\n.lego .soft-half {\n  padding: 5px !important; }\n.lego .soft-half--top {\n  padding-top: 5px !important; }\n.lego .soft-half--right {\n  padding-right: 5px !important; }\n.lego .soft-half--bottom {\n  padding-bottom: 5px !important; }\n.lego .soft-half--left {\n  padding-left: 5px !important; }\n.lego .soft-half--ends {\n  padding-top: 5px !important;\n  padding-bottom: 5px !important; }\n.lego .soft-half--sides {\n  padding-right: 5px !important;\n  padding-left: 5px !important; }\n.lego .soft-one-and-half--sides {\n  padding-right: 15px !important;\n  padding-left: 15px !important; }\n.lego .soft-double {\n  padding: 20px !important; }\n.lego .soft-double--top {\n  padding-top: 20px !important; }\n.lego .soft-double--right {\n  padding-right: 20px !important; }\n.lego .soft-double--bottom {\n  padding-bottom: 20px !important; }\n.lego .soft-double--left {\n  padding-left: 20px !important; }\n.lego .soft-double--ends {\n  padding-top: 20px !important;\n  padding-bottom: 20px !important; }\n.lego .soft-double--sides {\n  padding-right: 20px !important;\n  padding-left: 20px !important; }\n.lego .soft-triple--top {\n  padding-top: 30px !important; }\n.lego .soft-triple--right {\n  padding-right: 30px !important; }\n.lego .soft-triple--bottom {\n  padding-bottom: 30px !important; }\n.lego .soft-triple--left {\n  padding-left: 30px !important; }\n.lego .soft-triple--ends {\n  padding-top: 30px !important;\n  padding-bottom: 30px !important; }\n.lego .soft-triple--sides {\n  padding-right: 40px !important;\n  padding-left: 40px !important; }\n.lego .soft-quad--top {\n  padding-top: 40px !important; }\n.lego .soft-quad--right {\n  padding-right: 40px !important; }\n.lego .soft-quad--bottom {\n  padding-bottom: 40px !important; }\n.lego .soft-quad--left {\n  padding-left: 40px !important; }\n.lego .soft-quad--ends {\n  padding-top: 40px !important;\n  padding-bottom: 40px !important; }\n.lego .soft-quad--sides {\n  padding-right: 40px !important;\n  padding-left: 40px !important; }\n.lego .hard {\n  padding: 0 !important; }\n.lego .hard--top {\n  padding-top: 0 !important; }\n.lego .hard--right {\n  padding-right: 0 !important; }\n.lego .hard--bottom {\n  padding-bottom: 0 !important; }\n.lego .hard--left {\n  padding-left: 0 !important; }\n.lego .hard--ends {\n  padding-top: 0 !important;\n  padding-bottom: 0 !important; }\n.lego .hard--sides {\n  padding-right: 0 !important;\n  padding-left: 0 !important; }\n.lego .weight--light {\n  font-weight: 300 !important; }\n.lego .weight--normal {\n  font-weight: 400 !important; }\n.lego .weight--bold {\n  font-weight: 500 !important; }\n.lego .style--italic {\n  font-style: italic !important; }\n.lego .style--normal {\n  font-style: normal !important; }\n.lego .informative {\n  cursor: help !important; }\n.lego .underline {\n  text-decoration: underline !important; }\n.lego .strike {\n  text-decoration: line-through !important; }\n.lego .reverse {\n  color: white !important; }\n.lego .muted {\n  color: #a5a5a5 !important; }\n.lego .faint {\n  color: #e0e0e0 !important; }\n.lego .proceed {\n  text-align: right !important; }\n.lego .cell-truncate__text,\n.lego .truncate {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis; }\n.lego .go:after {\n  content: '\\00A0' '\\00BB' !important; }\n.lego .caps {\n  text-transform: uppercase !important; }\n.lego .force-break {\n  word-wrap: break-word !important; }\n.lego .nowrap {\n  white-space: nowrap !important; }\n.lego .text--block {\n  display: block !important; }\n.lego .text--inline {\n  display: inline !important; }\n.lego .line--tight {\n  line-height: 1.2 !important; }\n.lego .line--loose {\n  line-height: 1.8 !important; }\n.lego .word-break {\n  word-break: break-all !important; }\n.lego .good-news {\n  color: #97c70a !important; }\n.lego .warning {\n  color: #ffd40c !important; }\n.lego .bad-news {\n  color: #c6400c !important; }\n.lego .width-50 {\n  width: 50px !important;\n  -ms-flex-preferred-size: 50px !important; }\n.lego .width-75 {\n  width: 75px !important;\n  -ms-flex-preferred-size: 50px !important; }\n.lego .width-100 {\n  width: 100px !important;\n  -ms-flex-preferred-size: 100px !important; }\n.lego .width-150 {\n  width: 150px !important;\n  -ms-flex-preferred-size: 150px !important; }\n.lego .width-200 {\n  width: 200px !important;\n  -ms-flex-preferred-size: 200px !important; }\n.lego .width-250 {\n  width: 250px !important;\n  -ms-flex-preferred-size: 250px !important; }\n.lego .width-300 {\n  width: 300px !important;\n  -ms-flex-preferred-size: 300px !important; }\n.lego .height-50 {\n  height: 50px !important; }\n.lego .height-75 {\n  height: 75px !important; }\n.lego .height-100 {\n  height: 100px !important; }\n.lego .height-150 {\n  height: 150px !important; }\n.lego .height-200 {\n  height: 200px !important; }\n.lego .height-250 {\n  height: 250px !important; }\n.lego .height-300 {\n  height: 300px !important; }\n\n/*# sourceMappingURL=lego-desktop.css.map */\n", ""]);

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isIE9 = memoize(function() {
			return /msie 9\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isIE9();

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function () {
				styleElement.parentNode.removeChild(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	function replaceText(source, id, replacement) {
		var boundaries = ["/** >>" + id + " **/", "/** " + id + "<< **/"];
		var start = source.lastIndexOf(boundaries[0]);
		var wrappedReplacement = replacement
			? (boundaries[0] + replacement + boundaries[1])
			: "";
		if (source.lastIndexOf(boundaries[0]) >= 0) {
			var end = source.lastIndexOf(boundaries[1]) + boundaries[1].length;
			return source.slice(0, start) + wrappedReplacement + source.slice(end);
		} else {
			return source + wrappedReplacement;
		}
	}

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(styleElement.styleSheet.cssText, index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(sourceMap && typeof btoa === "function") {
			try {
				css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(JSON.stringify(sourceMap)) + " */";
				css = "@import url(\"data:stylesheet/css;base64," + btoa(css) + "\")";
			} catch(e) {}
		}

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function() {
		var list = [];
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
		return list;
	}

/***/ }
/******/ ]);

var noop = function(){}
window.history.replaceState = noop
window.history.pushState = noop
window.optly = {}
try {
  window.optlyConfig = {"env": {"ASSET_HOST_URL": "https://www.optimizely.test:9000", "EDIT_HOST": "www.optimizelyedit.test", "JS_ENV_ENDPOINT": "https://www-local.optimizely.com/assets/js/js_env.js", "INNIE_URL": "https://www.optimizely.test:9000/devel.440077732024747734/assets/js/innie.js", "INNER_BUNDLE_URL": "https://www.optimizely.test:9000/devel.440077732024747734/assets/js/bundle-s/inner.js", "IS_DEVELOPMENT": true, "FRAME_BUNDLE_URL": "https://www.optimizely.test:9000/devel.440077732024747734/assets/js/bundle-s/inner.js", "PREVIEW_URL": "https://www.optimizelyedit.test", "PMET_WEBWORKER_URL": "https://www.optimizely.test:9000/devel.440077732024747734/assets/js/webworker/pmet_webworker.js", "EDIT_URL": "https://www.optimizelyedit.test", "HOST_URL": "https://www-local.optimizely.com", "HOST": "www-local.optimizely.com", "DOMAIN_WHITELIST": "(www\\-devel\\.optimizely\\.com$)|(www\\-devel\\.optimizely\\.appspot\\.com$)|(www\\-devel\\-dot\\-optimizely\\.appspot\\.com$)|(\\.optimizely\\.test$)|(\\.optimizely\\.com$)|(\\.optimizely\\.at$)|(\\.optimizely\\.be$)|(\\.optimizely\\.bg$)|(\\.optimizely\\.by$)|(\\.optimizely\\.ch$)|(\\.optimizely\\.cl$)|(\\.optimizely\\.co\\.il$)|(\\.optimizely\\.co\\.nz$)|(\\.optimizely\\.co\\.uk$)|(\\.optimizely\\.com\\.br$)|(\\.optimizely\\.com\\.hr$)|(\\.optimizely\\.com\\.mx$)|(\\.optimizely\\.cz$)|(\\.optimizely\\.de$)|(\\.optimizely\\.es$)|(\\.optimizely\\.dk$)|(\\.optimizely\\.fr$)|(\\.optimizely\\.gr$)|(\\.optimizely\\.hk$)|(\\.optimizely\\.ie$)|(\\.optimizely\\.it$)|(\\.optimizely\\.jp$)|(\\.optimizely\\.lt$)|(\\.optimizely\\.lu$)|(\\.optimizely\\.lv$)|(\\.optimizely\\.nl$)|(\\.optimizely\\.mx$)|(\\.optimizely\\.pl$)|(\\.optimizely\\.pt$)|(\\.optimizely\\.ro$)|(\\.optimizely\\.ru$)|(\\.optimizely\\.se$)|(\\.optimizely\\.sg$)|(\\.optimisely\\.com$)|(\\.optimisely\\.at$)|(\\.optimisely\\.be$)|(\\.optimisely\\.bg$)|(\\.optimisely\\.by$)|(\\.optimisely\\.ch$)|(\\.optimisely\\.cl$)|(\\.optimisely\\.co\\.il$)|(\\.optimisely\\.co\\.nz$)|(\\.optimisely\\.co\\.uk$)|(\\.optimisely\\.com\\.br$)|(\\.optimisely\\.com\\.hr$)|(\\.optimisely\\.com\\.mx$)|(\\.optimisely\\.cz$)|(\\.optimisely\\.de$)|(\\.optimisely\\.es$)|(\\.optimisely\\.dk$)|(\\.optimisely\\.fr$)|(\\.optimisely\\.gr$)|(\\.optimisely\\.hk$)|(\\.optimisely\\.ie$)|(\\.optimisely\\.it$)|(\\.optimisely\\.jp$)|(\\.optimisely\\.lt$)|(\\.optimisely\\.lu$)|(\\.optimisely\\.lv$)|(\\.optimisely\\.nl$)|(\\.optimisely\\.mx$)|(\\.optimisely\\.pl$)|(\\.optimisely\\.pt$)|(\\.optimisely\\.ro$)|(\\.optimisely\\.ru$)|(\\.optimisely\\.se$)|(\\.optimisely\\.sg$)|(\\.optimizely\\.appspot\\.com$)|(\\.optimizely\\-hrd\\.appspot\\.com$)|(\\-dot\\-optimizely\\.appspot\\.com$)|(\\-dot\\-optimizely\\-hrd\\.appspot\\.com$)"},"account_info": {"project_count": 28, "last_name": "Garcia", "account_id": 555650815, "has_seen_audience_guiders": true, "munchkin_token": "f2a358a04dcb8238c6baa4c4ff9d6d164875178d", "plan_display_name": "Free", "backend_api_token": "AAKldgcAp_y0hD9lPx0B-nm6auFOl90E", "preview_script_url": "https://www.optimizely.com/js/preview-master-1747.380665938442665926.js?token=60cc2712d46247598091c56e03e52c26&amp;account_id=555650815", "projects": {"584180236": {"preview_js_file_name": "0f465968bde2beba819d03504f50a5d6", "project_status": "Active", "project_platforms": ["web"]}, "2241820687": {"preview_js_file_name": "39d8fd8fe1513fcb1e5e00ec6c24e4a2", "project_status": "Active", "project_platforms": ["ios"]}, "651071385": {"preview_js_file_name": "26b5978b3f6897c93d3406fe354afa93", "project_status": "Active", "project_platforms": ["web"]}, "566670883": {"preview_js_file_name": "4202c01a90f78a722b5895bd38269d4e", "project_status": "Active", "project_platforms": ["web"]}, "1839630117": {"preview_js_file_name": "6eb61c7dc6651aca19b34b0758dcadab", "project_status": "Active", "project_platforms": ["web"]}, "1653451174": {"preview_js_file_name": "b1a2047d87b313234acde04d7ef4a400", "project_status": "Active", "project_platforms": ["web"]}, "804231466": {"preview_js_file_name": "fae11396f06b27f58966affefe07199b", "project_status": "Active", "project_platforms": ["web"]}, "1343973042": {"preview_js_file_name": "376a8b830f42c2cd1ee01770eaf9cbc7", "project_status": "Active", "project_platforms": ["web"]}, "1347620788": {"preview_js_file_name": "84d65e896effcbdd73a7d16faba89356", "project_status": "Active", "project_platforms": ["web"]}, "859720118": {"preview_js_file_name": "1d7603a61971baee16b01b737d9fb4af", "project_status": "Active", "project_platforms": ["web"]}, "789236924": {"preview_js_file_name": "e4425cbcbaa82f3cff627d399660f73f", "project_status": "Active", "project_platforms": ["web"]}, "754864960": {"preview_js_file_name": "35c6a7d8bdfa531d6a65bbc6db147395", "project_status": "Active", "project_platforms": ["web"]}, "547944643": {"preview_js_file_name": "90667091292921d69a9ad00f60a8c70d", "project_status": "Active", "project_platforms": ["web"]}, "1540431046": {"preview_js_file_name": "45c5bf6f8b8a02a2ad30e5e53051e1a9", "project_status": "Active", "project_platforms": ["web"]}, "1359591495": {"preview_js_file_name": "450b9ad5b02ae19f814e5d1ab97d309a", "project_status": "Active", "project_platforms": ["web"]}, "758824777": {"preview_js_file_name": "e3d199e03e5f61ec2df6a4008c31cd8f", "project_status": "Active", "project_platforms": ["web"]}, "2153180497": {"preview_js_file_name": "c185709c79a7eef4c18f58e7e8a88247", "project_status": "Active", "project_platforms": ["ios"]}, "576000730": {"preview_js_file_name": "d9da9880c471281abd79fc56cdf89f2e", "project_status": "Active", "project_platforms": ["web"]}, "819000157": {"preview_js_file_name": "0f750f94d1864b772f70d7ada4946fa7", "project_status": "Active", "project_platforms": ["web"]}, "1323452127": {"preview_js_file_name": "f4320585edd505bcdbb7dd3e782d4cd9", "project_status": "Active", "project_platforms": ["ios"]}, "2103121124": {"preview_js_file_name": "55393e65868c2b221a2b8e601788ac40", "project_status": "Active", "project_platforms": ["web"]}, "1989190117": {"preview_js_file_name": "cbdff7bd1ea5b5af7b6b842c3b4e5242", "project_status": "Active", "project_platforms": ["web"]}, "1389401705": {"preview_js_file_name": "70f0c2da690be64cb1ef2cef772ce1ba", "project_status": "Active", "project_platforms": ["web"]}, "2097891184": {"preview_js_file_name": "e9a5595495c6c843ff8994376a41b827", "project_status": "Active", "project_platforms": ["web"]}, "2248411249": {"preview_js_file_name": "5f3614408774788fc9f513f6eb9e6a67", "project_status": "Active", "project_platforms": ["web"]}, "2008300919": {"preview_js_file_name": "e4499355407e5f7e4a0cb5d27c1f6fdb", "project_status": "Active", "project_platforms": ["web"]}, "2205203579": {"preview_js_file_name": "a693ccd570befd5324cba489bc0d98e4", "project_status": "Active", "project_platforms": ["ios"]}, "555650815": {"preview_js_file_name": "86ab5bd48261a56c4efd1d439a0f0d2f", "project_status": "Active", "project_platforms": ["web"]}}, "is_admin": true, "unique_user_id": "7afe4c97c06f11e38cadf35d39e1180f", "include_whitelist_feature": null, "trusted_tester": false, "beta_customer": false, "has_seen_first_notice": false, "experiments_total": 212, "is_entitled_to_platinum": true, "use_project_goals": true, "first_name": "Jordan", "has_installed_snippet": true, "user_accounts": [{"current_account": false, "account_id": 804231466, "email": "jordan@optimizely.com", "is_admin": true, "role": "Administrator", "account_name": null}, {"current_account": true, "account_id": 555650815, "email": "jon.noronha+test@optimizely.com", "is_admin": true, "role": "Administrator", "account_name": null}], "subscribed": true, "source": null, "project_ids": [804231466, 2241820687, 547944643, 555650815, 566670883, 576000730, 584180236, 651071385, 754864960, 758824777, 789236924, 819000157, 859720118, 1323452127, 1343973042, 1347620788, 1359591495, 1389401705, 1540431046, 1653451174, 1839630117, 1989190117, 2008300919, 2097891184, 2103121124, 2153180497, 2205203579, 2248411249], "max_projects": 500, "has_seen_editor_guiders": true, "must_change_password": false, "company_name": null, "plan_id": "free", "is_master_account": false, "permissions": {"userPermissions": ["delete-note", "modify-account-tokens", "view-audience", "editor-debug", "delete-experiment", "create-visitor-segment", "edit-project-integration", "pause-experiment", "edit-variation-code-after-cancel", "create-goal", "audit-log", "read-account-tokens", "modify-dimension", "mobile-in-browser", "view-collaborators", "preview-debug", "edit-project", "billing", "create-collaborators", "archive-experiment", "vue-editor-drawer", "delete-goal", "view-users", "modify-collaborators", "view-note", "executive-summary", "view-experiment", "create-audience", "modify-goal", "view-audit-log", "delete-collaborators", "invite", "create-experiment", "reset-results", "view-project-integration", "view-usage", "modify-running-experiment", "modify-project", "create-android-project", "activity-log", "update-note", "delete-user", "view-results2", "export events", "create-note", "modify-paused-experiment", "create-project", "create-ios-project", "view-goal", "activity-annotations", "delete-dimension", "start-experiment", "view-dashboard2", "user-permissions", "gae_admin", "modify-audience", "create-dimension"], "accountPermissions": ["segmented results", "custom segments", "premium default segments", "cross browser testing", "multivariate testing", "query-parameters", "cookie", "scheduling", "list-targeting", "create-report", "audit-log", "browser-or-device-targeting", "custom-javascript", "series-annotations", "custom-event", "audience-targeting", "new-or-returning-visitor", "activity-log", "referrer-url", "custom-tags", "geotargeting", "source-targeting", "time-and-day-targeting", "create-ios-project", "add user", "multipage testing", "ad-campaign-targeting"]}, "subscription": {"currency": "USD", "in_trial": false, "plan": {"trial_period_in_days": 0, "payment_method_required": true, "display_name": "Free", "variable_usage_rate_in_thousandths_of_cents_usd": 0, "usage_allowance": 9223372036854775807, "variable_usage_rate_in_thousandths_of_cents_gbp": 0, "subscription_period_in_months": 1, "subscription_price_in_cents_gbp": 0, "number_of_projects_allowed": 500, "usage_metric": "muv", "plan_id": "free", "subscription_price_in_cents_usd": 0, "variable_usage_rate_in_thousandths_of_cents_euro": 0, "subscription_price_in_cents_euro": 0}}, "has_seen_results2_guiders": false, "email": "jordan@optimizely.com"}, "domain": {"whiteList": "(\\.optimizely\\.appspot\\.com$)|(\\.optimizely\\-hrd\\.appspot\\.com$)|(\\-dot\\-optimizely\\.appspot\\.com$)|(\\-dot\\-optimizely\\-hrd\\.appspot\\.com$)|(\\.optimizely\\.com$)|(\\.optimizely\\.at$)|(\\.optimizely\\.be$)|(\\.optimizely\\.bg$)|(\\.optimizely\\.by$)|(\\.optimizely\\.ch$)|(\\.optimizely\\.cl$)|(\\.optimizely\\.co\\.il$)|(\\.optimizely\\.co\\.nz$)|(\\.optimizely\\.co\\.uk$)|(\\.optimizely\\.com\\.br$)|(\\.optimizely\\.com\\.hr$)|(\\.optimizely\\.com\\.mx$)|(\\.optimizely\\.cz$)|(\\.optimizely\\.de$)|(\\.optimizely\\.es$)|(\\.optimizely\\.dk$)|(\\.optimizely\\.fr$)|(\\.optimizely\\.gr$)|(\\.optimizely\\.hk$)|(\\.optimizely\\.ie$)|(\\.optimizely\\.it$)|(\\.optimizely\\.jp$)|(\\.optimizely\\.lt$)|(\\.optimizely\\.lu$)|(\\.optimizely\\.lv$)|(\\.optimizely\\.nl$)|(\\.optimizely\\.mx$)|(\\.optimizely\\.pl$)|(\\.optimizely\\.pt$)|(\\.optimizely\\.ro$)|(\\.optimizely\\.ru$)|(\\.optimizely\\.se$)|(\\.optimizely\\.sg$)|(\\.optimisely\\.com$)|(\\.optimisely\\.at$)|(\\.optimisely\\.be$)|(\\.optimisely\\.bg$)|(\\.optimisely\\.by$)|(\\.optimisely\\.ch$)|(\\.optimisely\\.cl$)|(\\.optimisely\\.co\\.il$)|(\\.optimisely\\.co\\.nz$)|(\\.optimisely\\.co\\.uk$)|(\\.optimisely\\.com\\.br$)|(\\.optimisely\\.com\\.hr$)|(\\.optimisely\\.com\\.mx$)|(\\.optimisely\\.cz$)|(\\.optimisely\\.de$)|(\\.optimisely\\.es$)|(\\.optimisely\\.dk$)|(\\.optimisely\\.fr$)|(\\.optimisely\\.gr$)|(\\.optimisely\\.hk$)|(\\.optimisely\\.ie$)|(\\.optimisely\\.it$)|(\\.optimisely\\.jp$)|(\\.optimisely\\.lt$)|(\\.optimisely\\.lu$)|(\\.optimisely\\.lv$)|(\\.optimisely\\.nl$)|(\\.optimisely\\.mx$)|(\\.optimisely\\.pl$)|(\\.optimisely\\.pt$)|(\\.optimisely\\.ro$)|(\\.optimisely\\.ru$)|(\\.optimisely\\.se$)|(\\.optimisely\\.sg$)|(\\.optimizely\\.test$)|(www\\-devel\\.optimizely\\.com$)|(www\\-devel\\.optimizely\\.appspot\\.com$)|(www\\-devel\\-dot\\-optimizely\\.appspot\\.com$)"}, "requirejs_module_config": {"services/targeting_conditions": {"dimensions": {"custom_dimension": {"has_permission": true, "fields": {"name": {"required": true}, "value": {"required": false}}, "title": "Dimension"}, "has_ppid": {"help_text": "Adds visitors if they have/does not have a Universal User ID.", "has_permission": true, "title": "Has Universal User ID"}, "cookies": {"help_text": "Adds visitors if they have a certain cookie, or if that cookie is set to a certain value.", "fields": {"match_type": {"required": true, "values": [{"text": "has any value", "value": "exists"}, {"text": "equals", "value": "exact"}, {"text": "contains", "value": "substring"}, {"text": "matches", "value": "regex"}]}, "name": {"required": true}, "value": {"required": false}}, "has_permission": true, "permission_required": "cookie", "title": "Cookie"}, "code": {"help_text": "Adds visitors if the Javascript code (like \"myVariable == 10\") evaluates to true.", "fields": {"value": {"required": true}}, "has_permission": true, "permission_required": "custom-javascript", "title": "Custom Javascript"}, "language": {"help_text": "Adds visitors if they have a certain preferred language choice (like \"en-us\") set in their browser.", "fields": {"value": {"placeholder": "Select a language", "required": true, "values": [{"text": "Arabic - any", "group": "Common", "value": "ar"}, {"text": "Afrikaans", "group": "A", "value": "af"}, {"text": "Albanian", "group": "A", "value": "sq"}, {"text": "Arabic - Algeria", "group": "A", "value": "ar-dz"}, {"text": "Arabic - Bahrain", "group": "A", "value": "ar-bh"}, {"text": "Arabic - Egypt", "group": "A", "value": "ar-eg"}, {"text": "Arabic - Iraq", "group": "A", "value": "ar-iq"}, {"text": "Arabic - Jordan", "group": "A", "value": "ar-jo"}, {"text": "Arabic - Kuwait", "group": "A", "value": "ar-kw"}, {"text": "Arabic - Lebanon", "group": "A", "value": "ar-lb"}, {"text": "Arabic - Libya", "group": "A", "value": "ar-ly"}, {"text": "Arabic - Morocco", "group": "A", "value": "ar-ma"}, {"text": "Arabic - Oman", "group": "A", "value": "ar-om"}, {"text": "Arabic - Saudi Arabia", "group": "A", "value": "ar-sa"}, {"text": "Arabic - Syria", "group": "A", "value": "ar-sy"}, {"text": "Arabic - Qatar", "group": "A", "value": "ar-qa"}, {"text": "Arabic - Tunisia", "group": "A", "value": "ar-tn"}, {"text": "Arabic - U.A.E.", "group": "A", "value": "ar-ae"}, {"text": "Arabic - Yemen", "group": "A", "value": "ar-ye"}, {"text": "Basque", "group": "B", "value": "eu"}, {"text": "Belarusian", "group": "B", "value": "be"}, {"text": "Bulgarian", "group": "B", "value": "bg"}, {"text": "Catalan", "group": "C", "value": "ca"}, {"text": "Chinese - any", "group": "Common", "value": "zh"}, {"text": "Chinese - Hong Kong", "group": "C", "value": "zh-hk"}, {"text": "Chinese - PRC", "group": "C", "value": "zh-cn"}, {"text": "Chinese - Singapore", "group": "C", "value": "zh-sg"}, {"text": "Chinese - Taiwan", "group": "C", "value": "zh-tw"}, {"text": "Croatian", "group": "C", "value": "hr"}, {"text": "Czech", "group": "C", "value": "cs"}, {"text": "Danish", "group": "Common", "value": "da"}, {"text": "Dutch - any", "group": "Common", "value": "nl"}, {"text": "Dutch - Belgian", "group": "D", "value": "nl-be"}, {"text": "English - any", "group": "Common", "value": "en"}, {"text": "English - Australian", "group": "E", "value": "en-au"}, {"text": "English - Belize", "group": "E", "value": "en-bz"}, {"text": "English - British", "group": "E", "value": "en-gb"}, {"text": "English - Canadian", "group": "E", "value": "en-ca"}, {"text": "English - Ireland", "group": "E", "value": "en-ie"}, {"text": "English - Jamaica", "group": "E", "value": "en-jm"}, {"text": "English - New Zealand", "group": "E", "value": "en-nz"}, {"text": "English - South Africa", "group": "E", "value": "en-za"}, {"text": "English - Trinidad", "group": "E", "value": "en-tt"}, {"text": "English - United States", "group": "E", "value": "en-us"}, {"text": "Estonian", "group": "E", "value": "et"}, {"text": "Farsi", "group": "F", "value": "fa"}, {"text": "Finnish", "group": "Common", "value": "fi"}, {"text": "French - any", "group": "Common", "value": "fr"}, {"text": "French - Belgian", "group": "F", "value": "fr-be"}, {"text": "French - Canadian", "group": "F", "value": "fr-ca"}, {"text": "French - Luxembourg", "group": "F", "value": "fr-lu"}, {"text": "French - Swiss", "group": "F", "value": "fr-ch"}, {"text": "Gaelic - any", "group": "G", "value": "gd"}, {"text": "German - any", "group": "G", "value": "de"}, {"text": "German - Austrian", "group": "G", "value": "de-at"}, {"text": "German - Liechtenstein", "group": "G", "value": "de-li"}, {"text": "German - Luxembourg", "group": "G", "value": "de-lu"}, {"text": "German - Swiss", "group": "G", "value": "de-ch"}, {"text": "Greek", "group": "G", "value": "el"}, {"text": "Hebrew", "group": "H", "value": "he"}, {"text": "Hindi", "group": "Common", "value": "hi"}, {"text": "Hungarian", "group": "H", "value": "hu"}, {"text": "Icelandic", "group": "I", "value": "is"}, {"text": "Indonesian", "group": "I", "value": "in"}, {"text": "Italian - any", "group": "I", "value": "it"}, {"text": "Italian - Swiss", "group": "I", "value": "it-ch"}, {"text": "Japanese", "group": "Common", "value": "ja"}, {"text": "Korean", "group": "K", "value": "ko"}, {"text": "Korean - Johab", "group": "K", "value": "ko"}, {"text": "Latvian", "group": "L", "value": "lv"}, {"text": "Lithuanian", "group": "L", "value": "lt"}, {"text": "Malaysian", "group": "M", "value": "ms"}, {"text": "Maltese", "group": "M", "value": "mt"}, {"text": "Norwegian", "group": "Common", "value": "no"}, {"text": "Polish", "group": "P", "value": "pl"}, {"text": "Portuguese - any", "group": "Common", "value": "pt"}, {"text": "Portuguese - Brazil", "group": "P", "value": "pt-br"}, {"text": "Romanian - any", "group": "R", "value": "ro"}, {"text": "Romanian - Moldavia", "group": "R", "value": "ro-mo"}, {"text": "Russian - any", "group": "Common", "value": "ru"}, {"text": "Russian - Moldavia", "group": "R", "value": "ru-mo"}, {"text": "Serbian", "group": "S", "value": "sr"}, {"text": "Slovak", "group": "S", "value": "sk"}, {"text": "Slovenian", "group": "S", "value": "sl"}, {"text": "Sorbian", "group": "S", "value": "sb"}, {"text": "Spanish - any", "group": "Common", "value": "es"}, {"text": "Spanish - Argentina", "group": "S", "value": "es-ar"}, {"text": "Spanish - Bolivia", "group": "S", "value": "es-bo"}, {"text": "Spanish - Chile", "group": "S", "value": "es-c"}, {"text": "Spanish - Colombia", "group": "S", "value": "es-co"}, {"text": "Spanish - Costa Rica", "group": "S", "value": "es-cr"}, {"text": "Spanish - Dominican Republic", "group": "S", "value": "es-do"}, {"text": "Spanish - Ecuador", "group": "S", "value": "es-ec"}, {"text": "Spanish - El Salvador", "group": "S", "value": "es-sv"}, {"text": "Spanish - Guatemala", "group": "S", "value": "es-gt"}, {"text": "Spanish - Honduras", "group": "S", "value": "es-hn"}, {"text": "Spanish - Mexican", "group": "S", "value": "es-mx"}, {"text": "Spanish - Nicaragua", "group": "S", "value": "es-ni"}, {"text": "Spanish - Panama", "group": "S", "value": "es-pa"}, {"text": "Spanish - Paraguay", "group": "S", "value": "es-py"}, {"text": "Spanish - Peru", "group": "S", "value": "es-pe"}, {"text": "Spanish - Puerto Rico", "group": "S", "value": "es-pr"}, {"text": "Spanish - Uruguay", "group": "S", "value": "es-uy"}, {"text": "Spanish - Venezuela", "group": "S", "value": "es-ve"}, {"text": "Sutu", "group": "S", "value": "sx"}, {"text": "Swedish - any", "group": "Common", "value": "sv"}, {"text": "Swedish - Finland", "group": "S", "value": "sv-fi"}, {"text": "Thai", "group": "T", "value": "th"}, {"text": "Tsonga", "group": "T", "value": "ts"}, {"text": "Tswana", "group": "T", "value": "tn"}, {"text": "Turkish", "group": "T", "value": "tr"}, {"text": "Ukrainian", "group": "U", "value": "uk"}, {"text": "Urdu", "group": "U", "value": "ur"}, {"text": "Vietnamese", "group": "V", "value": "vi"}, {"text": "Xhosa", "group": "X", "value": "xh"}, {"text": "Yiddish", "group": "Y", "value": "ji"}, {"text": "Zulu", "group": "Z", "value": "zu"}]}}, "has_permission": true, "title": "Language"}, "campaign": {"help_text": "Adds visitors who came from an ad campaign with a certain utm_campaign parameter.", "fields": {"match_type": {"required": true, "values": [{"text": "has any value", "value": "exists"}, {"text": "equals", "value": "exact"}, {"text": "contains", "value": "substring"}, {"text": "matches", "value": "regex"}]}, "value": {"required": false, "disallowed_values": ["none"]}}, "has_permission": true, "permission_required": "ad-campaign-targeting", "title": "Ad Campaign"}, "referrer": {"help_text": "Adds visitors if they just came from a certain URL (like \"facebook.com\").", "fields": {"match_type": {"required": true, "values": [{"text": "Simple match (hostname/path only)", "value": "simple"}, {"text": "Exact match", "value": "exact"}, {"text": "Substring match", "value": "substring"}, {"text": "Regular expression match", "value": "regex"}]}, "value": {"required": true}}, "has_permission": true, "permission_required": "referrer-url", "title": "Referrer URL"}, "time_and_day": {"help_text": "Adds people who visit during a certain time of the day or week.", "fields": {"value": {"required": true}}, "has_permission": true, "permission_required": "time-and-day-targeting", "title": "Time/Day of Visit"}, "ip": {"help_text": "Adds visitors if they match a certain IP address pattern.", "fields": {"match_type": {"required": true, "values": [{"text": "Exact match", "value": "exact"}, {"text": "Regular expression match", "value": "regex"}, {"text": "CIDR Notation (subnet/mask)", "value": "cidr"}, {"text": "Prefix match", "value": "prefix"}]}, "value": {"required": true}}, "has_permission": true, "permission_required": "geotargeting", "title": "IP Address"}, "list": {"help_text": "Adds visitors based on the lists you have uploaded.", "fields": {"name": {"required": true}, "value": {"required": false}}, "has_permission": true, "permission_required": "list-targeting", "title": "List Membership"}, "third_party_dimension": {"has_permission": true, "fields": {"name": {"required": true}, "value": {"required": true}}, "title": "Third Party Dimension"}, "source_type": {"help_text": "Adds visitors based on their traffic source (direct, referrer, search, or campaign).", "fields": {"value": {"required": true, "values": [{"text": "Direct", "value": "direct"}, {"text": "Search", "value": "search"}, {"text": "Referral", "value": "referral"}, {"text": "Campaign", "value": "campaign"}]}}, "has_permission": true, "permission_required": "source-targeting", "title": "Traffic Source"}, "first_session": {"help_text": "Adds visitors who are in their first session at your site.", "has_permission": true, "title": "New/Returning Session"}, "location": {"help_text": "Adds visitors based on their city, country, state, or region. Also known as Geotargeting.", "fields": {"value": {"required": true}}, "has_permission": true, "permission_required": "geotargeting", "title": "Location"}, "custom_tag": {"help_text": "Adds visitors based on custom information you've \"tagged\" on a visitor via the Javascript API.", "fields": {"match_type": {"required": true, "values": [{"text": "has any value", "value": "exists"}, {"text": "equals", "value": "exact"}, {"text": "contains", "value": "substring"}, {"text": "matches", "value": "regex"}]}, "name": {"required": true}, "value": {"required": false}}, "has_permission": true, "permission_required": "custom-tags", "title": "Custom Tags"}, "visitor": {"permission_required": "new-or-returning-visitor", "title": "New or Returning Visitor", "fields": {"value": {"required": true, "values": [{"text": "New", "value": "new"}, {"text": "Returning", "value": "returning"}]}}, "has_permission": true, "help_text": "Adds visitors if they've visited a page with your Optimizely Snippet before.", "hidden": true}, "query": {"help_text": "Adds visitors if the URL has a parameter with a matching value.", "fields": {"match_type": {"required": true, "values": [{"text": "has any value", "value": "exists"}, {"text": "equals", "value": "exact"}, {"text": "contains", "value": "substring"}, {"text": "matches", "value": "regex"}]}, "name": {"required": true}, "value": {"required": false}}, "has_permission": true, "permission_required": "query-parameters", "title": "Query Parameters"}, "event": {"help_text": "Adds visitors who triggered a goal with a certain custom event name recently.", "fields": {"name": {"required": true}}, "has_permission": true, "permission_required": "custom-event", "title": "Custom Event"}, "browser": {"help_text": "Adds visitors if they're using a certain browser or mobile device.", "fields": {"value": {"required": true, "values": [{"text": "Any mobile browser", "group": "Mobile", "value": "mobile"}, {"text": "Android (any browser)", "group": "Mobile", "value": "android"}, {"text": "Blackberry (any browser)", "group": "Mobile", "value": "blackberry"}, {"text": "iPad (any browser)", "group": "Mobile", "value": "ipad"}, {"text": "iPhone (any browser)", "group": "Mobile", "value": "iphone"}, {"text": "Windows Phone (any browser)", "group": "Mobile", "value": "windows phone"}, {"text": "Firefox 2", "group": "Firefox", "value": "ff2"}, {"text": "Firefox 3", "group": "Firefox", "value": "ff3"}, {"text": "Firefox 4", "group": "Firefox", "value": "ff4"}, {"text": "Firefox (any Desktop version)", "group": "Firefox", "value": "ff"}, {"text": "Internet Explorer 6", "group": "Internet Explorer", "value": "ie6", "deprecated": true}, {"text": "Internet Explorer 7", "group": "Internet Explorer", "value": "ie7", "deprecated": true}, {"text": "Internet Explorer 8", "group": "Internet Explorer", "value": "ie8"}, {"text": "Internet Explorer 9", "group": "Internet Explorer", "value": "ie9"}, {"text": "Internet Explorer 10", "group": "Internet Explorer", "value": "ie10"}, {"text": "Internet Explorer 11", "group": "Internet Explorer", "value": "ie11"}, {"text": "Safari 3", "group": "Safari (Desktop)", "value": "safari3"}, {"text": "Safari 4", "group": "Safari (Desktop)", "value": "safari4"}, {"text": "Safari 5", "group": "Safari (Desktop)", "value": "safari5"}, {"text": "Safari 6", "group": "Safari (Desktop)", "value": "safari6"}, {"text": "Safari 7", "group": "Safari (Desktop)", "value": "safari7"}, {"text": "Google Chrome", "group": "Other", "value": "gc"}, {"text": "Opera", "group": "Other", "value": "opera"}]}}, "has_permission": true, "permission_required": "browser-or-device-targeting", "title": "Browser or Device"}}}, "app_config": {"account_info": {"project_count": 28, "last_name": "Garcia", "account_id": 555650815, "has_seen_audience_guiders": true, "munchkin_token": "f2a358a04dcb8238c6baa4c4ff9d6d164875178d", "plan_display_name": "Free", "backend_api_token": "AAKldgcAp_y0hD9lPx0B-nm6auFOl90E", "preview_script_url": "https://www.optimizely.com/js/preview-master-1747.380665938442665926.js?token=60cc2712d46247598091c56e03e52c26&amp;account_id=555650815", "projects": {"584180236": {"preview_js_file_name": "0f465968bde2beba819d03504f50a5d6", "project_status": "Active", "project_platforms": ["web"]}, "2241820687": {"preview_js_file_name": "39d8fd8fe1513fcb1e5e00ec6c24e4a2", "project_status": "Active", "project_platforms": ["ios"]}, "651071385": {"preview_js_file_name": "26b5978b3f6897c93d3406fe354afa93", "project_status": "Active", "project_platforms": ["web"]}, "566670883": {"preview_js_file_name": "4202c01a90f78a722b5895bd38269d4e", "project_status": "Active", "project_platforms": ["web"]}, "1839630117": {"preview_js_file_name": "6eb61c7dc6651aca19b34b0758dcadab", "project_status": "Active", "project_platforms": ["web"]}, "1653451174": {"preview_js_file_name": "b1a2047d87b313234acde04d7ef4a400", "project_status": "Active", "project_platforms": ["web"]}, "804231466": {"preview_js_file_name": "fae11396f06b27f58966affefe07199b", "project_status": "Active", "project_platforms": ["web"]}, "1343973042": {"preview_js_file_name": "376a8b830f42c2cd1ee01770eaf9cbc7", "project_status": "Active", "project_platforms": ["web"]}, "1347620788": {"preview_js_file_name": "84d65e896effcbdd73a7d16faba89356", "project_status": "Active", "project_platforms": ["web"]}, "859720118": {"preview_js_file_name": "1d7603a61971baee16b01b737d9fb4af", "project_status": "Active", "project_platforms": ["web"]}, "789236924": {"preview_js_file_name": "e4425cbcbaa82f3cff627d399660f73f", "project_status": "Active", "project_platforms": ["web"]}, "754864960": {"preview_js_file_name": "35c6a7d8bdfa531d6a65bbc6db147395", "project_status": "Active", "project_platforms": ["web"]}, "547944643": {"preview_js_file_name": "90667091292921d69a9ad00f60a8c70d", "project_status": "Active", "project_platforms": ["web"]}, "1540431046": {"preview_js_file_name": "45c5bf6f8b8a02a2ad30e5e53051e1a9", "project_status": "Active", "project_platforms": ["web"]}, "1359591495": {"preview_js_file_name": "450b9ad5b02ae19f814e5d1ab97d309a", "project_status": "Active", "project_platforms": ["web"]}, "758824777": {"preview_js_file_name": "e3d199e03e5f61ec2df6a4008c31cd8f", "project_status": "Active", "project_platforms": ["web"]}, "2153180497": {"preview_js_file_name": "c185709c79a7eef4c18f58e7e8a88247", "project_status": "Active", "project_platforms": ["ios"]}, "576000730": {"preview_js_file_name": "d9da9880c471281abd79fc56cdf89f2e", "project_status": "Active", "project_platforms": ["web"]}, "819000157": {"preview_js_file_name": "0f750f94d1864b772f70d7ada4946fa7", "project_status": "Active", "project_platforms": ["web"]}, "1323452127": {"preview_js_file_name": "f4320585edd505bcdbb7dd3e782d4cd9", "project_status": "Active", "project_platforms": ["ios"]}, "2103121124": {"preview_js_file_name": "55393e65868c2b221a2b8e601788ac40", "project_status": "Active", "project_platforms": ["web"]}, "1989190117": {"preview_js_file_name": "cbdff7bd1ea5b5af7b6b842c3b4e5242", "project_status": "Active", "project_platforms": ["web"]}, "1389401705": {"preview_js_file_name": "70f0c2da690be64cb1ef2cef772ce1ba", "project_status": "Active", "project_platforms": ["web"]}, "2097891184": {"preview_js_file_name": "e9a5595495c6c843ff8994376a41b827", "project_status": "Active", "project_platforms": ["web"]}, "2248411249": {"preview_js_file_name": "5f3614408774788fc9f513f6eb9e6a67", "project_status": "Active", "project_platforms": ["web"]}, "2008300919": {"preview_js_file_name": "e4499355407e5f7e4a0cb5d27c1f6fdb", "project_status": "Active", "project_platforms": ["web"]}, "2205203579": {"preview_js_file_name": "a693ccd570befd5324cba489bc0d98e4", "project_status": "Active", "project_platforms": ["ios"]}, "555650815": {"preview_js_file_name": "86ab5bd48261a56c4efd1d439a0f0d2f", "project_status": "Active", "project_platforms": ["web"]}}, "is_admin": true, "unique_user_id": "7afe4c97c06f11e38cadf35d39e1180f", "include_whitelist_feature": null, "trusted_tester": false, "beta_customer": false, "has_seen_first_notice": false, "experiments_total": 212, "is_entitled_to_platinum": true, "use_project_goals": true, "first_name": "Jordan", "has_installed_snippet": true, "user_accounts": [{"current_account": false, "account_id": 804231466, "email": "jordan@optimizely.com", "is_admin": true, "role": "Administrator", "account_name": null}, {"current_account": true, "account_id": 555650815, "email": "jon.noronha+test@optimizely.com", "is_admin": true, "role": "Administrator", "account_name": null}], "subscribed": true, "source": null, "project_ids": [804231466, 2241820687, 547944643, 555650815, 566670883, 576000730, 584180236, 651071385, 754864960, 758824777, 789236924, 819000157, 859720118, 1323452127, 1343973042, 1347620788, 1359591495, 1389401705, 1540431046, 1653451174, 1839630117, 1989190117, 2008300919, 2097891184, 2103121124, 2153180497, 2205203579, 2248411249], "max_projects": 500, "has_seen_editor_guiders": true, "must_change_password": false, "company_name": null, "plan_id": "free", "is_master_account": false, "permissions": {"userPermissions": ["delete-note", "modify-account-tokens", "view-audience", "editor-debug", "delete-experiment", "create-visitor-segment", "edit-project-integration", "pause-experiment", "edit-variation-code-after-cancel", "create-goal", "audit-log", "read-account-tokens", "modify-dimension", "mobile-in-browser", "view-collaborators", "preview-debug", "edit-project", "billing", "create-collaborators", "archive-experiment", "vue-editor-drawer", "delete-goal", "view-users", "modify-collaborators", "view-note", "executive-summary", "view-experiment", "create-audience", "modify-goal", "view-audit-log", "delete-collaborators", "invite", "create-experiment", "reset-results", "view-project-integration", "view-usage", "modify-running-experiment", "modify-project", "create-android-project", "activity-log", "update-note", "delete-user", "view-results2", "export events", "create-note", "modify-paused-experiment", "create-project", "create-ios-project", "view-goal", "activity-annotations", "delete-dimension", "start-experiment", "view-dashboard2", "user-permissions", "gae_admin", "modify-audience", "create-dimension"], "accountPermissions": ["segmented results", "custom segments", "premium default segments", "cross browser testing", "multivariate testing", "query-parameters", "cookie", "scheduling", "list-targeting", "create-report", "audit-log", "browser-or-device-targeting", "custom-javascript", "series-annotations", "custom-event", "audience-targeting", "new-or-returning-visitor", "activity-log", "referrer-url", "custom-tags", "geotargeting", "source-targeting", "time-and-day-targeting", "create-ios-project", "add user", "multipage testing", "ad-campaign-targeting"]}, "subscription": {"currency": "USD", "in_trial": false, "plan": {"trial_period_in_days": 0, "payment_method_required": true, "display_name": "Free", "variable_usage_rate_in_thousandths_of_cents_usd": 0, "usage_allowance": 9223372036854775807, "variable_usage_rate_in_thousandths_of_cents_gbp": 0, "subscription_period_in_months": 1, "subscription_price_in_cents_gbp": 0, "number_of_projects_allowed": 500, "usage_metric": "muv", "plan_id": "free", "subscription_price_in_cents_usd": 0, "variable_usage_rate_in_thousandths_of_cents_euro": 0, "subscription_price_in_cents_euro": 0}}, "has_seen_results2_guiders": false, "email": "jordan@optimizely.com"}}, "services/third_party_targeting_conditions": {"conditions_metadata": {}}, "env": {"is_production": true, "backend_api_host": "https://api.optimizely.com"}}};
} catch (e) {
  window.optlyConfig = {};
}
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 */


/**
 * @define {boolean} Overridden to true by the compiler when --closure_pass
 *     or --mark_as_compiled is specified.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is
 * already defined in the current scope before assigning to prevent
 * clobbering if base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {}; // Identifies this file as the Closure base.

/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = window;


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production js_binary can be easily stripped
 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
 * because they are generally used for debugging purposes and it is difficult
 * for the JSCompiler to statically determine whether they are used.
 */
goog.DEBUG = true;


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */
goog.LOCALE = 'en';  // default to en


/**
 * Creates object stubs for a namespace.  The presence of one or more
 * goog.provide() calls indicate that the file defines the given
 * objects/namespaces.  Build tools also scan for provide/require statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 * @see goog.require
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */
goog.provide = function(name) {
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice. This is intended
    // to teach new developers that 'goog.provide' is effectively a variable
    // declaration. And when JSCompiler transforms goog.provide into a real
    // variable declaration, the compiled JS should work the same as the raw
    // JS--even when the raw JS uses goog.provide incorrectly.
    // if (goog.isProvided_(name)) {
    //   throw Error('Namespace "' + name + '" already declared.');
    // }
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(name);
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (COMPILED && !goog.DEBUG) {
    opt_message = opt_message || '';
    throw Error('Importing test-only code into non-debug environment' +
                opt_message ? ': ' + opt_message : '.');
  }
};


if (!COMPILED) {

  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return !goog.implicitNamespaces_[name] && !!goog.getObjectByName(name);
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares
   * that 'goog' and 'goog.events' must be namespaces.
   *
   * @type {Object}
   * @private
   */
  goog.implicitNamespaces_ = {};
}


/**
 * Builds an object structure for the provided namespace path,
 * ensuring that names that already exist are not overwritten. For
 * example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }

  // Certain browsers cannot parse code in the form for((a in b); c;);
  // This pattern is produced by the JSCompiler when it collapses the
  // statement above into the conditional loop below. To prevent this from
  // happening, use a for-loop and reserve the init logic as below.

  // Parentheses added to eliminate strict JS warning in Firefox.
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && goog.isDef(opt_object)) {
      // last part and we have an object; use it
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Returns an object based on its fully qualified external name.  If you are
 * using a compilation pass that renames property names beware that using this
 * function will not find renamed properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var part; part = parts.shift(); ) {
    if (goog.isDefAndNotNull(cur[part])) {
      cur = cur[part];
    } else {
      return null;
    }
  }
  return cur;
};


/**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */
goog.globalize = function(obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {Array} provides An array of strings with the names of the objects
 *                         this file provides.
 * @param {Array} requires An array of strings with the names of the objects
 *                         this file requires.
 */
goog.addDependency = function(relPath, provides, requires) {
  if (!COMPILED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      if (!(path in deps.pathToNames)) {
        deps.pathToNames[path] = {};
      }
      deps.pathToNames[path][provide] = true;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};




// NOTE(nnaze): The debug DOM loader was included in base.js as an orignal
// way to do "debug-mode" development.  The dependency system can sometimes
// be confusing, as can the debug DOM loader's asyncronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the
// script will not load until some point after the current script.  If a
// namespace is needed at runtime, it needs to be defined in a previous
// script, or loaded via require() with its registered dependencies.
// User-defined namespaces may need their own deps file.  See http://go/js_deps,
// http://go/genjsdeps, or, externally, DepsWriter.
// http://code.google.com/closure/library/docs/depswriter.html
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.ENABLE_DEBUG_LOADER = true;


/**
 * Implements a system for the dynamic resolution of dependencies
 * that works in parallel with the BUILD system. Note that all calls
 * to goog.require will be stripped by the JSCompiler when the
 * --closure_pass option is used.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide())
 *     in the form "goog.package.part".
 */
goog.require = function(name) {

  // if the object already exists we do not need do do anything
  // TODO(arv): If we start to support require based on file name this has
  //            to change
  // TODO(arv): If we allow goog.foo.* this has to change
  // TODO(arv): If we implement dynamic load after page load we should probably
  //            not remove this code for the compiled output
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      return;
    }

    if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.included_[path] = true;
        goog.writeScripts_();
        return;
      }
    }

    var errorMessage = 'goog.require could not find: ' + name;
    if (goog.global.console) {
      goog.global.console['error'](errorMessage);
    }


      throw Error(errorMessage);

  }
};


/**
 * Path for included scripts
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to write out Closure's deps file. By default,
 * the deps are written.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
goog.nullFunction = function() {};


/**
 * The identity function. Returns its first argument.
 *
 * @param {*=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {?} The first argument. We can't know the type -- just pass it along
 *      without type.
 * @deprecated Use goog.functions.identity instead.
 */
goog.identityFunction = function(opt_returnValue, var_args) {
  return opt_returnValue;
};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 *
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error
 * will be thrown when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as
 * an argument because that would make it more difficult to obfuscate
 * our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be
 *   overridden.
 */
goog.abstractMethod = function() {
  throw Error('unimplemented abstract method');
};


/**
 * Adds a {@code getInstance} static method that always return the same instance
 * object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */
goog.addSingletonGetter = function(ctor) {
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array.<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


if (!COMPILED && goog.ENABLE_DEBUG_LOADER) {
  /**
   * Object used to keep track of urls that have already been added. This
   * record allows the prevention of circular dependencies.
   * @type {Object}
   * @private
   */
  goog.included_ = {};


  /**
   * This object is used to keep track of dependencies and other data that is
   * used for loading scripts
   * @private
   * @type {Object}
   */
  goog.dependencies_ = {
    pathToNames: {}, // 1 to many
    nameToPath: {}, // 1 to 1
    requires: {}, // 1 to many
    // used when resolving dependencies to prevent us from
    // visiting the file twice
    visited: {},
    written: {} // used to keep track of script files we have written
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    var doc = goog.global.document;
    return typeof doc != 'undefined' &&
           'write' in doc;  // XULDocument misses write.
  };


  /**
   * Tries to detect the base path of the base.js script that bootstraps Closure
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    var doc = goog.global.document;
    var scripts = doc.getElementsByTagName('script');
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var src = scripts[i].src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };


  /**
   * Imports a script if, and only if, that script hasn't already been imported.
   * (Must be called at execution time)
   * @param {string} src Script source.
   * @private
   */
  goog.importScript_ = function(src) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
        goog.writeScriptTag_;
    if (!goog.dependencies_.written[src] && importScript(src)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /**
   * The default implementation of the import function. Writes a script tag to
   * import the script.
   *
   * @param {string} src The script source.
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src) {
    if (goog.inHtmlDocument_()) {
      var doc = goog.global.document;
      doc.write(
          '<script type="text/javascript" src="' + src + '"></' + 'script>');
      return true;
    } else {
      return false;
    }
  };


  /**
   * Resolves dependencies based on the dependencies added using addDependency
   * and calls importScript_ in the correct order.
   * @private
   */
  goog.writeScripts_ = function() {
    // the scripts we need to write this time
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;

    function visitNode(path) {
      if (path in deps.written) {
        return;
      }

      // we have already visited this one. We can get here if we have cyclic
      // dependencies
      if (path in deps.visited) {
        if (!(path in seenScript)) {
          seenScript[path] = true;
          scripts.push(path);
        }
        return;
      }

      deps.visited[path] = true;

      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          // If the required name is defined, we assume that it was already
          // bootstrapped by other means.
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }

      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }

    for (var path in goog.included_) {
      if (!deps.written[path]) {
        visitNode(path);
      }
    }

    for (var i = 0; i < scripts.length; i++) {
      if (scripts[i]) {
        goog.importScript_(goog.basePath + scripts[i]);
      } else {
        throw Error('Undefined script input');
      }
    }
  };


  /**
   * Looks at the dependency rules and tries to determine the script file that
   * fulfills a particular rule.
   * @param {string} rule In the form goog.namespace.Class or project.script.
   * @return {?string} Url corresponding to the rule, or null.
   * @private
   */
  goog.getPathFromDeps_ = function(rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };

  goog.findBasePath_();

  // Allow projects to manage the deps files themselves.
  if (goog.global.CLOSURE_NO_DEPS) {
    goog.importScript_(goog.basePath + 'deps.js');
  }
}



//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      // Check these first, so we can avoid calling Object.prototype.toString if
      // possible.
      //
      // IE improperly marshals tyepof across execution contexts, but a
      // cross-context object will still return false for "instanceof Object".
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }

      // HACK: In order to use an Object prototype method on the arbitrary
      //   value, the compiler requires the value be cast to type Object,
      //   even though the ECMA spec explicitly allows it.
      var className = Object.prototype.toString.call(
          /** @type {Object} */ (value));
      // In Firefox 3.6, attempting to access iframe window objects' length
      // property throws an NS_ERROR_FAILURE, so we need to special-case it
      // here.
      if (className == '[object Window]') {
        return 'object';
      }

      // We cannot always use constructor == Array or instanceof Array because
      // different frames have different Array objects. In IE6, if the iframe
      // where the array was created is destroyed, the array loses its
      // prototype. Then dereferencing val.splice here throws an exception, so
      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
      // so that will work. In this case, this function will return false and
      // most array functions will still work because the array is still
      // array-like (supports length and []) even though it has lost its
      // prototype.
      // Mark Miller noticed that Object.prototype.toString
      // allows access to the unforgeable [[Class]] property.
      //  15.2.4.2 Object.prototype.toString ( )
      //  When the toString method is called, the following steps are taken:
      //      1. Get the [[Class]] property of this object.
      //      2. Compute a string value by concatenating the three strings
      //         "[object ", Result(1), and "]".
      //      3. Return Result(2).
      // and this behavior survives the destruction of the execution context.
      if ((className == '[object Array]' ||
           // In IE all non value types are wrapped as objects across window
           // boundaries (not iframe though) so we have to do object detection
           // for this edge case
           typeof value.length == 'number' &&
           typeof value.splice != 'undefined' &&
           typeof value.propertyIsEnumerable != 'undefined' &&
           !value.propertyIsEnumerable('splice')

          )) {
        return 'array';
      }
      // HACK: There is still an array case that fails.
      //     function ArrayImpostor() {}
      //     ArrayImpostor.prototype = [];
      //     var impostor = new ArrayImpostor;
      // this can be fixed by getting rid of the fast path
      // (value instanceof Array) and solely relying on
      // (value && Object.prototype.toString.vall(value) === '[object Array]')
      // but that would require many more function calls and is not warranted
      // unless closure code is receiving objects from untrusted sources.

      // IE in cross-window calls does not correctly marshal the function type
      // (it appears just as an object) so we cannot use just typeof val ==
      // 'function'. However, if the object has a call property, it is a
      // function.
      if ((className == '[object Function]' ||
          typeof value.call != 'undefined' &&
          typeof value.propertyIsEnumerable != 'undefined' &&
          !value.propertyIsEnumerable('call'))) {
        return 'function';
      }


    } else {
      return 'null';
    }

  } else if (s == 'function' && typeof value.call == 'undefined') {
    // In Safari typeof nodeList returns 'function', and on Firefox
    // typeof behaves similarly for HTML{Applet,Embed,Object}Elements
    // and RegExps.  We would like to return object for those and we can
    // detect an invalid function by making sure that the function
    // object has a call method.
    return 'object';
  }
  return s;
};


/**
 * Returns true if the specified value is not |undefined|.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.  Additionally, this function assumes that the global
 * undefined variable has not been redefined.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function(val) {
  return val !== undefined;
};


/**
 * Returns true if the specified value is |null|
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function(val) {
  return val === null;
};


/**
 * Returns true if the specified value is defined and not null
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function(val) {
  // Note that undefined == null.
  return val != null;
};


/**
 * Returns true if the specified value is an array
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function(val) {
  return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like
 * the value needs to be an object and have a getFullYear() function.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a string
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function(val) {
  return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function(val) {
  return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function(val) {
  return typeof val == 'number';
};


/**
 * Returns true if the specified value is a function
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function(val) {
  return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays
 * and functions.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further
 * calls with the same object as a parameter returns the same value. The unique
 * ID is guaranteed to be unique across the current session amongst objects that
 * are passed into {@code getUid}. There is no guarantee that the ID is unique
 * or consistent across sessions. It is unsafe to generate unique ID for
 * function prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In Opera window.hasOwnProperty exists but always returns false so we avoid
  // using it. As a consequence the unique ID generated for BaseClass.prototype
  // and SubClass.prototype will be the same.
  return obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // DOM nodes in IE are not instance of Object and throws exception
  // for delete. Instead we try to use removeAttribute
  if ('removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  /** @preserveTry */
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure javascript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' +
    Math.floor(Math.random() * 2147483648).toString(36);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */
goog.getHashCode = goog.getUid;


/**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */
goog.removeHashCode = goog.removeUid;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which |this| should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially
 *     applied to the function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind
 *     is deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which |this| should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially
 *     applied to the function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of |this| 'pre-specified'.<br><br>
 *
 * Remaining arguments specified at call-time are appended to the pre-
 * specified ones.<br><br>
 *
 * Also see: {@link #partial}.<br><br>
 *
 * Usage:
 * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which |this| should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially
 *     applied to the function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @suppress {deprecated} See above.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default
      // Chrome extension environment. This means that for Chrome extensions,
      // they get the implementation of Function.prototype.bind that
      // calls goog.bind instead of the native one. Even worse, we don't want
      // to introduce a circular dependency between goog.bind and
      // Function.prototype.bind, so we have to hack this to make sure it
      // works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially
 *     applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Prepend the bound arguments to the current arguments.
    var newArgs = Array.prototype.slice.call(arguments);
    newArgs.unshift.apply(newArgs, args);
    return fn.apply(this, newArgs);
  };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }

  // For IE7 or lower, the for-in-loop does not contain any properties that are
  // not enumerable on the prototype object (for example, isPrototypeOf from
  // Object.prototype) but also it will not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = Date.now || (function() {
  // Unary plus operator converts its operand to a number which in the case of
  // a date is done by calling getTime().
  return +new Date();
});


/**
 * Evals javascript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */
goog.globalEval = function(script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    // Test to see if eval works
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _et_ = 1;');
      if (typeof goog.global['_et_'] != 'undefined') {
        delete goog.global['_et_'];
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }

    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      var doc = goog.global.document;
      var scriptElt = doc.createElement('script');
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      // Note(user): can't use .innerHTML since "t('<test>')" will fail and
      // .text doesn't work in Safari 2.  Therefore we append a text node.
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw Error('goog.globalEval not available');
  }
};


/**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */
goog.evalWorksForGlobals_ = null;


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @type {Object|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a
 * hyphen and passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which
 * these mappings are used. In the BY_PART style, each part (i.e. in
 * between hyphens) of the passed in css name is rewritten according
 * to the map. In the BY_WHOLE style, the full css name is looked up in
 * the map directly. If a rewrite is not specified by the map, the
 * compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls
 * to goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x= 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed
 * only the modifier will be processed, as it is assumed the first
 * argument was generated as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?
        getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  if (opt_modifier) {
    return className + '-' + rename(opt_modifier);
  } else {
    return rename(className);
  }
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --closure_pass flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {Object|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Abstract implementation of goog.getMsg for use with localized messages.
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object=} opt_values Map of place holder name to value.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values) {
  var values = opt_values || {};
  for (var key in values) {
    var value = ('' + values[key]).replace(/\$/g, '$$$$');
    str = str.replace(new RegExp('\\{\\$' + key + '\\}', 'gi'), value);
  }
  return str;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated,
 * unless they are exported in turn via this function or
 * goog.exportProperty
 *
 * <p>Also handy for making public items that are defined in anonymous
 * closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction',
 *                       Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 */
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { }
 *
 * function ChildClass(a, b, c) {
 *   goog.base(this, a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // works
 * </pre>
 *
 * In addition, a superclass' implementation of a method can be invoked
 * as follows:
 *
 * <pre>
 * ChildClass.prototype.foo = function(a) {
 *   ChildClass.superClass_.foo.call(this, a);
 *   // other code
 * };
 * </pre>
 *
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * contructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass
 * the name of the method as the second argument to this function. If
 * you do not, you will get a runtime error. This calls the superclass'
 * method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express
 * inheritance relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the
 * compiler will do macro expansion to remove a lot of
 * the extra overhead that this function introduces. The compiler
 * will also enforce a lot of the assumptions that this function
 * makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 */
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;
  if (caller.superClass_) {
    // This is a constructor. Call the superclass constructor.
    return caller.superClass_.constructor.apply(
        me, Array.prototype.slice.call(arguments, 1));
  }

  var args = Array.prototype.slice.call(arguments, 2);
  var foundCaller = false;
  for (var ctor = me.constructor;
       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }

  // If we did not find the caller in the prototype chain,
  // then one of two things happened:
  // 1) The caller is an instance method.
  // 2) This method was not called by the right caller.
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error(
        'goog.base called from a method of one name ' +
        'to a method of a different name');
  }
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the
 * aliases applied.  In uncompiled code the function is simply run since the
 * aliases as written are valid JavaScript.
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *    (e.g. "var Timer = goog.Timer").
 */
goog.scope = function(fn) {
  fn.call(goog.global);
};
(function() {
goog = window.goog || {};

// assets/js/shared/nativity.js
goog.provide("optly.nativity");

optly.nativity.getNativeGetElementsByClassName = function() {
  var nativeGetByClass = document.getElementsByClassName;

  // prototype.lite.js, which is part of moo.fx, sets
  // document.getElementsByClassName without checking if it already exists.
  // Its implementation doesn't play nice with jQuery.
  if (!optly.nativity.isNativeFunction(nativeGetByClass)) {
    var optimizely = window['optimizely'] || {};
    var optimizelyGetByClass = optimizely['getElementsByClassName'];
    var optly_ = window['optly'] || {};
    var optlyGetByClass = optly_['getElementsByClassName'];

    if (optly.nativity.isNativeFunction(optimizelyGetByClass)) {
      nativeGetByClass = optimizelyGetByClass;
    }
    else if (optly.nativity.isNativeFunction(optlyGetByClass)) {
      nativeGetByClass = optlyGetByClass;
    }
    else {
      nativeGetByClass = null;
    }
  }

  return nativeGetByClass;
};

/**
 * Check if function is native or has been replaced.
 *
 * @param {Object} function_
 */
optly.nativity.isNativeFunction = function(function_) {
  // Use String constructor for compatibility with MSIE since some
  // methods are objects and not functions so don't have toString().
  // http://stackoverflow.com/questions/6598945/detect-if-function-is-native-to-browser
  return function_ && String(function_).indexOf("[native code]") !== -1;
};


// assets/js/cleanse/main.js
goog.provide("optly.Cleanse");

goog.require("optly.nativity");

/**
 * When properties are added to the prototypes of native Javascript types,
 * there's a possibility that jQuery and other libraries will not load properly.
 *
 * For example, defining Object.prototype.extend cripples jQuery from loading.
 *
 * Cleanse saves properties added by the page's scripts and removes them
 * temporarily while Optimizely is loading. Afterwards, those properties will
 * be restored.
 *
 * 2012-09-15: HTMLElement added to list of prototypes checked because
 *             prototype.js 1.5.1.1 was found to to add properties.
 * 2012-09-27: Change template (not this file) to make sure this is only
 *             loaded once.
 */

/**
 * Iterate over keys in an object excluding properties found on prototype.
 *
 * @param {Object} object
 * @param {Function} function_
 * @param {Object=} context
 */
optly.Cleanse.each = function(object, function_, context) {
  // Get references to getter and setter functions instead of their return
  // values using this deprecated functions if they're available:
  // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/lookupGetter
  // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/lookupSetter
  var hasLookupGetter = !!Object.prototype.__lookupGetter__;
  var hasLookupSetter = !!Object.prototype.__lookupSetter__;

  for (var key in object) {
    if (object.hasOwnProperty(key)) {
      // Look up the definition of a getter set using __defineGetter__().
      // If a page has defined getters on the prototype, then we need the
      // definition of the getter, not just the value it returns.
      var getter = hasLookupGetter ? object.__lookupGetter__(key) : null;
      var setter = hasLookupSetter ? object.__lookupSetter__(key) : null;

      // MSIE behaves abnormally when you try to access methods and
      // properties on protected JavaScript objects (like HTMLElement).
      // MSIE 9.0 started throwing "Invalid calling object" exceptions.
      try {
        // If we have a getter, then the value returned isn't useful.
        var value = !getter ? object[key] : null;

        function_.call(context, key, value, getter, setter);
      }
      catch (err) {}
    }
  }
};

/**
 * Restore prototypes.
 */
optly.Cleanse.finish = function() {
  if (optly.Cleanse.running) {
    optly.Cleanse.running = false;

    // Restore Javascript prototypes:  Object, Function, etc.
    optly.Cleanse.each(optly.Cleanse.types, function(typeName, type) {
        // Restore getters to prototypes.
        if (Object.prototype.__defineGetter__) {
          var getters = optly.Cleanse.getters[typeName];
          optly.Cleanse.each(getters, function(propertyName, getter) {
              type.prototype.__defineGetter__(propertyName, getter);
              optly.Cleanse.log("restored getter", typeName, propertyName);
            });
        }

        // Restore setters to prototypes.
        if (Object.prototype.__defineSetter__) {
          var setters = optly.Cleanse.setters[typeName];
          optly.Cleanse.each(setters, function(propertyName, setter) {
              type.prototype.__defineSetter__(propertyName, setter);
              optly.Cleanse.log("restored setter", typeName, propertyName);
            });
        }

        // Restore properties to prototypes.
        var properties = optly.Cleanse.properties[typeName];
        optly.Cleanse.each(properties, function(propertyName, property) {
            type.prototype[propertyName] = property;
            optly.Cleanse.log("restored property", typeName, propertyName);
          });
      });

    optly.Cleanse.unfixGetElementsByClassName();

    optly.Cleanse.log("finish");

    // Output log.
    var console = window.console;
    var param = "optimizely_log=true";
    var log = window.location.hash.indexOf(param) !== -1 ||
              window.location.search.indexOf(param) !== -1;
    if (log && console && console.log) {
      var logs = optly.Cleanse.logs;
      for (var i = 0; i < logs.length; i++) {
        console.log(logs[i]);
      }
    }
  }
};

/**
 * @param {string} action
 * @param {string=} typeName
 * @param {string=} propertyName
 */
optly.Cleanse.log = function(action, typeName, propertyName) {
  if (typeName) {
    typeName = typeName.replace(/_/g, "");
    optly.Cleanse.logs.push("Optimizely / Info / Cleanse / " +
                            action + ": " + typeName + "." + propertyName);
  }
  else {
    optly.Cleanse.logs.push("Optimizely / Info / Cleanse / " + action);
  }
};

/**
 * Store properties and remove from prototypes.
 */
optly.Cleanse.start = function() {
  // Only run on non-Optimizely sites or on the editor proxy or clienttest
  var hostname = window.location.hostname;

  if (hostname.indexOf("optimizely") !== -1
      && hostname.indexOf("edit") === -1
      && hostname.indexOf("preview") === -1
      && hostname.indexOf("test") === -1) {
    return;
  }

  if (optly.Cleanse.running) {
    optly.Cleanse.log("already running so didn't start");
    return;
  }
  optly.Cleanse.log("start");
  optly.Cleanse.running = true;

  // Make sure type isn't undefined.
  // e.g. HTMLElement isn't accessible in MSIE before version 9.0.
  for (var type in optly.Cleanse.types) {
    if (!optly.Cleanse.types[type]) {
      delete optly.Cleanse.types[type];
    }
  }

  // Cleanse JavaScript prototypes: Object, Function, etc.
  optly.Cleanse.each(optly.Cleanse.types, function(typeName, type) {
      optly.Cleanse.getters[typeName] = {};
      optly.Cleanse.properties[typeName] = {};
      optly.Cleanse.setters[typeName] = {};

      // Save getters and properties and delete from prototypes.
      optly.Cleanse.each(type.prototype, function(propertyName, property, getter, setter) {
          if (optly.nativity.isNativeFunction(property) ||
              optly.nativity.isNativeFunction(getter) ||
              optly.nativity.isNativeFunction(setter)) {
            optly.Cleanse.log("ignore native code", typeName, propertyName);
            return;
          }

          if (getter) {
            optly.Cleanse.getters[typeName][propertyName] = getter;
            optly.Cleanse.log("cleansed getter", typeName, propertyName);
          }
          else {
            optly.Cleanse.properties[typeName][propertyName] = property;
            optly.Cleanse.log("cleansed property", typeName, propertyName);
          }

          if (setter) {
            optly.Cleanse.setters[typeName][propertyName] = setter;
            optly.Cleanse.log("cleansed setter", typeName, propertyName);
          }

          delete type.prototype[propertyName];
        });
    });

  optly.Cleanse.fixGetElementsByClassName();
  optly.Cleanse.hasRunStart = true;
};

/**
 * Restore native function if necessary and possible.
 */
optly.Cleanse.fixGetElementsByClassName = function() {
  if (!optly.nativity.isNativeFunction(document.getElementsByClassName)) {
    var nativeGetElementsByClassName = optly.nativity.getNativeGetElementsByClassName();

    if (nativeGetElementsByClassName) {
      optly.Cleanse.getElementsByClassName = document.getElementsByClassName;
      document.getElementsByClassName = nativeGetElementsByClassName;
    }
    else {
      // Unable to find native implementation.
      optly.Cleanse.log("Error: native HTMLElement.prototype.getElementsByClassName missing");
    }
  }
};

/**
 * Restore custom function.
 */
optly.Cleanse.unfixGetElementsByClassName = function() {
  if (optly.Cleanse.getElementsByClassName) {
    document.getElementsByClassName = optly.Cleanse.getElementsByClassName;
    optly.Cleanse.getElementsByClassName = null;
  }
};

/**
 * Stores function that replaced native JavaScript function.
 */
optly.Cleanse.getElementsByClassName = null;

/**
 * Stores getters that were added to native JavaScript types.
 *
 * @private
 */
optly.Cleanse.getters = {};

/**
 * Store logs.
 */
optly.Cleanse.logs = [];

/**
 * Stores properties that were added to native JavaScript types.
 *
 * @private
 */
optly.Cleanse.properties = {};

/**
 * Stores setters that were added to native JavaScript types.
 *
 * @private
 */
optly.Cleanse.setters = {};

/**
 * Prototypes to cleanse.
 *
 * @private
 */
optly.Cleanse.types = {
//  'Array_' : Array,
//  'DOMParser_' : DOMParser,
//  'Function_' : Function,
  'HTMLElement_' : window['HTMLElement'], // undefined in MSIE
//  'Number_' : Number,
  'Object_' : Object
//  'String_' : String,
//  'XMLSerializer_' : XMLSerializer
};

window.optly = window.optly || {};
window.optly.Cleanse = {
  each: optly.Cleanse.each,
  finish: optly.Cleanse.finish,
  fixGetElementsByClassName: optly.Cleanse.fixGetElementsByClassName,
  log: optly.Cleanse.log,
  logs: optly.Cleanse.logs,
  start: optly.Cleanse.start,
  unfixGetElementsByClassName: optly.Cleanse.unfixGetElementsByClassName
};


// node_modules/URIjs/src/URI.js
/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.10.2
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.com/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *   GPL v3 http://opensource.org/licenses/GPL-3.0
 *
 */
(function (root, factory) {
    // https://github.com/umdjs/umd/blob/master/returnExports.js
    if (typeof exports === 'object') {
        // Node
        module.exports = factory(require('./punycode'), require('./IPv6'), require('./SecondLevelDomains'));
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['./punycode', './IPv6', './SecondLevelDomains'], factory);
    } else {
        // Browser globals (root is window)
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains);
    }
}(this, function (punycode, IPv6, SLD) {
"use strict";

function URI(url, base) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof URI)) {
        return new URI(url, base);
    }

    if (url === undefined) {
        if (typeof location !== 'undefined') {
            url = location.href + "";
        } else {
            url = "";
        }
    }

    this.href(url);

    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
    if (base !== undefined) {
        return this.absoluteTo(base);
    }

    return this;
};

var p = URI.prototype;
var hasOwn = Object.prototype.hasOwnProperty;

function escapeRegEx(string) {
    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
}

function getType(value) {
    return String(Object.prototype.toString.call(value)).slice(8, -1);
}

function isArray(obj) {
    return getType(obj) === "Array";
}

function filterArrayValues(data, value) {
    var lookup = {};
    var i, length;

    if (isArray(value)) {
        for (i = 0, length = value.length; i < length; i++) {
            lookup[value[i]] = true;
        }
    } else {
        lookup[value] = true;
    }

    for (i = 0, length = data.length; i < length; i++) {
        if (lookup[data[i]] !== undefined) {
            data.splice(i, 1);
            length--;
            i--;
        }
    }

    return data;
}

function arrayContains(list, value) {
    var i, length;
    
    // value may be string, number, array, regexp
    if (isArray(value)) {
        // Note: this can be optimized to O(n) (instead of current O(m * n))
        for (i = 0, length = value.length; i < length; i++) {
            if (!arrayContains(list, value[i])) {
                return false;
            }
        }
        
        return true;
    }
    
    var _type = getType(value);
    for (i = 0, length = list.length; i < length; i++) {
        if (_type === 'RegExp') {
            if (typeof list[i] === 'string' && list[i].match(value)) {
                return true;
            }
        } else if (list[i] === value) {
            return true;
        }
    }

    return false;
}

function arraysEqual(one, two) {
    if (!isArray(one) || !isArray(two)) {
        return false;
    }
    
    // arrays can't be equal if they have different amount of content
    if (one.length !== two.length) {
        return false;
    }

    one.sort();
    two.sort();

    for (var i = 0, l = one.length; i < l; i++) {
        if (one[i] !== two[i]) {
            return false;
        }
    }
    
    return true;
}

URI._parts = function() {
    return {
        protocol: null,
        username: null,
        password: null,
        hostname: null,
        urn: null,
        port: null,
        path: null,
        query: null,
        fragment: null,
        // state
        duplicateQueryParameters: URI.duplicateQueryParameters
    };
};
// state: allow duplicate query parameters (a=1&a=1)
URI.duplicateQueryParameters = false;
// static properties
URI.protocol_expression = /^[a-z][a-z0-9-+-]*$/i;
URI.idn_expression = /[^a-z0-9\.-]/i;
URI.punycode_expression = /(xn--)/i;
// well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
// credits to Rich Brown
// source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
// specification: http://www.ietf.org/rfc/rfc4291.txt
URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
// gruber revised expression - http://rodneyrehm.de/t/url-regex.html
URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/ig;
// http://www.iana.org/assignments/uri-schemes.html
// http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
URI.defaultPorts = {
    http: "80",
    https: "443",
    ftp: "21",
    gopher: "70",
    ws: "80",
    wss: "443"
};
// allowed hostname characters according to RFC 3986
// ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
// I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -
URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
// encoding / decoding according to RFC3986
function strictEncodeURIComponent(string) {
    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
    return encodeURIComponent(string)
        .replace(/[!'()*]/g, escape)
        .replace(/\*/g, "%2A");
}
URI.encode = strictEncodeURIComponent;
URI.decode = decodeURIComponent;
URI.iso8859 = function() {
    URI.encode = escape;
    URI.decode = unescape;
};
URI.unicode = function() {
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
};
URI.characters = {
    pathname: {
        encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
            map: {
                // -._~!'()*
                "%24": "$",
                "%26": "&",
                "%2B": "+",
                "%2C": ",",
                "%3B": ";",
                "%3D": "=",
                "%3A": ":",
                "%40": "@"
            }
        },
        decode: {
            expression: /[\/\?#]/g,
            map: {
                "/": "%2F",
                "?": "%3F",
                "#": "%23"
            }
        }
    },
    reserved: {
        encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
            map: {
                // gen-delims
                "%3A": ":",
                "%2F": "/",
                "%3F": "?",
                "%23": "#",
                "%5B": "[",
                "%5D": "]",
                "%40": "@",
                // sub-delims
                "%21": "!",
                "%24": "$",
                "%26": "&",
                "%27": "'",
                "%28": "(",
                "%29": ")",
                "%2A": "*",
                "%2B": "+",
                "%2C": ",",
                "%3B": ";",
                "%3D": "="
            }
        }
    }
};
URI.encodeQuery = function(string) {
    return URI.encode(string + "").replace(/%20/g, '+');
};
URI.decodeQuery = function(string) {
    return URI.decode((string + "").replace(/\+/g, '%20'));
};
URI.recodePath = function(string) {
    var segments = (string + "").split('/');
    for (var i = 0, length = segments.length; i < length; i++) {
        segments[i] = URI.encodePathSegment(URI.decode(segments[i]));
    }

    return segments.join('/');
};
URI.decodePath = function(string) {
    var segments = (string + "").split('/');
    for (var i = 0, length = segments.length; i < length; i++) {
        segments[i] = URI.decodePathSegment(segments[i]);
    }

    return segments.join('/');
};
// generate encode/decode path functions
var _parts = {'encode':'encode', 'decode':'decode'};
var _part;
var generateAccessor = function(_group, _part) {
    return function(string) {
        return URI[_part](string + "").replace(URI.characters[_group][_part].expression, function(c) {
            return URI.characters[_group][_part].map[c];
        });
    };
};

for (_part in _parts) {
    URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
}

URI.encodeReserved = generateAccessor("reserved", "encode");

URI.parse = function(string, parts) {
    var pos, t;
    if (!parts) {
        parts = {};
    }
    // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

    // extract fragment
    pos = string.indexOf('#');
    if (pos > -1) {
        // escaping?
        parts.fragment = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
    }

    // extract query
    pos = string.indexOf('?');
    if (pos > -1) {
        // escaping?
        parts.query = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
    }

    // extract protocol
    if (string.substring(0, 2) === '//') {
        // relative-scheme
        parts.protocol = '';
        string = string.substring(2);
        // extract "user:pass@host:port"
        string = URI.parseAuthority(string, parts);
    } else {
        pos = string.indexOf(':');
        if (pos > -1) {
            parts.protocol = string.substring(0, pos);
            if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
                // : may be within the path
                parts.protocol = undefined;
            } else if (parts.protocol === 'file') {
                // the file scheme: does not contain an authority
                string = string.substring(pos + 3);
            } else if (string.substring(pos + 1, pos + 3) === '//') {
                string = string.substring(pos + 3);

                // extract "user:pass@host:port"
                string = URI.parseAuthority(string, parts);
            } else {
                string = string.substring(pos + 1);
                parts.urn = true;
            }
        }
    }

    // what's left must be the path
    parts.path = string;

    // and we're done
    return parts;
};
URI.parseHost = function(string, parts) {
    // extract host:port
    var pos = string.indexOf('/');
    var bracketPos;
    var t;

    if (pos === -1) {
        pos = string.length;
    }

    if (string.charAt(0) === "[") {
        // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
        // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
        // IPv6+port in the format [2001:db8::1]:80 (for the time being)
        bracketPos = string.indexOf(']');
        parts.hostname = string.substring(1, bracketPos) || null;
        parts.port = string.substring(bracketPos+2, pos) || null;
    } else if (string.indexOf(':') !== string.lastIndexOf(':')) {
        // IPv6 host contains multiple colons - but no port
        // this notation is actually not allowed by RFC 3986, but we're a liberal parser
        parts.hostname = string.substring(0, pos) || null;
        parts.port = null;
    } else {
        t = string.substring(0, pos).split(':');
        parts.hostname = t[0] || null;
        parts.port = t[1] || null;
    }

    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
        pos++;
        string = "/" + string;
    }

    return string.substring(pos) || '/';
};
URI.parseAuthority = function(string, parts) {
    string = URI.parseUserinfo(string, parts);
    return URI.parseHost(string, parts);
};
URI.parseUserinfo = function(string, parts) {
    // extract username:password
    var pos = string.indexOf('@');
    var firstSlash = string.indexOf('/');
    var t;

    // authority@ must come before /path
    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
        t = string.substring(0, pos).split(':');
        parts.username = t[0] ? URI.decode(t[0]) : null;
        t.shift();
        parts.password = t[0] ? URI.decode(t.join(':')) : null;
        string = string.substring(pos + 1);
    } else {
        parts.username = null;
        parts.password = null;
    }

    return string;
};
URI.parseQuery = function(string) {
    if (!string) {
        return {};
    }

    // throw out the funky business - "?"[name"="value"&"]+
    string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

    if (!string) {
        return {};
    }

    var items = {};
    var splits = string.split('&');
    var length = splits.length;
    var v, name, value;

    for (var i = 0; i < length; i++) {
        v = splits[i].split('=');
        name = URI.decodeQuery(v.shift());
        // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
        value = v.length ? URI.decodeQuery(v.join('=')) : null;

        if (items[name]) {
            if (typeof items[name] === "string") {
                items[name] = [items[name]];
            }

            items[name].push(value);
        } else {
            items[name] = value;
        }
    }

    return items;
};

URI.build = function(parts) {
    var t = "";

    if (parts.protocol) {
        t += parts.protocol + ":";
    }

    if (!parts.urn && (t || parts.hostname)) {
        t += '//';
    }

    t += (URI.buildAuthority(parts) || '');

    if (typeof parts.path === "string") {
        if (parts.path.charAt(0) !== '/' && typeof parts.hostname === "string") {
            t += '/';
        }

        t += parts.path;
    }

    if (typeof parts.query === "string" && parts.query) {
        t += '?' + parts.query;
    }

    if (typeof parts.fragment === "string" && parts.fragment) {
        t += '#' + parts.fragment;
    }
    return t;
};
URI.buildHost = function(parts) {
    var t = "";

    if (!parts.hostname) {
        return "";
    } else if (URI.ip6_expression.test(parts.hostname)) {
        if (parts.port) {
            t += "[" + parts.hostname + "]:" + parts.port;
        } else {
            // don't know if we should always wrap IPv6 in []
            // the RFC explicitly says SHOULD, not MUST.
            t += parts.hostname;
        }
    } else {
        t += parts.hostname;
        if (parts.port) {
            t += ':' + parts.port;
        }
    }

    return t;
};
URI.buildAuthority = function(parts) {
    return URI.buildUserinfo(parts) + URI.buildHost(parts);
};
URI.buildUserinfo = function(parts) {
    var t = "";

    if (parts.username) {
        t += URI.encode(parts.username);

        if (parts.password) {
            t += ':' + URI.encode(parts.password);
        }

        t += "@";
    }

    return t;
};
URI.buildQuery = function(data, duplicates) {
    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
    // being -._~!$&'()*+,;=:@/? %HEX and alnum are allowed
    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
    // URI.js treats the query string as being application/x-www-form-urlencoded
    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

    var t = "";
    var unique, key, i, length;
    for (key in data) {
        if (hasOwn.call(data, key) && key) {
            if (isArray(data[key])) {
                unique = {};
                for (i = 0, length = data[key].length; i < length; i++) {
                    if (data[key][i] !== undefined && unique[data[key][i] + ""] === undefined) {
                        t += "&" + URI.buildQueryParameter(key, data[key][i]);
                        if (duplicates !== true) {
                            unique[data[key][i] + ""] = true;
                        }
                    }
                }
            } else if (data[key] !== undefined) {
                t += '&' + URI.buildQueryParameter(key, data[key]);
            }
        }
    }

    return t.substring(1);
};
URI.buildQueryParameter = function(name, value) {
    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
    // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
    return URI.encodeQuery(name) + (value !== null ? "=" + URI.encodeQuery(value) : "");
};

URI.addQuery = function(data, name, value) {
    if (typeof name === "object") {
        for (var key in name) {
            if (hasOwn.call(name, key)) {
                URI.addQuery(data, key, name[key]);
            }
        }
    } else if (typeof name === "string") {
        if (data[name] === undefined) {
            data[name] = value;
            return;
        } else if (typeof data[name] === "string") {
            data[name] = [data[name]];
        }

        if (!isArray(value)) {
            value = [value];
        }

        data[name] = data[name].concat(value);
    } else {
        throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
    }
};
URI.removeQuery = function(data, name, value) {
    var i, length, key;
    
    if (isArray(name)) {
        for (i = 0, length = name.length; i < length; i++) {
            data[name[i]] = undefined;
        }
    } else if (typeof name === "object") {
        for (key in name) {
            if (hasOwn.call(name, key)) {
                URI.removeQuery(data, key, name[key]);
            }
        }
    } else if (typeof name === "string") {
        if (value !== undefined) {
            if (data[name] === value) {
                data[name] = undefined;
            } else if (isArray(data[name])) {
                data[name] = filterArrayValues(data[name], value);
            }
        } else {
            data[name] = undefined;
        }
    } else {
        throw new TypeError("URI.addQuery() accepts an object, string as the first parameter");
    }
};
URI.hasQuery = function(data, name, value, withinArray) {
    if (typeof name === "object") {
        for (var key in name) {
            if (hasOwn.call(name, key)) {
                if (!URI.hasQuery(data, key, name[key])) {
                    return false;
                }
            }
        }
        
        return true;
    } else if (typeof name !== "string") {
        throw new TypeError("URI.hasQuery() accepts an object, string as the name parameter");
    }

    switch (getType(value)) {
        case 'Undefined':
            // true if exists (but may be empty)
            return name in data; // data[name] !== undefined;

        case 'Boolean':
            // true if exists and non-empty
            var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
            return value === _booly;

        case 'Function':
            // allow complex comparison
            return !!value(data[name], name, data);

        case 'Array':
            if (!isArray(data[name])) {
                return false;
            }

            var op = withinArray ? arrayContains : arraysEqual;
            return op(data[name], value);

        case 'RegExp':
            if (!isArray(data[name])) {
                return Boolean(data[name] && data[name].match(value));
            }

            if (!withinArray) {
                return false;
            }

            return arrayContains(data[name], value);

        case 'Number':
            value = String(value);
            // omit break;
        case 'String':
            if (!isArray(data[name])) {
                return data[name] === value;
            }

            if (!withinArray) {
                return false;
            }

            return arrayContains(data[name], value);

        default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
    }
};


URI.commonPath = function(one, two) {
    var length = Math.min(one.length, two.length);
    var pos;

    // find first non-matching character
    for (pos = 0; pos < length; pos++) {
        if (one.charAt(pos) !== two.charAt(pos)) {
            pos--;
            break;
        }
    }

    if (pos < 1) {
        return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
    }
    
    // revert to last /
    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
        pos = one.substring(0, pos).lastIndexOf('/');
    }

    return one.substring(0, pos + 1);
};

URI.withinString = function(string, callback) {
    // expression used is "gruber revised" (@gruber v2) determined to be the best solution in
    // a regex sprint we did a couple of ages ago at
    // * http://mathiasbynens.be/demo/url-regex
    // * http://rodneyrehm.de/t/url-regex.html

    return string.replace(URI.find_uri_expression, callback);
};

URI.ensureValidHostname = function(v) {
    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
    // they are not part of DNS and therefore ignored by URI.js

    if (v.match(URI.invalid_hostname_characters)) {
        // test punycode
        if (!punycode) {
            throw new TypeError("Hostname '" + v + "' contains characters other than [A-Z0-9.-] and Punycode.js is not available");
        }

        if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
            throw new TypeError("Hostname '" + v + "' contains characters other than [A-Z0-9.-]");
        }
    }
};

p.build = function(deferBuild) {
    if (deferBuild === true) {
        this._deferred_build = true;
    } else if (deferBuild === undefined || this._deferred_build) {
        this._string = URI.build(this._parts);
        this._deferred_build = false;
    }

    return this;
};

p.clone = function() {
    return new URI(this);
};

p.valueOf = p.toString = function() {
    return this.build(false)._string;
};

// generate simple accessors
_parts = {protocol: 'protocol', username: 'username', password: 'password', hostname: 'hostname',  port: 'port'};
generateAccessor = function(_part){
    return function(v, build) {
        if (v === undefined) {
            return this._parts[_part] || "";
        } else {
            this._parts[_part] = v;
            this.build(!build);
            return this;
        }
    };
};

for (_part in _parts) {                                                                                                                                                                                        
    p[_part] = generateAccessor(_parts[_part]);
}

// generate accessors with optionally prefixed input
_parts = {query: '?', fragment: '#'};
generateAccessor = function(_part, _key){
    return function(v, build) {
        if (v === undefined) {
            return this._parts[_part] || "";
        } else {
            if (v !== null) {
                v = v + "";
                if (v.charAt(0) === _key) {
                    v = v.substring(1);
                }
            }

            this._parts[_part] = v;
            this.build(!build);
            return this;
        }
    };
};

for (_part in _parts) {
    p[_part] = generateAccessor(_part, _parts[_part]);
}

// generate accessors with prefixed output
_parts = {search: ['?', 'query'], hash: ['#', 'fragment']};
generateAccessor = function(_part, _key){
    return function(v, build) {
        var t = this[_part](v, build);
        return typeof t === "string" && t.length ? (_key + t) : t;
    };
};

for (_part in _parts) {
    p[_part] = generateAccessor(_parts[_part][1], _parts[_part][0]);
}

p.pathname = function(v, build) {
    if (v === undefined || v === true) {
        var res = this._parts.path || (this._parts.urn ? '' : '/');
        return v ? URI.decodePath(res) : res;
    } else {
        this._parts.path = v ? URI.recodePath(v) : "/";
        this.build(!build);
        return this;
    }
};
p.path = p.pathname;
p.href = function(href, build) {
    var key;
    
    if (href === undefined) {
        return this.toString();
    }

    this._string = "";
    this._parts = URI._parts();

    var _URI = href instanceof URI;
    var _object = typeof href === "object" && (href.hostname || href.path);

    
    // window.location is reported to be an object, but it's not the sort
    // of object we're looking for: 
    // * location.protocol ends with a colon
    // * location.query != object.search
    // * location.hash != object.fragment
    // simply serializing the unknown object should do the trick 
    // (for location, not for everything...)
    if (!_URI && _object && href.pathname !== undefined) {
        href = href.toString();
    }

    if (typeof href === "string") {
        this._parts = URI.parse(href, this._parts);
    } else if (_URI || _object) {
        var src = _URI ? href._parts : href;
        for (key in src) {
            if (hasOwn.call(this._parts, key)) {
                this._parts[key] = src[key];
            }
        }
    } else {
        throw new TypeError("invalid input");
    }

    this.build(!build);
    return this;
};

// identification accessors
p.is = function(what) {
    var ip = false;
    var ip4 = false;
    var ip6 = false;
    var name = false;
    var sld = false;
    var idn = false;
    var punycode = false;
    var relative = !this._parts.urn;

    if (this._parts.hostname) {
        relative = false;
        ip4 = URI.ip4_expression.test(this._parts.hostname);
        ip6 = URI.ip6_expression.test(this._parts.hostname);
        ip = ip4 || ip6;
        name = !ip;
        sld = name && SLD && SLD.has(this._parts.hostname);
        idn = name && URI.idn_expression.test(this._parts.hostname);
        punycode = name && URI.punycode_expression.test(this._parts.hostname);
    }

    switch (what.toLowerCase()) {
        case 'relative':
            return relative;

        case 'absolute':
            return !relative;

        // hostname identification
        case 'domain':
        case 'name':
            return name;

        case 'sld':
            return sld;

        case 'ip':
            return ip;

        case 'ip4':
        case 'ipv4':
        case 'inet4':
            return ip4;

        case 'ip6':
        case 'ipv6':
        case 'inet6':
            return ip6;

        case 'idn':
            return idn;

        case 'url':
            return !this._parts.urn;

        case 'urn':
            return !!this._parts.urn;

        case 'punycode':
            return punycode;
    }

    return null;
};

// component specific input validation
var _protocol = p.protocol;
var _port = p.port;
var _hostname = p.hostname;

p.protocol = function(v, build) {
    if (v !== undefined) {
        if (v) {
            // accept trailing ://
            v = v.replace(/:(\/\/)?$/, '');

            if (v.match(/[^a-zA-z0-9\.+-]/)) {
                throw new TypeError("Protocol '" + v + "' contains characters other than [A-Z0-9.+-]");
            }
        }
    }
    return _protocol.call(this, v, build);
};
p.scheme = p.protocol;
p.port = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (v !== undefined) {
        if (v === 0) {
            v = null;
        }

        if (v) {
            v += "";
            if (v.charAt(0) === ":") {
                v = v.substring(1);
            }

            if (v.match(/[^0-9]/)) {
                throw new TypeError("Port '" + v + "' contains characters other than [0-9]");
            }
        }
    }
    return _port.call(this, v, build);
};
p.hostname = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (v !== undefined) {
        var x = {};
        URI.parseHost(v, x);
        v = x.hostname;
    }
    return _hostname.call(this, v, build);
};

// compound accessors
p.host = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (v === undefined) {
        return this._parts.hostname ? URI.buildHost(this._parts) : "";
    } else {
        URI.parseHost(v, this._parts);
        this.build(!build);
        return this;
    }
};
p.authority = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (v === undefined) {
        return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
    } else {
        URI.parseAuthority(v, this._parts);
        this.build(!build);
        return this;
    }
};
p.userinfo = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (v === undefined) {
        if (!this._parts.username) {
            return "";
        }

        var t = URI.buildUserinfo(this._parts);
        return t.substring(0, t.length -1);
    } else {
        if (v[v.length-1] !== '@') {
            v += '@';
        }

        URI.parseUserinfo(v, this._parts);
        this.build(!build);
        return this;
    }
};
p.resource = function(v, build) {
    var parts;
    
    if (v === undefined) {
        return this.path() + this.search() + this.hash();
    }
    
    parts = URI.parse(v);
    this._parts.path = parts.path;
    this._parts.query = parts.query;
    this._parts.fragment = parts.fragment;
    this.build(!build);
    return this;
};

// fraction accessors
p.subdomain = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    // convenience, return "www" from "www.example.org"
    if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
            return "";
        }

        // grab domain and add another segment
        var end = this._parts.hostname.length - this.domain().length - 1;
        return this._parts.hostname.substring(0, end) || "";
    } else {
        var e = this._parts.hostname.length - this.domain().length;
        var sub = this._parts.hostname.substring(0, e);
        var replace = new RegExp('^' + escapeRegEx(sub));

        if (v && v.charAt(v.length - 1) !== '.') {
            v += ".";
        }

        if (v) {
            URI.ensureValidHostname(v);
        }

        this._parts.hostname = this._parts.hostname.replace(replace, v);
        this.build(!build);
        return this;
    }
};
p.domain = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
        build = v;
        v = undefined;
    }

    // convenience, return "example.org" from "www.example.org"
    if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
            return "";
        }

        // if hostname consists of 1 or 2 segments, it must be the domain
        var t = this._parts.hostname.match(/\./g);
        if (t && t.length < 2) {
            return this._parts.hostname;
        }

        // grab tld and add another segment
        var end = this._parts.hostname.length - this.tld(build).length - 1;
        end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
        return this._parts.hostname.substring(end) || "";
    } else {
        if (!v) {
            throw new TypeError("cannot set domain empty");
        }

        URI.ensureValidHostname(v);

        if (!this._parts.hostname || this.is('IP')) {
            this._parts.hostname = v;
        } else {
            var replace = new RegExp(escapeRegEx(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
        }

        this.build(!build);
        return this;
    }
};
p.tld = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
        build = v;
        v = undefined;
    }

    // return "org" from "www.example.org"
    if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
            return "";
        }

        var pos = this._parts.hostname.lastIndexOf('.');
        var tld = this._parts.hostname.substring(pos + 1);

        if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
            return SLD.get(this._parts.hostname) || tld;
        }

        return tld;
    } else {
        var replace;
        
        if (!v) {
            throw new TypeError("cannot set TLD empty");
        } else if (v.match(/[^a-zA-Z0-9-]/)) {
            if (SLD && SLD.is(v)) {
                replace = new RegExp(escapeRegEx(this.tld()) + "$");
                this._parts.hostname = this._parts.hostname.replace(replace, v);
            } else {
                throw new TypeError("TLD '" + v + "' contains characters other than [A-Z0-9]");
            }
        } else if (!this._parts.hostname || this.is('IP')) {
            throw new ReferenceError("cannot set TLD on non-domain host");
        } else {
            replace = new RegExp(escapeRegEx(this.tld()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
        }

        this.build(!build);
        return this;
    }
};
p.directory = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
        if (!this._parts.path && !this._parts.hostname) {
            return '';
        }

        if (this._parts.path === '/') {
            return '/';
        }

        var end = this._parts.path.length - this.filename().length - 1;
        var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");

        return v ? URI.decodePath(res) : res;

    } else {
        var e = this._parts.path.length - this.filename().length;
        var directory = this._parts.path.substring(0, e);
        var replace = new RegExp('^' + escapeRegEx(directory));

        // fully qualifier directories begin with a slash
        if (!this.is('relative')) {
            if (!v) {
                v = '/';
            }

            if (v.charAt(0) !== '/') {
                v = "/" + v;
            }
        }

        // directories always end with a slash
        if (v && v.charAt(v.length - 1) !== '/') {
            v += '/';
        }

        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
        this.build(!build);
        return this;
    }
};
p.filename = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
        if (!this._parts.path || this._parts.path === '/') {
            return "";
        }

        var pos = this._parts.path.lastIndexOf('/');
        var res = this._parts.path.substring(pos+1);

        return v ? URI.decodePathSegment(res) : res;
    } else {
        var mutatedDirectory = false;
        
        if (v.charAt(0) === '/') {
            v = v.substring(1);
        }

        if (v.match(/\.?\//)) {
            mutatedDirectory = true;
        }

        var replace = new RegExp(escapeRegEx(this.filename()) + "$");
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);

        if (mutatedDirectory) {
            this.normalizePath(build);
        } else {
            this.build(!build);
        }

        return this;
    }
};
p.suffix = function(v, build) {
    if (this._parts.urn) {
        return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
        if (!this._parts.path || this._parts.path === '/') {
            return "";
        }

        var filename = this.filename();
        var pos = filename.lastIndexOf('.');
        var s, res;

        if (pos === -1) {
            return "";
        }

        // suffix may only contain alnum characters (yup, I made this up.)
        s = filename.substring(pos+1);
        res = (/^[a-z0-9%]+$/i).test(s) ? s : "";
        return v ? URI.decodePathSegment(res) : res;
    } else {
        if (v.charAt(0) === '.') {
            v = v.substring(1);
        }

        var suffix = this.suffix();
        var replace;

        if (!suffix) {
            if (!v) {
                return this;
            }

            this._parts.path += '.' + URI.recodePath(v);
        } else if (!v) {
            replace = new RegExp(escapeRegEx("." + suffix) + "$");
        } else {
            replace = new RegExp(escapeRegEx(suffix) + "$");
        }

        if (replace) {
            v = URI.recodePath(v);
            this._parts.path = this._parts.path.replace(replace, v);
        }

        this.build(!build);
        return this;
    }
};
p.segment = function(segment, v, build) {
    var separator = this._parts.urn ? ':' : '/';
    var path = this.path();
    var absolute = path.substring(0, 1) === '/';
    var segments = path.split(separator);

    if (typeof segment !== 'number') {
        build = v;
        v = segment;
        segment = undefined;
    }

    if (segment !== undefined && typeof segment !== 'number') {
        throw new Error("Bad segment '" + segment + "', must be 0-based integer");
    }

    if (absolute) {
        segments.shift();
    }

    if (segment < 0) {
        // allow negative indexes to address from the end
        segment = Math.max(segments.length + segment, 0);
    }

    if (v === undefined) {
        return segment === undefined
            ? segments
            : segments[segment];
    } else if (segment === null || segments[segment] === undefined) {
        if (isArray(v)) {
            segments = v;
        } else if (v || (typeof v === "string" && v.length)) {
            if (segments[segments.length -1] === "") {
                // empty trailing elements have to be overwritten
                // to prefent results such as /foo//bar
                segments[segments.length -1] = v;
            } else {
                segments.push(v);
            }
        }
    } else {
        if (v || (typeof v === "string" && v.length)) {
            segments[segment] = v;
        } else {
            segments.splice(segment, 1);
        }
    }

    if (absolute) {
        segments.unshift("");
    }

    return this.path(segments.join(separator), build);
};

// mutating query string
var q = p.query;
p.query = function(v, build) {
    if (v === true) {
        return URI.parseQuery(this._parts.query);
    } else if (typeof v === "function") {
        var data = URI.parseQuery(this._parts.query);
        var result = v.call(this, data);
        this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters);
        this.build(!build);
        return this;
    } else if (v !== undefined && typeof v !== "string") {
        this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters);
        this.build(!build);
        return this;
    } else {
        return q.call(this, v, build);
    }
};
p.setQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query);
    
    if (typeof name === "object") {
        for (var key in name) {
            if (hasOwn.call(name, key)) {
                data[key] = name[key];
            }
        }
    } else if (typeof name === "string") {
        data[name] = value !== undefined ? value : null;
    } else {
        throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
    }
    
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters);
    if (typeof name !== "string") {
        build = value;
    }

    this.build(!build);
    return this;
};
p.addQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query);
    URI.addQuery(data, name, value === undefined ? null : value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters);
    if (typeof name !== "string") {
        build = value;
    }

    this.build(!build);
    return this;
};
p.removeQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query);
    URI.removeQuery(data, name, value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters);
    if (typeof name !== "string") {
        build = value;
    }

    this.build(!build);
    return this;
};
p.hasQuery = function(name, value, withinArray) {
    var data = URI.parseQuery(this._parts.query);
    return URI.hasQuery(data, name, value, withinArray);
};
p.setSearch = p.setQuery;
p.addSearch = p.addQuery;
p.removeSearch = p.removeQuery;
p.hasSearch = p.hasQuery;

// sanitizing URLs
p.normalize = function() {
    if (this._parts.urn) {
        return this
            .normalizeProtocol(false)
            .normalizeQuery(false)
            .normalizeFragment(false)
            .build();
    }

    return this
        .normalizeProtocol(false)
        .normalizeHostname(false)
        .normalizePort(false)
        .normalizePath(false)
        .normalizeQuery(false)
        .normalizeFragment(false)
        .build();
};
p.normalizeProtocol = function(build) {
    if (typeof this._parts.protocol === "string") {
        this._parts.protocol = this._parts.protocol.toLowerCase();
        this.build(!build);
    }

    return this;
};
p.normalizeHostname = function(build) {
    if (this._parts.hostname) {
        if (this.is('IDN') && punycode) {
            this._parts.hostname = punycode.toASCII(this._parts.hostname);
        } else if (this.is('IPv6') && IPv6) {
            this._parts.hostname = IPv6.best(this._parts.hostname);
        }

        this._parts.hostname = this._parts.hostname.toLowerCase();
        this.build(!build);
    }

    return this;
};
p.normalizePort = function(build) {
    // remove port of it's the protocol's default
    if (typeof this._parts.protocol === "string" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
        this._parts.port = null;
        this.build(!build);
    }

    return this;
};
p.normalizePath = function(build) {
    if (this._parts.urn) {
        return this;
    }

    if (!this._parts.path || this._parts.path === '/') {
        return this;
    }

    var _was_relative;
    var _was_relative_prefix;
    var _path = this._parts.path;
    var _parent, _pos;

    // handle relative paths
    if (_path.charAt(0) !== '/') {
        if (_path.charAt(0) === '.') {
            _was_relative_prefix = _path.substring(0, _path.indexOf('/'));
        }
        _was_relative = true;
        _path = '/' + _path;
    }
    // resolve simples
    _path = _path.replace(/(\/(\.\/)+)|\/{2,}/g, '/');
    // resolve parents
    while (true) {
        _parent = _path.indexOf('/../');
        if (_parent === -1) {
            // no more ../ to resolve
            break;
        } else if (_parent === 0) {
            // top level cannot be relative...
            _path = _path.substring(3);
            break;
        }

        _pos = _path.substring(0, _parent).lastIndexOf('/');
        if (_pos === -1) {
            _pos = _parent;
        }
        _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
    }
    // revert to relative
    if (_was_relative && this.is('relative')) {
        _path = _path.substring(1);
    }

    _path = URI.recodePath(_path);
    this._parts.path = _path;
    this.build(!build);
    return this;
};
p.normalizePathname = p.normalizePath;
p.normalizeQuery = function(build) {
    if (typeof this._parts.query === "string") {
        if (!this._parts.query.length) {
            this._parts.query = null;
        } else {
            this.query(URI.parseQuery(this._parts.query));
        }

        this.build(!build);
    }

    return this;
};
p.normalizeFragment = function(build) {
    if (!this._parts.fragment) {
        this._parts.fragment = null;
        this.build(!build);
    }

    return this;
};
p.normalizeSearch = p.normalizeQuery;
p.normalizeHash = p.normalizeFragment;

p.iso8859 = function() {
    // expect unicode input, iso8859 output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = escape;
    URI.decode = decodeURIComponent;
    this.normalize();
    URI.encode = e;
    URI.decode = d;
    return this;
};

p.unicode = function() {
    // expect iso8859 input, unicode output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = strictEncodeURIComponent;
    URI.decode = unescape;
    this.normalize();
    URI.encode = e;
    URI.decode = d;
    return this;
};

p.readable = function() {
    var uri = this.clone();
    // removing username, password, because they shouldn't be displayed according to RFC 3986
    uri.username("").password("").normalize();
    var t = '';
    if (uri._parts.protocol) {
        t += uri._parts.protocol + '://';
    }

    if (uri._parts.hostname) {
        if (uri.is('punycode') && punycode) {
            t += punycode.toUnicode(uri._parts.hostname);
            if (uri._parts.port) {
                t += ":" + uri._parts.port;
            }
        } else {
            t += uri.host();
        }
    }

    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
        t += '/';
    }

    t += uri.path(true);
    if (uri._parts.query) {
        var q = '';
        for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
            var kv = (qp[i] || "").split('=');
            q += '&' + URI.decodeQuery(kv[0])
                .replace(/&/g, '%26');

            if (kv[1] !== undefined) {
                q += "=" + URI.decodeQuery(kv[1])
                    .replace(/&/g, '%26');
            }
        }
        t += '?' + q.substring(1);
    }

    t += uri.hash();
    return t;
};

// resolving relative and absolute URLs
p.absoluteTo = function(base) {
    var resolved = this.clone();
    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
    var basedir, i, p;

    if (this._parts.urn) {
        throw new Error('URNs do not have any generally defined hierachical components');
    }

    if (!(base instanceof URI)) {
        base = new URI(base);
    }
    
    if (!resolved._parts.protocol) {
        resolved._parts.protocol = base._parts.protocol;
    }
    
    if (this._parts.hostname) {
        return resolved;
    }

    for (i = 0, p; p = properties[i]; i++) {
        resolved._parts[p] = base._parts[p];
    }
    
    properties = ['query', 'path'];
    for (i = 0, p; p = properties[i]; i++) {
        if (!resolved._parts[p] && base._parts[p]) {
            resolved._parts[p] = base._parts[p];
        }
    }

    if (resolved.path().charAt(0) !== '/') {
        basedir = base.directory();
        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
        resolved.normalizePath();
    }

    resolved.build();
    return resolved;
};
p.relativeTo = function(base) {
    var relative = this.clone();
    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
    var common, _base, _this, _base_diff, _this_diff;

    if (relative._parts.urn) {
        throw new Error('URNs do not have any generally defined hierachical components');
    }

    if (!(base instanceof URI)) {
        base = new URI(base);
    }

    if (relative.path().charAt(0) !== '/' || base.path().charAt(0) !== '/') {
        throw new Error('Cannot calculate common path from non-relative URLs');
    }

    // determine common sub path
    common = URI.commonPath(relative.path(), base.path());
    
    // relative paths don't have authority
    for (var i = 0, p; p = properties[i]; i++) {
        relative._parts[p] = null;
    }

    // no relation if there's nothing in common 
    if (common === '/') {
        return relative;
    } else if (!common) {
        // there's absolutely nothing in common here
        return this.clone();
    }
    
    _base = base.directory();
    _this = relative.directory();

    // base and this are on the same level
    if (_base === _this) {
        relative._parts.path = relative.filename();
        return relative.build();
    }
    
    _base_diff = _base.substring(common.length);
    _this_diff = _this.substring(common.length);
    
    // this is a descendant of base
    if (_base + '/' === common) {
        if (_this_diff) {
            _this_diff += '/';
        }
        
        relative._parts.path = _this_diff + relative.filename();
        return relative.build();
    } 

    // this is a descendant of base
    var parents = '../';
    var _common = new RegExp('^' + escapeRegEx(common));
    var _parents = _base.replace(_common, '/').match(/\//g).length -1;

    while (_parents--) {
        parents += '../';
    }

    relative._parts.path = relative._parts.path.replace(_common, parents);
    return relative.build();
};

// comparing URIs
p.equals = function(uri) {
    var one = this.clone();
    var two = new URI(uri);
    var one_map = {};
    var two_map = {};
    var checked = {};
    var one_query, two_query, key;

    one.normalize();
    two.normalize();

    // exact match
    if (one.toString() === two.toString()) {
        return true;
    }

    // extract query string
    one_query = one.query();
    two_query = two.query();
    one.query("");
    two.query("");

    // definitely not equal if not even non-query parts match
    if (one.toString() !== two.toString()) {
        return false;
    }

    // query parameters have the same length, even if they're permutated
    if (one_query.length !== two_query.length) {
        return false;
    }

    one_map = URI.parseQuery(one_query);
    two_map = URI.parseQuery(two_query);

    for (key in one_map) {
        if (hasOwn.call(one_map, key)) {
            if (!isArray(one_map[key])) {
                if (one_map[key] !== two_map[key]) {
                    return false;
                }
            } else if (!arraysEqual(one_map[key], two_map[key])) {
                return false;
            }

            checked[key] = true;
        }
    }

    for (key in two_map) {
        if (hasOwn.call(two_map, key)) {
            if (!checked[key]) {
                // two contains a parameter not present in one
                return false;
            }
        }
    }

    return true;
};

// state
p.duplicateQueryParameters = function(v) {
    this._parts.duplicateQueryParameters = !!v;
    return this;
};

return URI;
}));

// assets/js/lib/jquery-1.6.4-trim-source.js
/*!
 * jQuery JavaScript Library v1.6.4
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * 
 */
var $ = (function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Check for digits
	rdigit = /\d/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = (context ? context.ownerDocument || context : document);

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return (context || rootjQuery).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.6.4",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + (this.selector ? " " : "") + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.done( fn );

		return this;
	},

	eq: function( i ) {
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, +i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).unbind( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery._Deferred();

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNaN: function( obj ) {
		return obj == null || !rdigit.test( obj ) || isNaN( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw msg;
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return (new Function( "return " + data ))();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// The extra typeof function check is to prevent crashes
			// in Safari 2 (See: #3039)
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array ) {
		if ( !array ) {
			return -1;
		}

		if ( indexOf ) {
			return indexOf.call( array, elem );
		}

		for ( var i = 0, length = array.length; i < length; i++ ) {
			if ( array[ i ] === elem ) {
				return i;
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return (new Date()).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


var // Promise methods
	promiseMethods = "done fail isResolved isRejected promise then always pipe".split( " " ),
	// Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({
	// Create a simple deferred (one callbacks list)
	_Deferred: function() {
		var // callbacks list
			callbacks = [],
			// stored [ context , args ]
			fired,
			// to avoid firing when already doing so
			firing,
			// flag to know if the deferred has been cancelled
			cancelled,
			// the deferred itself
			deferred  = {

				// done( f1, f2, ...)
				done: function() {
					if ( !cancelled ) {
						var args = arguments,
							i,
							length,
							elem,
							type,
							_fired;
						if ( fired ) {
							_fired = fired;
							fired = 0;
						}
						for ( i = 0, length = args.length; i < length; i++ ) {
							elem = args[ i ];
							type = jQuery.type( elem );
							if ( type === "array" ) {
								deferred.done.apply( deferred, elem );
							} else if ( type === "function" ) {
								callbacks.push( elem );
							}
						}
						if ( _fired ) {
							deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );
						}
					}
					return this;
				},

				// resolve with given context and args
				resolveWith: function( context, args ) {
					if ( !cancelled && !fired && !firing ) {
						// make sure args are available (#8421)
						args = args || [];
						firing = 1;
						try {
							while( callbacks[ 0 ] ) {
								callbacks.shift().apply( context, args );
							}
						}
						finally {
							fired = [ context, args ];
							firing = 0;
						}
					}
					return this;
				},

				// resolve with this as context and given arguments
				resolve: function() {
					deferred.resolveWith( this, arguments );
					return this;
				},

				// Has this deferred been resolved?
				isResolved: function() {
					return !!( firing || fired );
				},

				// Cancel
				cancel: function() {
					cancelled = 1;
					callbacks = [];
					return this;
				}
			};

		return deferred;
	},

	// Full fledged deferred (two callbacks list)
	Deferred: function( func ) {
		var deferred = jQuery._Deferred(),
			failDeferred = jQuery._Deferred(),
			promise;
		// Add errorDeferred methods, then and promise
		jQuery.extend( deferred, {
			then: function( doneCallbacks, failCallbacks ) {
				deferred.done( doneCallbacks ).fail( failCallbacks );
				return this;
			},
			always: function() {
				return deferred.done.apply( deferred, arguments ).fail.apply( this, arguments );
			},
			fail: failDeferred.done,
			rejectWith: failDeferred.resolveWith,
			reject: failDeferred.resolve,
			isRejected: failDeferred.isResolved,
			pipe: function( fnDone, fnFail ) {
				return jQuery.Deferred(function( newDefer ) {
					jQuery.each( {
						done: [ fnDone, "resolve" ],
						fail: [ fnFail, "reject" ]
					}, function( handler, data ) {
						var fn = data[ 0 ],
							action = data[ 1 ],
							returned;
						if ( jQuery.isFunction( fn ) ) {
							deferred[ handler ](function() {
								returned = fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise().then( newDefer.resolve, newDefer.reject );
								} else {
									newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
								}
							});
						} else {
							deferred[ handler ]( newDefer[ action ] );
						}
					});
				}).promise();
			},
			// Get a promise for this deferred
			// If obj is provided, the promise aspect is added to the object
			promise: function( obj ) {
				if ( obj == null ) {
					if ( promise ) {
						return promise;
					}
					promise = obj = {};
				}
				var i = promiseMethods.length;
				while( i-- ) {
					obj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];
				}
				return obj;
			}
		});
		// Make sure only one callback list will be used
		deferred.done( failDeferred.cancel ).fail( deferred.cancel );
		// Unexpose cancel
		delete deferred.cancel;
		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = arguments,
			i = 0,
			length = args.length,
			count = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					// Strange bug in FF4:
					// Values changed onto the arguments object sometimes end up as undefined values
					// outside the $.when method. Cloning the object into a fresh array solves the issue
					deferred.resolveWith( deferred, sliceDeferred.call( args, 0 ) );
				}
			};
		}
		if ( length > 1 ) {
			for( ; i < length; i++ ) {
				if ( args[ i ] && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return deferred.promise();
	}
});



jQuery.support = (function() {

	var div = document.createElement( "div" ),
		documentElement = document.documentElement,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		support,
		fragment,
		body,
		testElementParent,
		testElement,
		testElementStyle,
		tds,
		events,
		eventName,
		i,
		isSupported;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";


	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName( "tbody" ).length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName( "link" ).length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute( "href" ) === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55$/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains it's value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.firstChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	div.innerHTML = "";

	// Figure out if the W3C box model works as expected
	div.style.width = div.style.paddingLeft = "1px";

	body = document.getElementsByTagName( "body" )[ 0 ];
	// We use our own, invisible, body unless the body is already present
	// in which case we use a div (#9239)
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		jQuery.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	support.boxModel = div.offsetWidth === 2;

	if ( "zoom" in div.style ) {
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		// (IE < 8 does this)
		div.style.display = "inline";
		div.style.zoom = 1;
		support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

		// Check if elements with layout shrink-wrap their children
		// (IE 6 does this)
		div.style.display = "";
		div.innerHTML = "<div style='width:4px;'></div>";
		support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
	}

	div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
	tds = div.getElementsByTagName( "td" );

	// Check if table cells still have offsetWidth/Height when they are set
	// to display:none and there are still other visible table cells in a
	// table row; if so, offsetWidth/Height are not reliable for use when
	// determining if an element has been hidden directly using
	// display:none (it is still safe to use offsets if a parent element is
	// hidden; don safety goggles and see bug #4512 for more information).
	// (only IE 8 fails this test)
	isSupported = ( tds[ 0 ].offsetHeight === 0 );

	tds[ 0 ].style.display = "";
	tds[ 1 ].style.display = "none";

	// Check if empty table cells still have offsetWidth/Height
	// (IE < 8 fail this test)
	support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
	div.innerHTML = "";

	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. For more
	// info see bug #3333
	// Fails in WebKit before Feb 2011 nightlies
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	if ( document.defaultView && document.defaultView.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( document.defaultView.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

	// Remove the body element we added
	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );

	// Technique from Juriy Zaytsev
	// http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		} ) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	// Null connected elements to avoid leaks in IE
	testElement = fragment = select = opt = body = marginDiv = div = input = null;

	return support;
})();

// Keep track of boxModel
jQuery.boxModel = jQuery.support.boxModel;




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];

		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] && jQuery.expando;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || (pvt && id && (cache[ id ] && !cache[ id ][ internalKey ]))) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ jQuery.expando ] = id = ++jQuery.uuid;
			} else {
				id = jQuery.expando;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
			// metadata on plain JS objects when the object is serialized using
			// JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ][ internalKey ] = jQuery.extend(cache[ id ][ internalKey ], name);
			} else {
				cache[ id ] = jQuery.extend(cache[ id ], name);
			}
		}

		thisCache = cache[ id ];

		// Internal jQuery data is stored in a separate object inside the object's data
		// cache in order to avoid key collisions between internal data and user-defined
		// data
		if ( pvt ) {
			if ( !thisCache[ internalKey ] ) {
				thisCache[ internalKey ] = {};
			}

			thisCache = thisCache[ internalKey ];
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
		// not attempt to inspect the internal events object using jQuery.data, as this
		// internal data object is undocumented and subject to change.
		if ( name === "events" && !thisCache[name] ) {
			return thisCache[ internalKey ] && thisCache[ internalKey ].events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ][ internalKey ] : cache[ id ];

			if ( thisCache ) {

				// Support interoperable removal of hyphenated or camelcased keys
				if ( !thisCache[ name ] ) {
					name = jQuery.camelCase( name );
				}

				delete thisCache[ name ];

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !isEmptyDataObject(thisCache) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( pvt ) {
			delete cache[ id ][ internalKey ];

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		var internalCache = cache[ id ][ internalKey ];

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the entire user cache at once because it's faster than
		// iterating through each key, but we need to continue to persist internal
		// data if it existed
		if ( internalCache ) {
			cache[ id ] = {};
			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
			// metadata on plain JS objects when the object is serialized using
			// JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}

			cache[ id ][ internalKey ] = internalCache;

		// Otherwise, we need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		} else if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ jQuery.expando ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( jQuery.expando );
			} else {
				elem[ jQuery.expando ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 ) {
			    var attr = this[0].attributes, name;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		var parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var $this = jQuery( this ),
					args = [ parts[0], value ];

				$this.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				$this.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				!jQuery.isNaN( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
// property to be considered empty objects; this property always exists in
// order to make sure JSON.stringify does not expose internal metadata
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery.data( elem, deferDataKey, undefined, true );
	if ( defer &&
		( src === "queue" || !jQuery.data( elem, queueDataKey, undefined, true ) ) &&
		( src === "mark" || !jQuery.data( elem, markDataKey, undefined, true ) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery.data( elem, queueDataKey, undefined, true ) &&
				!jQuery.data( elem, markDataKey, undefined, true ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.resolve();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = (type || "fx") + "mark";
			jQuery.data( elem, type, (jQuery.data(elem,type,undefined,true) || 0) + 1, true );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery.data( elem, key, undefined, true) || 1 ) - 1 );
			if ( count ) {
				jQuery.data( elem, key, count, true );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		if ( elem ) {
			type = (type || "fx") + "queue";
			var q = jQuery.data( elem, type, undefined, true );
			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery.data( elem, type, jQuery.makeArray(data), true );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			defer;

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift("inprogress");
			}

			fn.call(elem, function() {
				jQuery.dequeue(elem, type);
			});
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue( type, function() {
			var elem = this;
			setTimeout(function() {
				jQuery.dequeue( elem, type );
			}, time );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery._Deferred(), true ) )) {
				count++;
				tmp.done( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	nodeHook, boolHook;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},
	
	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},
	
	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = (value || "").split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ";
		for ( var i = 0, l = this.length; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret,
			elem = this[0];
		
		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ? 
					// handle most common string cases
					ret.replace(rreturn, "") : 
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return undefined;
		}

		var isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
					var option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},
	
	attrFix: {
		// Always normalize to ensure hook usage
		tabindex: "tabIndex"
	},
	
	attr: function( elem, name, value, pass ) {
		var nType = elem.nodeType;
		
		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return undefined;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( !("getAttribute" in elem) ) {
			return jQuery.prop( elem, name, value );
		}

		var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// Normalize the name if needed
		if ( notxml ) {
			name = jQuery.attrFix[ name ] || name;

			hooks = jQuery.attrHooks[ name ];

			if ( !hooks ) {
				// Use boolHook for boolean attributes
				if ( rboolean.test( name ) ) {
					hooks = boolHook;

				// Use nodeHook if available( IE6/7 )
				} else if ( nodeHook ) {
					hooks = nodeHook;
				}
			}
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return undefined;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, name ) {
		var propName;
		if ( elem.nodeType === 1 ) {
			name = jQuery.attrFix[ name ] || name;

			jQuery.attr( elem, name, "" );
			elem.removeAttribute( name );

			// Set corresponding property to false for boolean attributes
			if ( rboolean.test( name ) && (propName = jQuery.propFix[ name ] || name) in elem ) {
				elem[ propName ] = false;
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},
	
	prop: function( elem, name, value ) {
		var nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return undefined;
		}

		var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return (elem[ name ] = value);
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},
	
	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabindex propHook to attrHooks for back-compat
jQuery.attrHooks.tabIndex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode;
		return jQuery.prop( elem, name ) === true || ( attrNode = elem.getAttributeNode( name ) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !jQuery.support.getSetAttribute ) {
	
	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			// Return undefined if nodeValue is empty string
			return ret && ret.nodeValue !== "" ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return (ret.nodeValue = value + "");
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return (elem.style.cssText = "" + value);
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return (elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0);
			}
		}
	});
});




var rnamespaces = /\.(.*)$/,
	rformElems = /^(?:textarea|input|select)$/i,
	rperiod = /\./g,
	rspaces = / /g,
	rescape = /[^\w\s.|`]/g,
	fcleanup = function( nm ) {
		return nm.replace(rescape, "\\$&");
	};

/*
 * A number of helper functions used for managing events.
 * Many of the ideas behind this code originated from
 * Dean Edwards' addEvent library.
 */
jQuery.event = {

	// Bind an event to an element
	// Original by Dean Edwards
	add: function( elem, types, handler, data ) {
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		if ( handler === false ) {
			handler = returnFalse;
		} else if ( !handler ) {
			// Fixes bug #7229. Fix recommended by jdalton
			return;
		}

		var handleObjIn, handleObj;

		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the function being executed has a unique ID
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure
		var elemData = jQuery._data( elem );

		// If no elemData is found then we must be trying to bind to one of the
		// banned noData elements
		if ( !elemData ) {
			return;
		}

		var events = elemData.events,
			eventHandle = elemData.handle;

		if ( !events ) {
			elemData.events = events = {};
		}

		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.handle.apply( eventHandle.elem, arguments ) :
					undefined;
			};
		}

		// Add elem as a property of the handle function
		// This is to prevent a memory leak with non-native events in IE.
		eventHandle.elem = elem;

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = types.split(" ");

		var type, i = 0, namespaces;

		while ( (type = types[ i++ ]) ) {
			handleObj = handleObjIn ?
				jQuery.extend({}, handleObjIn) :
				{ handler: handler, data: data };

			// Namespaced event handlers
			if ( type.indexOf(".") > -1 ) {
				namespaces = type.split(".");
				type = namespaces.shift();
				handleObj.namespace = namespaces.slice(0).sort().join(".");

			} else {
				namespaces = [];
				handleObj.namespace = "";
			}

			handleObj.type = type;
			if ( !handleObj.guid ) {
				handleObj.guid = handler.guid;
			}

			// Get the current list of functions bound to this event
			var handlers = events[ type ],
				special = jQuery.event.special[ type ] || {};

			// Init the event handler queue
			if ( !handlers ) {
				handlers = events[ type ] = [];

				// Check for a special event handler
				// Only use addEventListener/attachEvent if the special
				// events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add the function to the element's handler list
			handlers.push( handleObj );

			// Keep track of which events have been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, pos ) {
		// don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		if ( handler === false ) {
			handler = returnFalse;
		}

		var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			events = elemData && elemData.events;

		if ( !elemData || !events ) {
			return;
		}

		// types is actually an event object here
		if ( types && types.type ) {
			handler = types.handler;
			types = types.type;
		}

		// Unbind all events for the element
		if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
			types = types || "";

			for ( type in events ) {
				jQuery.event.remove( elem, type + types );
			}

			return;
		}

		// Handle multiple events separated by a space
		// jQuery(...).unbind("mouseover mouseout", fn);
		types = types.split(" ");

		while ( (type = types[ i++ ]) ) {
			origType = type;
			handleObj = null;
			all = type.indexOf(".") < 0;
			namespaces = [];

			if ( !all ) {
				// Namespaced event handlers
				namespaces = type.split(".");
				type = namespaces.shift();

				namespace = new RegExp("(^|\\.)" +
					jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)");
			}

			eventType = events[ type ];

			if ( !eventType ) {
				continue;
			}

			if ( !handler ) {
				for ( j = 0; j < eventType.length; j++ ) {
					handleObj = eventType[ j ];

					if ( all || namespace.test( handleObj.namespace ) ) {
						jQuery.event.remove( elem, origType, handleObj.handler, j );
						eventType.splice( j--, 1 );
					}
				}

				continue;
			}

			special = jQuery.event.special[ type ] || {};

			for ( j = pos || 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( handler.guid === handleObj.guid ) {
					// remove the given handler for the given type
					if ( all || namespace.test( handleObj.namespace ) ) {
						if ( pos == null ) {
							eventType.splice( j--, 1 );
						}

						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}

					if ( pos != null ) {
						break;
					}
				}
			}

			// remove generic event handler if no more handlers exist
			if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				ret = null;
				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			var handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			delete elemData.events;
			delete elemData.handle;

			if ( jQuery.isEmptyObject( elemData ) ) {
				jQuery.removeData( elem, undefined, true );
			}
		}
	},
	
	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			exclusive;

		if ( type.indexOf("!") >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.exclusive = exclusive;
		event.namespace = namespaces.join(".");
		event.namespace_re = new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");
		
		// triggerHandler() and global events don't bubble or run the default action
		if ( onlyHandlers || !elem ) {
			event.preventDefault();
			event.stopPropagation();
		}

		// Handle a global trigger
		if ( !elem ) {
			// TODO: Stop taunting the data cache; remove global events and always attach to document
			jQuery.each( jQuery.cache, function() {
				// internalKey variable is just used to make it easier to find
				// and potentially change this stuff later; currently it just
				// points to jQuery.expando
				var internalKey = jQuery.expando,
					internalCache = this[ internalKey ];
				if ( internalCache && internalCache.events && internalCache.events[ type ] ) {
					jQuery.event.trigger( event, data, internalCache.handle.elem );
				}
			});
			return;
		}

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		event.target = elem;

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		var cur = elem,
			// IE doesn't like method names with a colon (#3533, #8272)
			ontype = type.indexOf(":") < 0 ? "on" + type : "";

		// Fire event on the current element, then bubble up the DOM tree
		do {
			var handle = jQuery._data( cur, "handle" );

			event.currentTarget = cur;
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Trigger an inline bound script
			if ( ontype && jQuery.acceptData( cur ) && cur[ ontype ] && cur[ ontype ].apply( cur, data ) === false ) {
				event.result = false;
				event.preventDefault();
			}

			// Bubble up to document, then to window
			cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;
		} while ( cur && !event.isPropagationStopped() );

		// If nobody prevented the default action, do it now
		if ( !event.isDefaultPrevented() ) {
			var old,
				special = jQuery.event.special[ type ] || {};

			if ( (!special._default || special._default.call( elem.ownerDocument, event ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction)() check here because IE6/7 fails that test.
				// IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.
				try {
					if ( ontype && elem[ type ] ) {
						// Don't re-trigger an onFOO event when we call its FOO() method
						old = elem[ ontype ];

						if ( old ) {
							elem[ ontype ] = null;
						}

						jQuery.event.triggered = type;
						elem[ type ]();
					}
				} catch ( ieError ) {}

				if ( old ) {
					elem[ ontype ] = old;
				}

				jQuery.event.triggered = undefined;
			}
		}
		
		return event.result;
	},

	handle: function( event ) {
		event = jQuery.event.fix( event || window.event );
		// Snapshot the handlers list since a called handler may add/remove events.
		var handlers = ((jQuery._data( this, "events" ) || {})[ event.type ] || []).slice(0),
			run_all = !event.exclusive && !event.namespace,
			args = Array.prototype.slice.call( arguments, 0 );

		// Use the fix-ed Event rather than the (read-only) native event
		args[0] = event;
		event.currentTarget = this;

		for ( var j = 0, l = handlers.length; j < l; j++ ) {
			var handleObj = handlers[ j ];

			// Triggered event must 1) be non-exclusive and have no namespace, or
			// 2) have namespace(s) a subset or equal to those in the bound event.
			if ( run_all || event.namespace_re.test( handleObj.namespace ) ) {
				// Pass in a reference to the handler function itself
				// So that we can later remove it
				event.handler = handleObj.handler;
				event.data = handleObj.data;
				event.handleObj = handleObj;

				var ret = handleObj.handler.apply( this, args );

				if ( ret !== undefined ) {
					event.result = ret;
					if ( ret === false ) {
						event.preventDefault();
						event.stopPropagation();
					}
				}

				if ( event.isImmediatePropagationStopped() ) {
					break;
				}
			}
		}
		return event.result;
	},

	props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// store a copy of the original event object
		// and "clone" to set read-only properties
		var originalEvent = event;
		event = jQuery.Event( originalEvent );

		for ( var i = this.props.length, prop; i; ) {
			prop = this.props[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary
		if ( !event.target ) {
			// Fixes #1925 where srcElement might not be defined either
			event.target = event.srcElement || document;
		}

		// check if target is a textnode (safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Add relatedTarget, if necessary
		if ( !event.relatedTarget && event.fromElement ) {
			event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
		}

		// Calculate pageX/Y if missing and clientX/Y available
		if ( event.pageX == null && event.clientX != null ) {
			var eventDocument = event.target.ownerDocument || document,
				doc = eventDocument.documentElement,
				body = eventDocument.body;

			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
			event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
		}

		// Add which for key events
		if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
			event.which = event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
		if ( !event.metaKey && event.ctrlKey ) {
			event.metaKey = event.ctrlKey;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		// Note: button is not normalized, so don't use it
		if ( !event.which && event.button !== undefined ) {
			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
		}

		return event;
	},

	// Deprecated, use jQuery.guid instead
	guid: 1E8,

	// Deprecated, use jQuery.proxy instead
	proxy: jQuery.proxy,

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady,
			teardown: jQuery.noop
		},

		live: {
			add: function( handleObj ) {
				jQuery.event.add( this,
					liveConvert( handleObj.origType, handleObj.selector ),
					jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) );
			},

			remove: function( handleObj ) {
				jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );
			}
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !this.preventDefault ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// timeStamp is buggy for some events on Firefox(#3843)
	// So we won't rely on the native value
	this.timeStamp = jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Checks if an event happened on an element within another element
// Used in jQuery.event.special.mouseenter and mouseleave handlers
var withinElement = function( event ) {

	// Check if mouse(over|out) are still within the same parent element
	var related = event.relatedTarget,
		inside = false,
		eventType = event.type;

	event.type = event.data;

	if ( related !== this ) {

		if ( related ) {
			inside = jQuery.contains( this, related );
		}

		if ( !inside ) {

			jQuery.event.handle.apply( this, arguments );

			event.type = eventType;
		}
	}
},

// In case of event delegation, we only need to rename the event.type,
// liveHandler will take care of the rest.
delegate = function( event ) {
	event.type = event.data;
	jQuery.event.handle.apply( this, arguments );
};

// Create mouseenter and mouseleave events
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		setup: function( data ) {
			jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );
		},
		teardown: function( data ) {
			jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );
		}
	};
});

// submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function( data, namespaces ) {
			if ( !jQuery.nodeName( this, "form" ) ) {
				jQuery.event.add(this, "click.specialSubmit", function( e ) {
					// Avoid triggering error on non-existent type attribute in IE VML (#7071)
					var elem = e.target,
						type = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.type : "";

					if ( (type === "submit" || type === "image") && jQuery( elem ).closest("form").length ) {
						trigger( "submit", this, arguments );
					}
				});

				jQuery.event.add(this, "keypress.specialSubmit", function( e ) {
					var elem = e.target,
						type = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.type : "";

					if ( (type === "text" || type === "password") && jQuery( elem ).closest("form").length && e.keyCode === 13 ) {
						trigger( "submit", this, arguments );
					}
				});

			} else {
				return false;
			}
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialSubmit" );
		}
	};

}

// change delegation, happens here so we have bind.
if ( !jQuery.support.changeBubbles ) {

	var changeFilters,

	getVal = function( elem ) {
		var type = jQuery.nodeName( elem, "input" ) ? elem.type : "",
			val = elem.value;

		if ( type === "radio" || type === "checkbox" ) {
			val = elem.checked;

		} else if ( type === "select-multiple" ) {
			val = elem.selectedIndex > -1 ?
				jQuery.map( elem.options, function( elem ) {
					return elem.selected;
				}).join("-") :
				"";

		} else if ( jQuery.nodeName( elem, "select" ) ) {
			val = elem.selectedIndex;
		}

		return val;
	},

	testChange = function testChange( e ) {
		var elem = e.target, data, val;

		if ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {
			return;
		}

		data = jQuery._data( elem, "_change_data" );
		val = getVal(elem);

		// the current data will be also retrieved by beforeactivate
		if ( e.type !== "focusout" || elem.type !== "radio" ) {
			jQuery._data( elem, "_change_data", val );
		}

		if ( data === undefined || val === data ) {
			return;
		}

		if ( data != null || val ) {
			e.type = "change";
			e.liveFired = undefined;
			jQuery.event.trigger( e, arguments[1], elem );
		}
	};

	jQuery.event.special.change = {
		filters: {
			focusout: testChange,

			beforedeactivate: testChange,

			click: function( e ) {
				var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

				if ( type === "radio" || type === "checkbox" || jQuery.nodeName( elem, "select" ) ) {
					testChange.call( this, e );
				}
			},

			// Change has to be called before submit
			// Keydown will be called before keypress, which is used in submit-event delegation
			keydown: function( e ) {
				var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

				if ( (e.keyCode === 13 && !jQuery.nodeName( elem, "textarea" ) ) ||
					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
					type === "select-multiple" ) {
					testChange.call( this, e );
				}
			},

			// Beforeactivate happens also before the previous element is blurred
			// with this event you can't trigger a change event, but you can store
			// information
			beforeactivate: function( e ) {
				var elem = e.target;
				jQuery._data( elem, "_change_data", getVal(elem) );
			}
		},

		setup: function( data, namespaces ) {
			if ( this.type === "file" ) {
				return false;
			}

			for ( var type in changeFilters ) {
				jQuery.event.add( this, type + ".specialChange", changeFilters[type] );
			}

			return rformElems.test( this.nodeName );
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialChange" );

			return rformElems.test( this.nodeName );
		}
	};

	changeFilters = jQuery.event.special.change.filters;

	// Handle when the input is .focus()'d
	changeFilters.focus = changeFilters.beforeactivate;
}

function trigger( type, elem, args ) {
	// Piggyback on a donor event to simulate a different one.
	// Fake originalEvent to avoid donor's stopPropagation, but if the
	// simulated event prevents default then we do the same on the donor.
	// Don't pass args or remember liveFired; they apply to the donor event.
	var event = jQuery.extend( {}, args[ 0 ] );
	event.type = type;
	event.originalEvent = {};
	event.liveFired = undefined;
	jQuery.event.handle.call( elem, event );
	if ( event.isDefaultPrevented() ) {
		args[ 0 ].preventDefault();
	}
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0;

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};

		function handler( donor ) {
			// Donor event is always a native one; fix it and switch its type.
			// Let focusin/out handler cancel the donor focus/blur event.
			var e = jQuery.event.fix( donor );
			e.type = fix;
			e.originalEvent = {};
			jQuery.event.trigger( e, null, e.target );
			if ( e.isDefaultPrevented() ) {
				donor.preventDefault();
			}
		}
	});
}

jQuery.each(["bind", "one"], function( i, name ) {
	jQuery.fn[ name ] = function( type, data, fn ) {
		var handler;

		// Handle object literals
		if ( typeof type === "object" ) {
			for ( var key in type ) {
				this[ name ](key, data, type[key], fn);
			}
			return this;
		}

		if ( arguments.length === 2 || data === false ) {
			fn = data;
			data = undefined;
		}

		if ( name === "one" ) {
			handler = function( event ) {
				jQuery( this ).unbind( event, handler );
				return fn.apply( this, arguments );
			};
			handler.guid = fn.guid || jQuery.guid++;
		} else {
			handler = fn;
		}

		if ( type === "unload" && name !== "one" ) {
			this.one( type, data, fn );

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.add( this[i], type, handler, data );
			}
		}

		return this;
	};
});

jQuery.fn.extend({
	unbind: function( type, fn ) {
		// Handle object literals
		if ( typeof type === "object" && !type.preventDefault ) {
			for ( var key in type ) {
				this.unbind(key, type[key]);
			}

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.remove( this[i], type, fn );
			}
		}

		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.live( types, data, fn, selector );
	},

	undelegate: function( selector, types, fn ) {
		if ( arguments.length === 0 ) {
			return this.unbind( "live" );

		} else {
			return this.die( types, null, fn, selector );
		}
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},

	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery.data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery.data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

var liveMap = {
	focus: "focusin",
	blur: "focusout",
	mouseenter: "mouseover",
	mouseleave: "mouseout"
};

jQuery.each(["live", "die"], function( i, name ) {
	jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {
		var type, i = 0, match, namespaces, preType,
			selector = origSelector || this.selector,
			context = origSelector ? this : jQuery( this.context );

		if ( typeof types === "object" && !types.preventDefault ) {
			for ( var key in types ) {
				context[ name ]( key, data, types[key], selector );
			}

			return this;
		}

		if ( name === "die" && !types &&
					origSelector && origSelector.charAt(0) === "." ) {

			context.unbind( origSelector );

			return this;
		}

		if ( data === false || jQuery.isFunction( data ) ) {
			fn = data || returnFalse;
			data = undefined;
		}

		types = (types || "").split(" ");

		while ( (type = types[ i++ ]) != null ) {
			match = rnamespaces.exec( type );
			namespaces = "";

			if ( match )  {
				namespaces = match[0];
				type = type.replace( rnamespaces, "" );
			}

			if ( type === "hover" ) {
				types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );
				continue;
			}

			preType = type;

			if ( liveMap[ type ] ) {
				types.push( liveMap[ type ] + namespaces );
				type = type + namespaces;

			} else {
				type = (liveMap[ type ] || type) + namespaces;
			}

			if ( name === "live" ) {
				// bind live handler
				for ( var j = 0, l = context.length; j < l; j++ ) {
					jQuery.event.add( context[j], "live." + liveConvert( type, selector ),
						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );
				}

			} else {
				// unbind live handler
				context.unbind( "live." + liveConvert( type, selector ), fn );
			}
		}

		return this;
	};
});

function liveHandler( event ) {
	var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
		elems = [],
		selectors = [],
		events = jQuery._data( this, "events" );

	// Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
	if ( event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click" ) {
		return;
	}

	if ( event.namespace ) {
		namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
	}

	event.liveFired = this;

	var live = events.live.slice(0);

	for ( j = 0; j < live.length; j++ ) {
		handleObj = live[j];

		if ( handleObj.origType.replace( rnamespaces, "" ) === event.type ) {
			selectors.push( handleObj.selector );

		} else {
			live.splice( j--, 1 );
		}
	}

	match = jQuery( event.target ).closest( selectors, event.currentTarget );

	for ( i = 0, l = match.length; i < l; i++ ) {
		close = match[i];

		for ( j = 0; j < live.length; j++ ) {
			handleObj = live[j];

			if ( close.selector === handleObj.selector && (!namespace || namespace.test( handleObj.namespace )) && !close.elem.disabled ) {
				elem = close.elem;
				related = null;

				// Those two events require additional checking
				if ( handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave" ) {
					event.type = handleObj.preType;
					related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];

					// Make sure not to accidentally match a child element with the same selector
					if ( related && jQuery.contains( elem, related ) ) {
						related = elem;
					}
				}

				if ( !related || related !== elem ) {
					elems.push({ elem: elem, handleObj: handleObj, level: close.level });
				}
			}
		}
	}

	for ( i = 0, l = elems.length; i < l; i++ ) {
		match = elems[i];

		if ( maxLevel && match.level > maxLevel ) {
			break;
		}

		event.currentTarget = match.elem;
		event.data = match.handleObj.data;
		event.handleObj = match.handleObj;

		ret = match.handleObj.origHandler.apply( match.elem, arguments );

		if ( ret === false || event.isPropagationStopped() ) {
			maxLevel = match.level;

			if ( ret === false ) {
				stop = false;
			}
			if ( event.isImmediatePropagationStopped() ) {
				break;
			}
		}
	}

	return stop;
}

function liveConvert( type, selector ) {
	return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspaces, "&");
}

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.bind( name, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var match,
			type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				var found, item,
					filter = Expr.filter[ type ],
					left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw "Syntax error, unrecognized expression: " + msg;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return "text" === elem.getAttribute( 'type' );
		},
		radio: function( elem ) {
			return "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return "checkbox" === elem.type;
		},

		file: function( elem ) {
			return "file" === elem.type;
		},
		password: function( elem ) {
			return "password" === elem.type;
		},

		submit: function( elem ) {
			return "submit" === elem.type;
		},

		image: function( elem ) {
			return "image" === elem.type;
		},

		reset: function( elem ) {
			return "reset" === elem.type;
		},

		button: function( elem ) {
			return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					var first = match[2],
						last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					var doneName = match[0],
						parent = elem.parentNode;
	
					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent.sizcache = doneName;
					}
					
					var diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// If the nodes are siblings (or identical) we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Utility function for retreiving the text value of an array of DOM nodes
Sizzle.getText = function( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += Sizzle.getText( elem.childNodes );
		}
	}

	return ret;
};

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector,
		pseudoWorks = false;

	try {
		// This should fail with an exception
		// Gecko does not error, returns false instead
		matches.call( document.documentElement, "[test!='']:sizzle" );
	
	} catch( pseudoError ) {
		pseudoWorks = true;
	}

	if ( matches ) {
		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						return matches.call( node, expr );
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && ( typeof selector === "string" ?
			jQuery.filter( selector, this ).length > 0 :
			this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		
		// Array
		if ( jQuery.isArray( selectors ) ) {
			var match, selector,
				matches = {},
				level = 1;

			if ( cur && selectors.length ) {
				for ( i = 0, l = selectors.length; i < l; i++ ) {
					selector = selectors[i];

					if ( !matches[ selector ] ) {
						matches[ selector ] = POS.test( selector ) ?
							jQuery( selector, context || this.context ) :
							selector;
					}
				}

				while ( cur && cur.ownerDocument && cur !== context ) {
					for ( selector in matches ) {
						match = matches[ selector ];

						if ( match.jquery ? match.index( cur ) > -1 : jQuery( cur ).is( match ) ) {
							ret.push({ selector: selector, elem: cur, level: level });
						}
					}

					cur = cur.parentNode;
					level++;
				}
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until ),
			// The variable 'args' was introduced in
			// https://github.com/jquery/jquery/commit/52a0238
			// to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.
			// http://code.google.com/p/v8/issues/detail?id=1050
			args = slice.call(arguments);

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, args.join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return (elem === qualifier) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return (jQuery.inArray( elem, qualifier ) >= 0) === keep;
	});
}




var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnocache = /<(?:script|object|embed|option|style)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	};

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		return this.each(function() {
			jQuery( this ).wrapAll( html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery(arguments[0]);
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery(arguments[0]).toArray() );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnocache.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || (l > 1 && i < lastIndex) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var internalKey = jQuery.expando,
		oldData = jQuery.data( src ),
		curData = jQuery.data( dest, oldData );

	// Switch to use the internal data object, if it exists, for the next
	// stage of data copying
	if ( (oldData = oldData[ internalKey ]) ) {
		var events = oldData.events;
				curData = curData[ internalKey ] = jQuery.extend({}, oldData);

		if ( events ) {
			delete curData.handle;
			curData.events = {};

			for ( var type in events ) {
				for ( var i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
				}
			}
		}
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc;

  // nodes may contain either an explicit document object,
  // a jQuery collection or context object.
  // If nodes[0] contains a valid object to assign to doc
  if ( nodes && nodes[0] ) {
    doc = nodes[0].ownerDocument || nodes[0];
  }

  // Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	if ( args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
		args[0].charAt(0) === "<" && !rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ args[0] ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = (i > 0 ? this.clone(true) : this).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( "getElementsByTagName" in elem ) {
		return elem.getElementsByTagName( "*" );

	} else if ( "querySelectorAll" in elem ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	if ( jQuery.nodeName( elem, "input" ) ) {
		fixDefaultChecked( elem );
	} else if ( "getElementsByTagName" in elem ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var clone = elem.cloneNode(true),
				srcElements,
				destElements,
				i;

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName
			// instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ] && cache[ id ][ internalKey ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNaN( value ) ? "" : "alpha(opacity=" + value * 100 + ")",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( !(defaultView = elem.ownerDocument.defaultView) ) {
			return undefined;
		}

		if ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			rsLeft = elem.runtimeStyle && elem.runtimeStyle[ name ],
			style = elem.style;

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
			// Remember the original values
			left = style.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : (ret || 0);
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			jQuery.each( which, function() {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + this ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + this ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + this + "Width" ) ) || 0;
				}
			});
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		jQuery.each( which, function() {
			val += parseFloat( jQuery.css( elem, "padding" + this ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + this + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + this ) ) || 0;
			}
		});
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}


return jQuery;
})(window);

$c = $.noConflict(true);

// assets/js/bundle/third_party/jquery.js
goog.provide("optly.jquery");

/*!
 * jQuery JavaScript Library v1.7.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Mar 21 12:46:34 2012 -0700
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
  navigator = window.navigator,
  location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
    // The jQuery object is actually just the init constructor 'enhanced'
    return new jQuery.fn.init( selector, context, rootjQuery );
  },

  // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,

  // Map over the $ in case of overwrite
  _$ = window.$,

  // A central reference to the root jQuery(document)
  rootjQuery,

  // A simple way to check for HTML strings or ID strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

  // Check if a string has a non-whitespace character in it
  rnotwhite = /\S/,

  // Used for trimming whitespace
  trimLeft = /^\s+/,
  trimRight = /\s+$/,

  // Match a standalone tag
  rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

  // JSON RegExp
  rvalidchars = /^[\],:{}\s]*$/,
  rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
  rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
  rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

  // Useragent RegExp
  rwebkit = /(webkit)[ \/]([\w.]+)/,
  ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
  rmsie = /(msie) ([\w.]+)/,
  rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

  // Matches dashed string for camelizing
  rdashAlpha = /-([a-z]|[0-9])/ig,
  rmsPrefix = /^-ms-/,

  // Used by jQuery.camelCase as callback to replace()
  fcamelCase = function( all, letter ) {
    return ( letter + "" ).toUpperCase();
  },

  // Keep a UserAgent string for use with jQuery.browser
  userAgent = navigator.userAgent,

  // For matching the engine and version of the browser
  browserMatch,

  // The deferred used on DOM ready
  readyList,

  // The ready event handler
  DOMContentLoaded,

  // Save a reference to some core methods
  toString = Object.prototype.toString,
  hasOwn = Object.prototype.hasOwnProperty,
  push = Array.prototype.push,
  slice = Array.prototype.slice,
  trim = String.prototype.trim,
  indexOf = Array.prototype.indexOf,

  // [[Class]] -> type pairs
  class2type = {};

jQuery.fn = jQuery.prototype = {
  constructor: jQuery,
  init: function( selector, context, rootjQuery ) {
    var match, elem, ret, doc;

    // Handle $(""), $(null), or $(undefined)
    if ( !selector ) {
      return this;
    }

    // Handle $(DOMElement)
    if ( selector.nodeType ) {
      this.context = this[0] = selector;
      this.length = 1;
      return this;
    }

    // The body element only exists once, optimize finding it
    if ( selector === "body" && !context && document.body ) {
      this.context = document;
      this[0] = document.body;
      this.selector = selector;
      this.length = 1;
      return this;
    }

    // Handle HTML strings
    if ( typeof selector === "string" ) {
      // Are we dealing with HTML string or an ID?
      if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [ null, selector, null ];

      } else {
        match = quickExpr.exec( selector );
      }

      // Verify a match, and that no context was specified for #id
      if ( match && (match[1] || !context) ) {

        // HANDLE: $(html) -> $(array)
        if ( match[1] ) {
          context = context instanceof jQuery ? context[0] : context;
          doc = ( context ? context.ownerDocument || context : document );

          // If a single string is passed in and it's a single tag
          // just do a createElement and skip the rest
          ret = rsingleTag.exec( selector );

          if ( ret ) {
            if ( jQuery.isPlainObject( context ) ) {
              selector = [ document.createElement( ret[1] ) ];
              jQuery.fn.attr.call( selector, context, true );

            } else {
              selector = [ doc.createElement( ret[1] ) ];
            }

          } else {
            ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
            selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
          }

          return jQuery.merge( this, selector );

        // HANDLE: $("#id")
        } else {
          elem = document.getElementById( match[2] );

          // Check parentNode to catch when Blackberry 4.6 returns
          // nodes that are no longer in the document #6963
          if ( elem && elem.parentNode ) {
            // Handle the case where IE and Opera return items
            // by name instead of ID
            if ( elem.id !== match[2] ) {
              return rootjQuery.find( selector );
            }

            // Otherwise, we inject the element directly into the jQuery object
            this.length = 1;
            this[0] = elem;
          }

          this.context = document;
          this.selector = selector;
          return this;
        }

      // HANDLE: $(expr, $(...))
      } else if ( !context || context.jquery ) {
        return ( context || rootjQuery ).find( selector );

      // HANDLE: $(expr, context)
      // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor( context ).find( selector );
      }

    // HANDLE: $(function)
    // Shortcut for document ready
    } else if ( jQuery.isFunction( selector ) ) {
      return rootjQuery.ready( selector );
    }

    if ( selector.selector !== undefined ) {
      this.selector = selector.selector;
      this.context = selector.context;
    }

    return jQuery.makeArray( selector, this );
  },

  // Start with an empty selector
  selector: "",

  // The current version of jQuery being used
  jquery: "1.7.2",

  // The default length of a jQuery object is 0
  length: 0,

  // The number of elements contained in the matched element set
  size: function() {
    return this.length;
  },

  toArray: function() {
    return slice.call( this, 0 );
  },

  // Get the Nth element in the matched element set OR
  // Get the whole matched element set as a clean array
  get: function( num ) {
    return num == null ?

      // Return a 'clean' array
      this.toArray() :

      // Return just the object
      ( num < 0 ? this[ this.length + num ] : this[ num ] );
  },

  // Take an array of elements and push it onto the stack
  // (returning the new matched element set)
  pushStack: function( elems, name, selector ) {
    // Build a new jQuery matched element set
    var ret = this.constructor();

    if ( jQuery.isArray( elems ) ) {
      push.apply( ret, elems );

    } else {
      jQuery.merge( ret, elems );
    }

    // Add the old object onto the stack (as a reference)
    ret.prevObject = this;

    ret.context = this.context;

    if ( name === "find" ) {
      ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
    } else if ( name ) {
      ret.selector = this.selector + "." + name + "(" + selector + ")";
    }

    // Return the newly-formed element set
    return ret;
  },

  // Execute a callback for every element in the matched set.
  // (You can seed the arguments with an array of args, but this is
  // only used internally.)
  each: function( callback, args ) {
    return jQuery.each( this, callback, args );
  },

  ready: function( fn ) {
    // Attach the listeners
    jQuery.bindReady();

    // Add the callback
    readyList.add( fn );

    return this;
  },

  eq: function( i ) {
    i = +i;
    return i === -1 ?
      this.slice( i ) :
      this.slice( i, i + 1 );
  },

  first: function() {
    return this.eq( 0 );
  },

  last: function() {
    return this.eq( -1 );
  },

  slice: function() {
    return this.pushStack( slice.apply( this, arguments ),
      "slice", slice.call(arguments).join(",") );
  },

  map: function( callback ) {
    return this.pushStack( jQuery.map(this, function( elem, i ) {
      return callback.call( elem, i, elem );
    }));
  },

  end: function() {
    return this.prevObject || this.constructor(null);
  },

  // For internal use only.
  // Behaves like an Array's method, not like a jQuery method.
  push: push,
  sort: [].sort,
  splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
  var options, name, src, copy, copyIsArray, clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // Handle a deep copy situation
  if ( typeof target === "boolean" ) {
    deep = target;
    target = arguments[1] || {};
    // skip the boolean and the target
    i = 2;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
    target = {};
  }

  // extend jQuery itself if only one argument is passed
  if ( length === i ) {
    target = this;
    --i;
  }

  for ( ; i < length; i++ ) {
    // Only deal with non-null/undefined values
    if ( (options = arguments[ i ]) != null ) {
      // Extend the base object
      for ( name in options ) {
        src = target[ name ];
        copy = options[ name ];

        // Prevent never-ending loop
        if ( target === copy ) {
          continue;
        }

        // Recurse if we're merging plain objects or arrays
        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
          if ( copyIsArray ) {
            copyIsArray = false;
            clone = src && jQuery.isArray(src) ? src : [];

          } else {
            clone = src && jQuery.isPlainObject(src) ? src : {};
          }

          // Never move original objects, clone them
          target[ name ] = jQuery.extend( deep, clone, copy );

        // Don't bring in undefined values
        } else if ( copy !== undefined ) {
          target[ name ] = copy;
        }
      }
    }
  }

  // Return the modified object
  return target;
};

jQuery.extend({
  noConflict: function( deep ) {
    if ( window.$ === jQuery ) {
      window.$ = _$;
    }

    if ( deep && window.jQuery === jQuery ) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  },

  // Is the DOM ready to be used? Set to true once it occurs.
  isReady: false,

  // A counter to track how many items to wait for before
  // the ready event fires. See #6781
  readyWait: 1,

  // Hold (or release) the ready event
  holdReady: function( hold ) {
    if ( hold ) {
      jQuery.readyWait++;
    } else {
      jQuery.ready( true );
    }
  },

  // Handle when the DOM is ready
  ready: function( wait ) {
    // Either a released hold or an DOMready/load event and not yet ready
    if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
      // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
      if ( !document.body ) {
        return setTimeout( jQuery.ready, 1 );
      }

      // Remember that the DOM is ready
      jQuery.isReady = true;

      // If a normal DOM Ready event fired, decrement, and wait if need be
      if ( wait !== true && --jQuery.readyWait > 0 ) {
        return;
      }

      // If there are functions bound, to execute
      readyList.fireWith( document, [ jQuery ] );

      // Trigger any bound ready events
      if ( jQuery.fn.trigger ) {
        jQuery( document ).trigger( "ready" ).off( "ready" );
      }
    }
  },

  bindReady: function() {
    if ( readyList ) {
      return;
    }

    readyList = jQuery.Callbacks( "once memory" );

    // Catch cases where $(document).ready() is called after the
    // browser event has already occurred.
    if ( document.readyState === "complete" ) {
      // Handle it asynchronously to allow scripts the opportunity to delay ready
      return setTimeout( jQuery.ready, 1 );
    }

    // Mozilla, Opera and webkit nightlies currently support this event
    if ( document.addEventListener ) {
      // Use the handy event callback
      document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

      // A fallback to window.onload, that will always work
      window.addEventListener( "load", jQuery.ready, false );

    // If IE event model is used
    } else if ( document.attachEvent ) {
      // ensure firing before onload,
      // maybe late but safe also for iframes
      document.attachEvent( "onreadystatechange", DOMContentLoaded );

      // A fallback to window.onload, that will always work
      window.attachEvent( "onload", jQuery.ready );

      // If IE and not a frame
      // continually check to see if the document is ready
      var toplevel = false;

      try {
        toplevel = window.frameElement == null;
      } catch(e) {}

      if ( document.documentElement.doScroll && toplevel ) {
        doScrollCheck();
      }
    }
  },

  // See test/unit/core.js for details concerning isFunction.
  // Since version 1.3, DOM methods and functions like alert
  // aren't supported. They return false on IE (#2968).
  isFunction: function( obj ) {
    return jQuery.type(obj) === "function";
  },

  isArray: Array.isArray || function( obj ) {
    return jQuery.type(obj) === "array";
  },

  isWindow: function( obj ) {
    return obj != null && obj == obj.window;
  },

  isNumeric: function( obj ) {
    return !isNaN( parseFloat(obj) ) && isFinite( obj );
  },

  type: function( obj ) {
    return obj == null ?
      String( obj ) :
      class2type[ toString.call(obj) ] || "object";
  },

  isPlainObject: function( obj ) {
    // Must be an Object.
    // Because of IE, we also have to check the presence of the constructor property.
    // Make sure that DOM nodes and window objects don't pass through, as well
    if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
      return false;
    }

    try {
      // Not own constructor property must be Object
      if ( obj.constructor &&
        !hasOwn.call(obj, "constructor") &&
        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
        return false;
      }
    } catch ( e ) {
      // IE8,9 Will throw exceptions on certain host objects #9897
      return false;
    }

    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.

    var key;
    for ( key in obj ) {}

    return key === undefined || hasOwn.call( obj, key );
  },

  isEmptyObject: function( obj ) {
    for ( var name in obj ) {
      return false;
    }
    return true;
  },

  error: function( msg ) {
    throw new Error( msg );
  },

  parseJSON: function( data ) {
    if ( typeof data !== "string" || !data ) {
      return null;
    }

    // Make sure leading/trailing whitespace is removed (IE can't handle it)
    data = jQuery.trim( data );

    // Attempt to parse using the native JSON parser first
    if ( window.JSON && window.JSON.parse ) {
      return window.JSON.parse( data );
    }

    // Make sure the incoming data is actual JSON
    // Logic borrowed from http://json.org/json2.js
    if ( rvalidchars.test( data.replace( rvalidescape, "@" )
      .replace( rvalidtokens, "]" )
      .replace( rvalidbraces, "")) ) {

      return ( new Function( "return " + data ) )();

    }
    jQuery.error( "Invalid JSON: " + data );
  },

  // Cross-browser xml parsing
  parseXML: function( data ) {
    if ( typeof data !== "string" || !data ) {
      return null;
    }
    var xml, tmp;
    try {
      if ( window.DOMParser ) { // Standard
        tmp = new DOMParser();
        xml = tmp.parseFromString( data , "text/xml" );
      } else { // IE
        xml = new ActiveXObject( "Microsoft.XMLDOM" );
        xml.async = "false";
        xml.loadXML( data );
      }
    } catch( e ) {
      xml = undefined;
    }
    if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
      jQuery.error( "Invalid XML: " + data );
    }
    return xml;
  },

  noop: function() {},

  // Evaluates a script in a global context
  // Workarounds based on findings by Jim Driscoll
  // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
  globalEval: function( data ) {
    if ( data && rnotwhite.test( data ) ) {
      // We use execScript on Internet Explorer
      // We use an anonymous function so that context is window
      // rather than jQuery in Firefox
      ( window.execScript || function( data ) {
        window[ "eval" ].call( window, data );
      } )( data );
    }
  },

  // Convert dashed to camelCase; used by the css and data modules
  // Microsoft forgot to hump their vendor prefix (#9572)
  camelCase: function( string ) {
    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  },

  nodeName: function( elem, name ) {
    return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
  },

  // args is for internal usage only
  each: function( object, callback, args ) {
    var name, i = 0,
      length = object.length,
      isObj = length === undefined || jQuery.isFunction( object );

    if ( args ) {
      if ( isObj ) {
        for ( name in object ) {
          if ( callback.apply( object[ name ], args ) === false ) {
            break;
          }
        }
      } else {
        for ( ; i < length; ) {
          if ( callback.apply( object[ i++ ], args ) === false ) {
            break;
          }
        }
      }

    // A special, fast, case for the most common use of each
    } else {
      if ( isObj ) {
        for ( name in object ) {
          if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
            break;
          }
        }
      } else {
        for ( ; i < length; ) {
          if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
            break;
          }
        }
      }
    }

    return object;
  },

  // Use native String.trim function wherever possible
  trim: trim ?
    function( text ) {
      return text == null ?
        "" :
        trim.call( text );
    } :

    // Otherwise use our own trimming functionality
    function( text ) {
      return text == null ?
        "" :
        text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
    },

  // results is for internal usage only
  makeArray: function( array, results ) {
    var ret = results || [];

    if ( array != null ) {
      // The window, strings (and functions) also have 'length'
      // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
      var type = jQuery.type( array );

      if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
        push.call( ret, array );
      } else {
        jQuery.merge( ret, array );
      }
    }

    return ret;
  },

  inArray: function( elem, array, i ) {
    var len;

    if ( array ) {
      if ( indexOf ) {
        return indexOf.call( array, elem, i );
      }

      len = array.length;
      i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

      for ( ; i < len; i++ ) {
        // Skip accessing in sparse arrays
        if ( i in array && array[ i ] === elem ) {
          return i;
        }
      }
    }

    return -1;
  },

  merge: function( first, second ) {
    var i = first.length,
      j = 0;

    if ( typeof second.length === "number" ) {
      for ( var l = second.length; j < l; j++ ) {
        first[ i++ ] = second[ j ];
      }

    } else {
      while ( second[j] !== undefined ) {
        first[ i++ ] = second[ j++ ];
      }
    }

    first.length = i;

    return first;
  },

  grep: function( elems, callback, inv ) {
    var ret = [], retVal;
    inv = !!inv;

    // Go through the array, only saving the items
    // that pass the validator function
    for ( var i = 0, length = elems.length; i < length; i++ ) {
      retVal = !!callback( elems[ i ], i );
      if ( inv !== retVal ) {
        ret.push( elems[ i ] );
      }
    }

    return ret;
  },

  // arg is for internal usage only
  map: function( elems, callback, arg ) {
    var value, key, ret = [],
      i = 0,
      length = elems.length,
      // jquery objects are treated as arrays
      isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

    // Go through the array, translating each of the items to their
    if ( isArray ) {
      for ( ; i < length; i++ ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
          ret[ ret.length ] = value;
        }
      }

    // Go through every key on the object,
    } else {
      for ( key in elems ) {
        value = callback( elems[ key ], key, arg );

        if ( value != null ) {
          ret[ ret.length ] = value;
        }
      }
    }

    // Flatten any nested arrays
    return ret.concat.apply( [], ret );
  },

  // A global GUID counter for objects
  guid: 1,

  // Bind a function to a context, optionally partially applying any
  // arguments.
  proxy: function( fn, context ) {
    if ( typeof context === "string" ) {
      var tmp = fn[ context ];
      context = fn;
      fn = tmp;
    }

    // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.
    if ( !jQuery.isFunction( fn ) ) {
      return undefined;
    }

    // Simulated bind
    var args = slice.call( arguments, 2 ),
      proxy = function() {
        return fn.apply( context, args.concat( slice.call( arguments ) ) );
      };

    // Set the guid of unique handler to the same of original handler, so it can be removed
    proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

    return proxy;
  },

  // Mutifunctional method to get and set values to a collection
  // The value/s can optionally be executed if it's a function
  access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
    var exec,
      bulk = key == null,
      i = 0,
      length = elems.length;

    // Sets many values
    if ( key && typeof key === "object" ) {
      for ( i in key ) {
        jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
      }
      chainable = 1;

    // Sets one value
    } else if ( value !== undefined ) {
      // Optionally, function values get executed if exec is true
      exec = pass === undefined && jQuery.isFunction( value );

      if ( bulk ) {
        // Bulk operations only iterate when executing function values
        if ( exec ) {
          exec = fn;
          fn = function( elem, key, value ) {
            return exec.call( jQuery( elem ), value );
          };

        // Otherwise they run against the entire set
        } else {
          fn.call( elems, value );
          fn = null;
        }
      }

      if ( fn ) {
        for (; i < length; i++ ) {
          fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
        }
      }

      chainable = 1;
    }

    return chainable ?
      elems :

      // Gets
      bulk ?
        fn.call( elems ) :
        length ? fn( elems[0], key ) : emptyGet;
  },

  now: function() {
    return ( new Date() ).getTime();
  },

  // Use of jQuery.browser is frowned upon.
  // More details: http://docs.jquery.com/Utilities/jQuery.browser
  uaMatch: function( ua ) {
    ua = ua.toLowerCase();

    var match = rwebkit.exec( ua ) ||
      ropera.exec( ua ) ||
      rmsie.exec( ua ) ||
      ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
      [];

    return { browser: match[1] || "", version: match[2] || "0" };
  },

  sub: function() {
    function jQuerySub( selector, context ) {
      return new jQuerySub.fn.init( selector, context );
    }
    jQuery.extend( true, jQuerySub, this );
    jQuerySub.superclass = this;
    jQuerySub.fn = jQuerySub.prototype = this();
    jQuerySub.fn.constructor = jQuerySub;
    jQuerySub.sub = this.sub;
    jQuerySub.fn.init = function init( selector, context ) {
      if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
        context = jQuerySub( context );
      }

      return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
    };
    jQuerySub.fn.init.prototype = jQuerySub.fn;
    var rootjQuerySub = jQuerySub(document);
    return jQuerySub;
  },

  browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
  class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
  jQuery.browser[ browserMatch.browser ] = true;
  jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
  jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
  trimLeft = /^[\s\xA0]+/;
  trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
  DOMContentLoaded = function() {
    document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
    jQuery.ready();
  };

} else if ( document.attachEvent ) {
  DOMContentLoaded = function() {
    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
    if ( document.readyState === "complete" ) {
      document.detachEvent( "onreadystatechange", DOMContentLoaded );
      jQuery.ready();
    }
  };
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
  if ( jQuery.isReady ) {
    return;
  }

  try {
    // If IE is used, use the trick by Diego Perini
    // http://javascript.nwbox.com/IEContentLoaded/
    document.documentElement.doScroll("left");
  } catch(e) {
    setTimeout( doScrollCheck, 1 );
    return;
  }

  // and execute any waiting functions
  jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
  var object = flagsCache[ flags ] = {},
    i, length;
  flags = flags.split( /\s+/ );
  for ( i = 0, length = flags.length; i < length; i++ ) {
    object[ flags[i] ] = true;
  }
  return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  flags:  an optional list of space-separated flags that will change how
 *      the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *  once:     will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:     will keep track of previous values and will call any callback added
 *          after the list has been fired right away with the latest "memorized"
 *          values (like a Deferred)
 *
 *  unique:     will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:  interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

  // Convert flags from String-formatted to Object-formatted
  // (we check in cache first)
  flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

  var // Actual callback list
    list = [],
    // Stack of fire calls for repeatable lists
    stack = [],
    // Last fire value (for non-forgettable lists)
    memory,
    // Flag to know if list was already fired
    fired,
    // Flag to know if list is currently firing
    firing,
    // First callback to fire (used internally by add and fireWith)
    firingStart,
    // End of the loop when firing
    firingLength,
    // Index of currently firing callback (modified by remove if needed)
    firingIndex,
    // Add one or several callbacks to the list
    add = function( args ) {
      var i,
        length,
        elem,
        type,
        actual;
      for ( i = 0, length = args.length; i < length; i++ ) {
        elem = args[ i ];
        type = jQuery.type( elem );
        if ( type === "array" ) {
          // Inspect recursively
          add( elem );
        } else if ( type === "function" ) {
          // Add if not in unique mode and callback is not in
          if ( !flags.unique || !self.has( elem ) ) {
            list.push( elem );
          }
        }
      }
    },
    // Fire callbacks
    fire = function( context, args ) {
      args = args || [];
      memory = !flags.memory || [ context, args ];
      fired = true;
      firing = true;
      firingIndex = firingStart || 0;
      firingStart = 0;
      firingLength = list.length;
      for ( ; list && firingIndex < firingLength; firingIndex++ ) {
        if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
          memory = true; // Mark as halted
          break;
        }
      }
      firing = false;
      if ( list ) {
        if ( !flags.once ) {
          if ( stack && stack.length ) {
            memory = stack.shift();
            self.fireWith( memory[ 0 ], memory[ 1 ] );
          }
        } else if ( memory === true ) {
          self.disable();
        } else {
          list = [];
        }
      }
    },
    // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function() {
        if ( list ) {
          var length = list.length;
          add( arguments );
          // Do we need to add the callbacks to the
          // current firing batch?
          if ( firing ) {
            firingLength = list.length;
          // With memory, if we're not firing then
          // we should call right away, unless previous
          // firing was halted (stopOnFalse)
          } else if ( memory && memory !== true ) {
            firingStart = length;
            fire( memory[ 0 ], memory[ 1 ] );
          }
        }
        return this;
      },
      // Remove a callback from the list
      remove: function() {
        if ( list ) {
          var args = arguments,
            argIndex = 0,
            argLength = args.length;
          for ( ; argIndex < argLength ; argIndex++ ) {
            for ( var i = 0; i < list.length; i++ ) {
              if ( args[ argIndex ] === list[ i ] ) {
                // Handle firingIndex and firingLength
                if ( firing ) {
                  if ( i <= firingLength ) {
                    firingLength--;
                    if ( i <= firingIndex ) {
                      firingIndex--;
                    }
                  }
                }
                // Remove the element
                list.splice( i--, 1 );
                // If we have some unicity property then
                // we only need to do this once
                if ( flags.unique ) {
                  break;
                }
              }
            }
          }
        }
        return this;
      },
      // Control if a given callback is in the list
      has: function( fn ) {
        if ( list ) {
          var i = 0,
            length = list.length;
          for ( ; i < length; i++ ) {
            if ( fn === list[ i ] ) {
              return true;
            }
          }
        }
        return false;
      },
      // Remove all callbacks from the list
      empty: function() {
        list = [];
        return this;
      },
      // Have the list do nothing anymore
      disable: function() {
        list = stack = memory = undefined;
        return this;
      },
      // Is it disabled?
      disabled: function() {
        return !list;
      },
      // Lock the list in its current state
      lock: function() {
        stack = undefined;
        if ( !memory || memory === true ) {
          self.disable();
        }
        return this;
      },
      // Is it locked?
      locked: function() {
        return !stack;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function( context, args ) {
        if ( stack ) {
          if ( firing ) {
            if ( !flags.once ) {
              stack.push( [ context, args ] );
            }
          } else if ( !( flags.once && memory ) ) {
            fire( context, args );
          }
        }
        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function() {
        self.fireWith( this, arguments );
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function() {
        return !!fired;
      }
    };

  return self;
};




var // Static reference to slice
  sliceDeferred = [].slice;

jQuery.extend({

  Deferred: function( func ) {
    var doneList = jQuery.Callbacks( "once memory" ),
      failList = jQuery.Callbacks( "once memory" ),
      progressList = jQuery.Callbacks( "memory" ),
      state = "pending",
      lists = {
        resolve: doneList,
        reject: failList,
        notify: progressList
      },
      promise = {
        done: doneList.add,
        fail: failList.add,
        progress: progressList.add,

        state: function() {
          return state;
        },

        // Deprecated
        isResolved: doneList.fired,
        isRejected: failList.fired,

        then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
          deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
          return this;
        },
        always: function() {
          deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
          return this;
        },
        pipe: function( fnDone, fnFail, fnProgress ) {
          return jQuery.Deferred(function( newDefer ) {
            jQuery.each( {
              done: [ fnDone, "resolve" ],
              fail: [ fnFail, "reject" ],
              progress: [ fnProgress, "notify" ]
            }, function( handler, data ) {
              var fn = data[ 0 ],
                action = data[ 1 ],
                returned;
              if ( jQuery.isFunction( fn ) ) {
                deferred[ handler ](function() {
                  returned = fn.apply( this, arguments );
                  if ( returned && jQuery.isFunction( returned.promise ) ) {
                    returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
                  } else {
                    newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
                  }
                });
              } else {
                deferred[ handler ]( newDefer[ action ] );
              }
            });
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function( obj ) {
          if ( obj == null ) {
            obj = promise;
          } else {
            for ( var key in promise ) {
              obj[ key ] = promise[ key ];
            }
          }
          return obj;
        }
      },
      deferred = promise.promise({}),
      key;

    for ( key in lists ) {
      deferred[ key ] = lists[ key ].fire;
      deferred[ key + "With" ] = lists[ key ].fireWith;
    }

    // Handle state
    deferred.done( function() {
      state = "resolved";
    }, failList.disable, progressList.lock ).fail( function() {
      state = "rejected";
    }, doneList.disable, progressList.lock );

    // Call given func if any
    if ( func ) {
      func.call( deferred, deferred );
    }

    // All done!
    return deferred;
  },

  // Deferred helper
  when: function( firstParam ) {
    var args = sliceDeferred.call( arguments, 0 ),
      i = 0,
      length = args.length,
      pValues = new Array( length ),
      count = length,
      pCount = length,
      deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
        firstParam :
        jQuery.Deferred(),
      promise = deferred.promise();
    function resolveFunc( i ) {
      return function( value ) {
        args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
        if ( !( --count ) ) {
          deferred.resolveWith( deferred, args );
        }
      };
    }
    function progressFunc( i ) {
      return function( value ) {
        pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
        deferred.notifyWith( promise, pValues );
      };
    }
    if ( length > 1 ) {
      for ( ; i < length; i++ ) {
        if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
          args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
        } else {
          --count;
        }
      }
      if ( !count ) {
        deferred.resolveWith( deferred, args );
      }
    } else if ( deferred !== firstParam ) {
      deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
    }
    return promise;
  }
});




jQuery.support = (function() {

  var support,
    all,
    a,
    select,
    opt,
    input,
    fragment,
    tds,
    events,
    eventName,
    i,
    isSupported,
    div = document.createElement( "div" ),
    documentElement = document.documentElement;

  // Preliminary tests
  div.setAttribute("className", "t");
  div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

  all = div.getElementsByTagName( "*" );
  a = div.getElementsByTagName( "a" )[ 0 ];

  // Can't get basic test support
  if ( !all || !all.length || !a ) {
    return {};
  }

  // First batch of supports tests
  select = document.createElement( "select" );
  opt = select.appendChild( document.createElement("option") );
  input = div.getElementsByTagName( "input" )[ 0 ];

  support = {
    // IE strips leading whitespace when .innerHTML is used
    leadingWhitespace: ( div.firstChild.nodeType === 3 ),

    // Make sure that tbody elements aren't automatically inserted
    // IE will insert them into empty tables
    tbody: !div.getElementsByTagName("tbody").length,

    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    htmlSerialize: !!div.getElementsByTagName("link").length,

    // Get the style information from getAttribute
    // (IE uses .cssText instead)
    style: /top/.test( a.getAttribute("style") ),

    // Make sure that URLs aren't manipulated
    // (IE normalizes it by default)
    hrefNormalized: ( a.getAttribute("href") === "/a" ),

    // Make sure that element opacity exists
    // (IE uses filter instead)
    // Use a regex to work around a WebKit issue. See #5145
    opacity: /^0.55/.test( a.style.opacity ),

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    cssFloat: !!a.style.cssFloat,

    // Make sure that if no value is specified for a checkbox
    // that it defaults to "on".
    // (WebKit defaults to "" instead)
    checkOn: ( input.value === "on" ),

    // Make sure that a selected-by-default option has a working selected property.
    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
    optSelected: opt.selected,

    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
    getSetAttribute: div.className !== "t",

    // Tests for enctype support on a form(#6743)
    enctype: !!document.createElement("form").enctype,

    // Makes sure cloning an html5 element does not cause problems
    // Where outerHTML is undefined, this still works
    html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

    // Will be defined later
    submitBubbles: true,
    changeBubbles: true,
    focusinBubbles: false,
    deleteExpando: true,
    noCloneEvent: true,
    inlineBlockNeedsLayout: false,
    shrinkWrapBlocks: false,
    reliableMarginRight: true,
    pixelMargin: true
  };

  // jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
  jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

  // Make sure checked status is properly cloned
  input.checked = true;
  support.noCloneChecked = input.cloneNode( true ).checked;

  // Make sure that the options inside disabled selects aren't marked as disabled
  // (WebKit marks them as disabled)
  select.disabled = true;
  support.optDisabled = !opt.disabled;

  // Test to see if it's possible to delete an expando from an element
  // Fails in Internet Explorer
  try {
    delete div.test;
  } catch( e ) {
    support.deleteExpando = false;
  }

  if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
    div.attachEvent( "onclick", function() {
      // Cloning a node shouldn't copy over any
      // bound event handlers (IE does this)
      support.noCloneEvent = false;
    });
    div.cloneNode( true ).fireEvent( "onclick" );
  }

  // Check if a radio maintains its value
  // after being appended to the DOM
  input = document.createElement("input");
  input.value = "t";
  input.setAttribute("type", "radio");
  support.radioValue = input.value === "t";

  input.setAttribute("checked", "checked");

  // #11217 - WebKit loses check when the name is after the checked attribute
  input.setAttribute( "name", "t" );

  div.appendChild( input );
  fragment = document.createDocumentFragment();
  fragment.appendChild( div.lastChild );

  // WebKit doesn't clone checked state correctly in fragments
  support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

  // Check if a disconnected checkbox will retain its checked
  // value of true after appended to the DOM (IE6/7)
  support.appendChecked = input.checked;

  fragment.removeChild( input );
  fragment.appendChild( div );

  // Technique from Juriy Zaytsev
  // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
  // We only care about the case where non-standard event systems
  // are used, namely in IE. Short-circuiting here helps us to
  // avoid an eval call (in setAttribute) which can cause CSP
  // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
  if ( div.attachEvent ) {
    for ( i in {
      submit: 1,
      change: 1,
      focusin: 1
    }) {
      eventName = "on" + i;
      isSupported = ( eventName in div );
      if ( !isSupported ) {
        div.setAttribute( eventName, "return;" );
        isSupported = ( typeof div[ eventName ] === "function" );
      }
      support[ i + "Bubbles" ] = isSupported;
    }
  }

  fragment.removeChild( div );

  // Null elements to avoid leaks in IE
  fragment = select = opt = div = input = null;

  // Run tests that need a body at doc ready
  jQuery(function() {
    var container, outer, inner, table, td, offsetSupport,
      marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
      paddingMarginBorderVisibility, paddingMarginBorder,
      body = document.getElementsByTagName("body")[0];

    if ( !body ) {
      // Return for frameset docs that don't have a body
      return;
    }

    conMarginTop = 1;
    paddingMarginBorder = "padding:0;margin:0;border:";
    positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
    paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
    style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
    html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
      "<table " + style + "' cellpadding='0' cellspacing='0'>" +
      "<tr><td></td></tr></table>";

    container = document.createElement("div");
    container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
    body.insertBefore( container, body.firstChild );

    // Construct the test element
    div = document.createElement("div");
    container.appendChild( div );

    // Check if table cells still have offsetWidth/Height when they are set
    // to display:none and there are still other visible table cells in a
    // table row; if so, offsetWidth/Height are not reliable for use when
    // determining if an element has been hidden directly using
    // display:none (it is still safe to use offsets if a parent element is
    // hidden; don safety goggles and see bug #4512 for more information).
    // (only IE 8 fails this test)
    div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
    tds = div.getElementsByTagName( "td" );
    isSupported = ( tds[ 0 ].offsetHeight === 0 );

    tds[ 0 ].style.display = "";
    tds[ 1 ].style.display = "none";

    // Check if empty table cells still have offsetWidth/Height
    // (IE <= 8 fail this test)
    support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

    // Check if div with explicit width and no margin-right incorrectly
    // gets computed margin-right based on width of container. For more
    // info see bug #3333
    // Fails in WebKit before Feb 2011 nightlies
    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
    if ( window.getComputedStyle ) {
      div.innerHTML = "";
      marginDiv = document.createElement( "div" );
      marginDiv.style.width = "0";
      marginDiv.style.marginRight = "0";
      div.style.width = "2px";
      div.appendChild( marginDiv );
      support.reliableMarginRight =
        ( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
    }

    if ( typeof div.style.zoom !== "undefined" ) {
      // Check if natively block-level elements act like inline-block
      // elements when setting their display to 'inline' and giving
      // them layout
      // (IE < 8 does this)
      div.innerHTML = "";
      div.style.width = div.style.padding = "1px";
      div.style.border = 0;
      div.style.overflow = "hidden";
      div.style.display = "inline";
      div.style.zoom = 1;
      support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

      // Check if elements with layout shrink-wrap their children
      // (IE 6 does this)
      div.style.display = "block";
      div.style.overflow = "visible";
      div.innerHTML = "<div style='width:5px;'></div>";
      support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
    }

    div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
    div.innerHTML = html;

    outer = div.firstChild;
    inner = outer.firstChild;
    td = outer.nextSibling.firstChild.firstChild;

    offsetSupport = {
      doesNotAddBorder: ( inner.offsetTop !== 5 ),
      doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
    };

    inner.style.position = "fixed";
    inner.style.top = "20px";

    // safari subtracts parent border width here which is 5px
    offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
    inner.style.position = inner.style.top = "";

    outer.style.overflow = "hidden";
    outer.style.position = "relative";

    offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
    offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

    if ( window.getComputedStyle ) {
      div.style.marginTop = "1%";
      support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
    }

    if ( typeof container.style.zoom !== "undefined" ) {
      container.style.zoom = 1;
    }

    body.removeChild( container );
    marginDiv = div = container = null;

    jQuery.extend( support, offsetSupport );
  });

  return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
  rmultiDash = /([A-Z])/g;

jQuery.extend({
  cache: {},

  // Please use with caution
  uuid: 0,

  // Unique for each copy of jQuery on the page
  // Non-digits removed to match rinlinejQuery
  expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

  // The following elements throw uncatchable exceptions if you
  // attempt to add expando properties to them.
  noData: {
    "embed": true,
    // Ban all objects except for Flash (which handle expandos)
    "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
    "applet": true
  },

  hasData: function( elem ) {
    elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
    return !!elem && !isEmptyDataObject( elem );
  },

  data: function( elem, name, data, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
      return;
    }

    var privateCache, thisCache, ret,
      internalKey = jQuery.expando,
      getByName = typeof name === "string",

      // We have to handle DOM nodes and JS objects differently because IE6-7
      // can't GC object references properly across the DOM-JS boundary
      isNode = elem.nodeType,

      // Only DOM nodes need the global jQuery cache; JS object data is
      // attached directly to the object so GC can occur automatically
      cache = isNode ? jQuery.cache : elem,

      // Only defining an ID for JS objects if its cache already exists allows
      // the code to shortcut on the same path as a DOM node with no cache
      id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
      isEvents = name === "events";

    // Avoid doing any more work than we need to when trying to get data on an
    // object that has no data at all
    if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
      return;
    }

    if ( !id ) {
      // Only DOM nodes need a new unique ID for each element since their data
      // ends up in the global cache
      if ( isNode ) {
        elem[ internalKey ] = id = ++jQuery.uuid;
      } else {
        id = internalKey;
      }
    }

    if ( !cache[ id ] ) {
      cache[ id ] = {};

      // Avoids exposing jQuery metadata on plain JS objects when the object
      // is serialized using JSON.stringify
      if ( !isNode ) {
        cache[ id ].toJSON = jQuery.noop;
      }
    }

    // An object can be passed to jQuery.data instead of a key/value pair; this gets
    // shallow copied over onto the existing cache
    if ( typeof name === "object" || typeof name === "function" ) {
      if ( pvt ) {
        cache[ id ] = jQuery.extend( cache[ id ], name );
      } else {
        cache[ id ].data = jQuery.extend( cache[ id ].data, name );
      }
    }

    privateCache = thisCache = cache[ id ];

    // jQuery data() is stored in a separate object inside the object's internal data
    // cache in order to avoid key collisions between internal data and user-defined
    // data.
    if ( !pvt ) {
      if ( !thisCache.data ) {
        thisCache.data = {};
      }

      thisCache = thisCache.data;
    }

    if ( data !== undefined ) {
      thisCache[ jQuery.camelCase( name ) ] = data;
    }

    // Users should not attempt to inspect the internal events object using jQuery.data,
    // it is undocumented and subject to change. But does anyone listen? No.
    if ( isEvents && !thisCache[ name ] ) {
      return privateCache.events;
    }

    // Check for both converted-to-camel and non-converted data property names
    // If a data property was specified
    if ( getByName ) {

      // First Try to find as-is property data
      ret = thisCache[ name ];

      // Test for null|undefined property data
      if ( ret == null ) {

        // Try to find the camelCased property
        ret = thisCache[ jQuery.camelCase( name ) ];
      }
    } else {
      ret = thisCache;
    }

    return ret;
  },

  removeData: function( elem, name, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
      return;
    }

    var thisCache, i, l,

      // Reference to internal data cache key
      internalKey = jQuery.expando,

      isNode = elem.nodeType,

      // See jQuery.data for more information
      cache = isNode ? jQuery.cache : elem,

      // See jQuery.data for more information
      id = isNode ? elem[ internalKey ] : internalKey;

    // If there is already no cache entry for this object, there is no
    // purpose in continuing
    if ( !cache[ id ] ) {
      return;
    }

    if ( name ) {

      thisCache = pvt ? cache[ id ] : cache[ id ].data;

      if ( thisCache ) {

        // Support array or space separated string names for data keys
        if ( !jQuery.isArray( name ) ) {

          // try the string as a key before any manipulation
          if ( name in thisCache ) {
            name = [ name ];
          } else {

            // split the camel cased version by spaces unless a key with the spaces exists
            name = jQuery.camelCase( name );
            if ( name in thisCache ) {
              name = [ name ];
            } else {
              name = name.split( " " );
            }
          }
        }

        for ( i = 0, l = name.length; i < l; i++ ) {
          delete thisCache[ name[i] ];
        }

        // If there is no data left in the cache, we want to continue
        // and let the cache object itself get destroyed
        if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
          return;
        }
      }
    }

    // See jQuery.data for more information
    if ( !pvt ) {
      delete cache[ id ].data;

      // Don't destroy the parent cache unless the internal data object
      // had been the only thing left in it
      if ( !isEmptyDataObject(cache[ id ]) ) {
        return;
      }
    }

    // Browsers that fail expando deletion also refuse to delete expandos on
    // the window, but it will allow it on all other JS objects; other browsers
    // don't care
    // Ensure that `cache` is not a window object #10080
    if ( jQuery.support.deleteExpando || !cache.setInterval ) {
      delete cache[ id ];
    } else {
      cache[ id ] = null;
    }

    // We destroyed the cache and need to eliminate the expando on the node to avoid
    // false lookups in the cache for entries that no longer exist
    if ( isNode ) {
      // IE does not allow us to delete expando properties from nodes,
      // nor does it have a removeAttribute function on Document nodes;
      // we must handle all of these cases
      if ( jQuery.support.deleteExpando ) {
        delete elem[ internalKey ];
      } else if ( elem.removeAttribute ) {
        elem.removeAttribute( internalKey );
      } else {
        elem[ internalKey ] = null;
      }
    }
  },

  // For internal use only.
  _data: function( elem, name, data ) {
    return jQuery.data( elem, name, data, true );
  },

  // A method for determining if a DOM node can handle the data expando
  acceptData: function( elem ) {
    if ( elem.nodeName ) {
      var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

      if ( match ) {
        return !(match === true || elem.getAttribute("classid") !== match);
      }
    }

    return true;
  }
});

jQuery.fn.extend({
  data: function( key, value ) {
    var parts, part, attr, name, l,
      elem = this[0],
      i = 0,
      data = null;

    // Gets all values
    if ( key === undefined ) {
      if ( this.length ) {
        data = jQuery.data( elem );

        if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
          attr = elem.attributes;
          for ( l = attr.length; i < l; i++ ) {
            name = attr[i].name;

            if ( name.indexOf( "data-" ) === 0 ) {
              name = jQuery.camelCase( name.substring(5) );

              dataAttr( elem, name, data[ name ] );
            }
          }
          jQuery._data( elem, "parsedAttrs", true );
        }
      }

      return data;
    }

    // Sets multiple values
    if ( typeof key === "object" ) {
      return this.each(function() {
        jQuery.data( this, key );
      });
    }

    parts = key.split( ".", 2 );
    parts[1] = parts[1] ? "." + parts[1] : "";
    part = parts[1] + "!";

    return jQuery.access( this, function( value ) {

      if ( value === undefined ) {
        data = this.triggerHandler( "getData" + part, [ parts[0] ] );

        // Try to fetch any internally stored data first
        if ( data === undefined && elem ) {
          data = jQuery.data( elem, key );
          data = dataAttr( elem, key, data );
        }

        return data === undefined && parts[1] ?
          this.data( parts[0] ) :
          data;
      }

      parts[1] = value;
      this.each(function() {
        var self = jQuery( this );

        self.triggerHandler( "setData" + part, parts );
        jQuery.data( this, key, value );
        self.triggerHandler( "changeData" + part, parts );
      });
    }, null, value, arguments.length > 1, null, false );
  },

  removeData: function( key ) {
    return this.each(function() {
      jQuery.removeData( this, key );
    });
  }
});

function dataAttr( elem, key, data ) {
  // If nothing was found internally, try to fetch any
  // data from the HTML5 data-* attribute
  if ( data === undefined && elem.nodeType === 1 ) {

    var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

    data = elem.getAttribute( name );

    if ( typeof data === "string" ) {
      try {
        data = data === "true" ? true :
        data === "false" ? false :
        data === "null" ? null :
        jQuery.isNumeric( data ) ? +data :
          rbrace.test( data ) ? jQuery.parseJSON( data ) :
          data;
      } catch( e ) {}

      // Make sure we set the data so it isn't changed later
      jQuery.data( elem, key, data );

    } else {
      data = undefined;
    }
  }

  return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
  for ( var name in obj ) {

    // if the public data object is empty, the private is still empty
    if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
      continue;
    }
    if ( name !== "toJSON" ) {
      return false;
    }
  }

  return true;
}




function handleQueueMarkDefer( elem, type, src ) {
  var deferDataKey = type + "defer",
    queueDataKey = type + "queue",
    markDataKey = type + "mark",
    defer = jQuery._data( elem, deferDataKey );
  if ( defer &&
    ( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
    ( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
    // Give room for hard-coded callbacks to fire first
    // and eventually mark/queue something else on the element
    setTimeout( function() {
      if ( !jQuery._data( elem, queueDataKey ) &&
        !jQuery._data( elem, markDataKey ) ) {
        jQuery.removeData( elem, deferDataKey, true );
        defer.fire();
      }
    }, 0 );
  }
}

jQuery.extend({

  _mark: function( elem, type ) {
    if ( elem ) {
      type = ( type || "fx" ) + "mark";
      jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
    }
  },

  _unmark: function( force, elem, type ) {
    if ( force !== true ) {
      type = elem;
      elem = force;
      force = false;
    }
    if ( elem ) {
      type = type || "fx";
      var key = type + "mark",
        count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
      if ( count ) {
        jQuery._data( elem, key, count );
      } else {
        jQuery.removeData( elem, key, true );
        handleQueueMarkDefer( elem, type, "mark" );
      }
    }
  },

  queue: function( elem, type, data ) {
    var q;
    if ( elem ) {
      type = ( type || "fx" ) + "queue";
      q = jQuery._data( elem, type );

      // Speed up dequeue by getting out quickly if this is just a lookup
      if ( data ) {
        if ( !q || jQuery.isArray(data) ) {
          q = jQuery._data( elem, type, jQuery.makeArray(data) );
        } else {
          q.push( data );
        }
      }
      return q || [];
    }
  },

  dequeue: function( elem, type ) {
    type = type || "fx";

    var queue = jQuery.queue( elem, type ),
      fn = queue.shift(),
      hooks = {};

    // If the fx queue is dequeued, always remove the progress sentinel
    if ( fn === "inprogress" ) {
      fn = queue.shift();
    }

    if ( fn ) {
      // Add a progress sentinel to prevent the fx queue from being
      // automatically dequeued
      if ( type === "fx" ) {
        queue.unshift( "inprogress" );
      }

      jQuery._data( elem, type + ".run", hooks );
      fn.call( elem, function() {
        jQuery.dequeue( elem, type );
      }, hooks );
    }

    if ( !queue.length ) {
      jQuery.removeData( elem, type + "queue " + type + ".run", true );
      handleQueueMarkDefer( elem, type, "queue" );
    }
  }
});

jQuery.fn.extend({
  queue: function( type, data ) {
    var setter = 2;

    if ( typeof type !== "string" ) {
      data = type;
      type = "fx";
      setter--;
    }

    if ( arguments.length < setter ) {
      return jQuery.queue( this[0], type );
    }

    return data === undefined ?
      this :
      this.each(function() {
        var queue = jQuery.queue( this, type, data );

        if ( type === "fx" && queue[0] !== "inprogress" ) {
          jQuery.dequeue( this, type );
        }
      });
  },
  dequeue: function( type ) {
    return this.each(function() {
      jQuery.dequeue( this, type );
    });
  },
  // Based off of the plugin by Clint Helfers, with permission.
  // http://blindsignals.com/index.php/2009/07/jquery-delay/
  delay: function( time, type ) {
    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    type = type || "fx";

    return this.queue( type, function( next, hooks ) {
      var timeout = setTimeout( next, time );
      hooks.stop = function() {
        clearTimeout( timeout );
      };
    });
  },
  clearQueue: function( type ) {
    return this.queue( type || "fx", [] );
  },
  // Get a promise resolved when queues of a certain type
  // are emptied (fx is the type by default)
  promise: function( type, object ) {
    if ( typeof type !== "string" ) {
      object = type;
      type = undefined;
    }
    type = type || "fx";
    var defer = jQuery.Deferred(),
      elements = this,
      i = elements.length,
      count = 1,
      deferDataKey = type + "defer",
      queueDataKey = type + "queue",
      markDataKey = type + "mark",
      tmp;
    function resolve() {
      if ( !( --count ) ) {
        defer.resolveWith( elements, [ elements ] );
      }
    }
    while( i-- ) {
      if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
          ( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
            jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
          jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
        count++;
        tmp.add( resolve );
      }
    }
    resolve();
    return defer.promise( object );
  }
});




var rclass = /[\n\t\r]/g,
  rspace = /\s+/,
  rreturn = /\r/g,
  rtype = /^(?:button|input)$/i,
  rfocusable = /^(?:button|input|object|select|textarea)$/i,
  rclickable = /^a(?:rea)?$/i,
  rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
  getSetAttribute = jQuery.support.getSetAttribute,
  nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
  attr: function( name, value ) {
    return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
  },

  removeAttr: function( name ) {
    return this.each(function() {
      jQuery.removeAttr( this, name );
    });
  },

  prop: function( name, value ) {
    return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
  },

  removeProp: function( name ) {
    name = jQuery.propFix[ name ] || name;
    return this.each(function() {
      // try/catch handles cases where IE balks (such as removing a property on window)
      try {
        this[ name ] = undefined;
        delete this[ name ];
      } catch( e ) {}
    });
  },

  addClass: function( value ) {
    var classNames, i, l, elem,
      setClass, c, cl;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).addClass( value.call(this, j, this.className) );
      });
    }

    if ( value && typeof value === "string" ) {
      classNames = value.split( rspace );

      for ( i = 0, l = this.length; i < l; i++ ) {
        elem = this[ i ];

        if ( elem.nodeType === 1 ) {
          if ( !elem.className && classNames.length === 1 ) {
            elem.className = value;

          } else {
            setClass = " " + elem.className + " ";

            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
              if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
                setClass += classNames[ c ] + " ";
              }
            }
            elem.className = jQuery.trim( setClass );
          }
        }
      }
    }

    return this;
  },

  removeClass: function( value ) {
    var classNames, i, l, elem, className, c, cl;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).removeClass( value.call(this, j, this.className) );
      });
    }

    if ( (value && typeof value === "string") || value === undefined ) {
      classNames = ( value || "" ).split( rspace );

      for ( i = 0, l = this.length; i < l; i++ ) {
        elem = this[ i ];

        if ( elem.nodeType === 1 && elem.className ) {
          if ( value ) {
            className = (" " + elem.className + " ").replace( rclass, " " );
            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
              className = className.replace(" " + classNames[ c ] + " ", " ");
            }
            elem.className = jQuery.trim( className );

          } else {
            elem.className = "";
          }
        }
      }
    }

    return this;
  },

  toggleClass: function( value, stateVal ) {
    var type = typeof value,
      isBool = typeof stateVal === "boolean";

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( i ) {
        jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
      });
    }

    return this.each(function() {
      if ( type === "string" ) {
        // toggle individual class names
        var className,
          i = 0,
          self = jQuery( this ),
          state = stateVal,
          classNames = value.split( rspace );

        while ( (className = classNames[ i++ ]) ) {
          // check each className given, space seperated list
          state = isBool ? state : !self.hasClass( className );
          self[ state ? "addClass" : "removeClass" ]( className );
        }

      } else if ( type === "undefined" || type === "boolean" ) {
        if ( this.className ) {
          // store className if set
          jQuery._data( this, "__className__", this.className );
        }

        // toggle whole className
        this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
      }
    });
  },

  hasClass: function( selector ) {
    var className = " " + selector + " ",
      i = 0,
      l = this.length;
    for ( ; i < l; i++ ) {
      if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
        return true;
      }
    }

    return false;
  },

  val: function( value ) {
    var hooks, ret, isFunction,
      elem = this[0];

    if ( !arguments.length ) {
      if ( elem ) {
        hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

        if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
          return ret;
        }

        ret = elem.value;

        return typeof ret === "string" ?
          // handle most common string cases
          ret.replace(rreturn, "") :
          // handle cases where value is null/undef or number
          ret == null ? "" : ret;
      }

      return;
    }

    isFunction = jQuery.isFunction( value );

    return this.each(function( i ) {
      var self = jQuery(this), val;

      if ( this.nodeType !== 1 ) {
        return;
      }

      if ( isFunction ) {
        val = value.call( this, i, self.val() );
      } else {
        val = value;
      }

      // Treat null/undefined as ""; convert numbers to string
      if ( val == null ) {
        val = "";
      } else if ( typeof val === "number" ) {
        val += "";
      } else if ( jQuery.isArray( val ) ) {
        val = jQuery.map(val, function ( value ) {
          return value == null ? "" : value + "";
        });
      }

      hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

      // If set returns undefined, fall back to normal setting
      if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
        this.value = val;
      }
    });
  }
});

jQuery.extend({
  valHooks: {
    option: {
      get: function( elem ) {
        // attributes.value is undefined in Blackberry 4.7 but
        // uses .value. See #6932
        var val = elem.attributes.value;
        return !val || val.specified ? elem.value : elem.text;
      }
    },
    select: {
      get: function( elem ) {
        var value, i, max, option,
          index = elem.selectedIndex,
          values = [],
          options = elem.options,
          one = elem.type === "select-one";

        // Nothing was selected
        if ( index < 0 ) {
          return null;
        }

        // Loop through all the selected options
        i = one ? index : 0;
        max = one ? index + 1 : options.length;
        for ( ; i < max; i++ ) {
          option = options[ i ];

          // Don't return options that are disabled or in a disabled optgroup
          if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
              (!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

            // Get the specific value for the option
            value = jQuery( option ).val();

            // We don't need an array for one selects
            if ( one ) {
              return value;
            }

            // Multi-Selects return an array
            values.push( value );
          }
        }

        // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
        if ( one && !values.length && options.length ) {
          return jQuery( options[ index ] ).val();
        }

        return values;
      },

      set: function( elem, value ) {
        var values = jQuery.makeArray( value );

        jQuery(elem).find("option").each(function() {
          this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
        });

        if ( !values.length ) {
          elem.selectedIndex = -1;
        }
        return values;
      }
    }
  },

  attrFn: {
    val: true,
    css: true,
    html: true,
    text: true,
    data: true,
    width: true,
    height: true,
    offset: true
  },

  attr: function( elem, name, value, pass ) {
    var ret, hooks, notxml,
      nType = elem.nodeType;

    // don't get/set attributes on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    if ( pass && name in jQuery.attrFn ) {
      return jQuery( elem )[ name ]( value );
    }

    // Fallback to prop when attributes are not supported
    if ( typeof elem.getAttribute === "undefined" ) {
      return jQuery.prop( elem, name, value );
    }

    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

    // All attributes are lowercase
    // Grab necessary hook if one is defined
    if ( notxml ) {
      name = name.toLowerCase();
      hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
    }

    if ( value !== undefined ) {

      if ( value === null ) {
        jQuery.removeAttr( elem, name );
        return;

      } else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
        return ret;

      } else {
        elem.setAttribute( name, "" + value );
        return value;
      }

    } else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
      return ret;

    } else {

      ret = elem.getAttribute( name );

      // Non-existent attributes return null, we normalize to undefined
      return ret === null ?
        undefined :
        ret;
    }
  },

  removeAttr: function( elem, value ) {
    var propName, attrNames, name, l, isBool,
      i = 0;

    if ( value && elem.nodeType === 1 ) {
      attrNames = value.toLowerCase().split( rspace );
      l = attrNames.length;

      for ( ; i < l; i++ ) {
        name = attrNames[ i ];

        if ( name ) {
          propName = jQuery.propFix[ name ] || name;
          isBool = rboolean.test( name );

          // See #9699 for explanation of this approach (setting first, then removal)
          // Do not do this for boolean attributes (see #10870)
          if ( !isBool ) {
            jQuery.attr( elem, name, "" );
          }
          elem.removeAttribute( getSetAttribute ? name : propName );

          // Set corresponding property to false for boolean attributes
          if ( isBool && propName in elem ) {
            elem[ propName ] = false;
          }
        }
      }
    }
  },

  attrHooks: {
    type: {
      set: function( elem, value ) {
        // We can't allow the type property to be changed (since it causes problems in IE)
        if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
          jQuery.error( "type property can't be changed" );
        } else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
          // Setting the type on a radio button after the value resets the value in IE6-9
          // Reset value to it's default in case type is set after value
          // This is for element creation
          var val = elem.value;
          elem.setAttribute( "type", value );
          if ( val ) {
            elem.value = val;
          }
          return value;
        }
      }
    },
    // Use the value property for back compat
    // Use the nodeHook for button elements in IE6/7 (#1954)
    value: {
      get: function( elem, name ) {
        if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
          return nodeHook.get( elem, name );
        }
        return name in elem ?
          elem.value :
          null;
      },
      set: function( elem, value, name ) {
        if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
          return nodeHook.set( elem, value, name );
        }
        // Does not return so that setAttribute is also used
        elem.value = value;
      }
    }
  },

  propFix: {
    tabindex: "tabIndex",
    readonly: "readOnly",
    "for": "htmlFor",
    "class": "className",
    maxlength: "maxLength",
    cellspacing: "cellSpacing",
    cellpadding: "cellPadding",
    rowspan: "rowSpan",
    colspan: "colSpan",
    usemap: "useMap",
    frameborder: "frameBorder",
    contenteditable: "contentEditable"
  },

  prop: function( elem, name, value ) {
    var ret, hooks, notxml,
      nType = elem.nodeType;

    // don't get/set properties on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

    if ( notxml ) {
      // Fix name and attach hooks
      name = jQuery.propFix[ name ] || name;
      hooks = jQuery.propHooks[ name ];
    }

    if ( value !== undefined ) {
      if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
        return ret;

      } else {
        return ( elem[ name ] = value );
      }

    } else {
      if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
        return ret;

      } else {
        return elem[ name ];
      }
    }
  },

  propHooks: {
    tabIndex: {
      get: function( elem ) {
        // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
        // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
        var attributeNode = elem.getAttributeNode("tabindex");

        return attributeNode && attributeNode.specified ?
          parseInt( attributeNode.value, 10 ) :
          rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
            0 :
            undefined;
      }
    }
  }
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
  get: function( elem, name ) {
    // Align boolean attributes with corresponding properties
    // Fall back to attribute presence where some booleans are not supported
    var attrNode,
      property = jQuery.prop( elem, name );
    return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
      name.toLowerCase() :
      undefined;
  },
  set: function( elem, value, name ) {
    var propName;
    if ( value === false ) {
      // Remove boolean attributes when set to false
      jQuery.removeAttr( elem, name );
    } else {
      // value is true since we know at this point it's type boolean and not false
      // Set boolean attributes to the same name and set the DOM property
      propName = jQuery.propFix[ name ] || name;
      if ( propName in elem ) {
        // Only set the IDL specifically if it already exists on the element
        elem[ propName ] = true;
      }

      elem.setAttribute( name, name.toLowerCase() );
    }
    return name;
  }
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

  fixSpecified = {
    name: true,
    id: true,
    coords: true
  };

  // Use this for any attribute in IE6/7
  // This fixes almost every IE6/7 issue
  nodeHook = jQuery.valHooks.button = {
    get: function( elem, name ) {
      var ret;
      ret = elem.getAttributeNode( name );
      return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
        ret.nodeValue :
        undefined;
    },
    set: function( elem, value, name ) {
      // Set the existing or create a new attribute node
      var ret = elem.getAttributeNode( name );
      if ( !ret ) {
        ret = document.createAttribute( name );
        elem.setAttributeNode( ret );
      }
      return ( ret.nodeValue = value + "" );
    }
  };

  // Apply the nodeHook to tabindex
  jQuery.attrHooks.tabindex.set = nodeHook.set;

  // Set width and height to auto instead of 0 on empty string( Bug #8150 )
  // This is for removals
  jQuery.each([ "width", "height" ], function( i, name ) {
    jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
      set: function( elem, value ) {
        if ( value === "" ) {
          elem.setAttribute( name, "auto" );
          return value;
        }
      }
    });
  });

  // Set contenteditable to false on removals(#10429)
  // Setting to empty string throws an error as an invalid value
  jQuery.attrHooks.contenteditable = {
    get: nodeHook.get,
    set: function( elem, value, name ) {
      if ( value === "" ) {
        value = "false";
      }
      nodeHook.set( elem, value, name );
    }
  };
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
  jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
    jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
      get: function( elem ) {
        var ret = elem.getAttribute( name, 2 );
        return ret === null ? undefined : ret;
      }
    });
  });
}

if ( !jQuery.support.style ) {
  jQuery.attrHooks.style = {
    get: function( elem ) {
      // Return undefined in the case of empty string
      // Normalize to lowercase since IE uppercases css property names
      return elem.style.cssText.toLowerCase() || undefined;
    },
    set: function( elem, value ) {
      return ( elem.style.cssText = "" + value );
    }
  };
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
  jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
    get: function( elem ) {
      var parent = elem.parentNode;

      if ( parent ) {
        parent.selectedIndex;

        // Make sure that it also works with optgroups, see #5701
        if ( parent.parentNode ) {
          parent.parentNode.selectedIndex;
        }
      }
      return null;
    }
  });
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
  jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
  jQuery.each([ "radio", "checkbox" ], function() {
    jQuery.valHooks[ this ] = {
      get: function( elem ) {
        // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
        return elem.getAttribute("value") === null ? "on" : elem.value;
      }
    };
  });
}
jQuery.each([ "radio", "checkbox" ], function() {
  jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
    set: function( elem, value ) {
      if ( jQuery.isArray( value ) ) {
        return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
      }
    }
  });
});




var rformElems = /^(?:textarea|input|select)$/i,
  rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
  rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
  rkeyEvent = /^key/,
  rmouseEvent = /^(?:mouse|contextmenu)|click/,
  rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
  quickParse = function( selector ) {
    var quick = rquickIs.exec( selector );
    if ( quick ) {
      //   0  1    2   3
      // [ _, tag, id, class ]
      quick[1] = ( quick[1] || "" ).toLowerCase();
      quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
    }
    return quick;
  },
  quickIs = function( elem, m ) {
    var attrs = elem.attributes || {};
    return (
      (!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
      (!m[2] || (attrs.id || {}).value === m[2]) &&
      (!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
    );
  },
  hoverHack = function( events ) {
    return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
  };

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

  add: function( elem, types, handler, data, selector ) {

    var elemData, eventHandle, events,
      t, tns, type, namespaces, handleObj,
      handleObjIn, quick, handlers, special;

    // Don't attach events to noData or text/comment nodes (allow plain objects tho)
    if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
      return;
    }

    // Caller can pass in an object of custom data in lieu of the handler
    if ( handler.handler ) {
      handleObjIn = handler;
      handler = handleObjIn.handler;
      selector = handleObjIn.selector;
    }

    // Make sure that the handler has a unique ID, used to find/remove it later
    if ( !handler.guid ) {
      handler.guid = jQuery.guid++;
    }

    // Init the element's event structure and main handler, if this is the first
    events = elemData.events;
    if ( !events ) {
      elemData.events = events = {};
    }
    eventHandle = elemData.handle;
    if ( !eventHandle ) {
      elemData.handle = eventHandle = function( e ) {
        // Discard the second event of a jQuery.event.trigger() and
        // when an event is called after a page has unloaded
        return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
          jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
          undefined;
      };
      // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
      eventHandle.elem = elem;
    }

    // Handle multiple events separated by a space
    // jQuery(...).bind("mouseover mouseout", fn);
    types = jQuery.trim( hoverHack(types) ).split( " " );
    for ( t = 0; t < types.length; t++ ) {

      tns = rtypenamespace.exec( types[t] ) || [];
      type = tns[1];
      namespaces = ( tns[2] || "" ).split( "." ).sort();

      // If event changes its type, use the special event handlers for the changed type
      special = jQuery.event.special[ type ] || {};

      // If selector defined, determine special event api type, otherwise given type
      type = ( selector ? special.delegateType : special.bindType ) || type;

      // Update special based on newly reset type
      special = jQuery.event.special[ type ] || {};

      // handleObj is passed to all event handlers
      handleObj = jQuery.extend({
        type: type,
        origType: tns[1],
        data: data,
        handler: handler,
        guid: handler.guid,
        selector: selector,
        quick: selector && quickParse( selector ),
        namespace: namespaces.join(".")
      }, handleObjIn );

      // Init the event handler queue if we're the first
      handlers = events[ type ];
      if ( !handlers ) {
        handlers = events[ type ] = [];
        handlers.delegateCount = 0;

        // Only use addEventListener/attachEvent if the special events handler returns false
        if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
          // Bind the global event handler to the element
          if ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle, false );

          } else if ( elem.attachEvent ) {
            elem.attachEvent( "on" + type, eventHandle );
          }
        }
      }

      if ( special.add ) {
        special.add.call( elem, handleObj );

        if ( !handleObj.handler.guid ) {
          handleObj.handler.guid = handler.guid;
        }
      }

      // Add to the element's handler list, delegates in front
      if ( selector ) {
        handlers.splice( handlers.delegateCount++, 0, handleObj );
      } else {
        handlers.push( handleObj );
      }

      // Keep track of which events have ever been used, for event optimization
      jQuery.event.global[ type ] = true;
    }

    // Nullify elem to prevent memory leaks in IE
    elem = null;
  },

  global: {},

  // Detach an event or set of events from an element
  remove: function( elem, types, handler, selector, mappedTypes ) {

    var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
      t, tns, type, origType, namespaces, origCount,
      j, events, special, handle, eventType, handleObj;

    if ( !elemData || !(events = elemData.events) ) {
      return;
    }

    // Once for each type.namespace in types; type may be omitted
    types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
    for ( t = 0; t < types.length; t++ ) {
      tns = rtypenamespace.exec( types[t] ) || [];
      type = origType = tns[1];
      namespaces = tns[2];

      // Unbind all events (on this namespace, if provided) for the element
      if ( !type ) {
        for ( type in events ) {
          jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
        }
        continue;
      }

      special = jQuery.event.special[ type ] || {};
      type = ( selector? special.delegateType : special.bindType ) || type;
      eventType = events[ type ] || [];
      origCount = eventType.length;
      namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

      // Remove matching events
      for ( j = 0; j < eventType.length; j++ ) {
        handleObj = eventType[ j ];

        if ( ( mappedTypes || origType === handleObj.origType ) &&
           ( !handler || handler.guid === handleObj.guid ) &&
           ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
           ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
          eventType.splice( j--, 1 );

          if ( handleObj.selector ) {
            eventType.delegateCount--;
          }
          if ( special.remove ) {
            special.remove.call( elem, handleObj );
          }
        }
      }

      // Remove generic event handler if we removed something and no more handlers exist
      // (avoids potential for endless recursion during removal of special event handlers)
      if ( eventType.length === 0 && origCount !== eventType.length ) {
        if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
          jQuery.removeEvent( elem, type, elemData.handle );
        }

        delete events[ type ];
      }
    }

    // Remove the expando if it's no longer used
    if ( jQuery.isEmptyObject( events ) ) {
      handle = elemData.handle;
      if ( handle ) {
        handle.elem = null;
      }

      // removeData also checks for emptiness and clears the expando if empty
      // so use it instead of delete
      jQuery.removeData( elem, [ "events", "handle" ], true );
    }
  },

  // Events that are safe to short-circuit if no handlers are attached.
  // Native DOM events should not be added, they may have inline handlers.
  customEvent: {
    "getData": true,
    "setData": true,
    "changeData": true
  },

  trigger: function( event, data, elem, onlyHandlers ) {
    // Don't do events on text and comment nodes
    if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
      return;
    }

    // Event object or event type
    var type = event.type || event,
      namespaces = [],
      cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

    // focus/blur morphs to focusin/out; ensure we're not firing them right now
    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
      return;
    }

    if ( type.indexOf( "!" ) >= 0 ) {
      // Exclusive events trigger only for the exact event (no namespaces)
      type = type.slice(0, -1);
      exclusive = true;
    }

    if ( type.indexOf( "." ) >= 0 ) {
      // Namespaced trigger; create a regexp to match event type in handle()
      namespaces = type.split(".");
      type = namespaces.shift();
      namespaces.sort();
    }

    if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
      // No jQuery handlers for this event type, and it can't have inline handlers
      return;
    }

    // Caller can pass in an Event, Object, or just an event type string
    event = typeof event === "object" ?
      // jQuery.Event object
      event[ jQuery.expando ] ? event :
      // Object literal
      new jQuery.Event( type, event ) :
      // Just the event type (string)
      new jQuery.Event( type );

    event.type = type;
    event.isTrigger = true;
    event.exclusive = exclusive;
    event.namespace = namespaces.join( "." );
    event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
    ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

    // Handle a global trigger
    if ( !elem ) {

      // TODO: Stop taunting the data cache; remove global events and always attach to document
      cache = jQuery.cache;
      for ( i in cache ) {
        if ( cache[ i ].events && cache[ i ].events[ type ] ) {
          jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
        }
      }
      return;
    }

    // Clean up the event in case it is being reused
    event.result = undefined;
    if ( !event.target ) {
      event.target = elem;
    }

    // Clone any incoming data and prepend the event, creating the handler arg list
    data = data != null ? jQuery.makeArray( data ) : [];
    data.unshift( event );

    // Allow special events to draw outside the lines
    special = jQuery.event.special[ type ] || {};
    if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
      return;
    }

    // Determine event propagation path in advance, per W3C events spec (#9951)
    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    eventPath = [[ elem, special.bindType || type ]];
    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

      bubbleType = special.delegateType || type;
      cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
      old = null;
      for ( ; cur; cur = cur.parentNode ) {
        eventPath.push([ cur, bubbleType ]);
        old = cur;
      }

      // Only add window if we got to document (e.g., not plain obj or detached DOM)
      if ( old && old === elem.ownerDocument ) {
        eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
      }
    }

    // Fire handlers on the event path
    for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

      cur = eventPath[i][0];
      event.type = eventPath[i][1];

      handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
      if ( handle ) {
        handle.apply( cur, data );
      }
      // Note that this is a bare JS function and not a jQuery handler
      handle = ontype && cur[ ontype ];
      if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
        event.preventDefault();
      }
    }
    event.type = type;

    // If nobody prevented the default action, do it now
    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

      if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
        !(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

        // Call a native DOM method on the target with the same name name as the event.
        // Can't use an .isFunction() check here because IE6/7 fails that test.
        // Don't do default actions on window, that's where global variables be (#6170)
        // IE<9 dies on focus/blur to hidden element (#1486)
        if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

          // Don't re-trigger an onFOO event when we call its FOO() method
          old = elem[ ontype ];

          if ( old ) {
            elem[ ontype ] = null;
          }

          // Prevent re-triggering of the same event, since we already bubbled it above
          jQuery.event.triggered = type;
          elem[ type ]();
          jQuery.event.triggered = undefined;

          if ( old ) {
            elem[ ontype ] = old;
          }
        }
      }
    }

    return event.result;
  },

  dispatch: function( event ) {

    // Make a writable jQuery.Event from the native event object
    event = jQuery.event.fix( event || window.event );

    var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
      delegateCount = handlers.delegateCount,
      args = [].slice.call( arguments, 0 ),
      run_all = !event.exclusive && !event.namespace,
      special = jQuery.event.special[ event.type ] || {},
      handlerQueue = [],
      i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

    // Use the fix-ed jQuery.Event rather than the (read-only) native event
    args[0] = event;
    event.delegateTarget = this;

    // Call the preDispatch hook for the mapped type, and let it bail if desired
    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
      return;
    }

    // Determine handlers that should run if there are delegated events
    // Avoid non-left-click bubbling in Firefox (#3861)
    if ( delegateCount && !(event.button && event.type === "click") ) {

      // Pregenerate a single jQuery object for reuse with .is()
      jqcur = jQuery(this);
      jqcur.context = this.ownerDocument || this;

      for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

        // Don't process events on disabled elements (#6911, #8165)
        if ( cur.disabled !== true ) {
          selMatch = {};
          matches = [];
          jqcur[0] = cur;
          for ( i = 0; i < delegateCount; i++ ) {
            handleObj = handlers[ i ];
            sel = handleObj.selector;

            if ( selMatch[ sel ] === undefined ) {
              selMatch[ sel ] = (
                handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
              );
            }
            if ( selMatch[ sel ] ) {
              matches.push( handleObj );
            }
          }
          if ( matches.length ) {
            handlerQueue.push({ elem: cur, matches: matches });
          }
        }
      }
    }

    // Add the remaining (directly-bound) handlers
    if ( handlers.length > delegateCount ) {
      handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
    }

    // Run delegates first; they may want to stop propagation beneath us
    for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
      matched = handlerQueue[ i ];
      event.currentTarget = matched.elem;

      for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
        handleObj = matched.matches[ j ];

        // Triggered event must either 1) be non-exclusive and have no namespace, or
        // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
        if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

          event.data = handleObj.data;
          event.handleObj = handleObj;

          ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
              .apply( matched.elem, args );

          if ( ret !== undefined ) {
            event.result = ret;
            if ( ret === false ) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }

    // Call the postDispatch hook for the mapped type
    if ( special.postDispatch ) {
      special.postDispatch.call( this, event );
    }

    return event.result;
  },

  // Includes some event props shared by KeyEvent and MouseEvent
  // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
  props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

  fixHooks: {},

  keyHooks: {
    props: "char charCode key keyCode".split(" "),
    filter: function( event, original ) {

      // Add which for key events
      if ( event.which == null ) {
        event.which = original.charCode != null ? original.charCode : original.keyCode;
      }

      return event;
    }
  },

  mouseHooks: {
    props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    filter: function( event, original ) {
      var eventDoc, doc, body,
        button = original.button,
        fromElement = original.fromElement;

      // Calculate pageX/Y if missing and clientX/Y available
      if ( event.pageX == null && original.clientX != null ) {
        eventDoc = event.target.ownerDocument || document;
        doc = eventDoc.documentElement;
        body = eventDoc.body;

        event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
        event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
      }

      // Add relatedTarget, if necessary
      if ( !event.relatedTarget && fromElement ) {
        event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
      }

      // Add which for click: 1 === left; 2 === middle; 3 === right
      // Note: button is not normalized, so don't use it
      if ( !event.which && button !== undefined ) {
        event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
      }

      return event;
    }
  },

  fix: function( event ) {
    if ( event[ jQuery.expando ] ) {
      return event;
    }

    // Create a writable copy of the event object and normalize some properties
    var i, prop,
      originalEvent = event,
      fixHook = jQuery.event.fixHooks[ event.type ] || {},
      copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

    event = jQuery.Event( originalEvent );

    for ( i = copy.length; i; ) {
      prop = copy[ --i ];
      event[ prop ] = originalEvent[ prop ];
    }

    // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
    if ( !event.target ) {
      event.target = originalEvent.srcElement || document;
    }

    // Target should not be a text node (#504, Safari)
    if ( event.target.nodeType === 3 ) {
      event.target = event.target.parentNode;
    }

    // For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
    if ( event.metaKey === undefined ) {
      event.metaKey = event.ctrlKey;
    }

    return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
  },

  special: {
    ready: {
      // Make sure the ready event is setup
      setup: jQuery.bindReady
    },

    load: {
      // Prevent triggered image.load events from bubbling to window.load
      noBubble: true
    },

    focus: {
      delegateType: "focusin"
    },
    blur: {
      delegateType: "focusout"
    },

    beforeunload: {
      setup: function( data, namespaces, eventHandle ) {
        // We only want to do this special case on windows
        if ( jQuery.isWindow( this ) ) {
          this.onbeforeunload = eventHandle;
        }
      },

      teardown: function( namespaces, eventHandle ) {
        if ( this.onbeforeunload === eventHandle ) {
          this.onbeforeunload = null;
        }
      }
    }
  },

  simulate: function( type, elem, event, bubble ) {
    // Piggyback on a donor event to simulate a different one.
    // Fake originalEvent to avoid donor's stopPropagation, but if the
    // simulated event prevents default then we do the same on the donor.
    var e = jQuery.extend(
      new jQuery.Event(),
      event,
      { type: type,
        isSimulated: true,
        originalEvent: {}
      }
    );
    if ( bubble ) {
      jQuery.event.trigger( e, null, elem );
    } else {
      jQuery.event.dispatch.call( elem, e );
    }
    if ( e.isDefaultPrevented() ) {
      event.preventDefault();
    }
  }
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
  function( elem, type, handle ) {
    if ( elem.removeEventListener ) {
      elem.removeEventListener( type, handle, false );
    }
  } :
  function( elem, type, handle ) {
    if ( elem.detachEvent ) {
      elem.detachEvent( "on" + type, handle );
    }
  };

jQuery.Event = function( src, props ) {
  // Allow instantiation without the 'new' keyword
  if ( !(this instanceof jQuery.Event) ) {
    return new jQuery.Event( src, props );
  }

  // Event object
  if ( src && src.type ) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
      src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if ( props ) {
    jQuery.extend( this, props );
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || jQuery.now();

  // Mark it as fixed
  this[ jQuery.expando ] = true;
};

function returnFalse() {
  return false;
}
function returnTrue() {
  return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
  preventDefault: function() {
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }

    // if preventDefault exists run it on the original event
    if ( e.preventDefault ) {
      e.preventDefault();

    // otherwise set the returnValue property of the original event to false (IE)
    } else {
      e.returnValue = false;
    }
  },
  stopPropagation: function() {
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }
    // if stopPropagation exists run it on the original event
    if ( e.stopPropagation ) {
      e.stopPropagation();
    }
    // otherwise set the cancelBubble property of the original event to true (IE)
    e.cancelBubble = true;
  },
  stopImmediatePropagation: function() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, function( orig, fix ) {
  jQuery.event.special[ orig ] = {
    delegateType: fix,
    bindType: fix,

    handle: function( event ) {
      var target = this,
        related = event.relatedTarget,
        handleObj = event.handleObj,
        selector = handleObj.selector,
        ret;

      // For mousenter/leave call the handler if related is outside the target.
      // NB: No relatedTarget if the mouse left/entered the browser window
      if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
        event.type = handleObj.origType;
        ret = handleObj.handler.apply( this, arguments );
        event.type = fix;
      }
      return ret;
    }
  };
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

  jQuery.event.special.submit = {
    setup: function() {
      // Only need this for delegated form submit events
      if ( jQuery.nodeName( this, "form" ) ) {
        return false;
      }

      // Lazy-add a submit handler when a descendant form may potentially be submitted
      jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
        // Node name check avoids a VML-related crash in IE (#9807)
        var elem = e.target,
          form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
        if ( form && !form._submit_attached ) {
          jQuery.event.add( form, "submit._submit", function( event ) {
            event._submit_bubble = true;
          });
          form._submit_attached = true;
        }
      });
      // return undefined since we don't need an event listener
    },

    postDispatch: function( event ) {
      // If form was submitted by the user, bubble the event up the tree
      if ( event._submit_bubble ) {
        delete event._submit_bubble;
        if ( this.parentNode && !event.isTrigger ) {
          jQuery.event.simulate( "submit", this.parentNode, event, true );
        }
      }
    },

    teardown: function() {
      // Only need this for delegated form submit events
      if ( jQuery.nodeName( this, "form" ) ) {
        return false;
      }

      // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
      jQuery.event.remove( this, "._submit" );
    }
  };
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

  jQuery.event.special.change = {

    setup: function() {

      if ( rformElems.test( this.nodeName ) ) {
        // IE doesn't fire change on a check/radio until blur; trigger it on click
        // after a propertychange. Eat the blur-change in special.change.handle.
        // This still fires onchange a second time for check/radio after blur.
        if ( this.type === "checkbox" || this.type === "radio" ) {
          jQuery.event.add( this, "propertychange._change", function( event ) {
            if ( event.originalEvent.propertyName === "checked" ) {
              this._just_changed = true;
            }
          });
          jQuery.event.add( this, "click._change", function( event ) {
            if ( this._just_changed && !event.isTrigger ) {
              this._just_changed = false;
              jQuery.event.simulate( "change", this, event, true );
            }
          });
        }
        return false;
      }
      // Delegated event; lazy-add a change handler on descendant inputs
      jQuery.event.add( this, "beforeactivate._change", function( e ) {
        var elem = e.target;

        if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
          jQuery.event.add( elem, "change._change", function( event ) {
            if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
              jQuery.event.simulate( "change", this.parentNode, event, true );
            }
          });
          elem._change_attached = true;
        }
      });
    },

    handle: function( event ) {
      var elem = event.target;

      // Swallow native change events from checkbox/radio, we already triggered them above
      if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
        return event.handleObj.handler.apply( this, arguments );
      }
    },

    teardown: function() {
      jQuery.event.remove( this, "._change" );

      return rformElems.test( this.nodeName );
    }
  };
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
  jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

    // Attach a single capturing handler while someone wants focusin/focusout
    var attaches = 0,
      handler = function( event ) {
        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
      };

    jQuery.event.special[ fix ] = {
      setup: function() {
        if ( attaches++ === 0 ) {
          document.addEventListener( orig, handler, true );
        }
      },
      teardown: function() {
        if ( --attaches === 0 ) {
          document.removeEventListener( orig, handler, true );
        }
      }
    };
  });
}

jQuery.fn.extend({

  on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
    var origFn, type;

    // Types can be a map of types/handlers
    if ( typeof types === "object" ) {
      // ( types-Object, selector, data )
      if ( typeof selector !== "string" ) { // && selector != null
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }
      for ( type in types ) {
        this.on( type, selector, data, types[ type ], one );
      }
      return this;
    }

    if ( data == null && fn == null ) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if ( fn == null ) {
      if ( typeof selector === "string" ) {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if ( fn === false ) {
      fn = returnFalse;
    } else if ( !fn ) {
      return this;
    }

    if ( one === 1 ) {
      origFn = fn;
      fn = function( event ) {
        // Can use an empty set, since event contains the info
        jQuery().off( event );
        return origFn.apply( this, arguments );
      };
      // Use same guid so caller can remove using origFn
      fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    }
    return this.each( function() {
      jQuery.event.add( this, types, fn, data, selector );
    });
  },
  one: function( types, selector, data, fn ) {
    return this.on( types, selector, data, fn, 1 );
  },
  off: function( types, selector, fn ) {
    if ( types && types.preventDefault && types.handleObj ) {
      // ( event )  dispatched jQuery.Event
      var handleObj = types.handleObj;
      jQuery( types.delegateTarget ).off(
        handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
        handleObj.selector,
        handleObj.handler
      );
      return this;
    }
    if ( typeof types === "object" ) {
      // ( types-object [, selector] )
      for ( var type in types ) {
        this.off( type, selector, types[ type ] );
      }
      return this;
    }
    if ( selector === false || typeof selector === "function" ) {
      // ( types [, fn] )
      fn = selector;
      selector = undefined;
    }
    if ( fn === false ) {
      fn = returnFalse;
    }
    return this.each(function() {
      jQuery.event.remove( this, types, fn, selector );
    });
  },

  bind: function( types, data, fn ) {
    return this.on( types, null, data, fn );
  },
  unbind: function( types, fn ) {
    return this.off( types, null, fn );
  },

  live: function( types, data, fn ) {
    jQuery( this.context ).on( types, this.selector, data, fn );
    return this;
  },
  die: function( types, fn ) {
    jQuery( this.context ).off( types, this.selector || "**", fn );
    return this;
  },

  delegate: function( selector, types, data, fn ) {
    return this.on( types, selector, data, fn );
  },
  undelegate: function( selector, types, fn ) {
    // ( namespace ) or ( selector, types [, fn] )
    return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
  },

  trigger: function( type, data ) {
    return this.each(function() {
      jQuery.event.trigger( type, data, this );
    });
  },
  triggerHandler: function( type, data ) {
    if ( this[0] ) {
      return jQuery.event.trigger( type, data, this[0], true );
    }
  },

  toggle: function( fn ) {
    // Save reference to arguments for access in closure
    var args = arguments,
      guid = fn.guid || jQuery.guid++,
      i = 0,
      toggler = function( event ) {
        // Figure out which function to execute
        var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
        jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

        // Make sure that clicks stop
        event.preventDefault();

        // and execute the function
        return args[ lastToggle ].apply( this, arguments ) || false;
      };

    // link all the functions, so any of them can unbind this click handler
    toggler.guid = guid;
    while ( i < args.length ) {
      args[ i++ ].guid = guid;
    }

    return this.click( toggler );
  },

  hover: function( fnOver, fnOut ) {
    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  }
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
  "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

  // Handle event binding
  jQuery.fn[ name ] = function( data, fn ) {
    if ( fn == null ) {
      fn = data;
      data = null;
    }

    return arguments.length > 0 ?
      this.on( name, null, data, fn ) :
      this.trigger( name );
  };

  if ( jQuery.attrFn ) {
    jQuery.attrFn[ name ] = true;
  }

  if ( rkeyEvent.test( name ) ) {
    jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
  }

  if ( rmouseEvent.test( name ) ) {
    jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
  }
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
  expando = "sizcache" + (Math.random() + '').replace('.', ''),
  done = 0,
  toString = Object.prototype.toString,
  hasDuplicate = false,
  baseHasDuplicate = true,
  rBackslash = /\\/g,
  rReturn = /\r\n/g,
  rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
  baseHasDuplicate = false;
  return 0;
});

var Sizzle = function( selector, context, results, seed ) {
  results = results || [];
  context = context || document;

  var origContext = context;

  if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
    return [];
  }

  if ( !selector || typeof selector !== "string" ) {
    return results;
  }

  var m, set, checkSet, extra, ret, cur, pop, i,
    prune = true,
    contextXML = Sizzle.isXML( context ),
    parts = [],
    soFar = selector;

  // Reset the position of the chunker regexp (start from head)
  do {
    chunker.exec( "" );
    m = chunker.exec( soFar );

    if ( m ) {
      soFar = m[3];

      parts.push( m[1] );

      if ( m[2] ) {
        extra = m[3];
        break;
      }
    }
  } while ( m );

  if ( parts.length > 1 && origPOS.exec( selector ) ) {

    if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
      set = posProcess( parts[0] + parts[1], context, seed );

    } else {
      set = Expr.relative[ parts[0] ] ?
        [ context ] :
        Sizzle( parts.shift(), context );

      while ( parts.length ) {
        selector = parts.shift();

        if ( Expr.relative[ selector ] ) {
          selector += parts.shift();
        }

        set = posProcess( selector, set, seed );
      }
    }

  } else {
    // Take a shortcut and set the context if the root selector is an ID
    // (but not if it'll be faster if the inner selector is an ID)
    if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
        Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

      ret = Sizzle.find( parts.shift(), context, contextXML );
      context = ret.expr ?
        Sizzle.filter( ret.expr, ret.set )[0] :
        ret.set[0];
    }

    if ( context ) {
      ret = seed ?
        { expr: parts.pop(), set: makeArray(seed) } :
        Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

      set = ret.expr ?
        Sizzle.filter( ret.expr, ret.set ) :
        ret.set;

      if ( parts.length > 0 ) {
        checkSet = makeArray( set );

      } else {
        prune = false;
      }

      while ( parts.length ) {
        cur = parts.pop();
        pop = cur;

        if ( !Expr.relative[ cur ] ) {
          cur = "";
        } else {
          pop = parts.pop();
        }

        if ( pop == null ) {
          pop = context;
        }

        Expr.relative[ cur ]( checkSet, pop, contextXML );
      }

    } else {
      checkSet = parts = [];
    }
  }

  if ( !checkSet ) {
    checkSet = set;
  }

  if ( !checkSet ) {
    Sizzle.error( cur || selector );
  }

  if ( toString.call(checkSet) === "[object Array]" ) {
    if ( !prune ) {
      results.push.apply( results, checkSet );

    } else if ( context && context.nodeType === 1 ) {
      for ( i = 0; checkSet[i] != null; i++ ) {
        if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
          results.push( set[i] );
        }
      }

    } else {
      for ( i = 0; checkSet[i] != null; i++ ) {
        if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
          results.push( set[i] );
        }
      }
    }

  } else {
    makeArray( checkSet, results );
  }

  if ( extra ) {
    Sizzle( extra, origContext, results, seed );
    Sizzle.uniqueSort( results );
  }

  return results;
};

Sizzle.uniqueSort = function( results ) {
  if ( sortOrder ) {
    hasDuplicate = baseHasDuplicate;
    results.sort( sortOrder );

    if ( hasDuplicate ) {
      for ( var i = 1; i < results.length; i++ ) {
        if ( results[i] === results[ i - 1 ] ) {
          results.splice( i--, 1 );
        }
      }
    }
  }

  return results;
};

Sizzle.matches = function( expr, set ) {
  return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
  return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
  var set, i, len, match, type, left;

  if ( !expr ) {
    return [];
  }

  for ( i = 0, len = Expr.order.length; i < len; i++ ) {
    type = Expr.order[i];

    if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
      left = match[1];
      match.splice( 1, 1 );

      if ( left.substr( left.length - 1 ) !== "\\" ) {
        match[1] = (match[1] || "").replace( rBackslash, "" );
        set = Expr.find[ type ]( match, context, isXML );

        if ( set != null ) {
          expr = expr.replace( Expr.match[ type ], "" );
          break;
        }
      }
    }
  }

  if ( !set ) {
    set = typeof context.getElementsByTagName !== "undefined" ?
      context.getElementsByTagName( "*" ) :
      [];
  }

  return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
  var match, anyFound,
    type, found, item, filter, left,
    i, pass,
    old = expr,
    result = [],
    curLoop = set,
    isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

  while ( expr && set.length ) {
    for ( type in Expr.filter ) {
      if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
        filter = Expr.filter[ type ];
        left = match[1];

        anyFound = false;

        match.splice(1,1);

        if ( left.substr( left.length - 1 ) === "\\" ) {
          continue;
        }

        if ( curLoop === result ) {
          result = [];
        }

        if ( Expr.preFilter[ type ] ) {
          match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

          if ( !match ) {
            anyFound = found = true;

          } else if ( match === true ) {
            continue;
          }
        }

        if ( match ) {
          for ( i = 0; (item = curLoop[i]) != null; i++ ) {
            if ( item ) {
              found = filter( item, match, i, curLoop );
              pass = not ^ found;

              if ( inplace && found != null ) {
                if ( pass ) {
                  anyFound = true;

                } else {
                  curLoop[i] = false;
                }

              } else if ( pass ) {
                result.push( item );
                anyFound = true;
              }
            }
          }
        }

        if ( found !== undefined ) {
          if ( !inplace ) {
            curLoop = result;
          }

          expr = expr.replace( Expr.match[ type ], "" );

          if ( !anyFound ) {
            return [];
          }

          break;
        }
      }
    }

    // Improper expression
    if ( expr === old ) {
      if ( anyFound == null ) {
        Sizzle.error( expr );

      } else {
        break;
      }
    }

    old = expr;
  }

  return curLoop;
};

Sizzle.error = function( msg ) {
  throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
    nodeType = elem.nodeType,
    ret = "";

  if ( nodeType ) {
    if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
      // Use textContent || innerText for elements
      if ( typeof elem.textContent === 'string' ) {
        return elem.textContent;
      } else if ( typeof elem.innerText === 'string' ) {
        // Replace IE's carriage returns
        return elem.innerText.replace( rReturn, '' );
      } else {
        // Traverse it's children
        for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
          ret += getText( elem );
        }
      }
    } else if ( nodeType === 3 || nodeType === 4 ) {
      return elem.nodeValue;
    }
  } else {

    // If no nodeType, this is expected to be an array
    for ( i = 0; (node = elem[i]); i++ ) {
      // Do not traverse comment nodes
      if ( node.nodeType !== 8 ) {
        ret += getText( node );
      }
    }
  }
  return ret;
};

var Expr = Sizzle.selectors = {
  order: [ "ID", "NAME", "TAG" ],

  match: {
    ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
    CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
    NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
    ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
    TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
    CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
    POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
    PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
  },

  leftMatch: {},

  attrMap: {
    "class": "className",
    "for": "htmlFor"
  },

  attrHandle: {
    href: function( elem ) {
      return elem.getAttribute( "href" );
    },
    type: function( elem ) {
      return elem.getAttribute( "type" );
    }
  },

  relative: {
    "+": function(checkSet, part){
      var isPartStr = typeof part === "string",
        isTag = isPartStr && !rNonWord.test( part ),
        isPartStrNotTag = isPartStr && !isTag;

      if ( isTag ) {
        part = part.toLowerCase();
      }

      for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
        if ( (elem = checkSet[i]) ) {
          while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

          checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
            elem || false :
            elem === part;
        }
      }

      if ( isPartStrNotTag ) {
        Sizzle.filter( part, checkSet, true );
      }
    },

    ">": function( checkSet, part ) {
      var elem,
        isPartStr = typeof part === "string",
        i = 0,
        l = checkSet.length;

      if ( isPartStr && !rNonWord.test( part ) ) {
        part = part.toLowerCase();

        for ( ; i < l; i++ ) {
          elem = checkSet[i];

          if ( elem ) {
            var parent = elem.parentNode;
            checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
          }
        }

      } else {
        for ( ; i < l; i++ ) {
          elem = checkSet[i];

          if ( elem ) {
            checkSet[i] = isPartStr ?
              elem.parentNode :
              elem.parentNode === part;
          }
        }

        if ( isPartStr ) {
          Sizzle.filter( part, checkSet, true );
        }
      }
    },

    "": function(checkSet, part, isXML){
      var nodeCheck,
        doneName = done++,
        checkFn = dirCheck;

      if ( typeof part === "string" && !rNonWord.test( part ) ) {
        part = part.toLowerCase();
        nodeCheck = part;
        checkFn = dirNodeCheck;
      }

      checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
    },

    "~": function( checkSet, part, isXML ) {
      var nodeCheck,
        doneName = done++,
        checkFn = dirCheck;

      if ( typeof part === "string" && !rNonWord.test( part ) ) {
        part = part.toLowerCase();
        nodeCheck = part;
        checkFn = dirNodeCheck;
      }

      checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
    }
  },

  find: {
    ID: function( match, context, isXML ) {
      if ( typeof context.getElementById !== "undefined" && !isXML ) {
        var m = context.getElementById(match[1]);
        // Check parentNode to catch when Blackberry 4.6 returns
        // nodes that are no longer in the document #6963
        return m && m.parentNode ? [m] : [];
      }
    },

    NAME: function( match, context ) {
      if ( typeof context.getElementsByName !== "undefined" ) {
        var ret = [],
          results = context.getElementsByName( match[1] );

        for ( var i = 0, l = results.length; i < l; i++ ) {
          if ( results[i].getAttribute("name") === match[1] ) {
            ret.push( results[i] );
          }
        }

        return ret.length === 0 ? null : ret;
      }
    },

    TAG: function( match, context ) {
      if ( typeof context.getElementsByTagName !== "undefined" ) {
        return context.getElementsByTagName( match[1] );
      }
    }
  },
  preFilter: {
    CLASS: function( match, curLoop, inplace, result, not, isXML ) {
      match = " " + match[1].replace( rBackslash, "" ) + " ";

      if ( isXML ) {
        return match;
      }

      for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
        if ( elem ) {
          if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
            if ( !inplace ) {
              result.push( elem );
            }

          } else if ( inplace ) {
            curLoop[i] = false;
          }
        }
      }

      return false;
    },

    ID: function( match ) {
      return match[1].replace( rBackslash, "" );
    },

    TAG: function( match, curLoop ) {
      return match[1].replace( rBackslash, "" ).toLowerCase();
    },

    CHILD: function( match ) {
      if ( match[1] === "nth" ) {
        if ( !match[2] ) {
          Sizzle.error( match[0] );
        }

        match[2] = match[2].replace(/^\+|\s*/g, '');

        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
        var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
          match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
          !/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

        // calculate the numbers (first)n+(last) including if they are negative
        match[2] = (test[1] + (test[2] || 1)) - 0;
        match[3] = test[3] - 0;
      }
      else if ( match[2] ) {
        Sizzle.error( match[0] );
      }

      // TODO: Move to normal caching system
      match[0] = done++;

      return match;
    },

    ATTR: function( match, curLoop, inplace, result, not, isXML ) {
      var name = match[1] = match[1].replace( rBackslash, "" );

      if ( !isXML && Expr.attrMap[name] ) {
        match[1] = Expr.attrMap[name];
      }

      // Handle if an un-quoted value was used
      match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

      if ( match[2] === "~=" ) {
        match[4] = " " + match[4] + " ";
      }

      return match;
    },

    PSEUDO: function( match, curLoop, inplace, result, not ) {
      if ( match[1] === "not" ) {
        // If we're dealing with a complex expression, or a simple one
        if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
          match[3] = Sizzle(match[3], null, null, curLoop);

        } else {
          var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

          if ( !inplace ) {
            result.push.apply( result, ret );
          }

          return false;
        }

      } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
        return true;
      }

      return match;
    },

    POS: function( match ) {
      match.unshift( true );

      return match;
    }
  },

  filters: {
    enabled: function( elem ) {
      return elem.disabled === false && elem.type !== "hidden";
    },

    disabled: function( elem ) {
      return elem.disabled === true;
    },

    checked: function( elem ) {
      return elem.checked === true;
    },

    selected: function( elem ) {
      // Accessing this property makes selected-by-default
      // options in Safari work properly
      if ( elem.parentNode ) {
        elem.parentNode.selectedIndex;
      }

      return elem.selected === true;
    },

    parent: function( elem ) {
      return !!elem.firstChild;
    },

    empty: function( elem ) {
      return !elem.firstChild;
    },

    has: function( elem, i, match ) {
      return !!Sizzle( match[3], elem ).length;
    },

    header: function( elem ) {
      return (/h\d/i).test( elem.nodeName );
    },

    text: function( elem ) {
      var attr = elem.getAttribute( "type" ), type = elem.type;
      // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
      // use getAttribute instead to test this case
      return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
    },

    radio: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
    },

    checkbox: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
    },

    file: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
    },

    password: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
    },

    submit: function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return (name === "input" || name === "button") && "submit" === elem.type;
    },

    image: function( elem ) {
      return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
    },

    reset: function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return (name === "input" || name === "button") && "reset" === elem.type;
    },

    button: function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && "button" === elem.type || name === "button";
    },

    input: function( elem ) {
      return (/input|select|textarea|button/i).test( elem.nodeName );
    },

    focus: function( elem ) {
      return elem === elem.ownerDocument.activeElement;
    }
  },
  setFilters: {
    first: function( elem, i ) {
      return i === 0;
    },

    last: function( elem, i, match, array ) {
      return i === array.length - 1;
    },

    even: function( elem, i ) {
      return i % 2 === 0;
    },

    odd: function( elem, i ) {
      return i % 2 === 1;
    },

    lt: function( elem, i, match ) {
      return i < match[3] - 0;
    },

    gt: function( elem, i, match ) {
      return i > match[3] - 0;
    },

    nth: function( elem, i, match ) {
      return match[3] - 0 === i;
    },

    eq: function( elem, i, match ) {
      return match[3] - 0 === i;
    }
  },
  filter: {
    PSEUDO: function( elem, match, i, array ) {
      var name = match[1],
        filter = Expr.filters[ name ];

      if ( filter ) {
        return filter( elem, i, match, array );

      } else if ( name === "contains" ) {
        return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

      } else if ( name === "not" ) {
        var not = match[3];

        for ( var j = 0, l = not.length; j < l; j++ ) {
          if ( not[j] === elem ) {
            return false;
          }
        }

        return true;

      } else {
        Sizzle.error( name );
      }
    },

    CHILD: function( elem, match ) {
      var first, last,
        doneName, parent, cache,
        count, diff,
        type = match[1],
        node = elem;

      switch ( type ) {
        case "only":
        case "first":
          while ( (node = node.previousSibling) ) {
            if ( node.nodeType === 1 ) {
              return false;
            }
          }

          if ( type === "first" ) {
            return true;
          }

          node = elem;

          /* falls through */
        case "last":
          while ( (node = node.nextSibling) ) {
            if ( node.nodeType === 1 ) {
              return false;
            }
          }

          return true;

        case "nth":
          first = match[2];
          last = match[3];

          if ( first === 1 && last === 0 ) {
            return true;
          }

          doneName = match[0];
          parent = elem.parentNode;

          if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
            count = 0;

            for ( node = parent.firstChild; node; node = node.nextSibling ) {
              if ( node.nodeType === 1 ) {
                node.nodeIndex = ++count;
              }
            }

            parent[ expando ] = doneName;
          }

          diff = elem.nodeIndex - last;

          if ( first === 0 ) {
            return diff === 0;

          } else {
            return ( diff % first === 0 && diff / first >= 0 );
          }
      }
    },

    ID: function( elem, match ) {
      return elem.nodeType === 1 && elem.getAttribute("id") === match;
    },

    TAG: function( elem, match ) {
      return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
    },

    CLASS: function( elem, match ) {
      return (" " + (elem.className || elem.getAttribute("class")) + " ")
        .indexOf( match ) > -1;
    },

    ATTR: function( elem, match ) {
      var name = match[1],
        result = Sizzle.attr ?
          Sizzle.attr( elem, name ) :
          Expr.attrHandle[ name ] ?
          Expr.attrHandle[ name ]( elem ) :
          elem[ name ] != null ?
            elem[ name ] :
            elem.getAttribute( name ),
        value = result + "",
        type = match[2],
        check = match[4];

      return result == null ?
        type === "!=" :
        !type && Sizzle.attr ?
        result != null :
        type === "=" ?
        value === check :
        type === "*=" ?
        value.indexOf(check) >= 0 :
        type === "~=" ?
        (" " + value + " ").indexOf(check) >= 0 :
        !check ?
        value && result !== false :
        type === "!=" ?
        value !== check :
        type === "^=" ?
        value.indexOf(check) === 0 :
        type === "$=" ?
        value.substr(value.length - check.length) === check :
        type === "|=" ?
        value === check || value.substr(0, check.length + 1) === check + "-" :
        false;
    },

    POS: function( elem, match, i, array ) {
      var name = match[2],
        filter = Expr.setFilters[ name ];

      if ( filter ) {
        return filter( elem, i, match, array );
      }
    }
  }
};

var origPOS = Expr.match.POS,
  fescape = function(all, num){
    return "\\" + (num - 0 + 1);
  };

for ( var type in Expr.match ) {
  Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
  Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}
// Expose origPOS
// "global" as in regardless of relation to brackets/parens
Expr.match.globalPOS = origPOS;

var makeArray = function( array, results ) {
  array = Array.prototype.slice.call( array, 0 );

  if ( results ) {
    results.push.apply( results, array );
    return results;
  }

  return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
  Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
  makeArray = function( array, results ) {
    var i = 0,
      ret = results || [];

    if ( toString.call(array) === "[object Array]" ) {
      Array.prototype.push.apply( ret, array );

    } else {
      if ( typeof array.length === "number" ) {
        for ( var l = array.length; i < l; i++ ) {
          ret.push( array[i] );
        }

      } else {
        for ( ; array[i]; i++ ) {
          ret.push( array[i] );
        }
      }
    }

    return ret;
  };
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
  sortOrder = function( a, b ) {
    if ( a === b ) {
      hasDuplicate = true;
      return 0;
    }

    if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
      return a.compareDocumentPosition ? -1 : 1;
    }

    return a.compareDocumentPosition(b) & 4 ? -1 : 1;
  };

} else {
  sortOrder = function( a, b ) {
    // The nodes are identical, we can exit early
    if ( a === b ) {
      hasDuplicate = true;
      return 0;

    // Fallback to using sourceIndex (in IE) if it's available on both nodes
    } else if ( a.sourceIndex && b.sourceIndex ) {
      return a.sourceIndex - b.sourceIndex;
    }

    var al, bl,
      ap = [],
      bp = [],
      aup = a.parentNode,
      bup = b.parentNode,
      cur = aup;

    // If the nodes are siblings (or identical) we can do a quick check
    if ( aup === bup ) {
      return siblingCheck( a, b );

    // If no parents were found then the nodes are disconnected
    } else if ( !aup ) {
      return -1;

    } else if ( !bup ) {
      return 1;
    }

    // Otherwise they're somewhere else in the tree so we need
    // to build up a full list of the parentNodes for comparison
    while ( cur ) {
      ap.unshift( cur );
      cur = cur.parentNode;
    }

    cur = bup;

    while ( cur ) {
      bp.unshift( cur );
      cur = cur.parentNode;
    }

    al = ap.length;
    bl = bp.length;

    // Start walking down the tree looking for a discrepancy
    for ( var i = 0; i < al && i < bl; i++ ) {
      if ( ap[i] !== bp[i] ) {
        return siblingCheck( ap[i], bp[i] );
      }
    }

    // We ended someplace up the tree so do a sibling check
    return i === al ?
      siblingCheck( a, bp[i], -1 ) :
      siblingCheck( ap[i], b, 1 );
  };

  siblingCheck = function( a, b, ret ) {
    if ( a === b ) {
      return ret;
    }

    var cur = a.nextSibling;

    while ( cur ) {
      if ( cur === b ) {
        return -1;
      }

      cur = cur.nextSibling;
    }

    return 1;
  };
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
  // We're going to inject a fake input element with a specified name
  var form = document.createElement("div"),
    id = "script" + (new Date()).getTime(),
    root = document.documentElement;

  form.innerHTML = "<a name='" + id + "'/>";

  // Inject it into the root element, check its status, and remove it quickly
  root.insertBefore( form, root.firstChild );

  // The workaround has to do additional checks after a getElementById
  // Which slows things down for other browsers (hence the branching)
  if ( document.getElementById( id ) ) {
    Expr.find.ID = function( match, context, isXML ) {
      if ( typeof context.getElementById !== "undefined" && !isXML ) {
        var m = context.getElementById(match[1]);

        return m ?
          m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
            [m] :
            undefined :
          [];
      }
    };

    Expr.filter.ID = function( elem, match ) {
      var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

      return elem.nodeType === 1 && node && node.nodeValue === match;
    };
  }

  root.removeChild( form );

  // release memory in IE
  root = form = null;
})();

(function(){
  // Check to see if the browser returns only elements
  // when doing getElementsByTagName("*")

  // Create a fake element
  var div = document.createElement("div");
  div.appendChild( document.createComment("") );

  // Make sure no comments are found
  if ( div.getElementsByTagName("*").length > 0 ) {
    Expr.find.TAG = function( match, context ) {
      var results = context.getElementsByTagName( match[1] );

      // Filter out possible comments
      if ( match[1] === "*" ) {
        var tmp = [];

        for ( var i = 0; results[i]; i++ ) {
          if ( results[i].nodeType === 1 ) {
            tmp.push( results[i] );
          }
        }

        results = tmp;
      }

      return results;
    };
  }

  // Check to see if an attribute returns normalized href attributes
  div.innerHTML = "<a href='#'></a>";

  if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
      div.firstChild.getAttribute("href") !== "#" ) {

    Expr.attrHandle.href = function( elem ) {
      return elem.getAttribute( "href", 2 );
    };
  }

  // release memory in IE
  div = null;
})();

if ( document.querySelectorAll ) {
  (function(){
    var oldSizzle = Sizzle,
      div = document.createElement("div"),
      id = "__sizzle__";

    div.innerHTML = "<p class='TEST'></p>";

    // Safari can't handle uppercase or unicode characters when
    // in quirks mode.
    if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
      return;
    }

    Sizzle = function( query, context, extra, seed ) {
      context = context || document;

      // Only use querySelectorAll on non-XML documents
      // (ID selectors don't work in non-HTML documents)
      if ( !seed && !Sizzle.isXML(context) ) {
        // See if we find a selector to speed up
        var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

        if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
          // Speed-up: Sizzle("TAG")
          if ( match[1] ) {
            return makeArray( context.getElementsByTagName( query ), extra );

          // Speed-up: Sizzle(".CLASS")
          } else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
            return makeArray( context.getElementsByClassName( match[2] ), extra );
          }
        }

        if ( context.nodeType === 9 ) {
          // Speed-up: Sizzle("body")
          // The body element only exists once, optimize finding it
          if ( query === "body" && context.body ) {
            return makeArray( [ context.body ], extra );

          // Speed-up: Sizzle("#ID")
          } else if ( match && match[3] ) {
            var elem = context.getElementById( match[3] );

            // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963
            if ( elem && elem.parentNode ) {
              // Handle the case where IE and Opera return items
              // by name instead of ID
              if ( elem.id === match[3] ) {
                return makeArray( [ elem ], extra );
              }

            } else {
              return makeArray( [], extra );
            }
          }

          try {
            return makeArray( context.querySelectorAll(query), extra );
          } catch(qsaError) {}

        // qSA works strangely on Element-rooted queries
        // We can work around this by specifying an extra ID on the root
        // and working up from there (Thanks to Andrew Dupont for the technique)
        // IE 8 doesn't work on object elements
        } else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
          var oldContext = context,
            old = context.getAttribute( "id" ),
            nid = old || id,
            hasParent = context.parentNode,
            relativeHierarchySelector = /^\s*[+~]/.test( query );

          if ( !old ) {
            context.setAttribute( "id", nid );
          } else {
            nid = nid.replace( /'/g, "\\$&" );
          }
          if ( relativeHierarchySelector && hasParent ) {
            context = context.parentNode;
          }

          try {
            if ( !relativeHierarchySelector || hasParent ) {
              return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
            }

          } catch(pseudoError) {
          } finally {
            if ( !old ) {
              oldContext.removeAttribute( "id" );
            }
          }
        }
      }

      return oldSizzle(query, context, extra, seed);
    };

    for ( var prop in oldSizzle ) {
      Sizzle[ prop ] = oldSizzle[ prop ];
    }

    // release memory in IE
    div = null;
  })();
}

(function(){
  var html = document.documentElement,
    matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

  if ( matches ) {
    // Check to see if it's possible to do matchesSelector
    // on a disconnected node (IE 9 fails this)
    var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
      pseudoWorks = false;

    try {
      // This should fail with an exception
      // Gecko does not error, returns false instead
      matches.call( document.documentElement, "[test!='']:sizzle" );

    } catch( pseudoError ) {
      pseudoWorks = true;
    }

    Sizzle.matchesSelector = function( node, expr ) {
      // Make sure that attribute selectors are quoted
      expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

      if ( !Sizzle.isXML( node ) ) {
        try {
          if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
            var ret = matches.call( node, expr );

            // IE 9's matchesSelector returns false on disconnected nodes
            if ( ret || !disconnectedMatch ||
                // As well, disconnected nodes are said to be in a document
                // fragment in IE 9, so check for that
                node.document && node.document.nodeType !== 11 ) {
              return ret;
            }
          }
        } catch(e) {}
      }

      return Sizzle(expr, null, null, [node]).length > 0;
    };
  }
})();

(function(){
  var div = document.createElement("div");

  div.innerHTML = "<div class='test e'></div><div class='test'></div>";

  // Opera can't find a second classname (in 9.6)
  // Also, make sure that getElementsByClassName actually exists
  if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
    return;
  }

  // Safari caches class attributes, doesn't catch changes (in 3.2)
  div.lastChild.className = "e";

  if ( div.getElementsByClassName("e").length === 1 ) {
    return;
  }

  Expr.order.splice(1, 0, "CLASS");
  Expr.find.CLASS = function( match, context, isXML ) {
    if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
      return context.getElementsByClassName(match[1]);
    }
  };

  // release memory in IE
  div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
  for ( var i = 0, l = checkSet.length; i < l; i++ ) {
    var elem = checkSet[i];

    if ( elem ) {
      var match = false;

      elem = elem[dir];

      while ( elem ) {
        if ( elem[ expando ] === doneName ) {
          match = checkSet[elem.sizset];
          break;
        }

        if ( elem.nodeType === 1 && !isXML ){
          elem[ expando ] = doneName;
          elem.sizset = i;
        }

        if ( elem.nodeName.toLowerCase() === cur ) {
          match = elem;
          break;
        }

        elem = elem[dir];
      }

      checkSet[i] = match;
    }
  }
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
  for ( var i = 0, l = checkSet.length; i < l; i++ ) {
    var elem = checkSet[i];

    if ( elem ) {
      var match = false;

      elem = elem[dir];

      while ( elem ) {
        if ( elem[ expando ] === doneName ) {
          match = checkSet[elem.sizset];
          break;
        }

        if ( elem.nodeType === 1 ) {
          if ( !isXML ) {
            elem[ expando ] = doneName;
            elem.sizset = i;
          }

          if ( typeof cur !== "string" ) {
            if ( elem === cur ) {
              match = true;
              break;
            }

          } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
            match = elem;
            break;
          }
        }

        elem = elem[dir];
      }

      checkSet[i] = match;
    }
  }
}

if ( document.documentElement.contains ) {
  Sizzle.contains = function( a, b ) {
    return a !== b && (a.contains ? a.contains(b) : true);
  };

} else if ( document.documentElement.compareDocumentPosition ) {
  Sizzle.contains = function( a, b ) {
    return !!(a.compareDocumentPosition(b) & 16);
  };

} else {
  Sizzle.contains = function() {
    return false;
  };
}

Sizzle.isXML = function( elem ) {
  // documentElement is verified for cases where it doesn't yet exist
  // (such as loading iframes in IE - #4833)
  var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

  return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
  var match,
    tmpSet = [],
    later = "",
    root = context.nodeType ? [context] : context;

  // Position selectors must be done after the filter
  // And so must :not(positional) so we move all PSEUDOs to the end
  while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
    later += match[0];
    selector = selector.replace( Expr.match.PSEUDO, "" );
  }

  selector = Expr.relative[selector] ? selector + "*" : selector;

  for ( var i = 0, l = root.length; i < l; i++ ) {
    Sizzle( selector, root[i], tmpSet, seed );
  }

  return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
  rparentsprev = /^(?:parents|prevUntil|prevAll)/,
  // Note: This RegExp should be improved, or likely pulled from Sizzle
  rmultiselector = /,/,
  isSimple = /^.[^:#\[\.,]*$/,
  slice = Array.prototype.slice,
  POS = jQuery.expr.match.globalPOS,
  // methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };

jQuery.fn.extend({
  find: function( selector ) {
    var self = this,
      i, l;

    if ( typeof selector !== "string" ) {
      return jQuery( selector ).filter(function() {
        for ( i = 0, l = self.length; i < l; i++ ) {
          if ( jQuery.contains( self[ i ], this ) ) {
            return true;
          }
        }
      });
    }

    var ret = this.pushStack( "", "find", selector ),
      length, n, r;

    for ( i = 0, l = this.length; i < l; i++ ) {
      length = ret.length;
      jQuery.find( selector, this[i], ret );

      if ( i > 0 ) {
        // Make sure that the results are unique
        for ( n = length; n < ret.length; n++ ) {
          for ( r = 0; r < length; r++ ) {
            if ( ret[r] === ret[n] ) {
              ret.splice(n--, 1);
              break;
            }
          }
        }
      }
    }

    return ret;
  },

  has: function( target ) {
    var targets = jQuery( target );
    return this.filter(function() {
      for ( var i = 0, l = targets.length; i < l; i++ ) {
        if ( jQuery.contains( this, targets[i] ) ) {
          return true;
        }
      }
    });
  },

  not: function( selector ) {
    return this.pushStack( winnow(this, selector, false), "not", selector);
  },

  filter: function( selector ) {
    return this.pushStack( winnow(this, selector, true), "filter", selector );
  },

  is: function( selector ) {
    return !!selector && (
      typeof selector === "string" ?
        // If this is a positional selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        POS.test( selector ) ?
          jQuery( selector, this.context ).index( this[0] ) >= 0 :
          jQuery.filter( selector, this ).length > 0 :
        this.filter( selector ).length > 0 );
  },

  closest: function( selectors, context ) {
    var ret = [], i, l, cur = this[0];

    // Array (deprecated as of jQuery 1.7)
    if ( jQuery.isArray( selectors ) ) {
      var level = 1;

      while ( cur && cur.ownerDocument && cur !== context ) {
        for ( i = 0; i < selectors.length; i++ ) {

          if ( jQuery( cur ).is( selectors[ i ] ) ) {
            ret.push({ selector: selectors[ i ], elem: cur, level: level });
          }
        }

        cur = cur.parentNode;
        level++;
      }

      return ret;
    }

    // String
    var pos = POS.test( selectors ) || typeof selectors !== "string" ?
        jQuery( selectors, context || this.context ) :
        0;

    for ( i = 0, l = this.length; i < l; i++ ) {
      cur = this[i];

      while ( cur ) {
        if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
          ret.push( cur );
          break;

        } else {
          cur = cur.parentNode;
          if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
            break;
          }
        }
      }
    }

    ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

    return this.pushStack( ret, "closest", selectors );
  },

  // Determine the position of an element within
  // the matched set of elements
  index: function( elem ) {

    // No argument, return index in parent
    if ( !elem ) {
      return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
    }

    // index in selector
    if ( typeof elem === "string" ) {
      return jQuery.inArray( this[0], jQuery( elem ) );
    }

    // Locate the position of the desired element
    return jQuery.inArray(
      // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem, this );
  },

  add: function( selector, context ) {
    var set = typeof selector === "string" ?
        jQuery( selector, context ) :
        jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
      all = jQuery.merge( this.get(), set );

    return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
      all :
      jQuery.unique( all ) );
  },

  andSelf: function() {
    return this.add( this.prevObject );
  }
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
  return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
  parent: function( elem ) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },
  parents: function( elem ) {
    return jQuery.dir( elem, "parentNode" );
  },
  parentsUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "parentNode", until );
  },
  next: function( elem ) {
    return jQuery.nth( elem, 2, "nextSibling" );
  },
  prev: function( elem ) {
    return jQuery.nth( elem, 2, "previousSibling" );
  },
  nextAll: function( elem ) {
    return jQuery.dir( elem, "nextSibling" );
  },
  prevAll: function( elem ) {
    return jQuery.dir( elem, "previousSibling" );
  },
  nextUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "nextSibling", until );
  },
  prevUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "previousSibling", until );
  },
  siblings: function( elem ) {
    return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
  },
  children: function( elem ) {
    return jQuery.sibling( elem.firstChild );
  },
  contents: function( elem ) {
    return jQuery.nodeName( elem, "iframe" ) ?
      elem.contentDocument || elem.contentWindow.document :
      jQuery.makeArray( elem.childNodes );
  }
}, function( name, fn ) {
  jQuery.fn[ name ] = function( until, selector ) {
    var ret = jQuery.map( this, fn, until );

    if ( !runtil.test( name ) ) {
      selector = until;
    }

    if ( selector && typeof selector === "string" ) {
      ret = jQuery.filter( selector, ret );
    }

    ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

    if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
      ret = ret.reverse();
    }

    return this.pushStack( ret, name, slice.call( arguments ).join(",") );
  };
});

jQuery.extend({
  filter: function( expr, elems, not ) {
    if ( not ) {
      expr = ":not(" + expr + ")";
    }

    return elems.length === 1 ?
      jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
      jQuery.find.matches(expr, elems);
  },

  dir: function( elem, dir, until ) {
    var matched = [],
      cur = elem[ dir ];

    while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
      if ( cur.nodeType === 1 ) {
        matched.push( cur );
      }
      cur = cur[dir];
    }
    return matched;
  },

  nth: function( cur, result, dir, elem ) {
    result = result || 1;
    var num = 0;

    for ( ; cur; cur = cur[dir] ) {
      if ( cur.nodeType === 1 && ++num === result ) {
        break;
      }
    }

    return cur;
  },

  sibling: function( n, elem ) {
    var r = [];

    for ( ; n; n = n.nextSibling ) {
      if ( n.nodeType === 1 && n !== elem ) {
        r.push( n );
      }
    }

    return r;
  }
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

  // Can't pass null or undefined to indexOf in Firefox 4
  // Set to 0 to skip string check
  qualifier = qualifier || 0;

  if ( jQuery.isFunction( qualifier ) ) {
    return jQuery.grep(elements, function( elem, i ) {
      var retVal = !!qualifier.call( elem, i, elem );
      return retVal === keep;
    });

  } else if ( qualifier.nodeType ) {
    return jQuery.grep(elements, function( elem, i ) {
      return ( elem === qualifier ) === keep;
    });

  } else if ( typeof qualifier === "string" ) {
    var filtered = jQuery.grep(elements, function( elem ) {
      return elem.nodeType === 1;
    });

    if ( isSimple.test( qualifier ) ) {
      return jQuery.filter(qualifier, filtered, !keep);
    } else {
      qualifier = jQuery.filter( qualifier, filtered );
    }
  }

  return jQuery.grep(elements, function( elem, i ) {
    return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
  });
}




function createSafeFragment( document ) {
  var list = nodeNames.split( "|" ),
  safeFrag = document.createDocumentFragment();

  if ( safeFrag.createElement ) {
    while ( list.length ) {
      safeFrag.createElement(
        list.pop()
      );
    }
  }
  return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
    "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
  rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
  rleadingWhitespace = /^\s+/,
  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
  rtagName = /<([\w:]+)/,
  rtbody = /<tbody/i,
  rhtml = /<|&#?\w+;/,
  rnoInnerhtml = /<(?:script|style)/i,
  rnocache = /<(?:script|object|embed|option|style)/i,
  rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
  // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  rscriptType = /\/(java|ecma)script/i,
  rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
  wrapMap = {
    option: [ 1, "<select multiple='multiple'>", "</select>" ],
    legend: [ 1, "<fieldset>", "</fieldset>" ],
    thead: [ 1, "<table>", "</table>" ],
    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
    col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
    area: [ 1, "<map>", "</map>" ],
    _default: [ 0, "", "" ]
  },
  safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
  wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
  text: function( value ) {
    return jQuery.access( this, function( value ) {
      return value === undefined ?
        jQuery.text( this ) :
        this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
    }, null, value, arguments.length );
  },

  wrapAll: function( html ) {
    if ( jQuery.isFunction( html ) ) {
      return this.each(function(i) {
        jQuery(this).wrapAll( html.call(this, i) );
      });
    }

    if ( this[0] ) {
      // The elements to wrap the target around
      var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

      if ( this[0].parentNode ) {
        wrap.insertBefore( this[0] );
      }

      wrap.map(function() {
        var elem = this;

        while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
          elem = elem.firstChild;
        }

        return elem;
      }).append( this );
    }

    return this;
  },

  wrapInner: function( html ) {
    if ( jQuery.isFunction( html ) ) {
      return this.each(function(i) {
        jQuery(this).wrapInner( html.call(this, i) );
      });
    }

    return this.each(function() {
      var self = jQuery( this ),
        contents = self.contents();

      if ( contents.length ) {
        contents.wrapAll( html );

      } else {
        self.append( html );
      }
    });
  },

  wrap: function( html ) {
    var isFunction = jQuery.isFunction( html );

    return this.each(function(i) {
      jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
    });
  },

  unwrap: function() {
    return this.parent().each(function() {
      if ( !jQuery.nodeName( this, "body" ) ) {
        jQuery( this ).replaceWith( this.childNodes );
      }
    }).end();
  },

  append: function() {
    return this.domManip(arguments, true, function( elem ) {
      if ( this.nodeType === 1 ) {
        this.appendChild( elem );
      }
    });
  },

  prepend: function() {
    return this.domManip(arguments, true, function( elem ) {
      if ( this.nodeType === 1 ) {
        this.insertBefore( elem, this.firstChild );
      }
    });
  },

  before: function() {
    if ( this[0] && this[0].parentNode ) {
      return this.domManip(arguments, false, function( elem ) {
        this.parentNode.insertBefore( elem, this );
      });
    } else if ( arguments.length ) {
      var set = jQuery.clean( arguments );
      set.push.apply( set, this.toArray() );
      return this.pushStack( set, "before", arguments );
    }
  },

  after: function() {
    if ( this[0] && this[0].parentNode ) {
      return this.domManip(arguments, false, function( elem ) {
        this.parentNode.insertBefore( elem, this.nextSibling );
      });
    } else if ( arguments.length ) {
      var set = this.pushStack( this, "after", arguments );
      set.push.apply( set, jQuery.clean(arguments) );
      return set;
    }
  },

  // keepData is for internal use only--do not document
  remove: function( selector, keepData ) {
    for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
      if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
        if ( !keepData && elem.nodeType === 1 ) {
          jQuery.cleanData( elem.getElementsByTagName("*") );
          jQuery.cleanData( [ elem ] );
        }

        if ( elem.parentNode ) {
          elem.parentNode.removeChild( elem );
        }
      }
    }

    return this;
  },

  empty: function() {
    for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
      // Remove element nodes and prevent memory leaks
      if ( elem.nodeType === 1 ) {
        jQuery.cleanData( elem.getElementsByTagName("*") );
      }

      // Remove any remaining nodes
      while ( elem.firstChild ) {
        elem.removeChild( elem.firstChild );
      }
    }

    return this;
  },

  clone: function( dataAndEvents, deepDataAndEvents ) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

    return this.map( function () {
      return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    });
  },

  html: function( value ) {
    return jQuery.access( this, function( value ) {
      var elem = this[0] || {},
        i = 0,
        l = this.length;

      if ( value === undefined ) {
        return elem.nodeType === 1 ?
          elem.innerHTML.replace( rinlinejQuery, "" ) :
          null;
      }


      if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
        ( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
        !wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

        value = value.replace( rxhtmlTag, "<$1></$2>" );

        try {
          for (; i < l; i++ ) {
            // Remove element nodes and prevent memory leaks
            elem = this[i] || {};
            if ( elem.nodeType === 1 ) {
              jQuery.cleanData( elem.getElementsByTagName( "*" ) );
              elem.innerHTML = value;
            }
          }

          elem = 0;

        // If using innerHTML throws an exception, use the fallback method
        } catch(e) {}
      }

      if ( elem ) {
        this.empty().append( value );
      }
    }, null, value, arguments.length );
  },

  replaceWith: function( value ) {
    if ( this[0] && this[0].parentNode ) {
      // Make sure that the elements are removed from the DOM before they are inserted
      // this can help fix replacing a parent with child elements
      if ( jQuery.isFunction( value ) ) {
        return this.each(function(i) {
          var self = jQuery(this), old = self.html();
          self.replaceWith( value.call( this, i, old ) );
        });
      }

      if ( typeof value !== "string" ) {
        value = jQuery( value ).detach();
      }

      return this.each(function() {
        var next = this.nextSibling,
          parent = this.parentNode;

        jQuery( this ).remove();

        if ( next ) {
          jQuery(next).before( value );
        } else {
          jQuery(parent).append( value );
        }
      });
    } else {
      return this.length ?
        this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
        this;
    }
  },

  detach: function( selector ) {
    return this.remove( selector, true );
  },

  domManip: function( args, table, callback ) {
    var results, first, fragment, parent,
      value = args[0],
      scripts = [];

    // We can't cloneNode fragments that contain checked, in WebKit
    if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
      return this.each(function() {
        jQuery(this).domManip( args, table, callback, true );
      });
    }

    if ( jQuery.isFunction(value) ) {
      return this.each(function(i) {
        var self = jQuery(this);
        args[0] = value.call(this, i, table ? self.html() : undefined);
        self.domManip( args, table, callback );
      });
    }

    if ( this[0] ) {
      parent = value && value.parentNode;

      // If we're in a fragment, just use that instead of building a new one
      if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
        results = { fragment: parent };

      } else {
        results = jQuery.buildFragment( args, this, scripts );
      }

      fragment = results.fragment;

      if ( fragment.childNodes.length === 1 ) {
        first = fragment = fragment.firstChild;
      } else {
        first = fragment.firstChild;
      }

      if ( first ) {
        table = table && jQuery.nodeName( first, "tr" );

        for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
          callback.call(
            table ?
              root(this[i], first) :
              this[i],
            // Make sure that we do not leak memory by inadvertently discarding
            // the original fragment (which might have attached data) instead of
            // using it; in addition, use the original fragment object for the last
            // item instead of first because it can end up being emptied incorrectly
            // in certain situations (Bug #8070).
            // Fragments from the fragment cache must always be cloned and never used
            // in place.
            results.cacheable || ( l > 1 && i < lastIndex ) ?
              jQuery.clone( fragment, true, true ) :
              fragment
          );
        }
      }

      if ( scripts.length ) {
        jQuery.each( scripts, function( i, elem ) {
          if ( elem.src ) {
            jQuery.ajax({
              type: "GET",
              global: false,
              url: elem.src,
              async: false,
              dataType: "script"
            });
          } else {
            jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
          }

          if ( elem.parentNode ) {
            elem.parentNode.removeChild( elem );
          }
        });
      }
    }

    return this;
  }
});

function root( elem, cur ) {
  return jQuery.nodeName(elem, "table") ?
    (elem.getElementsByTagName("tbody")[0] ||
    elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
    elem;
}

function cloneCopyEvent( src, dest ) {

  if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
    return;
  }

  var type, i, l,
    oldData = jQuery._data( src ),
    curData = jQuery._data( dest, oldData ),
    events = oldData.events;

  if ( events ) {
    delete curData.handle;
    curData.events = {};

    for ( type in events ) {
      for ( i = 0, l = events[ type ].length; i < l; i++ ) {
        jQuery.event.add( dest, type, events[ type ][ i ] );
      }
    }
  }

  // make the cloned public data object a copy from the original
  if ( curData.data ) {
    curData.data = jQuery.extend( {}, curData.data );
  }
}

function cloneFixAttributes( src, dest ) {
  var nodeName;

  // We do not need to do anything for non-Elements
  if ( dest.nodeType !== 1 ) {
    return;
  }

  // clearAttributes removes the attributes, which we don't want,
  // but also removes the attachEvent events, which we *do* want
  if ( dest.clearAttributes ) {
    dest.clearAttributes();
  }

  // mergeAttributes, in contrast, only merges back on the
  // original attributes, not the events
  if ( dest.mergeAttributes ) {
    dest.mergeAttributes( src );
  }

  nodeName = dest.nodeName.toLowerCase();

  // IE6-8 fail to clone children inside object elements that use
  // the proprietary classid attribute value (rather than the type
  // attribute) to identify the type of content to display
  if ( nodeName === "object" ) {
    dest.outerHTML = src.outerHTML;

  } else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
    // IE6-8 fails to persist the checked state of a cloned checkbox
    // or radio button. Worse, IE6-7 fail to give the cloned element
    // a checked appearance if the defaultChecked value isn't also set
    if ( src.checked ) {
      dest.defaultChecked = dest.checked = src.checked;
    }

    // IE6-7 get confused and end up setting the value of a cloned
    // checkbox/radio button to an empty string instead of "on"
    if ( dest.value !== src.value ) {
      dest.value = src.value;
    }

  // IE6-8 fails to return the selected option to the default selected
  // state when cloning options
  } else if ( nodeName === "option" ) {
    dest.selected = src.defaultSelected;

  // IE6-8 fails to set the defaultValue to the correct value when
  // cloning other types of input fields
  } else if ( nodeName === "input" || nodeName === "textarea" ) {
    dest.defaultValue = src.defaultValue;

  // IE blanks contents when cloning scripts
  } else if ( nodeName === "script" && dest.text !== src.text ) {
    dest.text = src.text;
  }

  // Event data gets referenced instead of copied if the expando
  // gets copied too
  dest.removeAttribute( jQuery.expando );

  // Clear flags for bubbling special change/submit events, they must
  // be reattached when the newly cloned events are first activated
  dest.removeAttribute( "_submit_attached" );
  dest.removeAttribute( "_change_attached" );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
  var fragment, cacheable, cacheresults, doc,
  first = args[ 0 ];

  // nodes may contain either an explicit document object,
  // a jQuery collection or context object.
  // If nodes[0] contains a valid object to assign to doc
  if ( nodes && nodes[0] ) {
    doc = nodes[0].ownerDocument || nodes[0];
  }

  // Ensure that an attr object doesn't incorrectly stand in as a document object
  // Chrome and Firefox seem to allow this to occur and will throw exception
  // Fixes #8950
  if ( !doc.createDocumentFragment ) {
    doc = document;
  }

  // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
  // Cloning options loses the selected state, so don't cache them
  // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
  // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
  // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
  if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
    first.charAt(0) === "<" && !rnocache.test( first ) &&
    (jQuery.support.checkClone || !rchecked.test( first )) &&
    (jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

    cacheable = true;

    cacheresults = jQuery.fragments[ first ];
    if ( cacheresults && cacheresults !== 1 ) {
      fragment = cacheresults;
    }
  }

  if ( !fragment ) {
    fragment = doc.createDocumentFragment();
    jQuery.clean( args, doc, fragment, scripts );
  }

  if ( cacheable ) {
    jQuery.fragments[ first ] = cacheresults ? fragment : 1;
  }

  return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
  appendTo: "append",
  prependTo: "prepend",
  insertBefore: "before",
  insertAfter: "after",
  replaceAll: "replaceWith"
}, function( name, original ) {
  jQuery.fn[ name ] = function( selector ) {
    var ret = [],
      insert = jQuery( selector ),
      parent = this.length === 1 && this[0].parentNode;

    if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
      insert[ original ]( this[0] );
      return this;

    } else {
      for ( var i = 0, l = insert.length; i < l; i++ ) {
        var elems = ( i > 0 ? this.clone(true) : this ).get();
        jQuery( insert[i] )[ original ]( elems );
        ret = ret.concat( elems );
      }

      return this.pushStack( ret, name, insert.selector );
    }
  };
});

function getAll( elem ) {
  if ( typeof elem.getElementsByTagName !== "undefined" ) {
    return elem.getElementsByTagName( "*" );

  } else if ( typeof elem.querySelectorAll !== "undefined" ) {
    return elem.querySelectorAll( "*" );

  } else {
    return [];
  }
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
  if ( elem.type === "checkbox" || elem.type === "radio" ) {
    elem.defaultChecked = elem.checked;
  }
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
  var nodeName = ( elem.nodeName || "" ).toLowerCase();
  if ( nodeName === "input" ) {
    fixDefaultChecked( elem );
  // Skip scripts, get other children
  } else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
    jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
  }
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
  var div = document.createElement( "div" );
  safeFragment.appendChild( div );

  div.innerHTML = elem.outerHTML;
  return div.firstChild;
}

jQuery.extend({
  clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    var srcElements,
      destElements,
      i,
      // IE<=8 does not properly clone detached, unknown element nodes
      clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
        elem.cloneNode( true ) :
        shimCloneNode( elem );

    if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
        (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
      // IE copies events bound via attachEvent when using cloneNode.
      // Calling detachEvent on the clone will also remove the events
      // from the original. In order to get around this, we use some
      // proprietary methods to clear the events. Thanks to MooTools
      // guys for this hotness.

      cloneFixAttributes( elem, clone );

      // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
      srcElements = getAll( elem );
      destElements = getAll( clone );

      // Weird iteration because IE will replace the length property
      // with an element if you are cloning the body and one of the
      // elements on the page has a name or id of "length"
      for ( i = 0; srcElements[i]; ++i ) {
        // Ensure that the destination node is not null; Fixes #9587
        if ( destElements[i] ) {
          cloneFixAttributes( srcElements[i], destElements[i] );
        }
      }
    }

    // Copy the events from the original to the clone
    if ( dataAndEvents ) {
      cloneCopyEvent( elem, clone );

      if ( deepDataAndEvents ) {
        srcElements = getAll( elem );
        destElements = getAll( clone );

        for ( i = 0; srcElements[i]; ++i ) {
          cloneCopyEvent( srcElements[i], destElements[i] );
        }
      }
    }

    srcElements = destElements = null;

    // Return the cloned set
    return clone;
  },

  clean: function( elems, context, fragment, scripts ) {
    var checkScriptType, script, j,
        ret = [];

    context = context || document;

    // !context.createElement fails in IE with an error but returns typeof 'object'
    if ( typeof context.createElement === "undefined" ) {
      context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
    }

    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
      if ( typeof elem === "number" ) {
        elem += "";
      }

      if ( !elem ) {
        continue;
      }

      // Convert html string into DOM nodes
      if ( typeof elem === "string" ) {
        if ( !rhtml.test( elem ) ) {
          elem = context.createTextNode( elem );
        } else {
          // Fix "XHTML"-style tags in all browsers
          elem = elem.replace(rxhtmlTag, "<$1></$2>");

          // Trim whitespace, otherwise indexOf won't work as expected
          var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
            wrap = wrapMap[ tag ] || wrapMap._default,
            depth = wrap[0],
            div = context.createElement("div"),
            safeChildNodes = safeFragment.childNodes,
            remove;

          // Append wrapper element to unknown element safe doc fragment
          if ( context === document ) {
            // Use the fragment we've already created for this document
            safeFragment.appendChild( div );
          } else {
            // Use a fragment created with the owner document
            createSafeFragment( context ).appendChild( div );
          }

          // Go to html and back, then peel off extra wrappers
          div.innerHTML = wrap[1] + elem + wrap[2];

          // Move to the right depth
          while ( depth-- ) {
            div = div.lastChild;
          }

          // Remove IE's autoinserted <tbody> from table fragments
          if ( !jQuery.support.tbody ) {

            // String was a <table>, *may* have spurious <tbody>
            var hasBody = rtbody.test(elem),
              tbody = tag === "table" && !hasBody ?
                div.firstChild && div.firstChild.childNodes :

                // String was a bare <thead> or <tfoot>
                wrap[1] === "<table>" && !hasBody ?
                  div.childNodes :
                  [];

            for ( j = tbody.length - 1; j >= 0 ; --j ) {
              if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
                tbody[ j ].parentNode.removeChild( tbody[ j ] );
              }
            }
          }

          // IE completely kills leading whitespace when innerHTML is used
          if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
            div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
          }

          elem = div.childNodes;

          // Clear elements from DocumentFragment (safeFragment or otherwise)
          // to avoid hoarding elements. Fixes #11356
          if ( div ) {
            div.parentNode.removeChild( div );

            // Guard against -1 index exceptions in FF3.6
            if ( safeChildNodes.length > 0 ) {
              remove = safeChildNodes[ safeChildNodes.length - 1 ];

              if ( remove && remove.parentNode ) {
                remove.parentNode.removeChild( remove );
              }
            }
          }
        }
      }

      // Resets defaultChecked for any radios and checkboxes
      // about to be appended to the DOM in IE 6/7 (#8060)
      var len;
      if ( !jQuery.support.appendChecked ) {
        if ( elem[0] && typeof (len = elem.length) === "number" ) {
          for ( j = 0; j < len; j++ ) {
            findInputs( elem[j] );
          }
        } else {
          findInputs( elem );
        }
      }

      if ( elem.nodeType ) {
        ret.push( elem );
      } else {
        ret = jQuery.merge( ret, elem );
      }
    }

    if ( fragment ) {
      checkScriptType = function( elem ) {
        return !elem.type || rscriptType.test( elem.type );
      };
      for ( i = 0; ret[i]; i++ ) {
        script = ret[i];
        if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
          scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );

        } else {
          if ( script.nodeType === 1 ) {
            var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );

            ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
          }
          fragment.appendChild( script );
        }
      }
    }

    return ret;
  },

  cleanData: function( elems ) {
    var data, id,
      cache = jQuery.cache,
      special = jQuery.event.special,
      deleteExpando = jQuery.support.deleteExpando;

    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
      if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
        continue;
      }

      id = elem[ jQuery.expando ];

      if ( id ) {
        data = cache[ id ];

        if ( data && data.events ) {
          for ( var type in data.events ) {
            if ( special[ type ] ) {
              jQuery.event.remove( elem, type );

            // This is a shortcut to avoid jQuery.event.remove's overhead
            } else {
              jQuery.removeEvent( elem, type, data.handle );
            }
          }

          // Null the DOM reference to avoid IE6/7/8 leak (#7054)
          if ( data.handle ) {
            data.handle.elem = null;
          }
        }

        if ( deleteExpando ) {
          delete elem[ jQuery.expando ];

        } else if ( elem.removeAttribute ) {
          elem.removeAttribute( jQuery.expando );
        }

        delete cache[ id ];
      }
    }
  }
});




var ralpha = /alpha\([^)]*\)/i,
  ropacity = /opacity=([^)]*)/,
  // fixed for IE9, see #8346
  rupper = /([A-Z]|^ms)/g,
  rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
  rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
  rrelNum = /^([\-+])=([\-+.\de]+)/,
  rmargin = /^margin/,

  cssShow = { position: "absolute", visibility: "hidden", display: "block" },

  // order is important!
  cssExpand = [ "Top", "Right", "Bottom", "Left" ],

  curCSS,

  getComputedStyle,
  currentStyle;

jQuery.fn.css = function( name, value ) {
  return jQuery.access( this, function( elem, name, value ) {
    return value !== undefined ?
      jQuery.style( elem, name, value ) :
      jQuery.css( elem, name );
  }, name, value, arguments.length > 1 );
};

jQuery.extend({
  // Add in style property hooks for overriding the default
  // behavior of getting and setting a style property
  cssHooks: {
    opacity: {
      get: function( elem, computed ) {
        if ( computed ) {
          // We should always get a number back from opacity
          var ret = curCSS( elem, "opacity" );
          return ret === "" ? "1" : ret;

        } else {
          return elem.style.opacity;
        }
      }
    }
  },

  // Exclude the following css properties to add px
  cssNumber: {
    "fillOpacity": true,
    "fontWeight": true,
    "lineHeight": true,
    "opacity": true,
    "orphans": true,
    "widows": true,
    "zIndex": true,
    "zoom": true
  },

  // Add in properties whose names you wish to fix before
  // setting or getting the value
  cssProps: {
    // normalize float css property
    "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
  },

  // Get and set the style property on a DOM Node
  style: function( elem, name, value, extra ) {
    // Don't set styles on text and comment nodes
    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
      return;
    }

    // Make sure that we're working with the right name
    var ret, type, origName = jQuery.camelCase( name ),
      style = elem.style, hooks = jQuery.cssHooks[ origName ];

    name = jQuery.cssProps[ origName ] || origName;

    // Check if we're setting a value
    if ( value !== undefined ) {
      type = typeof value;

      // convert relative number strings (+= or -=) to relative numbers. #7345
      if ( type === "string" && (ret = rrelNum.exec( value )) ) {
        value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
        // Fixes bug #9237
        type = "number";
      }

      // Make sure that NaN and null values aren't set. See: #7116
      if ( value == null || type === "number" && isNaN( value ) ) {
        return;
      }

      // If a number was passed in, add 'px' to the (except for certain CSS properties)
      if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
        value += "px";
      }

      // If a hook was provided, use that value, otherwise just set the specified value
      if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
        // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
        // Fixes bug #5509
        try {
          style[ name ] = value;
        } catch(e) {}
      }

    } else {
      // If a hook was provided get the non-computed value from there
      if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
        return ret;
      }

      // Otherwise just get the value from the style object
      return style[ name ];
    }
  },

  css: function( elem, name, extra ) {
    var ret, hooks;

    // Make sure that we're working with the right name
    name = jQuery.camelCase( name );
    hooks = jQuery.cssHooks[ name ];
    name = jQuery.cssProps[ name ] || name;

    // cssFloat needs a special treatment
    if ( name === "cssFloat" ) {
      name = "float";
    }

    // If a hook was provided get the computed value from there
    if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
      return ret;

    // Otherwise, if a way to get the computed value exists, use that
    } else if ( curCSS ) {
      return curCSS( elem, name );
    }
  },

  // A method for quickly swapping in/out CSS properties to get correct calculations
  swap: function( elem, options, callback ) {
    var old = {},
      ret, name;

    // Remember the old values, and insert the new ones
    for ( name in options ) {
      old[ name ] = elem.style[ name ];
      elem.style[ name ] = options[ name ];
    }

    ret = callback.call( elem );

    // Revert the old values
    for ( name in options ) {
      elem.style[ name ] = old[ name ];
    }

    return ret;
  }
});

// DEPRECATED in 1.3, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

if ( document.defaultView && document.defaultView.getComputedStyle ) {
  getComputedStyle = function( elem, name ) {
    var ret, defaultView, computedStyle, width,
      style = elem.style;

    name = name.replace( rupper, "-$1" ).toLowerCase();

    if ( (defaultView = elem.ownerDocument.defaultView) &&
        (computedStyle = defaultView.getComputedStyle( elem, null )) ) {

      ret = computedStyle.getPropertyValue( name );
      if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
        ret = jQuery.style( elem, name );
      }
    }

    // A tribute to the "awesome hack by Dean Edwards"
    // WebKit uses "computed value (percentage if specified)" instead of "used value" for margins
    // which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
    if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
      width = style.width;
      style.width = ret;
      ret = computedStyle.width;
      style.width = width;
    }

    return ret;
  };
}

if ( document.documentElement.currentStyle ) {
  currentStyle = function( elem, name ) {
    var left, rsLeft, uncomputed,
      ret = elem.currentStyle && elem.currentStyle[ name ],
      style = elem.style;

    // Avoid setting ret to empty string here
    // so we don't default to auto
    if ( ret == null && style && (uncomputed = style[ name ]) ) {
      ret = uncomputed;
    }

    // From the awesome hack by Dean Edwards
    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

    // If we're not dealing with a regular pixel number
    // but a number that has a weird ending, we need to convert it to pixels
    if ( rnumnonpx.test( ret ) ) {

      // Remember the original values
      left = style.left;
      rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

      // Put in the new values to get a computed value out
      if ( rsLeft ) {
        elem.runtimeStyle.left = elem.currentStyle.left;
      }
      style.left = name === "fontSize" ? "1em" : ret;
      ret = style.pixelLeft + "px";

      // Revert the changed values
      style.left = left;
      if ( rsLeft ) {
        elem.runtimeStyle.left = rsLeft;
      }
    }

    return ret === "" ? "auto" : ret;
  };
}

curCSS = getComputedStyle || currentStyle;

function getWidthOrHeight( elem, name, extra ) {

  // Start with offset property
  var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
    i = name === "width" ? 1 : 0,
    len = 4;

  if ( val > 0 ) {
    if ( extra !== "border" ) {
      for ( ; i < len; i += 2 ) {
        if ( !extra ) {
          val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
        }
        if ( extra === "margin" ) {
          val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
        } else {
          val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
        }
      }
    }

    return val + "px";
  }

  // Fall back to computed then uncomputed css if necessary
  val = curCSS( elem, name );
  if ( val < 0 || val == null ) {
    val = elem.style[ name ];
  }

  // Computed unit is not pixels. Stop here and return.
  if ( rnumnonpx.test(val) ) {
    return val;
  }

  // Normalize "", auto, and prepare for extra
  val = parseFloat( val ) || 0;

  // Add padding, border, margin
  if ( extra ) {
    for ( ; i < len; i += 2 ) {
      val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
      if ( extra !== "padding" ) {
        val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
      }
      if ( extra === "margin" ) {
        val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
      }
    }
  }

  return val + "px";
}

jQuery.each([ "height", "width" ], function( i, name ) {
  jQuery.cssHooks[ name ] = {
    get: function( elem, computed, extra ) {
      if ( computed ) {
        if ( elem.offsetWidth !== 0 ) {
          return getWidthOrHeight( elem, name, extra );
        } else {
          return jQuery.swap( elem, cssShow, function() {
            return getWidthOrHeight( elem, name, extra );
          });
        }
      }
    },

    set: function( elem, value ) {
      return rnum.test( value ) ?
        value + "px" :
        value;
    }
  };
});

if ( !jQuery.support.opacity ) {
  jQuery.cssHooks.opacity = {
    get: function( elem, computed ) {
      // IE uses filters for opacity
      return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
        ( parseFloat( RegExp.$1 ) / 100 ) + "" :
        computed ? "1" : "";
    },

    set: function( elem, value ) {
      var style = elem.style,
        currentStyle = elem.currentStyle,
        opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
        filter = currentStyle && currentStyle.filter || style.filter || "";

      // IE has trouble with opacity if it does not have layout
      // Force it by setting the zoom level
      style.zoom = 1;

      // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
      if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

        // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
        // if "filter:" is present at all, clearType is disabled, we want to avoid this
        // style.removeAttribute is IE Only, but so apparently is this code path...
        style.removeAttribute( "filter" );

        // if there there is no filter style applied in a css rule, we are done
        if ( currentStyle && !currentStyle.filter ) {
          return;
        }
      }

      // otherwise, set new filter values
      style.filter = ralpha.test( filter ) ?
        filter.replace( ralpha, opacity ) :
        filter + " " + opacity;
    }
  };
}

jQuery(function() {
  // This hook cannot be added until DOM ready because the support test
  // for it is not run until after DOM ready
  if ( !jQuery.support.reliableMarginRight ) {
    jQuery.cssHooks.marginRight = {
      get: function( elem, computed ) {
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        // Work around by temporarily setting element display to inline-block
        return jQuery.swap( elem, { "display": "inline-block" }, function() {
          if ( computed ) {
            return curCSS( elem, "margin-right" );
          } else {
            return elem.style.marginRight;
          }
        });
      }
    };
  }
});

if ( jQuery.expr && jQuery.expr.filters ) {
  jQuery.expr.filters.hidden = function( elem ) {
    var width = elem.offsetWidth,
      height = elem.offsetHeight;

    return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
  };

  jQuery.expr.filters.visible = function( elem ) {
    return !jQuery.expr.filters.hidden( elem );
  };
}

// These hooks are used by animate to expand properties
jQuery.each({
  margin: "",
  padding: "",
  border: "Width"
}, function( prefix, suffix ) {

  jQuery.cssHooks[ prefix + suffix ] = {
    expand: function( value ) {
      var i,

        // assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [ value ],
        expanded = {};

      for ( i = 0; i < 4; i++ ) {
        expanded[ prefix + cssExpand[ i ] + suffix ] =
          parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
      }

      return expanded;
    }
  };
});




var r20 = /%20/g,
  rbracket = /\[\]$/,
  rCRLF = /\r?\n/g,
  rhash = /#.*$/,
  rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
  rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
  // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
  rnoContent = /^(?:GET|HEAD)$/,
  rprotocol = /^\/\//,
  rquery = /\?/,
  rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
  rselectTextarea = /^(?:select|textarea)/i,
  rspacesAjax = /\s+/,
  rts = /([?&])_=[^&]*/,
  rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

  // Keep a copy of the old load method
  _load = jQuery.fn.load,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},

  // Document location
  ajaxLocation,

  // Document location segments
  ajaxLocParts,

  // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
  ajaxLocation = location.href;
} catch( e ) {
  // Use the href attribute of an A element
  // since IE will modify it given document.location
  ajaxLocation = document.createElement( "a" );
  ajaxLocation.href = "";
  ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

  // dataTypeExpression is optional and defaults to "*"
  return function( dataTypeExpression, func ) {

    if ( typeof dataTypeExpression !== "string" ) {
      func = dataTypeExpression;
      dataTypeExpression = "*";
    }

    if ( jQuery.isFunction( func ) ) {
      var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
        i = 0,
        length = dataTypes.length,
        dataType,
        list,
        placeBefore;

      // For each dataType in the dataTypeExpression
      for ( ; i < length; i++ ) {
        dataType = dataTypes[ i ];
        // We control if we're asked to add before
        // any existing element
        placeBefore = /^\+/.test( dataType );
        if ( placeBefore ) {
          dataType = dataType.substr( 1 ) || "*";
        }
        list = structure[ dataType ] = structure[ dataType ] || [];
        // then we add to the structure accordingly
        list[ placeBefore ? "unshift" : "push" ]( func );
      }
    }
  };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
    dataType /* internal */, inspected /* internal */ ) {

  dataType = dataType || options.dataTypes[ 0 ];
  inspected = inspected || {};

  inspected[ dataType ] = true;

  var list = structure[ dataType ],
    i = 0,
    length = list ? list.length : 0,
    executeOnly = ( structure === prefilters ),
    selection;

  for ( ; i < length && ( executeOnly || !selection ); i++ ) {
    selection = list[ i ]( options, originalOptions, jqXHR );
    // If we got redirected to another dataType
    // we try there if executing only and not done already
    if ( typeof selection === "string" ) {
      if ( !executeOnly || inspected[ selection ] ) {
        selection = undefined;
      } else {
        options.dataTypes.unshift( selection );
        selection = inspectPrefiltersOrTransports(
            structure, options, originalOptions, jqXHR, selection, inspected );
      }
    }
  }
  // If we're only executing or nothing was selected
  // we try the catchall dataType if not done already
  if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
    selection = inspectPrefiltersOrTransports(
        structure, options, originalOptions, jqXHR, "*", inspected );
  }
  // unnecessary when only executing (prefilters)
  // but it'll be ignored by the caller in that case
  return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
  var key, deep,
    flatOptions = jQuery.ajaxSettings.flatOptions || {};
  for ( key in src ) {
    if ( src[ key ] !== undefined ) {
      ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
    }
  }
  if ( deep ) {
    jQuery.extend( true, target, deep );
  }
}

jQuery.fn.extend({
  load: function( url, params, callback ) {
    if ( typeof url !== "string" && _load ) {
      return _load.apply( this, arguments );

    // Don't do a request if no elements are being requested
    } else if ( !this.length ) {
      return this;
    }

    var off = url.indexOf( " " );
    if ( off >= 0 ) {
      var selector = url.slice( off, url.length );
      url = url.slice( 0, off );
    }

    // Default to a GET request
    var type = "GET";

    // If the second parameter was provided
    if ( params ) {
      // If it's a function
      if ( jQuery.isFunction( params ) ) {
        // We assume that it's the callback
        callback = params;
        params = undefined;

      // Otherwise, build a param string
      } else if ( typeof params === "object" ) {
        params = jQuery.param( params, jQuery.ajaxSettings.traditional );
        type = "POST";
      }
    }

    var self = this;

    // Request the remote document
    jQuery.ajax({
      url: url,
      type: type,
      dataType: "html",
      data: params,
      // Complete callback (responseText is used internally)
      complete: function( jqXHR, status, responseText ) {
        // Store the response as specified by the jqXHR object
        responseText = jqXHR.responseText;
        // If successful, inject the HTML into all the matched elements
        if ( jqXHR.isResolved() ) {
          // #4825: Get the actual response in case
          // a dataFilter is present in ajaxSettings
          jqXHR.done(function( r ) {
            responseText = r;
          });
          // See if a selector was specified
          self.html( selector ?
            // Create a dummy div to hold the results
            jQuery("<div>")
              // inject the contents of the document in, removing the scripts
              // to avoid any 'Permission Denied' errors in IE
              .append(responseText.replace(rscript, ""))

              // Locate the specified elements
              .find(selector) :

            // If not, just inject the full result
            responseText );
        }

        if ( callback ) {
          self.each( callback, [ responseText, status, jqXHR ] );
        }
      }
    });

    return this;
  },

  serialize: function() {
    return jQuery.param( this.serializeArray() );
  },

  serializeArray: function() {
    return this.map(function(){
      return this.elements ? jQuery.makeArray( this.elements ) : this;
    })
    .filter(function(){
      return this.name && !this.disabled &&
        ( this.checked || rselectTextarea.test( this.nodeName ) ||
          rinput.test( this.type ) );
    })
    .map(function( i, elem ){
      var val = jQuery( this ).val();

      return val == null ?
        null :
        jQuery.isArray( val ) ?
          jQuery.map( val, function( val, i ){
            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
          }) :
          { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    }).get();
  }
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
  jQuery.fn[ o ] = function( f ){
    return this.on( o, f );
  };
});

jQuery.each( [ "get", "post" ], function( i, method ) {
  jQuery[ method ] = function( url, data, callback, type ) {
    // shift arguments if data argument was omitted
    if ( jQuery.isFunction( data ) ) {
      type = type || callback;
      callback = data;
      data = undefined;
    }

    return jQuery.ajax({
      type: method,
      url: url,
      data: data,
      success: callback,
      dataType: type
    });
  };
});

jQuery.extend({

  getScript: function( url, callback ) {
    return jQuery.get( url, undefined, callback, "script" );
  },

  getJSON: function( url, data, callback ) {
    return jQuery.get( url, data, callback, "json" );
  },

  // Creates a full fledged settings object into target
  // with both ajaxSettings and settings fields.
  // If target is omitted, writes into ajaxSettings.
  ajaxSetup: function( target, settings ) {
    if ( settings ) {
      // Building a settings object
      ajaxExtend( target, jQuery.ajaxSettings );
    } else {
      // Extending ajaxSettings
      settings = target;
      target = jQuery.ajaxSettings;
    }
    ajaxExtend( target, settings );
    return target;
  },

  ajaxSettings: {
    url: ajaxLocation,
    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
    global: true,
    type: "GET",
    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
    processData: true,
    async: true,
    /*
    timeout: 0,
    data: null,
    dataType: null,
    username: null,
    password: null,
    cache: null,
    traditional: false,
    headers: {},
    */

    accepts: {
      xml: "application/xml, text/xml",
      html: "text/html",
      text: "text/plain",
      json: "application/json, text/javascript",
      "*": allTypes
    },

    contents: {
      xml: /xml/,
      html: /html/,
      json: /json/
    },

    responseFields: {
      xml: "responseXML",
      text: "responseText"
    },

    // List of data converters
    // 1) key format is "source_type destination_type" (a single space in-between)
    // 2) the catchall symbol "*" can be used for source_type
    converters: {

      // Convert anything to text
      "* text": window.String,

      // Text to html (true = no transformation)
      "text html": true,

      // Evaluate text as a json expression
      "text json": jQuery.parseJSON,

      // Parse text as xml
      "text xml": jQuery.parseXML
    },

    // For options that shouldn't be deep extended:
    // you can add your own custom options here if
    // and when you create one that shouldn't be
    // deep extended (see ajaxExtend)
    flatOptions: {
      context: true,
      url: true
    }
  },

  ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  ajaxTransport: addToPrefiltersOrTransports( transports ),

  // Main method
  ajax: function( url, options ) {

    // If url is an object, simulate pre-1.5 signature
    if ( typeof url === "object" ) {
      options = url;
      url = undefined;
    }

    // Force options to be an object
    options = options || {};

    var // Create the final options object
      s = jQuery.ajaxSetup( {}, options ),
      // Callbacks context
      callbackContext = s.context || s,
      // Context for global events
      // It's the callbackContext if one was provided in the options
      // and if it's a DOM node or a jQuery collection
      globalEventContext = callbackContext !== s &&
        ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
            jQuery( callbackContext ) : jQuery.event,
      // Deferreds
      deferred = jQuery.Deferred(),
      completeDeferred = jQuery.Callbacks( "once memory" ),
      // Status-dependent callbacks
      statusCode = s.statusCode || {},
      // ifModified key
      ifModifiedKey,
      // Headers (they are sent all at once)
      requestHeaders = {},
      requestHeadersNames = {},
      // Response headers
      responseHeadersString,
      responseHeaders,
      // transport
      transport,
      // timeout handle
      timeoutTimer,
      // Cross-domain detection vars
      parts,
      // The jqXHR state
      state = 0,
      // To know if global events are to be dispatched
      fireGlobals,
      // Loop variable
      i,
      // Fake xhr
      jqXHR = {

        readyState: 0,

        // Caches the header
        setRequestHeader: function( name, value ) {
          if ( !state ) {
            var lname = name.toLowerCase();
            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
            requestHeaders[ name ] = value;
          }
          return this;
        },

        // Raw string
        getAllResponseHeaders: function() {
          return state === 2 ? responseHeadersString : null;
        },

        // Builds headers hashtable if needed
        getResponseHeader: function( key ) {
          var match;
          if ( state === 2 ) {
            if ( !responseHeaders ) {
              responseHeaders = {};
              while( ( match = rheaders.exec( responseHeadersString ) ) ) {
                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
              }
            }
            match = responseHeaders[ key.toLowerCase() ];
          }
          return match === undefined ? null : match;
        },

        // Overrides response content-type header
        overrideMimeType: function( type ) {
          if ( !state ) {
            s.mimeType = type;
          }
          return this;
        },

        // Cancel the request
        abort: function( statusText ) {
          statusText = statusText || "abort";
          if ( transport ) {
            transport.abort( statusText );
          }
          done( 0, statusText );
          return this;
        }
      };

    // Callback for when everything is done
    // It is defined here because jslint complains if it is declared
    // at the end of the function (which would be more logical and readable)
    function done( status, nativeStatusText, responses, headers ) {

      // Called once
      if ( state === 2 ) {
        return;
      }

      // State is "done" now
      state = 2;

      // Clear timeout if it exists
      if ( timeoutTimer ) {
        clearTimeout( timeoutTimer );
      }

      // Dereference transport for early garbage collection
      // (no matter how long the jqXHR object will be used)
      transport = undefined;

      // Cache response headers
      responseHeadersString = headers || "";

      // Set readyState
      jqXHR.readyState = status > 0 ? 4 : 0;

      var isSuccess,
        success,
        error,
        statusText = nativeStatusText,
        response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
        lastModified,
        etag;

      // If successful, handle type chaining
      if ( status >= 200 && status < 300 || status === 304 ) {

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {

          if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
            jQuery.lastModified[ ifModifiedKey ] = lastModified;
          }
          if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
            jQuery.etag[ ifModifiedKey ] = etag;
          }
        }

        // If not modified
        if ( status === 304 ) {

          statusText = "notmodified";
          isSuccess = true;

        // If we have data
        } else {

          try {
            success = ajaxConvert( s, response );
            statusText = "success";
            isSuccess = true;
          } catch(e) {
            // We have a parsererror
            statusText = "parsererror";
            error = e;
          }
        }
      } else {
        // We extract error from statusText
        // then normalize statusText and status for non-aborts
        error = statusText;
        if ( !statusText || status ) {
          statusText = "error";
          if ( status < 0 ) {
            status = 0;
          }
        }
      }

      // Set data for the fake xhr object
      jqXHR.status = status;
      jqXHR.statusText = "" + ( nativeStatusText || statusText );

      // Success/Error
      if ( isSuccess ) {
        deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
      } else {
        deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
      }

      // Status-dependent callbacks
      jqXHR.statusCode( statusCode );
      statusCode = undefined;

      if ( fireGlobals ) {
        globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
            [ jqXHR, s, isSuccess ? success : error ] );
      }

      // Complete
      completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
        // Handle the global AJAX counter
        if ( !( --jQuery.active ) ) {
          jQuery.event.trigger( "ajaxStop" );
        }
      }
    }

    // Attach deferreds
    deferred.promise( jqXHR );
    jqXHR.success = jqXHR.done;
    jqXHR.error = jqXHR.fail;
    jqXHR.complete = completeDeferred.add;

    // Status-dependent callbacks
    jqXHR.statusCode = function( map ) {
      if ( map ) {
        var tmp;
        if ( state < 2 ) {
          for ( tmp in map ) {
            statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
          }
        } else {
          tmp = map[ jqXHR.status ];
          jqXHR.then( tmp, tmp );
        }
      }
      return this;
    };

    // Remove hash character (#7531: and string promotion)
    // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
    // We also use the url parameter if available
    s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

    // Extract dataTypes list
    s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

    // Determine if a cross-domain request is in order
    if ( s.crossDomain == null ) {
      parts = rurl.exec( s.url.toLowerCase() );
      s.crossDomain = !!( parts &&
        ( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
          ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
            ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
      );
    }

    // Convert data if not already a string
    if ( s.data && s.processData && typeof s.data !== "string" ) {
      s.data = jQuery.param( s.data, s.traditional );
    }

    // Apply prefilters
    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

    // If request was aborted inside a prefilter, stop there
    if ( state === 2 ) {
      return false;
    }

    // We can fire global events as of now if asked to
    fireGlobals = s.global;

    // Uppercase the type
    s.type = s.type.toUpperCase();

    // Determine if request has content
    s.hasContent = !rnoContent.test( s.type );

    // Watch for a new set of requests
    if ( fireGlobals && jQuery.active++ === 0 ) {
      jQuery.event.trigger( "ajaxStart" );
    }

    // More options handling for requests with no content
    if ( !s.hasContent ) {

      // If data is available, append data to url
      if ( s.data ) {
        s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
        // #9682: remove data so that it's not used in an eventual retry
        delete s.data;
      }

      // Get ifModifiedKey before adding the anti-cache parameter
      ifModifiedKey = s.url;

      // Add anti-cache in url if needed
      if ( s.cache === false ) {

        var ts = jQuery.now(),
          // try replacing _= if it is there
          ret = s.url.replace( rts, "$1_=" + ts );

        // if nothing was replaced, add timestamp to the end
        s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
      }
    }

    // Set the correct header, if data is being sent
    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
      jqXHR.setRequestHeader( "Content-Type", s.contentType );
    }

    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    if ( s.ifModified ) {
      ifModifiedKey = ifModifiedKey || s.url;
      if ( jQuery.lastModified[ ifModifiedKey ] ) {
        jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
      }
      if ( jQuery.etag[ ifModifiedKey ] ) {
        jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
      }
    }

    // Set the Accepts header for the server, depending on the dataType
    jqXHR.setRequestHeader(
      "Accept",
      s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
        s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
        s.accepts[ "*" ]
    );

    // Check for headers option
    for ( i in s.headers ) {
      jqXHR.setRequestHeader( i, s.headers[ i ] );
    }

    // Allow custom headers/mimetypes and early abort
    if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
        // Abort if not done already
        jqXHR.abort();
        return false;

    }

    // Install callbacks on deferreds
    for ( i in { success: 1, error: 1, complete: 1 } ) {
      jqXHR[ i ]( s[ i ] );
    }

    // Get transport
    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

    // If no transport, we auto-abort
    if ( !transport ) {
      done( -1, "No Transport" );
    } else {
      jqXHR.readyState = 1;
      // Send global event
      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
      }
      // Timeout
      if ( s.async && s.timeout > 0 ) {
        timeoutTimer = setTimeout( function(){
          jqXHR.abort( "timeout" );
        }, s.timeout );
      }

      try {
        state = 1;
        transport.send( requestHeaders, done );
      } catch (e) {
        // Propagate exception as error if not done
        if ( state < 2 ) {
          done( -1, e );
        // Simply rethrow otherwise
        } else {
          throw e;
        }
      }
    }

    return jqXHR;
  },

  // Serialize an array of form elements or a set of
  // key/values into a query string
  param: function( a, traditional ) {
    var s = [],
      add = function( key, value ) {
        // If value is a function, invoke it and return its value
        value = jQuery.isFunction( value ) ? value() : value;
        s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
      };

    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if ( traditional === undefined ) {
      traditional = jQuery.ajaxSettings.traditional;
    }

    // If an array was passed in, assume that it is an array of form elements.
    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
      // Serialize the form elements
      jQuery.each( a, function() {
        add( this.name, this.value );
      });

    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for ( var prefix in a ) {
        buildParams( prefix, a[ prefix ], traditional, add );
      }
    }

    // Return the resulting serialization
    return s.join( "&" ).replace( r20, "+" );
  }
});

function buildParams( prefix, obj, traditional, add ) {
  if ( jQuery.isArray( obj ) ) {
    // Serialize array item.
    jQuery.each( obj, function( i, v ) {
      if ( traditional || rbracket.test( prefix ) ) {
        // Treat each array item as a scalar.
        add( prefix, v );

      } else {
        // If array item is non-scalar (array or object), encode its
        // numeric index to resolve deserialization ambiguity issues.
        // Note that rack (as of 1.0.0) can't currently deserialize
        // nested arrays properly, and attempting to do so may cause
        // a server error. Possible fixes are to modify rack's
        // deserialization algorithm or to provide an option or flag
        // to force array serialization to be shallow.
        buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
      }
    });

  } else if ( !traditional && jQuery.type( obj ) === "object" ) {
    // Serialize object item.
    for ( var name in obj ) {
      buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    }

  } else {
    // Serialize scalar item.
    add( prefix, obj );
  }
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

  // Counter for holding the number of active queries
  active: 0,

  // Last-Modified header cache for next request
  lastModified: {},
  etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

  var contents = s.contents,
    dataTypes = s.dataTypes,
    responseFields = s.responseFields,
    ct,
    type,
    finalDataType,
    firstDataType;

  // Fill responseXXX fields
  for ( type in responseFields ) {
    if ( type in responses ) {
      jqXHR[ responseFields[type] ] = responses[ type ];
    }
  }

  // Remove auto dataType and get content-type in the process
  while( dataTypes[ 0 ] === "*" ) {
    dataTypes.shift();
    if ( ct === undefined ) {
      ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
    }
  }

  // Check if we're dealing with a known content-type
  if ( ct ) {
    for ( type in contents ) {
      if ( contents[ type ] && contents[ type ].test( ct ) ) {
        dataTypes.unshift( type );
        break;
      }
    }
  }

  // Check to see if we have a response for the expected dataType
  if ( dataTypes[ 0 ] in responses ) {
    finalDataType = dataTypes[ 0 ];
  } else {
    // Try convertible dataTypes
    for ( type in responses ) {
      if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
        finalDataType = type;
        break;
      }
      if ( !firstDataType ) {
        firstDataType = type;
      }
    }
    // Or just use first one
    finalDataType = finalDataType || firstDataType;
  }

  // If we found a dataType
  // We add the dataType to the list if needed
  // and return the corresponding response
  if ( finalDataType ) {
    if ( finalDataType !== dataTypes[ 0 ] ) {
      dataTypes.unshift( finalDataType );
    }
    return responses[ finalDataType ];
  }
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

  // Apply the dataFilter if provided
  if ( s.dataFilter ) {
    response = s.dataFilter( response, s.dataType );
  }

  var dataTypes = s.dataTypes,
    converters = {},
    i,
    key,
    length = dataTypes.length,
    tmp,
    // Current and previous dataTypes
    current = dataTypes[ 0 ],
    prev,
    // Conversion expression
    conversion,
    // Conversion function
    conv,
    // Conversion functions (transitive conversion)
    conv1,
    conv2;

  // For each dataType in the chain
  for ( i = 1; i < length; i++ ) {

    // Create converters map
    // with lowercased keys
    if ( i === 1 ) {
      for ( key in s.converters ) {
        if ( typeof key === "string" ) {
          converters[ key.toLowerCase() ] = s.converters[ key ];
        }
      }
    }

    // Get the dataTypes
    prev = current;
    current = dataTypes[ i ];

    // If current is auto dataType, update it to prev
    if ( current === "*" ) {
      current = prev;
    // If no auto and dataTypes are actually different
    } else if ( prev !== "*" && prev !== current ) {

      // Get the converter
      conversion = prev + " " + current;
      conv = converters[ conversion ] || converters[ "* " + current ];

      // If there is no direct converter, search transitively
      if ( !conv ) {
        conv2 = undefined;
        for ( conv1 in converters ) {
          tmp = conv1.split( " " );
          if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
            conv2 = converters[ tmp[1] + " " + current ];
            if ( conv2 ) {
              conv1 = converters[ conv1 ];
              if ( conv1 === true ) {
                conv = conv2;
              } else if ( conv2 === true ) {
                conv = conv1;
              }
              break;
            }
          }
        }
      }
      // If we found no converter, dispatch an error
      if ( !( conv || conv2 ) ) {
        jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
      }
      // If found converter is not an equivalence
      if ( conv !== true ) {
        // Convert with 1 or 2 converters accordingly
        response = conv ? conv( response ) : conv2( conv1(response) );
      }
    }
  }
  return response;
}




var jsc = jQuery.now(),
  jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
  jsonp: "callback",
  jsonpCallback: function() {
    return jQuery.expando + "_" + ( jsc++ );
  }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );

  if ( s.dataTypes[ 0 ] === "jsonp" ||
    s.jsonp !== false && ( jsre.test( s.url ) ||
        inspectData && jsre.test( s.data ) ) ) {

    var responseContainer,
      jsonpCallback = s.jsonpCallback =
        jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
      previous = window[ jsonpCallback ],
      url = s.url,
      data = s.data,
      replace = "$1" + jsonpCallback + "$2";

    if ( s.jsonp !== false ) {
      url = url.replace( jsre, replace );
      if ( s.url === url ) {
        if ( inspectData ) {
          data = data.replace( jsre, replace );
        }
        if ( s.data === data ) {
          // Add callback manually
          url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
        }
      }
    }

    s.url = url;
    s.data = data;

    // Install callback
    window[ jsonpCallback ] = function( response ) {
      responseContainer = [ response ];
    };

    // Clean-up function
    jqXHR.always(function() {
      // Set callback back to previous value
      window[ jsonpCallback ] = previous;
      // Call if it was a function and we have a response
      if ( responseContainer && jQuery.isFunction( previous ) ) {
        window[ jsonpCallback ]( responseContainer[ 0 ] );
      }
    });

    // Use data converter to retrieve json after script execution
    s.converters["script json"] = function() {
      if ( !responseContainer ) {
        jQuery.error( jsonpCallback + " was not called" );
      }
      return responseContainer[ 0 ];
    };

    // force json dataType
    s.dataTypes[ 0 ] = "json";

    // Delegate to script
    return "script";
  }
});




// Install script dataType
jQuery.ajaxSetup({
  accepts: {
    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
  },
  contents: {
    script: /javascript|ecmascript/
  },
  converters: {
    "text script": function( text ) {
      jQuery.globalEval( text );
      return text;
    }
  }
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
  if ( s.cache === undefined ) {
    s.cache = false;
  }
  if ( s.crossDomain ) {
    s.type = "GET";
    s.global = false;
  }
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

  // This transport only deals with cross domain requests
  if ( s.crossDomain ) {

    var script,
      head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

    return {

      send: function( _, callback ) {

        script = document.createElement( "script" );

        script.async = "async";

        if ( s.scriptCharset ) {
          script.charset = s.scriptCharset;
        }

        script.src = s.url;

        // Attach handlers for all browsers
        script.onload = script.onreadystatechange = function( _, isAbort ) {

          if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

            // Handle memory leak in IE
            script.onload = script.onreadystatechange = null;

            // Remove the script
            if ( head && script.parentNode ) {
              head.removeChild( script );
            }

            // Dereference the script
            script = undefined;

            // Callback if not abort
            if ( !isAbort ) {
              callback( 200, "success" );
            }
          }
        };
        // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
        // This arises when a base node is used (#2709 and #4378).
        head.insertBefore( script, head.firstChild );
      },

      abort: function() {
        if ( script ) {
          script.onload( 0, 1 );
        }
      }
    };
  }
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
  xhrOnUnloadAbort = window.ActiveXObject ? function() {
    // Abort all pending requests
    for ( var key in xhrCallbacks ) {
      xhrCallbacks[ key ]( 0, 1 );
    }
  } : false,
  xhrId = 0,
  xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
  try {
    return new window.XMLHttpRequest();
  } catch( e ) {}
}

function createActiveXHR() {
  try {
    return new window.ActiveXObject( "Microsoft.XMLHTTP" );
  } catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
  /* Microsoft failed to properly
   * implement the XMLHttpRequest in IE7 (can't request local files),
   * so we use the ActiveXObject when it is available
   * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
   * we need a fallback.
   */
  function() {
    return !this.isLocal && createStandardXHR() || createActiveXHR();
  } :
  // For all other browsers, use the standard XMLHttpRequest object
  createStandardXHR;

// Determine support properties
(function( xhr ) {
  jQuery.extend( jQuery.support, {
    ajax: !!xhr,
    cors: !!xhr && ( "withCredentials" in xhr )
  });
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

  jQuery.ajaxTransport(function( s ) {
    // Cross domain only allowed if supported through XMLHttpRequest
    if ( !s.crossDomain || jQuery.support.cors ) {

      var callback;

      return {
        send: function( headers, complete ) {

          // Get a new xhr
          var xhr = s.xhr(),
            handle,
            i;

          // Open the socket
          // Passing null username, generates a login popup on Opera (#2865)
          if ( s.username ) {
            xhr.open( s.type, s.url, s.async, s.username, s.password );
          } else {
            xhr.open( s.type, s.url, s.async );
          }

          // Apply custom fields if provided
          if ( s.xhrFields ) {
            for ( i in s.xhrFields ) {
              xhr[ i ] = s.xhrFields[ i ];
            }
          }

          // Override mime type if needed
          if ( s.mimeType && xhr.overrideMimeType ) {
            xhr.overrideMimeType( s.mimeType );
          }

          // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.
          if ( !s.crossDomain && !headers["X-Requested-With"] ) {
            headers[ "X-Requested-With" ] = "XMLHttpRequest";
          }

          // Need an extra try/catch for cross domain requests in Firefox 3
          try {
            for ( i in headers ) {
              xhr.setRequestHeader( i, headers[ i ] );
            }
          } catch( _ ) {}

          // Do send the request
          // This may raise an exception which is actually
          // handled in jQuery.ajax (so no try/catch here)
          xhr.send( ( s.hasContent && s.data ) || null );

          // Listener
          callback = function( _, isAbort ) {

            var status,
              statusText,
              responseHeaders,
              responses,
              xml;

            // Firefox throws exceptions when accessing properties
            // of an xhr when a network error occured
            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
            try {

              // Was never called and is aborted or complete
              if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

                // Only called once
                callback = undefined;

                // Do not keep as active anymore
                if ( handle ) {
                  xhr.onreadystatechange = jQuery.noop;
                  if ( xhrOnUnloadAbort ) {
                    delete xhrCallbacks[ handle ];
                  }
                }

                // If it's an abort
                if ( isAbort ) {
                  // Abort it manually if needed
                  if ( xhr.readyState !== 4 ) {
                    xhr.abort();
                  }
                } else {
                  status = xhr.status;
                  responseHeaders = xhr.getAllResponseHeaders();
                  responses = {};
                  xml = xhr.responseXML;

                  // Construct response list
                  if ( xml && xml.documentElement /* #4958 */ ) {
                    responses.xml = xml;
                  }

                  // When requesting binary data, IE6-9 will throw an exception
                  // on any attempt to access responseText (#11426)
                  try {
                    responses.text = xhr.responseText;
                  } catch( _ ) {
                  }

                  // Firefox throws an exception when accessing
                  // statusText for faulty cross-domain requests
                  try {
                    statusText = xhr.statusText;
                  } catch( e ) {
                    // We normalize with Webkit giving an empty statusText
                    statusText = "";
                  }

                  // Filter status for non standard behaviors

                  // If the request is local and we have data: assume a success
                  // (success with no data won't get notified, that's the best we
                  // can do given current implementations)
                  if ( !status && s.isLocal && !s.crossDomain ) {
                    status = responses.text ? 200 : 404;
                  // IE - #1450: sometimes returns 1223 when it should be 204
                  } else if ( status === 1223 ) {
                    status = 204;
                  }
                }
              }
            } catch( firefoxAccessException ) {
              if ( !isAbort ) {
                complete( -1, firefoxAccessException );
              }
            }

            // Call complete if needed
            if ( responses ) {
              complete( status, statusText, responses, responseHeaders );
            }
          };

          // if we're in sync mode or it's in cache
          // and has been retrieved directly (IE6 & IE7)
          // we need to manually fire the callback
          if ( !s.async || xhr.readyState === 4 ) {
            callback();
          } else {
            handle = ++xhrId;
            if ( xhrOnUnloadAbort ) {
              // Create the active xhrs callbacks list if needed
              // and attach the unload handler
              if ( !xhrCallbacks ) {
                xhrCallbacks = {};
                jQuery( window ).unload( xhrOnUnloadAbort );
              }
              // Add to list of active xhrs callbacks
              xhrCallbacks[ handle ] = callback;
            }
            xhr.onreadystatechange = callback;
          }
        },

        abort: function() {
          if ( callback ) {
            callback(0,1);
          }
        }
      };
    }
  });
}




var elemdisplay = {},
  iframe, iframeDoc,
  rfxtypes = /^(?:toggle|show|hide)$/,
  rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
  timerId,
  fxAttrs = [
    // height animations
    [ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
    // width animations
    [ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
    // opacity animations
    [ "opacity" ]
  ],
  fxNow;

jQuery.fn.extend({
  show: function( speed, easing, callback ) {
    var elem, display;

    if ( speed || speed === 0 ) {
      return this.animate( genFx("show", 3), speed, easing, callback );

    } else {
      for ( var i = 0, j = this.length; i < j; i++ ) {
        elem = this[ i ];

        if ( elem.style ) {
          display = elem.style.display;

          // Reset the inline display of this element to learn if it is
          // being hidden by cascaded rules or not
          if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
            display = elem.style.display = "";
          }

          // Set elements which have been overridden with display: none
          // in a stylesheet to whatever the default browser style is
          // for such an element
          if ( (display === "" && jQuery.css(elem, "display") === "none") ||
            !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
            jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
          }
        }
      }

      // Set the display of most of the elements in a second loop
      // to avoid the constant reflow
      for ( i = 0; i < j; i++ ) {
        elem = this[ i ];

        if ( elem.style ) {
          display = elem.style.display;

          if ( display === "" || display === "none" ) {
            elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
          }
        }
      }

      return this;
    }
  },

  hide: function( speed, easing, callback ) {
    if ( speed || speed === 0 ) {
      return this.animate( genFx("hide", 3), speed, easing, callback);

    } else {
      var elem, display,
        i = 0,
        j = this.length;

      for ( ; i < j; i++ ) {
        elem = this[i];
        if ( elem.style ) {
          display = jQuery.css( elem, "display" );

          if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
            jQuery._data( elem, "olddisplay", display );
          }
        }
      }

      // Set the display of the elements in a second loop
      // to avoid the constant reflow
      for ( i = 0; i < j; i++ ) {
        if ( this[i].style ) {
          this[i].style.display = "none";
        }
      }

      return this;
    }
  },

  // Save the old toggle function
  _toggle: jQuery.fn.toggle,

  toggle: function( fn, fn2, callback ) {
    var bool = typeof fn === "boolean";

    if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
      this._toggle.apply( this, arguments );

    } else if ( fn == null || bool ) {
      this.each(function() {
        var state = bool ? fn : jQuery(this).is(":hidden");
        jQuery(this)[ state ? "show" : "hide" ]();
      });

    } else {
      this.animate(genFx("toggle", 3), fn, fn2, callback);
    }

    return this;
  },

  fadeTo: function( speed, to, easing, callback ) {
    return this.filter(":hidden").css("opacity", 0).show().end()
          .animate({opacity: to}, speed, easing, callback);
  },

  animate: function( prop, speed, easing, callback ) {
    var optall = jQuery.speed( speed, easing, callback );

    if ( jQuery.isEmptyObject( prop ) ) {
      return this.each( optall.complete, [ false ] );
    }

    // Do not change referenced properties as per-property easing will be lost
    prop = jQuery.extend( {}, prop );

    function doAnimation() {
      // XXX 'this' does not always have a nodeName when running the
      // test suite

      if ( optall.queue === false ) {
        jQuery._mark( this );
      }

      var opt = jQuery.extend( {}, optall ),
        isElement = this.nodeType === 1,
        hidden = isElement && jQuery(this).is(":hidden"),
        name, val, p, e, hooks, replace,
        parts, start, end, unit,
        method;

      // will store per property easing and be used to determine when an animation is complete
      opt.animatedProperties = {};

      // first pass over propertys to expand / normalize
      for ( p in prop ) {
        name = jQuery.camelCase( p );
        if ( p !== name ) {
          prop[ name ] = prop[ p ];
          delete prop[ p ];
        }

        if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
          replace = hooks.expand( prop[ name ] );
          delete prop[ name ];

          // not quite $.extend, this wont overwrite keys already present.
          // also - reusing 'p' from above because we have the correct "name"
          for ( p in replace ) {
            if ( ! ( p in prop ) ) {
              prop[ p ] = replace[ p ];
            }
          }
        }
      }

      for ( name in prop ) {
        val = prop[ name ];
        // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
        if ( jQuery.isArray( val ) ) {
          opt.animatedProperties[ name ] = val[ 1 ];
          val = prop[ name ] = val[ 0 ];
        } else {
          opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
        }

        if ( val === "hide" && hidden || val === "show" && !hidden ) {
          return opt.complete.call( this );
        }

        if ( isElement && ( name === "height" || name === "width" ) ) {
          // Make sure that nothing sneaks out
          // Record all 3 overflow attributes because IE does not
          // change the overflow attribute when overflowX and
          // overflowY are set to the same value
          opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

          // Set display property to inline-block for height/width
          // animations on inline elements that are having width/height animated
          if ( jQuery.css( this, "display" ) === "inline" &&
              jQuery.css( this, "float" ) === "none" ) {

            // inline-level elements accept inline-block;
            // block-level elements need to be inline with layout
            if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
              this.style.display = "inline-block";

            } else {
              this.style.zoom = 1;
            }
          }
        }
      }

      if ( opt.overflow != null ) {
        this.style.overflow = "hidden";
      }

      for ( p in prop ) {
        e = new jQuery.fx( this, opt, p );
        val = prop[ p ];

        if ( rfxtypes.test( val ) ) {

          // Tracks whether to show or hide based on private
          // data attached to the element
          method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
          if ( method ) {
            jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
            e[ method ]();
          } else {
            e[ val ]();
          }

        } else {
          parts = rfxnum.exec( val );
          start = e.cur();

          if ( parts ) {
            end = parseFloat( parts[2] );
            unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

            // We need to compute starting value
            if ( unit !== "px" ) {
              jQuery.style( this, p, (end || 1) + unit);
              start = ( (end || 1) / e.cur() ) * start;
              jQuery.style( this, p, start + unit);
            }

            // If a +=/-= token was provided, we're doing a relative animation
            if ( parts[1] ) {
              end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
            }

            e.custom( start, end, unit );

          } else {
            e.custom( start, val, "" );
          }
        }
      }

      // For JS strict compliance
      return true;
    }

    return optall.queue === false ?
      this.each( doAnimation ) :
      this.queue( optall.queue, doAnimation );
  },

  stop: function( type, clearQueue, gotoEnd ) {
    if ( typeof type !== "string" ) {
      gotoEnd = clearQueue;
      clearQueue = type;
      type = undefined;
    }
    if ( clearQueue && type !== false ) {
      this.queue( type || "fx", [] );
    }

    return this.each(function() {
      var index,
        hadTimers = false,
        timers = jQuery.timers,
        data = jQuery._data( this );

      // clear marker counters if we know they won't be
      if ( !gotoEnd ) {
        jQuery._unmark( true, this );
      }

      function stopQueue( elem, data, index ) {
        var hooks = data[ index ];
        jQuery.removeData( elem, index, true );
        hooks.stop( gotoEnd );
      }

      if ( type == null ) {
        for ( index in data ) {
          if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
            stopQueue( this, data, index );
          }
        }
      } else if ( data[ index = type + ".run" ] && data[ index ].stop ){
        stopQueue( this, data, index );
      }

      for ( index = timers.length; index--; ) {
        if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
          if ( gotoEnd ) {

            // force the next step to be the last
            timers[ index ]( true );
          } else {
            timers[ index ].saveState();
          }
          hadTimers = true;
          timers.splice( index, 1 );
        }
      }

      // start the next in the queue if the last step wasn't forced
      // timers currently will call their complete callbacks, which will dequeue
      // but only if they were gotoEnd
      if ( !( gotoEnd && hadTimers ) ) {
        jQuery.dequeue( this, type );
      }
    });
  }

});

// Animations created synchronously will run synchronously
function createFxNow() {
  setTimeout( clearFxNow, 0 );
  return ( fxNow = jQuery.now() );
}

function clearFxNow() {
  fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
  var obj = {};

  jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
    obj[ this ] = type;
  });

  return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
  slideDown: genFx( "show", 1 ),
  slideUp: genFx( "hide", 1 ),
  slideToggle: genFx( "toggle", 1 ),
  fadeIn: { opacity: "show" },
  fadeOut: { opacity: "hide" },
  fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return this.animate( props, speed, easing, callback );
  };
});

jQuery.extend({
  speed: function( speed, easing, fn ) {
    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
      complete: fn || !fn && easing ||
        jQuery.isFunction( speed ) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
    };

    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
      opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

    // normalize opt.queue - true/undefined/null -> "fx"
    if ( opt.queue == null || opt.queue === true ) {
      opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function( noUnmark ) {
      if ( jQuery.isFunction( opt.old ) ) {
        opt.old.call( this );
      }

      if ( opt.queue ) {
        jQuery.dequeue( this, opt.queue );
      } else if ( noUnmark !== false ) {
        jQuery._unmark( this );
      }
    };

    return opt;
  },

  easing: {
    linear: function( p ) {
      return p;
    },
    swing: function( p ) {
      return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
    }
  },

  timers: [],

  fx: function( elem, options, prop ) {
    this.options = options;
    this.elem = elem;
    this.prop = prop;

    options.orig = options.orig || {};
  }

});

jQuery.fx.prototype = {
  // Simple function for setting a style value
  update: function() {
    if ( this.options.step ) {
      this.options.step.call( this.elem, this.now, this );
    }

    ( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
  },

  // Get the current size
  cur: function() {
    if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
      return this.elem[ this.prop ];
    }

    var parsed,
      r = jQuery.css( this.elem, this.prop );
    // Empty strings, null, undefined and "auto" are converted to 0,
    // complex values such as "rotate(1rad)" are returned as is,
    // simple values such as "10px" are parsed to Float.
    return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
  },

  // Start an animation from one number to another
  custom: function( from, to, unit ) {
    var self = this,
      fx = jQuery.fx;

    this.startTime = fxNow || createFxNow();
    this.end = to;
    this.now = this.start = from;
    this.pos = this.state = 0;
    this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

    function t( gotoEnd ) {
      return self.step( gotoEnd );
    }

    t.queue = this.options.queue;
    t.elem = this.elem;
    t.saveState = function() {
      if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
        if ( self.options.hide ) {
          jQuery._data( self.elem, "fxshow" + self.prop, self.start );
        } else if ( self.options.show ) {
          jQuery._data( self.elem, "fxshow" + self.prop, self.end );
        }
      }
    };

    if ( t() && jQuery.timers.push(t) && !timerId ) {
      timerId = setInterval( fx.tick, fx.interval );
    }
  },

  // Simple 'show' function
  show: function() {
    var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

    // Remember where we started, so that we can go back to it later
    this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
    this.options.show = true;

    // Begin the animation
    // Make sure that we start at a small width/height to avoid any flash of content
    if ( dataShow !== undefined ) {
      // This show is picking up where a previous hide or show left off
      this.custom( this.cur(), dataShow );
    } else {
      this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
    }

    // Start by showing the element
    jQuery( this.elem ).show();
  },

  // Simple 'hide' function
  hide: function() {
    // Remember where we started, so that we can go back to it later
    this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
    this.options.hide = true;

    // Begin the animation
    this.custom( this.cur(), 0 );
  },

  // Each step of an animation
  step: function( gotoEnd ) {
    var p, n, complete,
      t = fxNow || createFxNow(),
      done = true,
      elem = this.elem,
      options = this.options;

    if ( gotoEnd || t >= options.duration + this.startTime ) {
      this.now = this.end;
      this.pos = this.state = 1;
      this.update();

      options.animatedProperties[ this.prop ] = true;

      for ( p in options.animatedProperties ) {
        if ( options.animatedProperties[ p ] !== true ) {
          done = false;
        }
      }

      if ( done ) {
        // Reset the overflow
        if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

          jQuery.each( [ "", "X", "Y" ], function( index, value ) {
            elem.style[ "overflow" + value ] = options.overflow[ index ];
          });
        }

        // Hide the element if the "hide" operation was done
        if ( options.hide ) {
          jQuery( elem ).hide();
        }

        // Reset the properties, if the item has been hidden or shown
        if ( options.hide || options.show ) {
          for ( p in options.animatedProperties ) {
            jQuery.style( elem, p, options.orig[ p ] );
            jQuery.removeData( elem, "fxshow" + p, true );
            // Toggle data is no longer needed
            jQuery.removeData( elem, "toggle" + p, true );
          }
        }

        // Execute the complete function
        // in the event that the complete function throws an exception
        // we must ensure it won't be called twice. #5684

        complete = options.complete;
        if ( complete ) {

          options.complete = false;
          complete.call( elem );
        }
      }

      return false;

    } else {
      // classical easing cannot be used with an Infinity duration
      if ( options.duration == Infinity ) {
        this.now = t;
      } else {
        n = t - this.startTime;
        this.state = n / options.duration;

        // Perform the easing function, defaults to swing
        this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
        this.now = this.start + ( (this.end - this.start) * this.pos );
      }
      // Perform the next step of the animation
      this.update();
    }

    return true;
  }
};

jQuery.extend( jQuery.fx, {
  tick: function() {
    var timer,
      timers = jQuery.timers,
      i = 0;

    for ( ; i < timers.length; i++ ) {
      timer = timers[ i ];
      // Checks the timer has not already been removed
      if ( !timer() && timers[ i ] === timer ) {
        timers.splice( i--, 1 );
      }
    }

    if ( !timers.length ) {
      jQuery.fx.stop();
    }
  },

  interval: 13,

  stop: function() {
    clearInterval( timerId );
    timerId = null;
  },

  speeds: {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  },

  step: {
    opacity: function( fx ) {
      jQuery.style( fx.elem, "opacity", fx.now );
    },

    _default: function( fx ) {
      if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
        fx.elem.style[ fx.prop ] = fx.now + fx.unit;
      } else {
        fx.elem[ fx.prop ] = fx.now;
      }
    }
  }
});

// Ensure props that can't be negative don't go there on undershoot easing
jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
  // exclude marginTop, marginLeft, marginBottom and marginRight from this list
  if ( prop.indexOf( "margin" ) ) {
    jQuery.fx.step[ prop ] = function( fx ) {
      jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
    };
  }
});

if ( jQuery.expr && jQuery.expr.filters ) {
  jQuery.expr.filters.animated = function( elem ) {
    return jQuery.grep(jQuery.timers, function( fn ) {
      return elem === fn.elem;
    }).length;
  };
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

  if ( !elemdisplay[ nodeName ] ) {

    var body = document.body,
      elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
      display = elem.css( "display" );
    elem.remove();

    // If the simple way fails,
    // get element's real default display by attaching it to a temp iframe
    if ( display === "none" || display === "" ) {
      // No iframe to use yet, so create it
      if ( !iframe ) {
        iframe = document.createElement( "iframe" );
        iframe.frameBorder = iframe.width = iframe.height = 0;
      }

      body.appendChild( iframe );

      // Create a cacheable copy of the iframe document on first call.
      // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
      // document to it; WebKit & Firefox won't allow reusing the iframe document.
      if ( !iframeDoc || !iframe.createElement ) {
        iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
        iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
        iframeDoc.close();
      }

      elem = iframeDoc.createElement( nodeName );

      iframeDoc.body.appendChild( elem );

      display = jQuery.css( elem, "display" );
      body.removeChild( iframe );
    }

    // Store the correct default display
    elemdisplay[ nodeName ] = display;
  }

  return elemdisplay[ nodeName ];
}




var getOffset,
  rtable = /^t(?:able|d|h)$/i,
  rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
  getOffset = function( elem, doc, docElem, box ) {
    try {
      box = elem.getBoundingClientRect();
    } catch(e) {}

    // Make sure we're not dealing with a disconnected DOM node
    if ( !box || !jQuery.contains( docElem, elem ) ) {
      return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
    }

    var body = doc.body,
      win = getWindow( doc ),
      clientTop  = docElem.clientTop  || body.clientTop  || 0,
      clientLeft = docElem.clientLeft || body.clientLeft || 0,
      scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
      scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
      top  = box.top  + scrollTop  - clientTop,
      left = box.left + scrollLeft - clientLeft;

    return { top: top, left: left };
  };

} else {
  getOffset = function( elem, doc, docElem ) {
    var computedStyle,
      offsetParent = elem.offsetParent,
      prevOffsetParent = elem,
      body = doc.body,
      defaultView = doc.defaultView,
      prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
      top = elem.offsetTop,
      left = elem.offsetLeft;

    while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
      if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
        break;
      }

      computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
      top  -= elem.scrollTop;
      left -= elem.scrollLeft;

      if ( elem === offsetParent ) {
        top  += elem.offsetTop;
        left += elem.offsetLeft;

        if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
          top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
          left += parseFloat( computedStyle.borderLeftWidth ) || 0;
        }

        prevOffsetParent = offsetParent;
        offsetParent = elem.offsetParent;
      }

      if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
        top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
        left += parseFloat( computedStyle.borderLeftWidth ) || 0;
      }

      prevComputedStyle = computedStyle;
    }

    if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
      top  += body.offsetTop;
      left += body.offsetLeft;
    }

    if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
      top  += Math.max( docElem.scrollTop, body.scrollTop );
      left += Math.max( docElem.scrollLeft, body.scrollLeft );
    }

    return { top: top, left: left };
  };
}

jQuery.fn.offset = function( options ) {
  if ( arguments.length ) {
    return options === undefined ?
      this :
      this.each(function( i ) {
        jQuery.offset.setOffset( this, options, i );
      });
  }

  var elem = this[0],
    doc = elem && elem.ownerDocument;

  if ( !doc ) {
    return null;
  }

  if ( elem === doc.body ) {
    return jQuery.offset.bodyOffset( elem );
  }

  return getOffset( elem, doc, doc.documentElement );
};

jQuery.offset = {

  bodyOffset: function( body ) {
    var top = body.offsetTop,
      left = body.offsetLeft;

    if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
      top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
      left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
    }

    return { top: top, left: left };
  },

  setOffset: function( elem, options, i ) {
    var position = jQuery.css( elem, "position" );

    // set position first, in-case top/left are set even on static elem
    if ( position === "static" ) {
      elem.style.position = "relative";
    }

    var curElem = jQuery( elem ),
      curOffset = curElem.offset(),
      curCSSTop = jQuery.css( elem, "top" ),
      curCSSLeft = jQuery.css( elem, "left" ),
      calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
      props = {}, curPosition = {}, curTop, curLeft;

    // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
    if ( calculatePosition ) {
      curPosition = curElem.position();
      curTop = curPosition.top;
      curLeft = curPosition.left;
    } else {
      curTop = parseFloat( curCSSTop ) || 0;
      curLeft = parseFloat( curCSSLeft ) || 0;
    }

    if ( jQuery.isFunction( options ) ) {
      options = options.call( elem, i, curOffset );
    }

    if ( options.top != null ) {
      props.top = ( options.top - curOffset.top ) + curTop;
    }
    if ( options.left != null ) {
      props.left = ( options.left - curOffset.left ) + curLeft;
    }

    if ( "using" in options ) {
      options.using.call( elem, props );
    } else {
      curElem.css( props );
    }
  }
};


jQuery.fn.extend({

  position: function() {
    if ( !this[0] ) {
      return null;
    }

    var elem = this[0],

    // Get *real* offsetParent
    offsetParent = this.offsetParent(),

    // Get correct offsets
    offset       = this.offset(),
    parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

    // Subtract element margins
    // note: when an element has margin: auto the offsetLeft and marginLeft
    // are the same in Safari causing offset.left to incorrectly be 0
    offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
    offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

    // Add offsetParent borders
    parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
    parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

    // Subtract the two offsets
    return {
      top:  offset.top  - parentOffset.top,
      left: offset.left - parentOffset.left
    };
  },

  offsetParent: function() {
    return this.map(function() {
      var offsetParent = this.offsetParent || document.body;
      while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent;
    });
  }
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
  var top = /Y/.test( prop );

  jQuery.fn[ method ] = function( val ) {
    return jQuery.access( this, function( elem, method, val ) {
      var win = getWindow( elem );

      if ( val === undefined ) {
        return win ? (prop in win) ? win[ prop ] :
          jQuery.support.boxModel && win.document.documentElement[ method ] ||
            win.document.body[ method ] :
          elem[ method ];
      }

      if ( win ) {
        win.scrollTo(
          !top ? val : jQuery( win ).scrollLeft(),
           top ? val : jQuery( win ).scrollTop()
        );

      } else {
        elem[ method ] = val;
      }
    }, method, val, arguments.length, null );
  };
});

function getWindow( elem ) {
  return jQuery.isWindow( elem ) ?
    elem :
    elem.nodeType === 9 ?
      elem.defaultView || elem.parentWindow :
      false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  var clientProp = "client" + name,
    scrollProp = "scroll" + name,
    offsetProp = "offset" + name;

  // innerHeight and innerWidth
  jQuery.fn[ "inner" + name ] = function() {
    var elem = this[0];
    return elem ?
      elem.style ?
      parseFloat( jQuery.css( elem, type, "padding" ) ) :
      this[ type ]() :
      null;
  };

  // outerHeight and outerWidth
  jQuery.fn[ "outer" + name ] = function( margin ) {
    var elem = this[0];
    return elem ?
      elem.style ?
      parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
      this[ type ]() :
      null;
  };

  jQuery.fn[ type ] = function( value ) {
    return jQuery.access( this, function( elem, type, value ) {
      var doc, docElemProp, orig, ret;

      if ( jQuery.isWindow( elem ) ) {
        // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
        doc = elem.document;
        docElemProp = doc.documentElement[ clientProp ];
        return jQuery.support.boxModel && docElemProp ||
          doc.body && doc.body[ clientProp ] || docElemProp;
      }

      // Get document width or height
      if ( elem.nodeType === 9 ) {
        // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
        doc = elem.documentElement;

        // when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]
        // so we can't use max, as it'll choose the incorrect offset[Width/Height]
        // instead we use the correct client[Width/Height]
        // support:IE6
        if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
          return doc[ clientProp ];
        }

        return Math.max(
          elem.body[ scrollProp ], doc[ scrollProp ],
          elem.body[ offsetProp ], doc[ offsetProp ]
        );
      }

      // Get width or height on the element
      if ( value === undefined ) {
        orig = jQuery.css( elem, type );
        ret = parseFloat( orig );
        return jQuery.isNumeric( ret ) ? ret : orig;
      }

      // Set the width or height on the element
      jQuery( elem ).css( type, value );
    }, type, value, arguments.length, null );
  };
});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
  define( "jquery", [], function () { return jQuery; } );
}



})( window );

// eval() prevents Closure Compiler from messing this up.
eval("var jQuery = window.jQuery.noConflict(true); var $ = jQuery; $j = $;");


// assets/js/bundle/third_party/jquery/outerhtml.js
goog.provide("optly.jquery.outerhtml");

goog.require("optly.jquery");

// http://brandonaaron.net/blog/2007/06/17/jquery-snippets-outerhtml/

(function ($) {
  jQuery.fn.outerHtml = function() {
    return $("<div>").append(this.eq(0).clone()).html();
  };
})($);


// assets/js/bundle/enums/url_condition_type.js
goog.provide("optly.enums.UrlConditionType");

/**
 * @enum {string}
 */
optly.enums.UrlConditionType = {
  EXACT: "exact",
  REGEX: "regex",
  SIMPLE: "simple",
  SUBSTRING: "substring"
};


// assets/js/bundle/enums/inbound_form_lead_type.js
goog.provide("optly.enums.InboundFormLeadType");

/**
 * Used in Marketo and SalesForce integation.
 * Field name: Inbound_Lead_Form_Type__c
 *
 * @enum {string}
 */
optly.enums.InboundFormLeadType = {
  CONTACT_SALES: "Contact Sales",
  DEMO_REQUESTED: "Demo Request",
  OPTIMIZELY_FOR_AGENCIES: "Optimizely for Agencies",
  OPTIMIZELY_FOR_DEVELOPERS: "Optimizely for Developers",
  OPTIMIZELY_FOR_ECOMMERCE: "Optimizely for E-Commerce",
  OPTIMIZELY_FOR_ENTERPRISES: "Optimizely for Enterprises",
  OPTIMIZELY_FOR_PUBLISHERS: "Optimizely for Publishers",
  OPTIMIZELY_FOR_SMALL_BUSINESS: "Optimizely for Small Business",
  AFFILIATE_PROGRAM: "Affiliate Program",
  CERTIFIED_PARTNER_PROGRAM: "Certified Partner Program",
  MOBILE_LAUNCH_NOTIFICATION_REQUEST: "Mobile Launch Notification Request"
};


// assets/js/bundle/enums/html_tag_type.js
goog.provide("optly.enums.HtmlTagType");

/**
 * @enum {string}
 */
optly.enums.HtmlTagType = {
  a: "Link",
  abbr: "Abbreviation",
  area: "Image Map Area",
  b: "Bold Text",
  big: "Big Text",
  blockquote: "Block Quote",
  br: "Line Break",
  cite: "Citation",
  col: "Column",
  colgroup: "Column Group",
  dd: "Definition List Definition",
  del: "Deleted Text",
  dfn: "Definition",
  dir: "Directory List",
  div: "Division",
  dl: "Definition List",
  dt: "Definition List Item",
  em: "Emphasized Text",
  embed: "Embedded Object",
  eventsource: "Event Source",
  figcaption: "Figure Caption",
  h1: "Headline",
  h2: "Headline",
  h3: "Headline",
  h4: "Headline",
  h5: "Headline",
  h6: "Headline",
  hgroup: "Section Header",
  hr: "Horizonal Rule",
  i: "Italic Text",
  iframe: "iFrame",
  img: "Image",
  input: "Input Field",
  ins: "Inserted Text",
  kbd: "Keyboard Text",
  li: "List Item",
  map: "Image Map",
  mark: "Marked Text",
  menu: "Menu List",
  nav: "Navigation Section",
  object: "Embedded Object",
  ol: "Ordered List",
  optgroup: "Option Group",
  option: "Selection Option",
  p: "Paragraph",
  param: "Embedded Object Parameter",
  pre: "Preformatted Text",
  q: "Quotation",
  samp: "Sample Output",
  select: "Selection List",
  small: "Small Text",
  strong: "Strong Text",
  sub: "Subscript Text",
  sup: "Superscript Text",
  tbody: "Table Body",
  td: "Table Data",
  textarea: "Text Field",
  tfoot: "Table Footer",
  th: "Table Header",
  thead: "Table Header",
  tr: "Table Row",
  tt: "Typewriter Text",
  u: "Underlined Text",
  ul: "Unordered List",
  'var': "Variable"
};


// assets/js/bundle/enums/before_unload_button_text.js
goog.provide("optly.enums.BeforeUnloadButtonText");

/**
 * @enum {string}
 */
optly.enums.BeforeUnloadButtonText = {
  CHROME: tr("Stay on this Page"),
  FIREFOX: tr("Cancel"),
  SAFARI: tr("Cancel")
};


// assets/js/bundle/enums/goal_metric_type.js
goog.provide("optly.enums.GoalMetricType");

/**
 * @enum {number}
 */
optly.enums.GoalMetricType = {
  CONVERSION_RATE: 0,
  CONVERSIONS_PER_VISITOR: 1
};

// assets/js/bundle/enums/experiment_type.js
goog.provide("optly.enums.ExperimentType");

/**
 * @enum {string}
 */
optly.enums.ExperimentType = {
  AB: "ab",
  MULTIPAGE: "multipage",
  MULTIVARIATE: "multivariate"
};


// assets/js/bundle/enums/tracking_event_action.js
goog.provide("optly.enums.TrackingEventAction");

/**
 * Enum for Google Analytics categories used in trackEventGA in analytics.js.
 * Actions correspond to behaviors on features. Common ones should be enumerated here.
 * https://developers.google.com/analytics/devguides/collection/gajs/eventTrackerGuide#Actions
 * @enum {string}
 */
optly.enums.TrackingEventAction = {
  ADD: "add",
  APPLY: "apply",
  CANCEL: "cancel",
  CLICK: "click",
  COLLAPSE: "collapse",
  CREATE: "create",
  EDIT: "edit",
  EXPAND: "expand",
  OPEN: "open",
  REMOVE: "remove",
  REMOVE_DUPLICATE_LINE: "removeDuplicateLine",
  SHOW_DIALOG: "showDialog",
  TOGGLE: "toggle"
};


// assets/js/bundle/enums/scroller_go_to_type.js
goog.provide("optly.enums.ScrollerGoToType");

/**
 * @enum {string}
 */
optly.enums.ScrollerGoToType = {
  CURRENT: "current",
  FIRST: "first",
  NEXT: "next",
  PREVIOUS: "previous",
  RESET: "reset"
};


// assets/js/bundle/enums/experiment_status_type.js
goog.provide("optly.enums.ExperimentStatusType");

/**
 * Enum for types in experiments.py.
 *
 * @enum {string}
 */
optly.enums.ExperimentStatusType = {
  ARCHIVED: "Archived",
  DELETED: "Deleted",
  ERROR: "Error",
  NOT_STARTED: "Not started",
  PAUSED: "Paused",
  PAUSING: "Pausing...",
  RUNNING: "Running",
  STARTING: "Starting..."
};


// assets/js/bundle/enums/tracking_event_category.js
goog.provide("optly.enums.TrackingEventCategory");

/**
 * Enum for Google Analytics categories used in trackEventGA in analytics.js.
 * Categories correspond to distinct features.
 * https://developers.google.com/analytics/devguides/collection/gajs/eventTrackerGuide#Categories
 * @enum {string}
 */

optly.enums.TrackingEventCategory = {
  PREVIEW: "Preview",
  AUDIENCES: "Audiences",
  RESULTS: "Results",
  WEB_EDITOR: "Web Editor"
};



// assets/js/bundle/enums/main.js
goog.provide("optly.enums.main");

goog.require("optly.enums.BeforeUnloadButtonText");
goog.require("optly.enums.ExperimentStatusType");
goog.require("optly.enums.ExperimentType");
goog.require("optly.enums.GoalMetricType");
goog.require("optly.enums.HtmlTagType");
goog.require("optly.enums.InboundFormLeadType");
goog.require("optly.enums.ScrollerGoToType");
goog.require("optly.enums.UrlConditionType");
goog.require("optly.enums.TrackingEventAction");
goog.require("optly.enums.TrackingEventCategory");

/**
 * Enum for types in accounts.py.
 *
 *  @enum {string}
 */
optly.enums.ProjectStatusType = {
  ACTIVE: "Active",
  ARCHIVED: "Archived"
};

/**
 *  @enum {string}
 */
optly.enums.ProjectPlatformType = {
  ANDROID: "android",
  IOS: "ios",
  WEB: "web"
};

optly.enums.MobilePlatformTypes = [optly.enums.ProjectPlatformType.ANDROID, optly.enums.ProjectPlatformType.IOS];

optly.enums.GoalType = {
  CLICK: 0,
  CUSTOM_EVENT: 1,
  ENGAGEMENT: 2,
  PAGEVIEW: 3,
  REVENUE: 4,
  MOBILE_TAP_EVENT: 5,
  MOBILE_VIEW_EVENT: 6
};

optly.enums.Features = {
  ACTIVITY_LOG: "activity-log",
  AD_CAMPAIGN_TARGETING: 'ad-campaign-targeting',
  ADD_USER: "add user",
  ARCHIVE_EXPERIMENT: "archive-experiment",
  ATTACHED_REVENUE: "attached-revenue",
  AUDIENCE_API_ONLY: 'audience-api-only',
  AUDIENCE_EXPLORER: 'audience-explorer',
  AUDIENCE_TARGETING: "audience-targeting",
  AUDIT_LOG: "audit-log",
  BANDITS: "bandits",
  BUCKETED_REVENUE: "bucketed-revenue",
  CREATE_EXPERIMENT: "create-experiment",
  CREATE_AUDIENCE: "create-audience",
  CREATE_DIMENSION: "create-dimension",
  CREATE_ANDROID_PROJECT: "create-android-project",
  CREATE_IOS_PROJECT: "create-ios-project",
  CREATE_PROJECT: "create-project",
  CROSS_BROWSER_TESTING: "cross browser testing",
  CUSTOM_SEGMENTS: "custom segments",
  DEFAULT_SEGMENT_TARGETING: "default-segment-targeting",
  DELETE_EXPERIMENT: "delete-experiment",
  DELETE_USER: "delete-user",
  DELETE_DIMENSION: "delete-dimension",
  EDIT_INTEGRATION: 'edit-project-integration',
  EDIT_PROJECT: "edit-project",
  EDIT_VARIATION_CODE_AFTER_CANCEL: "edit-variation-code-after-cancel",
  EDITOR_DEBUG: "editor-debug",
  EXECUTIVE_SUMMARY: 'executive-summary',
  EXPORT_EVENTS: "export events",
  GENERATE_TOKEN: "modify-account-tokens",
  GEOTARGETING: "geotargeting",
  INTEGRATION_DASHBOARD: "integration-dashboard",
  INVITE: "invite",
  LIST_TARGETING: "list-targeting",
  MOBILE_IN_BROWSER: "mobile-in-browser",
  MODIFY_PAUSED_EXPERIMENT: "modify-paused-experiment",
  MODIFY_RUNNING_EXPERIMENT: "modify-running-experiment",
  MODIFY_AUDIENCE: "modify-audience",
  MODIFY_DIMENSION: "modify-dimension",
  MULTICHANNEL_EXPERIMENTS: 'multichannel-experiments',
  MULTIPAGE_TESTING: "multipage testing",
  MULTIVARIATE_TESTING: "multivariate testing",
  PAUSE_EXPERIMENT: "pause-experiment",
  PREMIUM_DEFAULT_SEGMENTS: "premium default segments",
  PREVIEW_DEBUG: "preview-debug",
  RESET_RESULTS: "reset-results",
  SCHEDULING: "scheduling",
  SEGMENTED_RESULTS: "segmented results",
  SEQUENTIAL_STATISTICS: 'sequential-statistics',
  SHOW_BILLING: "billing",
  SOURCE_TARGETING: 'source-targeting',
  START_EXPERIMENT: "start-experiment",
  TIME_AND_DAY_TARGETING: "time-and-day-targeting",
  TWILIO: "twilio integration",
  USER_PERMISSIONS: "user-permissions",
  VIEW_AUDIT_LOG: "view-audit-log",
  VIEW_COLLABORATORS: "view-collaborators",
  VIEW_DASHBOARD2: "view-dashboard2",
  VUE_EDITOR_DRAWER: "vue-editor-drawer",
  /* Analytics Integrations */
  AT_INTERNET_INTEGRATION: 'at-internet',
  CHARTBEAT_INTEGRATION: 'chartbeat',
  GOOGLE_ANALYTICS_INTEGRATION: 'google-analytics',
  KISSMETRICS_INTEGRATION: 'kissmetrics',
  MIXPANEL_INTEGRATION: 'mixpanel',
  UNIVERSAL_ANALYTICS_INTEGRATION: 'universal-analytics'
};


// assets/js/bundle/third_party/jquery/contextmenu.js
goog.provide("optly.jquery.contextmenu");

goog.require("optly.jquery");

/**
 * adapted from http://plugins.jquery.com/project/wdContextMenu
 * - added rules to hide items
 * - left click and right click both open context menu
 * - added onHide event
 * - hide menu on window resize
 * - added alias in call to click handler
 * - added hideTrailingSplitLines()
 */

(function($) {
    function returnfalse() { return false; };
    $.fn.contextmenu = function(option) {
        option = $.extend({ alias: "cmroot", width: 150 }, option);
        var ruleName = null, target = null,
          groups = {}, mitems = {}, actions = {}, showGroups = [],
          itemTpl = "<div class='b-m-$[type]' unselectable=on><nobr unselectable=on><img src='$[icon]' align='absmiddle'/><span unselectable=on>$[text]</span></nobr></div>";
        var gTemplet = $("<div/>").addClass("b-m-mpanel").attr("unselectable", "on").css("display", "none");
        var iTemplet = $("<div/>").addClass("b-m-item").attr("unselectable", "on");
        var sTemplet = $("<div/>").addClass("b-m-split");
        //build group item, which has sub items
        var buildGroup = function(obj) {
            groups[obj.alias] = this;
            this.gidx = obj.alias;
            this.id = obj.alias;
            if (obj.disable) {
                this.disable = obj.disable;
                this.className = "b-m-idisable";
            }
            else if (obj.hide) {
                this.hide = obj.hide;
                this.className = "b-m-ihide";
            }
            $(this).width(obj.width).click(returnfalse).mousedown(returnfalse).appendTo($("body"));
            obj = null;
            return this;
        };
        var buildItem = function(obj) {
            var T = this;
            T.idx = obj.alias;
            T.gidx = obj.gidx;
            T.data = obj;
            T.innerHTML = itemTpl.replace(/\$\[([^\]]+)\]/g, function() {
                return obj[arguments[1]];
            });
            if (obj.disable) {
                T.disable = obj.disable;
                T.className = "b-m-idisable";
            }
            else if (obj.hide) {
                T.hide = obj.hide;
                T.className = "b-m-ihide";
            }
            obj.items && (T.group = true);
            obj.action && (actions[obj.alias] = obj.action);
            mitems[obj.alias] = T;
            T = obj = null;
            return this;
        };
        //add new items
        var addItems = function(gidx, items) {
            var tmp = null;
            for (var i = 0; i < items.length; i++) {
                if (items[i].type == "splitLine") {
                    //split line
                    tmp = sTemplet.clone()[0];
                } else {
                    items[i].gidx = gidx;
                    if (items[i].type == "group") {
                        //group
                        buildGroup.apply(gTemplet.clone()[0], [items[i]]);
                        arguments.callee(items[i].alias, items[i].items);
                        items[i].type = "arrow";
                        tmp = buildItem.apply(iTemplet.clone()[0], [items[i]]);
                    } else {
                        //normal item
                        items[i].type = "ibody";
                        tmp = buildItem.apply(iTemplet.clone()[0], [items[i]]);
                        $(tmp).click(function(e) {
                            if (!this.disable && !this.hide) {
                                if ($.isFunction(actions[this.idx])) {
                                    actions[this.idx].call(this, target, this.idx);
                                }
                                hideMenuPane();
                            }
                            return false;
                        });

                    } //end if
                    $(tmp).bind("click", returnfalse)
                          .bind("contextmenu", returnfalse)
                          .hover(overItem, outItem);
                }
                groups[gidx].appendChild(tmp);
                tmp = items[i] = items[i].items = null;
            } //end for
            gidx = items = null;
        };
        var overItem = function(e) {
            //menu item is disabled
            if (this.disable || this.hide)
                return false;
            hideMenuPane.call(groups[this.gidx]);
            //has sub items
            if (this.group) {
                var pos = $(this).offset();
                var width = $(this).outerWidth();
                showMenuGroup.apply(groups[this.idx], [pos, width]);
            }
            this.className = "b-m-ifocus";
            return false;
        };
        //menu loses focus
        var outItem = function(e) {
            //disabled or hidden item
            if (this.disable || this.hide)
                return false;
            if (!this.group) {
                //normal item
                this.className = "b-m-item";
            } //Endif
            return false;
        };
        //show menu group at specified position
        var showMenuGroup = function(pos, width) {
            var bwidth = $("body").width();
            var bheight = document.documentElement.clientHeight;
            var mwidth = $(this).outerWidth();
            var mheight = $(this).outerHeight();
            pos.left = (pos.left + width + mwidth > bwidth) ? (pos.left - mwidth < 0 ? 0 : pos.left - mwidth) : pos.left + width;
            pos.top = (pos.top + mheight > bheight) ? (pos.top - mheight + (width > 0 ? 25 : 0) < 0 ? 0 : pos.top - mheight + (width > 0 ? 25 : 0)) : pos.top;
            $(this).css(pos).show();
            showGroups.push(this.gidx);
        };
        //to hide menu
        var hideMenuPane = function() {
            var alias = null;
            for (var i = showGroups.length - 1; i >= 0; i--) {
                if (showGroups[i] == this.gidx)
                    break;
                alias = showGroups.pop();
                groups[alias].style.display = "none";
                mitems[alias] && (mitems[alias].className = "b-m-item");
            } //Endfor
            if (!this.gidx && $.isFunction(option.onHide)) {
                option.onHide();
            }
            //CollectGarbage();
        };
        function applyRule(rule) {
            if (ruleName && ruleName == rule.name)
                return false;
            // reset
            for (var i in mitems) {
                disable(i, false);
                hide(i, false);
            }
            // disable
            if ("disabled_items" in rule)
              for (var i = 0; i < rule.disabled_items.length; i++)
                disable(rule.disabled_items[i], true);
            // hide
            if ("hidden_items" in rule)
              for (var i = 0; i < rule.hidden_items.length; i++)
                hide(rule.hidden_items[i], true);

            hideTrailingSplitLines();
            ruleName = rule.name;
        };
        function disable(alias, disabled) {
            var item = mitems[alias];
            item.className = (item.disable = item.lastChild.disabled = disabled) ? "b-m-idisable" : "b-m-item";
        };
        function hide(alias, hidden) {
            var item = mitems[alias];
            item.className = (item.hide = item.lastChild.hidden = hidden) ? "b-m-ihide" : "b-m-item";
        };
        function hideTrailingSplitLines() {
          for (var gidx in groups) {
            var items = $(groups[gidx]).children();
            var lastVisibleItemFound = false;

            for (var i = items.length - 1; i >= 0; i--) {
              var item = items.eq(i);

              if (item.hasClass("b-m-split")) {
                item.toggle(lastVisibleItemFound);
              }
              else if (!lastVisibleItemFound && !item.hasClass("b-m-ihide")) {
                lastVisibleItemFound = true;
              }
            }
          }
        };

        /* to show menu */
        function showMenu(e, menutarget) {
            target = menutarget;
            showMenuGroup.call(groups[option.alias], { left: e.pageX, top: e.pageY }, 0);
            $(document).one('mousedown', hideMenuPane);
            $(window).one('resize', hideMenuPane);
        }
        var $root = $("#" + option.alias);
        var root = null;
        if ($root.length != 0) {
          $root.remove();
        }
        root = buildGroup.apply(gTemplet.clone()[0], [option]);
        root.applyrule = applyRule;
        root.showMenu = showMenu;
        addItems(option.alias, option.items);

        // Handle left and right clicks.
        function handleClick(e) {
            var bShowContext = (option.onContextMenu && $.isFunction(option.onContextMenu)) ? option.onContextMenu.call(this, e) : true;
            if (bShowContext) {
                if (option.onShow && $.isFunction(option.onShow)) {
                    option.onShow.call(this, root);
                }
                root.showMenu(e, this);
            }
            return false;
        }

        var me = $(this).each(function() {
            return $(this).bind("click", handleClick)
                          .bind("contextmenu", handleClick);
        });
        //to apply rule
        if (option.rule) {
            applyRule(option.rule);
        }
        gTemplet = iTemplet = sTemplet = itemTpl = buildGroup = buildItem = null;
        addItems = overItem = outItem = null;
        //CollectGarbage();
        return me;
    }

})(jQuery);


// assets/js/bundle/third_party/jquery/dataTables.js
goog.provide("optly.jquery.dataTables");

goog.require("optly.jquery");

/**
 * @summary     DataTables
 * @description Paginate, search and sort HTML tables
 * @version     1.9.3
 * @file        jquery.dataTables.js
 * @author      Allan Jardine (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 *
 * @copyright Copyright 2008-2012 Allan Jardine, all rights reserved.
 *
 * This source file is free software, under either the GPL v2 license or a
 * BSD style license, available at:
 *   http://datatables.net/license_gpl2
 *   http://datatables.net/license_bsd
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $, jQuery,_fnExternApiFunc,_fnInitialise,_fnInitComplete,_fnLanguageCompat,_fnAddColumn,_fnColumnOptions,_fnAddData,_fnCreateTr,_fnGatherData,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnServerParams,_fnAddOptionsHtml,_fnFeatureHtmlTable,_fnScrollDraw,_fnAdjustColumnSizing,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnBuildSearchArray,_fnBuildSearchRow,_fnFilterCreateSearch,_fnDataToSearch,_fnSort,_fnSortAttachListener,_fnSortingClasses,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnFeatureHtmlLength,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnNodeToDataIndex,_fnVisbleColumns,_fnCalculateEnd,_fnConvertToWidth,_fnCalculateColumnWidths,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnDetectType,_fnSettingsFromNode,_fnGetDataMaster,_fnGetTrNodes,_fnGetTdNodes,_fnEscapeRegex,_fnDeleteIndex,_fnReOrderIndex,_fnColumnOrdering,_fnLog,_fnClearTable,_fnSaveState,_fnLoadState,_fnCreateCookie,_fnReadCookie,_fnDetectHeader,_fnGetUniqueThs,_fnScrollBarWidth,_fnApplyToChildren,_fnMap,_fnGetRowData,_fnGetCellData,_fnSetCellData,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnApplyColumnDefs,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnJsonString,_fnRender,_fnNodeToColumnIndex,_fnInfoMacros,_fnBrowserDetect,_fnGetColumns*/

(/** @lends <global> */function($, window, document, undefined) {
  /**
   * DataTables is a plug-in for the jQuery Javascript library. It is a
   * highly flexible tool, based upon the foundations of progressive
   * enhancement, which will add advanced interaction controls to any
   * HTML table. For a full list of features please refer to
   * <a href="http://datatables.net">DataTables.net</a>.
   *
   * Note that the <i>DataTable</i> object is not a global variable but is
   * aliased to <i>jQuery.fn.DataTable</i> and <i>jQuery.fn.dataTable</i> through which
   * it may be  accessed.
   *
   *  @class
   *  @param {object} [oInit={}] Configuration object for DataTables. Options
   *    are defined by {@link DataTable.defaults}
   *  @requires jQuery 1.3+
   *
   *  @example
   *    // Basic initialisation
   *    $(document).ready( function {
	 *      $('#example').dataTable();
	 *    } );
   *
   *  @example
   *    // Initialisation with configuration options - in this case, disable
   *    // pagination and sorting.
   *    $(document).ready( function {
	 *      $('#example').dataTable( {
	 *        "bPaginate": false,
	 *        "bSort": false 
	 *      } );
	 *    } );
   */
  var DataTable = function( oInit )
  {


    /**
     * Add a column to the list used for the table with default values
     *  @param {object} oSettings dataTables settings object
     *  @param {node} nTh The th element for this column
     *  @memberof DataTable#oApi
     */
    function _fnAddColumn( oSettings, nTh )
    {
      var oDefaults = DataTable.defaults.columns;
      var iCol = oSettings.aoColumns.length;
      var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
        "sSortingClass": oSettings.oClasses.sSortable,
        "sSortingClassJUI": oSettings.oClasses.sSortJUI,
        "nTh": nTh ? nTh : document.createElement('th'),
        "sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
        "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
        "mData": oDefaults.mData ? oDefaults.oDefaults : iCol
      } );
      oSettings.aoColumns.push( oCol );

      /* Add a column specific filter */
      if ( oSettings.aoPreSearchCols[ iCol ] === undefined || oSettings.aoPreSearchCols[ iCol ] === null )
      {
        oSettings.aoPreSearchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch );
      }
      else
      {
        var oPre = oSettings.aoPreSearchCols[ iCol ];

        /* Don't require that the user must specify bRegex, bSmart or bCaseInsensitive */
        if ( oPre.bRegex === undefined )
        {
          oPre.bRegex = true;
        }

        if ( oPre.bSmart === undefined )
        {
          oPre.bSmart = true;
        }

        if ( oPre.bCaseInsensitive === undefined )
        {
          oPre.bCaseInsensitive = true;
        }
      }

      /* Use the column options function to initialise classes etc */
      _fnColumnOptions( oSettings, iCol, null );
    }


    /**
     * Apply options for a column
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iCol column index to consider
     *  @param {object} oOptions object with sType, bVisible and bSearchable etc
     *  @memberof DataTable#oApi
     */
    function _fnColumnOptions( oSettings, iCol, oOptions )
    {
      var oCol = oSettings.aoColumns[ iCol ];

      /* User specified column options */
      if ( oOptions !== undefined && oOptions !== null )
      {
        /* Backwards compatibility for mDataProp */
        if ( oOptions.mDataProp && !oOptions.mData )
        {
          oOptions.mData = oOptions.mDataProp;
        }

        if ( oOptions.sType !== undefined )
        {
          oCol.sType = oOptions.sType;
          oCol._bAutoType = false;
        }

        $.extend( oCol, oOptions );
        _fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );

        /* iDataSort to be applied (backwards compatibility), but aDataSort will take
         * priority if defined
         */
        if ( oOptions.iDataSort !== undefined )
        {
          oCol.aDataSort = [ oOptions.iDataSort ];
        }
        _fnMap( oCol, oOptions, "aDataSort" );
      }

      /* Cache the data get and set functions for speed */
      var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
      var mData = _fnGetObjectDataFn( oCol.mData );

      oCol.fnGetData = function (oData, sSpecific) {
        var innerData = mData( oData, sSpecific );

        if ( oCol.mRender && (sSpecific && sSpecific !== '') )
        {
          return mRender( innerData, sSpecific, oData );
        }
        return innerData;
      };
      oCol.fnSetData = _fnSetObjectDataFn( oCol.mData );

      /* Feature sorting overrides column specific when off */
      if ( !oSettings.oFeatures.bSort )
      {
        oCol.bSortable = false;
      }

      /* Check that the class assignment is correct for sorting */
      if ( !oCol.bSortable ||
        ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1) )
      {
        oCol.sSortingClass = oSettings.oClasses.sSortableNone;
        oCol.sSortingClassJUI = "";
      }
      else if ( oCol.bSortable ||
        ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1) )
      {
        oCol.sSortingClass = oSettings.oClasses.sSortable;
        oCol.sSortingClassJUI = oSettings.oClasses.sSortJUI;
      }
      else if ( $.inArray('asc', oCol.asSorting) != -1 && $.inArray('desc', oCol.asSorting) == -1 )
      {
        oCol.sSortingClass = oSettings.oClasses.sSortableAsc;
        oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIAscAllowed;
      }
      else if ( $.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) != -1 )
      {
        oCol.sSortingClass = oSettings.oClasses.sSortableDesc;
        oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIDescAllowed;
      }
    }


    /**
     * Adjust the table column widths for new data. Note: you would probably want to
     * do a redraw after calling this function!
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnAdjustColumnSizing ( oSettings )
    {
      /* Not interested in doing column width calculation if auto-width is disabled */
      if ( oSettings.oFeatures.bAutoWidth === false )
      {
        return false;
      }

      _fnCalculateColumnWidths( oSettings );
      for ( var i=0 , iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        oSettings.aoColumns[i].nTh.style.width = oSettings.aoColumns[i].sWidth;
      }
    }


    /**
     * Covert the index of a visible column to the index in the data array (take account
     * of hidden columns)
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iMatch Visible column index to lookup
     *  @returns {int} i the data index
     *  @memberof DataTable#oApi
     */
    function _fnVisibleToColumnIndex( oSettings, iMatch )
    {
      var aiVis = _fnGetColumns( oSettings, 'bVisible' );

      return typeof aiVis[iMatch] === 'number' ?
        aiVis[iMatch] :
        null;
    }


    /**
     * Covert the index of an index in the data array and convert it to the visible
     *   column index (take account of hidden columns)
     *  @param {int} iMatch Column index to lookup
     *  @param {object} oSettings dataTables settings object
     *  @returns {int} i the data index
     *  @memberof DataTable#oApi
     */
    function _fnColumnIndexToVisible( oSettings, iMatch )
    {
      var aiVis = _fnGetColumns( oSettings, 'bVisible' );
      var iPos = $.inArray( iMatch, aiVis );

      return iPos !== -1 ? iPos : null;
    }


    /**
     * Get the number of visible columns
     *  @param {object} oSettings dataTables settings object
     *  @returns {int} i the number of visible columns
     *  @memberof DataTable#oApi
     */
    function _fnVisbleColumns( oSettings )
    {
      return _fnGetColumns( oSettings, 'bVisible' ).length;
    }


    /**
     * Get an array of column indexes that match a given property
     *  @param {object} oSettings dataTables settings object
     *  @param {string} sParam Parameter in aoColumns to look for - typically
     *    bVisible or bSearchable
     *  @returns {array} Array of indexes with matched properties
     *  @memberof DataTable#oApi
     */
    function _fnGetColumns( oSettings, sParam )
    {
      var a = [];

      $.map( oSettings.aoColumns, function(val, i) {
        if ( val[sParam] ) {
          a.push( i );
        }
      } );

      return a;
    }


    /**
     * Get the sort type based on an input string
     *  @param {string} sData data we wish to know the type of
     *  @returns {string} type (defaults to 'string' if no type can be detected)
     *  @memberof DataTable#oApi
     */
    function _fnDetectType( sData )
    {
      var aTypes = DataTable.ext.aTypes;
      var iLen = aTypes.length;

      for ( var i=0 ; i<iLen ; i++ )
      {
        var sType = aTypes[i]( sData );
        if ( sType !== null )
        {
          return sType;
        }
      }

      return 'string';
    }


    /**
     * Figure out how to reorder a display list
     *  @param {object} oSettings dataTables settings object
     *  @returns array {int} aiReturn index list for reordering
     *  @memberof DataTable#oApi
     */
    function _fnReOrderIndex ( oSettings, sColumns )
    {
      var aColumns = sColumns.split(',');
      var aiReturn = [];

      for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        for ( var j=0 ; j<iLen ; j++ )
        {
          if ( oSettings.aoColumns[i].sName == aColumns[j] )
          {
            aiReturn.push( j );
            break;
          }
        }
      }

      return aiReturn;
    }


    /**
     * Get the column ordering that DataTables expects
     *  @param {object} oSettings dataTables settings object
     *  @returns {string} comma separated list of names
     *  @memberof DataTable#oApi
     */
    function _fnColumnOrdering ( oSettings )
    {
      var sNames = '';
      for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        sNames += oSettings.aoColumns[i].sName+',';
      }
      if ( sNames.length == iLen )
      {
        return "";
      }
      return sNames.slice(0, -1);
    }


    /**
     * Take the column definitions and static columns arrays and calculate how
     * they relate to column indexes. The callback function will then apply the
     * definition found for a column to a suitable configuration object.
     *  @param {object} oSettings dataTables settings object
     *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
     *  @param {array} aoCols The aoColumns array that defines columns individually
     *  @param {function} fn Callback function - takes two parameters, the calculated
     *    column index and the definition for that column.
     *  @memberof DataTable#oApi
     */
    function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
    {
      var i, iLen, j, jLen, k, kLen;

      // Column definitions with aTargets
      if ( aoColDefs )
      {
        /* Loop over the definitions array - loop in reverse so first instance has priority */
        for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
        {
          /* Each definition can target multiple columns, as it is an array */
          var aTargets = aoColDefs[i].aTargets;
          if ( !$.isArray( aTargets ) )
          {
            _fnLog( oSettings, 1, 'aTargets must be an array of targets, not a '+(typeof aTargets) );
          }

          for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
          {
            if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
            {
              /* Add columns that we don't yet know about */
              while( oSettings.aoColumns.length <= aTargets[j] )
              {
                _fnAddColumn( oSettings );
              }

              /* Integer, basic index */
              fn( aTargets[j], aoColDefs[i] );
            }
            else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
            {
              /* Negative integer, right to left column counting */
              fn( oSettings.aoColumns.length+aTargets[j], aoColDefs[i] );
            }
            else if ( typeof aTargets[j] === 'string' )
            {
              /* Class name matching on TH element */
              for ( k=0, kLen=oSettings.aoColumns.length ; k<kLen ; k++ )
              {
                if ( aTargets[j] == "_all" ||
                  $(oSettings.aoColumns[k].nTh).hasClass( aTargets[j] ) )
                {
                  fn( k, aoColDefs[i] );
                }
              }
            }
          }
        }
      }

      // Statically defined columns array
      if ( aoCols )
      {
        for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
        {
          fn( i, aoCols[i] );
        }
      }
    }



    /**
     * Add a data array to the table, creating DOM node etc. This is the parallel to
     * _fnGatherData, but for adding rows from a Javascript source, rather than a
     * DOM source.
     *  @param {object} oSettings dataTables settings object
     *  @param {array} aData data array to be added
     *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
     *  @memberof DataTable#oApi
     */
    function _fnAddData ( oSettings, aDataSupplied )
    {
      var oCol;

      /* Take an independent copy of the data source so we can bash it about as we wish */
      var aDataIn = ($.isArray(aDataSupplied)) ?
        aDataSupplied.slice() :
        $.extend( true, {}, aDataSupplied );

      /* Create the object for storing information about this new row */
      var iRow = oSettings.aoData.length;
      var oData = $.extend( true, {}, DataTable.models.oRow );
      oData._aData = aDataIn;
      oSettings.aoData.push( oData );

      /* Create the cells */
      var nTd, sThisType;
      for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        oCol = oSettings.aoColumns[i];

        /* Use rendered data for filtering / sorting */
        if ( typeof oCol.fnRender === 'function' && oCol.bUseRendered && oCol.mData !== null )
        {
          _fnSetCellData( oSettings, iRow, i, _fnRender(oSettings, iRow, i) );
        }
        else
        {
          _fnSetCellData( oSettings, iRow, i, _fnGetCellData( oSettings, iRow, i ) );
        }

        /* See if we should auto-detect the column type */
        if ( oCol._bAutoType && oCol.sType != 'string' )
        {
          /* Attempt to auto detect the type - same as _fnGatherData() */
          var sVarType = _fnGetCellData( oSettings, iRow, i, 'type' );
          if ( sVarType !== null && sVarType !== '' )
          {
            sThisType = _fnDetectType( sVarType );
            if ( oCol.sType === null )
            {
              oCol.sType = sThisType;
            }
            else if ( oCol.sType != sThisType && oCol.sType != "html" )
            {
              /* String is always the 'fallback' option */
              oCol.sType = 'string';
            }
          }
        }
      }

      /* Add to the display array */
      oSettings.aiDisplayMaster.push( iRow );

      /* Create the DOM imformation */
      if ( !oSettings.oFeatures.bDeferRender )
      {
        _fnCreateTr( oSettings, iRow );
      }

      return iRow;
    }


    /**
     * Read in the data from the target table from the DOM
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnGatherData( oSettings )
    {
      var iLoop, i, iLen, j, jLen, jInner,
        nTds, nTrs, nTd, aLocalData, iThisIndex,
        iRow, iRows, iColumn, iColumns, sNodeName,
        oCol, oData;

      /*
       * Process by row first
       * Add the data object for the whole table - storing the tr node. Note - no point in getting
       * DOM based data if we are going to go and replace it with Ajax source data.
       */
      if ( oSettings.bDeferLoading || oSettings.sAjaxSource === null )
      {
        nTrs = oSettings.nTBody.childNodes;
        for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
        {
          if ( nTrs[i].nodeName.toUpperCase() == "TR" )
          {
            iThisIndex = oSettings.aoData.length;
            nTrs[i]._DT_RowIndex = iThisIndex;
            oSettings.aoData.push( $.extend( true, {}, DataTable.models.oRow, {
              "nTr": nTrs[i]
            } ) );

            oSettings.aiDisplayMaster.push( iThisIndex );
            nTds = nTrs[i].childNodes;
            jInner = 0;

            for ( j=0, jLen=nTds.length ; j<jLen ; j++ )
            {
              sNodeName = nTds[j].nodeName.toUpperCase();
              if ( sNodeName == "TD" || sNodeName == "TH" )
              {
                _fnSetCellData( oSettings, iThisIndex, jInner, $.trim(nTds[j].innerHTML) );
                jInner++;
              }
            }
          }
        }
      }

      /* Gather in the TD elements of the Table - note that this is basically the same as
       * fnGetTdNodes, but that function takes account of hidden columns, which we haven't yet
       * setup!
       */
      nTrs = _fnGetTrNodes( oSettings );
      nTds = [];
      for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
      {
        for ( j=0, jLen=nTrs[i].childNodes.length ; j<jLen ; j++ )
        {
          nTd = nTrs[i].childNodes[j];
          sNodeName = nTd.nodeName.toUpperCase();
          if ( sNodeName == "TD" || sNodeName == "TH" )
          {
            nTds.push( nTd );
          }
        }
      }

      /* Now process by column */
      for ( iColumn=0, iColumns=oSettings.aoColumns.length ; iColumn<iColumns ; iColumn++ )
      {
        oCol = oSettings.aoColumns[iColumn];

        /* Get the title of the column - unless there is a user set one */
        if ( oCol.sTitle === null )
        {
          oCol.sTitle = oCol.nTh.innerHTML;
        }

        var
          bAutoType = oCol._bAutoType,
          bRender = typeof oCol.fnRender === 'function',
          bClass = oCol.sClass !== null,
          bVisible = oCol.bVisible,
          nCell, sThisType, sRendered, sValType;

        /* A single loop to rule them all (and be more efficient) */
        if ( bAutoType || bRender || bClass || !bVisible )
        {
          for ( iRow=0, iRows=oSettings.aoData.length ; iRow<iRows ; iRow++ )
          {
            oData = oSettings.aoData[iRow];
            nCell = nTds[ (iRow*iColumns) + iColumn ];

            /* Type detection */
            if ( bAutoType && oCol.sType != 'string' )
            {
              sValType = _fnGetCellData( oSettings, iRow, iColumn, 'type' );
              if ( sValType !== '' )
              {
                sThisType = _fnDetectType( sValType );
                if ( oCol.sType === null )
                {
                  oCol.sType = sThisType;
                }
                else if ( oCol.sType != sThisType &&
                  oCol.sType != "html" )
                {
                  /* String is always the 'fallback' option */
                  oCol.sType = 'string';
                }
              }
            }

            if ( typeof oCol.mData === 'function' )
            {
              nCell.innerHTML = _fnGetCellData( oSettings, iRow, iColumn, 'display' );
            }

            /* Rendering */
            if ( bRender )
            {
              sRendered = _fnRender( oSettings, iRow, iColumn );
              nCell.innerHTML = sRendered;
              if ( oCol.bUseRendered )
              {
                /* Use the rendered data for filtering / sorting */
                _fnSetCellData( oSettings, iRow, iColumn, sRendered );
              }
            }

            /* Classes */
            if ( bClass )
            {
              nCell.className += ' '+oCol.sClass;
            }

            /* Column visibility */
            if ( !bVisible )
            {
              oData._anHidden[iColumn] = nCell;
              nCell.parentNode.removeChild( nCell );
            }
            else
            {
              oData._anHidden[iColumn] = null;
            }

            if ( oCol.fnCreatedCell )
            {
              oCol.fnCreatedCell.call( oSettings.oInstance,
                nCell, _fnGetCellData( oSettings, iRow, iColumn, 'display' ), oData._aData, iRow, iColumn
              );
            }
          }
        }
      }

      /* Row created callbacks */
      if ( oSettings.aoRowCreatedCallback.length !== 0 )
      {
        for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
        {
          oData = oSettings.aoData[i];
          _fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, i] );
        }
      }
    }


    /**
     * Take a TR element and convert it to an index in aoData
     *  @param {object} oSettings dataTables settings object
     *  @param {node} n the TR element to find
     *  @returns {int} index if the node is found, null if not
     *  @memberof DataTable#oApi
     */
    function _fnNodeToDataIndex( oSettings, n )
    {
      return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
    }


    /**
     * Take a TD element and convert it into a column data index (not the visible index)
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iRow The row number the TD/TH can be found in
     *  @param {node} n The TD/TH element to find
     *  @returns {int} index if the node is found, -1 if not
     *  @memberof DataTable#oApi
     */
    function _fnNodeToColumnIndex( oSettings, iRow, n )
    {
      var anCells = _fnGetTdNodes( oSettings, iRow );

      for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        if ( anCells[i] === n )
        {
          return i;
        }
      }
      return -1;
    }


    /**
     * Get an array of data for a given row from the internal data cache
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iRow aoData row id
     *  @param {string} sSpecific data get type ('type' 'filter' 'sort')
     *  @param {array} aiColumns Array of column indexes to get data from
     *  @returns {array} Data array
     *  @memberof DataTable#oApi
     */
    function _fnGetRowData( oSettings, iRow, sSpecific, aiColumns )
    {
      var out = [];
      for ( var i=0, iLen=aiColumns.length ; i<iLen ; i++ )
      {
        out.push( _fnGetCellData( oSettings, iRow, aiColumns[i], sSpecific ) );
      }
      return out;
    }


    /**
     * Get the data for a given cell from the internal cache, taking into account data mapping
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iRow aoData row id
     *  @param {int} iCol Column index
     *  @param {string} sSpecific data get type ('display', 'type' 'filter' 'sort')
     *  @returns {*} Cell data
     *  @memberof DataTable#oApi
     */
    function _fnGetCellData( oSettings, iRow, iCol, sSpecific )
    {
      var sData;
      var oCol = oSettings.aoColumns[iCol];
      var oData = oSettings.aoData[iRow]._aData;

      if ( (sData=oCol.fnGetData( oData, sSpecific )) === undefined )
      {
        if ( oSettings.iDrawError != oSettings.iDraw && oCol.sDefaultContent === null )
        {
          _fnLog( oSettings, 0, "Requested unknown parameter "+
            (typeof oCol.mData=='function' ? '{mData function}' : "'"+oCol.mData+"'")+
            " from the data source for row "+iRow );
          oSettings.iDrawError = oSettings.iDraw;
        }
        return oCol.sDefaultContent;
      }

      /* When the data source is null, we can use default column data */
      if ( sData === null && oCol.sDefaultContent !== null )
      {
        sData = oCol.sDefaultContent;
      }
      else if ( typeof sData === 'function' )
      {
        /* If the data source is a function, then we run it and use the return */
        return sData();
      }

      if ( sSpecific == 'display' && sData === null )
      {
        return '';
      }
      return sData;
    }


    /**
     * Set the value for a specific cell, into the internal data cache
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iRow aoData row id
     *  @param {int} iCol Column index
     *  @param {*} val Value to set
     *  @memberof DataTable#oApi
     */
    function _fnSetCellData( oSettings, iRow, iCol, val )
    {
      var oCol = oSettings.aoColumns[iCol];
      var oData = oSettings.aoData[iRow]._aData;

      oCol.fnSetData( oData, val );
    }


    // Private variable that is used to match array syntax in the data property object
    var __reArray = /\[.*?\]$/;

    /**
     * Return a function that can be used to get data from a source object, taking
     * into account the ability to use nested objects as a source
     *  @param {string|int|function} mSource The data source for the object
     *  @returns {function} Data get function
     *  @memberof DataTable#oApi
     */
    function _fnGetObjectDataFn( mSource )
    {
      if ( mSource === null )
      {
        /* Give an empty string for rendering / sorting etc */
        return function (data, type) {
          return null;
        };
      }
      else if ( typeof mSource === 'function' )
      {
        return function (data, type, extra) {
          return mSource( data, type, extra );
        };
      }
      else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1) )
      {
        /* If there is a . in the source string then the data source is in a 
         * nested object so we loop over the data for each level to get the next
         * level down. On each loop we test for undefined, and if found immediately
         * return. This allows entire objects to be missing and sDefaultContent to
         * be used if defined, rather than throwing an error
         */
        var fetchData = function (data, type, src) {
          var a = src.split('.');
          var arrayNotation, out, innerSrc;

          if ( src !== "" )
          {
            for ( var i=0, iLen=a.length ; i<iLen ; i++ )
            {
              // Check if we are dealing with an array notation request
              arrayNotation = a[i].match(__reArray);

              if ( arrayNotation ) {
                a[i] = a[i].replace(__reArray, '');

                // Condition allows simply [] to be passed in
                if ( a[i] !== "" ) {
                  data = data[ a[i] ];
                }
                out = [];

                // Get the remainder of the nested object to get
                a.splice( 0, i+1 );
                innerSrc = a.join('.');

                // Traverse each entry in the array getting the properties requested
                for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
                  out.push( fetchData( data[j], type, innerSrc ) );
                }

                // If a string is given in between the array notation indicators, that
                // is used to join the strings together, otherwise an array is returned
                var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
                data = (join==="") ? out : out.join(join);

                // The inner call to fetchData has already traversed through the remainder
                // of the source requested, so we exit from the loop
                break;
              }

              if ( data === null || data[ a[i] ] === undefined )
              {
                return undefined;
              }
              data = data[ a[i] ];
            }
          }

          return data;
        };

        return function (data, type) {
          return fetchData( data, type, mSource );
        };
      }
      else
      {
        /* Array or flat object mapping */
        return function (data, type) {
          return data[mSource];
        };
      }
    }


    /**
     * Return a function that can be used to set data from a source object, taking
     * into account the ability to use nested objects as a source
     *  @param {string|int|function} mSource The data source for the object
     *  @returns {function} Data set function
     *  @memberof DataTable#oApi
     */
    function _fnSetObjectDataFn( mSource )
    {
      if ( mSource === null )
      {
        /* Nothing to do when the data source is null */
        return function (data, val) {};
      }
      else if ( typeof mSource === 'function' )
      {
        return function (data, val) {
          mSource( data, 'set', val );
        };
      }
      else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1) )
      {
        /* Like the get, we need to get data from a nested object */
        var setData = function (data, val, src) {
          var a = src.split('.'), b;
          var arrayNotation, o, innerSrc;

          for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
          {
            // Check if we are dealing with an array notation request
            arrayNotation = a[i].match(__reArray);

            if ( arrayNotation )
            {
              a[i] = a[i].replace(__reArray, '');
              data[ a[i] ] = [];

              // Get the remainder of the nested object to set so we can recurse
              b = a.slice();
              b.splice( 0, i+1 );
              innerSrc = b.join('.');

              // Traverse each entry in the array setting the properties requested
              for ( var j=0, jLen=val.length ; j<jLen ; j++ )
              {
                o = {};
                setData( o, val[j], innerSrc );
                data[ a[i] ].push( o );
              }

              // The inner call to setData has already traversed through the remainder
              // of the source and has set the data, thus we can exit here
              return;
            }

            // If the nested object doesn't currently exist - since we are
            // trying to set the value - create it
            if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
            {
              data[ a[i] ] = {};
            }
            data = data[ a[i] ];
          }

          // If array notation is used, we just want to strip it and use the property name
          // and assign the value. If it isn't used, then we get the result we want anyway
          data[ a[a.length-1].replace(__reArray, '') ] = val;
        };

        return function (data, val) {
          return setData( data, val, mSource );
        };
      }
      else
      {
        /* Array or flat object mapping */
        return function (data, val) {
          data[mSource] = val;
        };
      }
    }


    /**
     * Return an array with the full table data
     *  @param {object} oSettings dataTables settings object
     *  @returns array {array} aData Master data array
     *  @memberof DataTable#oApi
     */
    function _fnGetDataMaster ( oSettings )
    {
      var aData = [];
      var iLen = oSettings.aoData.length;
      for ( var i=0 ; i<iLen; i++ )
      {
        aData.push( oSettings.aoData[i]._aData );
      }
      return aData;
    }


    /**
     * Nuke the table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnClearTable( oSettings )
    {
      oSettings.aoData.splice( 0, oSettings.aoData.length );
      oSettings.aiDisplayMaster.splice( 0, oSettings.aiDisplayMaster.length );
      oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length );
      _fnCalculateEnd( oSettings );
    }


    /**
     * Take an array of integers (index array) and remove a target integer (value - not
     * the key!)
     *  @param {array} a Index array to target
     *  @param {int} iTarget value to find
     *  @memberof DataTable#oApi
     */
    function _fnDeleteIndex( a, iTarget )
    {
      var iTargetIndex = -1;

      for ( var i=0, iLen=a.length ; i<iLen ; i++ )
      {
        if ( a[i] == iTarget )
        {
          iTargetIndex = i;
        }
        else if ( a[i] > iTarget )
        {
          a[i]--;
        }
      }

      if ( iTargetIndex != -1 )
      {
        a.splice( iTargetIndex, 1 );
      }
    }


    /**
     * Call the developer defined fnRender function for a given cell (row/column) with
     * the required parameters and return the result.
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iRow aoData index for the row
     *  @param {int} iCol aoColumns index for the column
     *  @returns {*} Return of the developer's fnRender function
     *  @memberof DataTable#oApi
     */
    function _fnRender( oSettings, iRow, iCol )
    {
      var oCol = oSettings.aoColumns[iCol];

      return oCol.fnRender( {
        "iDataRow":    iRow,
        "iDataColumn": iCol,
        "oSettings":   oSettings,
        "aData":       oSettings.aoData[iRow]._aData,
        "mDataProp":   oCol.mData
      }, _fnGetCellData(oSettings, iRow, iCol, 'display') );
    }

    /**
     * Create a new TR element (and it's TD children) for a row
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iRow Row to consider
     *  @memberof DataTable#oApi
     */
    function _fnCreateTr ( oSettings, iRow )
    {
      var oData = oSettings.aoData[iRow];
      var nTd;

      if ( oData.nTr === null )
      {
        oData.nTr = document.createElement('tr');

        /* Use a private property on the node to allow reserve mapping from the node
         * to the aoData array for fast look up
         */
        oData.nTr._DT_RowIndex = iRow;

        /* Special parameters can be given by the data source to be used on the row */
        if ( oData._aData.DT_RowId )
        {
          oData.nTr.id = oData._aData.DT_RowId;
        }

        if ( oData._aData.DT_RowClass )
        {
          $(oData.nTr).addClass( oData._aData.DT_RowClass );
        }

        /* Process each column */
        for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
        {
          var oCol = oSettings.aoColumns[i];
          nTd = document.createElement( oCol.sCellType );

          /* Render if needed - if bUseRendered is true then we already have the rendered
           * value in the data source - so can just use that
           */
          nTd.innerHTML = (typeof oCol.fnRender === 'function' && (!oCol.bUseRendered || oCol.mData === null)) ?
            _fnRender( oSettings, iRow, i ) :
            _fnGetCellData( oSettings, iRow, i, 'display' );

          /* Add user defined class */
          if ( oCol.sClass !== null )
          {
            nTd.className = oCol.sClass;
          }

          if ( oCol.bVisible )
          {
            oData.nTr.appendChild( nTd );
            oData._anHidden[i] = null;
          }
          else
          {
            oData._anHidden[i] = nTd;
          }

          if ( oCol.fnCreatedCell )
          {
            oCol.fnCreatedCell.call( oSettings.oInstance,
              nTd, _fnGetCellData( oSettings, iRow, i, 'display' ), oData._aData, iRow, i
            );
          }
        }

        _fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, iRow] );
      }
    }


    /**
     * Create the HTML header for the table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnBuildHead( oSettings )
    {
      var i, nTh, iLen, j, jLen;
      var iThs = oSettings.nTHead.getElementsByTagName('th').length;
      var iCorrector = 0;
      var jqChildren;

      /* If there is a header in place - then use it - otherwise it's going to get nuked... */
      if ( iThs !== 0 )
      {
        /* We've got a thead from the DOM, so remove hidden columns and apply width to vis cols */
        for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
        {
          nTh = oSettings.aoColumns[i].nTh;
          nTh.setAttribute('role', 'columnheader');
          if ( oSettings.aoColumns[i].bSortable )
          {
            nTh.setAttribute('tabindex', oSettings.iTabIndex);
            nTh.setAttribute('aria-controls', oSettings.sTableId);
          }

          if ( oSettings.aoColumns[i].sClass !== null )
          {
            $(nTh).addClass( oSettings.aoColumns[i].sClass );
          }

          /* Set the title of the column if it is user defined (not what was auto detected) */
          if ( oSettings.aoColumns[i].sTitle != nTh.innerHTML )
          {
            nTh.innerHTML = oSettings.aoColumns[i].sTitle;
          }
        }
      }
      else
      {
        /* We don't have a header in the DOM - so we are going to have to create one */
        var nTr = document.createElement( "tr" );

        for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
        {
          nTh = oSettings.aoColumns[i].nTh;
          nTh.innerHTML = oSettings.aoColumns[i].sTitle;
          nTh.setAttribute('tabindex', '0');

          if ( oSettings.aoColumns[i].sClass !== null )
          {
            $(nTh).addClass( oSettings.aoColumns[i].sClass );
          }

          nTr.appendChild( nTh );
        }
        $(oSettings.nTHead).html( '' )[0].appendChild( nTr );
        _fnDetectHeader( oSettings.aoHeader, oSettings.nTHead );
      }

      /* ARIA role for the rows */
      $(oSettings.nTHead).children('tr').attr('role', 'row');

      /* Add the extra markup needed by jQuery UI's themes */
      if ( oSettings.bJUI )
      {
        for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
        {
          nTh = oSettings.aoColumns[i].nTh;

          var nDiv = document.createElement('div');
          nDiv.className = oSettings.oClasses.sSortJUIWrapper;
          $(nTh).contents().appendTo(nDiv);

          var nSpan = document.createElement('span');
          nSpan.className = oSettings.oClasses.sSortIcon;
          nDiv.appendChild( nSpan );
          nTh.appendChild( nDiv );
        }
      }

      if ( oSettings.oFeatures.bSort )
      {
        for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
        {
          if ( oSettings.aoColumns[i].bSortable !== false )
          {
            _fnSortAttachListener( oSettings, oSettings.aoColumns[i].nTh, i );
          }
          else
          {
            $(oSettings.aoColumns[i].nTh).addClass( oSettings.oClasses.sSortableNone );
          }
        }
      }

      /* Deal with the footer - add classes if required */
      if ( oSettings.oClasses.sFooterTH !== "" )
      {
        $(oSettings.nTFoot).children('tr').children('th').addClass( oSettings.oClasses.sFooterTH );
      }

      /* Cache the footer elements */
      if ( oSettings.nTFoot !== null )
      {
        var anCells = _fnGetUniqueThs( oSettings, null, oSettings.aoFooter );
        for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
        {
          if ( anCells[i] )
          {
            oSettings.aoColumns[i].nTf = anCells[i];
            if ( oSettings.aoColumns[i].sClass )
            {
              $(anCells[i]).addClass( oSettings.aoColumns[i].sClass );
            }
          }
        }
      }
    }


    /**
     * Draw the header (or footer) element based on the column visibility states. The
     * methodology here is to use the layout array from _fnDetectHeader, modified for
     * the instantaneous column visibility, to construct the new layout. The grid is
     * traversed over cell at a time in a rows x columns grid fashion, although each
     * cell insert can cover multiple elements in the grid - which is tracks using the
     * aApplied array. Cell inserts in the grid will only occur where there isn't
     * already a cell in that position.
     *  @param {object} oSettings dataTables settings object
     *  @param array {objects} aoSource Layout array from _fnDetectHeader
     *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
     *  @memberof DataTable#oApi
     */
    function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
    {
      var i, iLen, j, jLen, k, kLen, n, nLocalTr;
      var aoLocal = [];
      var aApplied = [];
      var iColumns = oSettings.aoColumns.length;
      var iRowspan, iColspan;

      if (  bIncludeHidden === undefined )
      {
        bIncludeHidden = false;
      }

      /* Make a copy of the master layout array, but without the visible columns in it */
      for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
      {
        aoLocal[i] = aoSource[i].slice();
        aoLocal[i].nTr = aoSource[i].nTr;

        /* Remove any columns which are currently hidden */
        for ( j=iColumns-1 ; j>=0 ; j-- )
        {
          if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
          {
            aoLocal[i].splice( j, 1 );
          }
        }

        /* Prep the applied array - it needs an element for each row */
        aApplied.push( [] );
      }

      for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
      {
        nLocalTr = aoLocal[i].nTr;

        /* All cells are going to be replaced, so empty out the row */
        if ( nLocalTr )
        {
          while( (n = nLocalTr.firstChild) )
          {
            nLocalTr.removeChild( n );
          }
        }

        for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
        {
          iRowspan = 1;
          iColspan = 1;

          /* Check to see if there is already a cell (row/colspan) covering our target
           * insert point. If there is, then there is nothing to do.
           */
          if ( aApplied[i][j] === undefined )
          {
            nLocalTr.appendChild( aoLocal[i][j].cell );
            aApplied[i][j] = 1;

            /* Expand the cell to cover as many rows as needed */
            while ( aoLocal[i+iRowspan] !== undefined &&
              aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
            {
              aApplied[i+iRowspan][j] = 1;
              iRowspan++;
            }

            /* Expand the cell to cover as many columns as needed */
            while ( aoLocal[i][j+iColspan] !== undefined &&
              aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
            {
              /* Must update the applied array over the rows for the columns */
              for ( k=0 ; k<iRowspan ; k++ )
              {
                aApplied[i+k][j+iColspan] = 1;
              }
              iColspan++;
            }

            /* Do the actual expansion in the DOM */
            aoLocal[i][j].cell.rowSpan = iRowspan;
            aoLocal[i][j].cell.colSpan = iColspan;
          }
        }
      }
    }


    /**
     * Insert the required TR nodes into the table for display
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnDraw( oSettings )
    {
      /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
      var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
      if ( $.inArray( false, aPreDraw ) !== -1 )
      {
        _fnProcessingDisplay( oSettings, false );
        return;
      }

      var i, iLen, n;
      var anRows = [];
      var iRowCount = 0;
      var iStripes = oSettings.asStripeClasses.length;
      var iOpenRows = oSettings.aoOpenRows.length;

      oSettings.bDrawing = true;

      /* Check and see if we have an initial draw position from state saving */
      if ( oSettings.iInitDisplayStart !== undefined && oSettings.iInitDisplayStart != -1 )
      {
        if ( oSettings.oFeatures.bServerSide )
        {
          oSettings._iDisplayStart = oSettings.iInitDisplayStart;
        }
        else
        {
          oSettings._iDisplayStart = (oSettings.iInitDisplayStart >= oSettings.fnRecordsDisplay()) ?
            0 : oSettings.iInitDisplayStart;
        }
        oSettings.iInitDisplayStart = -1;
        _fnCalculateEnd( oSettings );
      }

      /* Server-side processing draw intercept */
      if ( oSettings.bDeferLoading )
      {
        oSettings.bDeferLoading = false;
        oSettings.iDraw++;
      }
      else if ( !oSettings.oFeatures.bServerSide )
      {
        oSettings.iDraw++;
      }
      else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
      {
        return;
      }

      if ( oSettings.aiDisplay.length !== 0 )
      {
        var iStart = oSettings._iDisplayStart;
        var iEnd = oSettings._iDisplayEnd;

        if ( oSettings.oFeatures.bServerSide )
        {
          iStart = 0;
          iEnd = oSettings.aoData.length;
        }

        for ( var j=iStart ; j<iEnd ; j++ )
        {
          var aoData = oSettings.aoData[ oSettings.aiDisplay[j] ];
          if ( aoData.nTr === null )
          {
            _fnCreateTr( oSettings, oSettings.aiDisplay[j] );
          }

          var nRow = aoData.nTr;

          /* Remove the old striping classes and then add the new one */
          if ( iStripes !== 0 )
          {
            var sStripe = oSettings.asStripeClasses[ iRowCount % iStripes ];
            if ( aoData._sRowStripe != sStripe )
            {
              $(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
              aoData._sRowStripe = sStripe;
            }
          }

          /* Row callback functions - might want to manipulate the row */
          _fnCallbackFire( oSettings, 'aoRowCallback', null,
            [nRow, oSettings.aoData[ oSettings.aiDisplay[j] ]._aData, iRowCount, j] );

          anRows.push( nRow );
          iRowCount++;

          /* If there is an open row - and it is attached to this parent - attach it on redraw */
          if ( iOpenRows !== 0 )
          {
            for ( var k=0 ; k<iOpenRows ; k++ )
            {
              if ( nRow == oSettings.aoOpenRows[k].nParent )
              {
                anRows.push( oSettings.aoOpenRows[k].nTr );
                break;
              }
            }
          }
        }
      }
      else
      {
        /* Table is empty - create a row with an empty message in it */
        anRows[ 0 ] = document.createElement( 'tr' );

        if ( oSettings.asStripeClasses[0] )
        {
          anRows[ 0 ].className = oSettings.asStripeClasses[0];
        }

        var oLang = oSettings.oLanguage;
        var sZero = oLang.sZeroRecords;
        if ( oSettings.iDraw == 1 && oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide )
        {
          sZero = oLang.sLoadingRecords;
        }
        else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
        {
          sZero = oLang.sEmptyTable;
        }

        var nTd = document.createElement( 'td' );
        nTd.setAttribute( 'valign', "top" );
        nTd.colSpan = _fnVisbleColumns( oSettings );
        nTd.className = oSettings.oClasses.sRowEmpty;
        nTd.innerHTML = _fnInfoMacros( oSettings, sZero );

        anRows[ iRowCount ].appendChild( nTd );
      }

      /* Header and footer callbacks */
      _fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
        _fnGetDataMaster( oSettings ), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay ] );

      _fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
        _fnGetDataMaster( oSettings ), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay ] );

      /* 
       * Need to remove any old row from the display - note we can't just empty the tbody using
       * $().html('') since this will unbind the jQuery event handlers (even although the node 
       * still exists!) - equally we can't use innerHTML, since IE throws an exception.
       */
      var
        nAddFrag = document.createDocumentFragment(),
        nRemoveFrag = document.createDocumentFragment(),
        nBodyPar, nTrs;

      if ( oSettings.nTBody )
      {
        nBodyPar = oSettings.nTBody.parentNode;
        nRemoveFrag.appendChild( oSettings.nTBody );

        /* When doing infinite scrolling, only remove child rows when sorting, filtering or start
         * up. When not infinite scroll, always do it.
         */
        if ( !oSettings.oScroll.bInfinite || !oSettings._bInitComplete ||
          oSettings.bSorted || oSettings.bFiltered )
        {
          while( (n = oSettings.nTBody.firstChild) )
          {
            oSettings.nTBody.removeChild( n );
          }
        }

        /* Put the draw table into the dom */
        for ( i=0, iLen=anRows.length ; i<iLen ; i++ )
        {
          nAddFrag.appendChild( anRows[i] );
        }

        oSettings.nTBody.appendChild( nAddFrag );
        if ( nBodyPar !== null )
        {
          nBodyPar.appendChild( oSettings.nTBody );
        }
      }

      /* Call all required callback functions for the end of a draw */
      _fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );

      /* Draw is complete, sorting and filtering must be as well */
      oSettings.bSorted = false;
      oSettings.bFiltered = false;
      oSettings.bDrawing = false;

      if ( oSettings.oFeatures.bServerSide )
      {
        _fnProcessingDisplay( oSettings, false );
        if ( !oSettings._bInitComplete )
        {
          _fnInitComplete( oSettings );
        }
      }
    }


    /**
     * Redraw the table - taking account of the various features which are enabled
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnReDraw( oSettings )
    {
      if ( oSettings.oFeatures.bSort )
      {
        /* Sorting will refilter and draw for us */
        _fnSort( oSettings, oSettings.oPreviousSearch );
      }
      else if ( oSettings.oFeatures.bFilter )
      {
        /* Filtering will redraw for us */
        _fnFilterComplete( oSettings, oSettings.oPreviousSearch );
      }
      else
      {
        _fnCalculateEnd( oSettings );
        _fnDraw( oSettings );
      }
    }


    /**
     * Add the options to the page HTML for the table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnAddOptionsHtml ( oSettings )
    {
      /*
       * Create a temporary, empty, div which we can later on replace with what we have generated
       * we do it this way to rendering the 'options' html offline - speed :-)
       */
      var nHolding = $('<div></div>')[0];
      oSettings.nTable.parentNode.insertBefore( nHolding, oSettings.nTable );

      /* 
       * All DataTables are wrapped in a div
       */
      oSettings.nTableWrapper = $('<div id="'+oSettings.sTableId+'_wrapper" class="'+oSettings.oClasses.sWrapper+'" role="grid"></div>')[0];
      oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

      /* Track where we want to insert the option */
      var nInsertNode = oSettings.nTableWrapper;

      /* Loop over the user set positioning and place the elements as needed */
      var aDom = oSettings.sDom.split('');
      var nTmp, iPushFeature, cOption, nNewNode, cNext, sAttr, j;
      for ( var i=0 ; i<aDom.length ; i++ )
      {
        iPushFeature = 0;
        cOption = aDom[i];

        if ( cOption == '<' )
        {
          /* New container div */
          nNewNode = $('<div></div>')[0];

          /* Check to see if we should append an id and/or a class name to the container */
          cNext = aDom[i+1];
          if ( cNext == "'" || cNext == '"' )
          {
            sAttr = "";
            j = 2;
            while ( aDom[i+j] != cNext )
            {
              sAttr += aDom[i+j];
              j++;
            }

            /* Replace jQuery UI constants */
            if ( sAttr == "H" )
            {
              sAttr = oSettings.oClasses.sJUIHeader;
            }
            else if ( sAttr == "F" )
            {
              sAttr = oSettings.oClasses.sJUIFooter;
            }

            /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
             * breaks the string into parts and applies them as needed
             */
            if ( sAttr.indexOf('.') != -1 )
            {
              var aSplit = sAttr.split('.');
              nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
              nNewNode.className = aSplit[1];
            }
            else if ( sAttr.charAt(0) == "#" )
            {
              nNewNode.id = sAttr.substr(1, sAttr.length-1);
            }
            else
            {
              nNewNode.className = sAttr;
            }

            i += j; /* Move along the position array */
          }

          nInsertNode.appendChild( nNewNode );
          nInsertNode = nNewNode;
        }
        else if ( cOption == '>' )
        {
          /* End container div */
          nInsertNode = nInsertNode.parentNode;
        }
        else if ( cOption == 'l' && oSettings.oFeatures.bPaginate && oSettings.oFeatures.bLengthChange )
        {
          /* Length */
          nTmp = _fnFeatureHtmlLength( oSettings );
          iPushFeature = 1;
        }
        else if ( cOption == 'f' && oSettings.oFeatures.bFilter )
        {
          /* Filter */
          nTmp = _fnFeatureHtmlFilter( oSettings );
          iPushFeature = 1;
        }
        else if ( cOption == 'r' && oSettings.oFeatures.bProcessing )
        {
          /* pRocessing */
          nTmp = _fnFeatureHtmlProcessing( oSettings );
          iPushFeature = 1;
        }
        else if ( cOption == 't' )
        {
          /* Table */
          nTmp = _fnFeatureHtmlTable( oSettings );
          iPushFeature = 1;
        }
        else if ( cOption ==  'i' && oSettings.oFeatures.bInfo )
        {
          /* Info */
          nTmp = _fnFeatureHtmlInfo( oSettings );
          iPushFeature = 1;
        }
        else if ( cOption == 'p' && oSettings.oFeatures.bPaginate )
        {
          /* Pagination */
          nTmp = _fnFeatureHtmlPaginate( oSettings );
          iPushFeature = 1;
        }
        else if ( DataTable.ext.aoFeatures.length !== 0 )
        {
          /* Plug-in features */
          var aoFeatures = DataTable.ext.aoFeatures;
          for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
          {
            if ( cOption == aoFeatures[k].cFeature )
            {
              nTmp = aoFeatures[k].fnInit( oSettings );
              if ( nTmp )
              {
                iPushFeature = 1;
              }
              break;
            }
          }
        }

        /* Add to the 2D features array */
        if ( iPushFeature == 1 && nTmp !== null )
        {
          if ( typeof oSettings.aanFeatures[cOption] !== 'object' )
          {
            oSettings.aanFeatures[cOption] = [];
          }
          oSettings.aanFeatures[cOption].push( nTmp );
          nInsertNode.appendChild( nTmp );
        }
      }

      /* Built our DOM structure - replace the holding div with what we want */
      nHolding.parentNode.replaceChild( oSettings.nTableWrapper, nHolding );
    }


    /**
     * Use the DOM source to create up an array of header cells. The idea here is to
     * create a layout grid (array) of rows x columns, which contains a reference
     * to the cell that that point in the grid (regardless of col/rowspan), such that
     * any column / row could be removed and the new grid constructed
     *  @param array {object} aLayout Array to store the calculated layout in
     *  @param {node} nThead The header/footer element for the table
     *  @memberof DataTable#oApi
     */
    function _fnDetectHeader ( aLayout, nThead )
    {
      var nTrs = $(nThead).children('tr');
      var nCell;
      var i, j, k, l, iLen, jLen, iColShifted;
      var fnShiftCol = function ( a, i, j ) {
        while ( a[i][j] ) {
          j++;
        }
        return j;
      };

      aLayout.splice( 0, aLayout.length );

      /* We know how many rows there are in the layout - so prep it */
      for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
      {
        aLayout.push( [] );
      }

      /* Calculate a layout array */
      for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
      {
        var iColumn = 0;

        /* For every cell in the row... */
        for ( j=0, jLen=nTrs[i].childNodes.length ; j<jLen ; j++ )
        {
          nCell = nTrs[i].childNodes[j];

          if ( nCell.nodeName.toUpperCase() == "TD" ||
            nCell.nodeName.toUpperCase() == "TH" )
          {
            /* Get the col and rowspan attributes from the DOM and sanitise them */
            var iColspan = nCell.getAttribute('colspan') * 1;
            var iRowspan = nCell.getAttribute('rowspan') * 1;
            iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
            iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;

            /* There might be colspan cells already in this row, so shift our target 
             * accordingly
             */
            iColShifted = fnShiftCol( aLayout, i, iColumn );

            /* If there is col / rowspan, copy the information into the layout grid */
            for ( l=0 ; l<iColspan ; l++ )
            {
              for ( k=0 ; k<iRowspan ; k++ )
              {
                aLayout[i+k][iColShifted+l] = {
                  "cell": nCell,
                  "unique": iColspan == 1 ? true : false
                };
                aLayout[i+k].nTr = nTrs[i];
              }
            }
          }
        }
      }
    }


    /**
     * Get an array of unique th elements, one for each column
     *  @param {object} oSettings dataTables settings object
     *  @param {node} nHeader automatically detect the layout from this node - optional
     *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
     *  @returns array {node} aReturn list of unique th's
     *  @memberof DataTable#oApi
     */
    function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
    {
      var aReturn = [];
      if ( !aLayout )
      {
        aLayout = oSettings.aoHeader;
        if ( nHeader )
        {
          aLayout = [];
          _fnDetectHeader( aLayout, nHeader );
        }
      }

      for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
      {
        for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
        {
          if ( aLayout[i][j].unique &&
            (!aReturn[j] || !oSettings.bSortCellsTop) )
          {
            aReturn[j] = aLayout[i][j].cell;
          }
        }
      }

      return aReturn;
    }



    /**
     * Update the table using an Ajax call
     *  @param {object} oSettings dataTables settings object
     *  @returns {boolean} Block the table drawing or not
     *  @memberof DataTable#oApi
     */
    function _fnAjaxUpdate( oSettings )
    {
      if ( oSettings.bAjaxDataGet )
      {
        oSettings.iDraw++;
        _fnProcessingDisplay( oSettings, true );
        var iColumns = oSettings.aoColumns.length;
        var aoData = _fnAjaxParameters( oSettings );
        _fnServerParams( oSettings, aoData );

        oSettings.fnServerData.call( oSettings.oInstance, oSettings.sAjaxSource, aoData,
          function(json) {
            _fnAjaxUpdateDraw( oSettings, json );
          }, oSettings );
        return false;
      }
      else
      {
        return true;
      }
    }


    /**
     * Build up the parameters in an object needed for a server-side processing request
     *  @param {object} oSettings dataTables settings object
     *  @returns {bool} block the table drawing or not
     *  @memberof DataTable#oApi
     */
    function _fnAjaxParameters( oSettings )
    {
      var iColumns = oSettings.aoColumns.length;
      var aoData = [], mDataProp, aaSort, aDataSort;
      var i, j;

      aoData.push( { "name": "sEcho",          "value": oSettings.iDraw } );
      aoData.push( { "name": "iColumns",       "value": iColumns } );
      aoData.push( { "name": "sColumns",       "value": _fnColumnOrdering(oSettings) } );
      aoData.push( { "name": "iDisplayStart",  "value": oSettings._iDisplayStart } );
      aoData.push( { "name": "iDisplayLength", "value": oSettings.oFeatures.bPaginate !== false ?
        oSettings._iDisplayLength : -1 } );

      for ( i=0 ; i<iColumns ; i++ )
      {
        mDataProp = oSettings.aoColumns[i].mData;
        aoData.push( { "name": "mDataProp_"+i, "value": typeof(mDataProp)==="function" ? 'function' : mDataProp } );
      }

      /* Filtering */
      if ( oSettings.oFeatures.bFilter !== false )
      {
        aoData.push( { "name": "sSearch", "value": oSettings.oPreviousSearch.sSearch } );
        aoData.push( { "name": "bRegex",  "value": oSettings.oPreviousSearch.bRegex } );
        for ( i=0 ; i<iColumns ; i++ )
        {
          aoData.push( { "name": "sSearch_"+i,     "value": oSettings.aoPreSearchCols[i].sSearch } );
          aoData.push( { "name": "bRegex_"+i,      "value": oSettings.aoPreSearchCols[i].bRegex } );
          aoData.push( { "name": "bSearchable_"+i, "value": oSettings.aoColumns[i].bSearchable } );
        }
      }

      /* Sorting */
      if ( oSettings.oFeatures.bSort !== false )
      {
        var iCounter = 0;

        aaSort = ( oSettings.aaSortingFixed !== null ) ?
          oSettings.aaSortingFixed.concat( oSettings.aaSorting ) :
          oSettings.aaSorting.slice();

        for ( i=0 ; i<aaSort.length ; i++ )
        {
          aDataSort = oSettings.aoColumns[ aaSort[i][0] ].aDataSort;

          for ( j=0 ; j<aDataSort.length ; j++ )
          {
            aoData.push( { "name": "iSortCol_"+iCounter,  "value": aDataSort[j] } );
            aoData.push( { "name": "sSortDir_"+iCounter,  "value": aaSort[i][1] } );
            iCounter++;
          }
        }
        aoData.push( { "name": "iSortingCols",   "value": iCounter } );

        for ( i=0 ; i<iColumns ; i++ )
        {
          aoData.push( { "name": "bSortable_"+i,  "value": oSettings.aoColumns[i].bSortable } );
        }
      }

      return aoData;
    }


    /**
     * Add Ajax parameters from plug-ins
     *  @param {object} oSettings dataTables settings object
     *  @param array {objects} aoData name/value pairs to send to the server
     *  @memberof DataTable#oApi
     */
    function _fnServerParams( oSettings, aoData )
    {
      _fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [aoData] );
    }


    /**
     * Data the data from the server (nuking the old) and redraw the table
     *  @param {object} oSettings dataTables settings object
     *  @param {object} json json data return from the server.
     *  @param {string} json.sEcho Tracking flag for DataTables to match requests
     *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
     *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
     *  @param {array} json.aaData The data to display on this page
     *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
     *  @memberof DataTable#oApi
     */
    function _fnAjaxUpdateDraw ( oSettings, json )
    {
      if ( json.sEcho !== undefined )
      {
        /* Protect against old returns over-writing a new one. Possible when you get
         * very fast interaction, and later queries are completed much faster
         */
        if ( json.sEcho*1 < oSettings.iDraw )
        {
          return;
        }
        else
        {
          oSettings.iDraw = json.sEcho * 1;
        }
      }

      if ( !oSettings.oScroll.bInfinite ||
        (oSettings.oScroll.bInfinite && (oSettings.bSorted || oSettings.bFiltered)) )
      {
        _fnClearTable( oSettings );
      }
      oSettings._iRecordsTotal = parseInt(json.iTotalRecords, 10);
      oSettings._iRecordsDisplay = parseInt(json.iTotalDisplayRecords, 10);

      /* Determine if reordering is required */
      var sOrdering = _fnColumnOrdering(oSettings);
      var bReOrder = (json.sColumns !== undefined && sOrdering !== "" && json.sColumns != sOrdering );
      var aiIndex;
      if ( bReOrder )
      {
        aiIndex = _fnReOrderIndex( oSettings, json.sColumns );
      }

      var aData = _fnGetObjectDataFn( oSettings.sAjaxDataProp )( json );
      for ( var i=0, iLen=aData.length ; i<iLen ; i++ )
      {
        if ( bReOrder )
        {
          /* If we need to re-order, then create a new array with the correct order and add it */
          var aDataSorted = [];
          for ( var j=0, jLen=oSettings.aoColumns.length ; j<jLen ; j++ )
          {
            aDataSorted.push( aData[i][ aiIndex[j] ] );
          }
          _fnAddData( oSettings, aDataSorted );
        }
        else
        {
          /* No re-order required, sever got it "right" - just straight add */
          _fnAddData( oSettings, aData[i] );
        }
      }
      oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

      oSettings.bAjaxDataGet = false;
      _fnDraw( oSettings );
      oSettings.bAjaxDataGet = true;
      _fnProcessingDisplay( oSettings, false );
    }



    /**
     * Generate the node required for filtering text
     *  @returns {node} Filter control element
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnFeatureHtmlFilter ( oSettings )
    {
      var oPreviousSearch = oSettings.oPreviousSearch;

      var sSearchStr = oSettings.oLanguage.sSearch;
      sSearchStr = (sSearchStr.indexOf('_INPUT_') !== -1) ?
        sSearchStr.replace('_INPUT_', '<input type="text" />') :
        sSearchStr==="" ? '<input type="text" />' : sSearchStr+' <input type="text" />';

      var nFilter = document.createElement( 'div' );
      nFilter.className = oSettings.oClasses.sFilter;
      nFilter.innerHTML = '<label>'+sSearchStr+'</label>';
      if ( !oSettings.aanFeatures.f )
      {
        nFilter.id = oSettings.sTableId+'_filter';
      }

      var jqFilter = $('input[type="text"]', nFilter);

      // Store a reference to the input element, so other input elements could be
      // added to the filter wrapper if needed (submit button for example)
      nFilter._DT_Input = jqFilter[0];

      jqFilter.val( oPreviousSearch.sSearch.replace('"','&quot;') );
      jqFilter.bind( 'keyup.DT', function(e) {
        /* Update all other filter input elements for the new display */
        var n = oSettings.aanFeatures.f;
        var val = this.value==="" ? "" : this.value; // mental IE8 fix :-(

        for ( var i=0, iLen=n.length ; i<iLen ; i++ )
        {
          if ( n[i] != $(this).parents('div.dataTables_filter')[0] )
          {
            $(n[i]._DT_Input).val( val );
          }
        }

        /* Now do the filter */
        if ( val != oPreviousSearch.sSearch )
        {
          _fnFilterComplete( oSettings, {
            "sSearch": val,
            "bRegex": oPreviousSearch.bRegex,
            "bSmart": oPreviousSearch.bSmart ,
            "bCaseInsensitive": oPreviousSearch.bCaseInsensitive
          } );
        }
      } );

      jqFilter
        .attr('aria-controls', oSettings.sTableId)
        .bind( 'keypress.DT', function(e) {
          /* Prevent form submission */
          if ( e.keyCode == 13 )
          {
            return false;
          }
        }
      );

      return nFilter;
    }


    /**
     * Filter the table using both the global filter and column based filtering
     *  @param {object} oSettings dataTables settings object
     *  @param {object} oSearch search information
     *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
     *  @memberof DataTable#oApi
     */
    function _fnFilterComplete ( oSettings, oInput, iForce )
    {
      var oPrevSearch = oSettings.oPreviousSearch;
      var aoPrevSearch = oSettings.aoPreSearchCols;
      var fnSaveFilter = function ( oFilter ) {
        /* Save the filtering values */
        oPrevSearch.sSearch = oFilter.sSearch;
        oPrevSearch.bRegex = oFilter.bRegex;
        oPrevSearch.bSmart = oFilter.bSmart;
        oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
      };

      /* In server-side processing all filtering is done by the server, so no point hanging around here */
      if ( !oSettings.oFeatures.bServerSide )
      {
        /* Global filter */
        _fnFilter( oSettings, oInput.sSearch, iForce, oInput.bRegex, oInput.bSmart, oInput.bCaseInsensitive );
        fnSaveFilter( oInput );

        /* Now do the individual column filter */
        for ( var i=0 ; i<oSettings.aoPreSearchCols.length ; i++ )
        {
          _fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, aoPrevSearch[i].bRegex,
            aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
        }

        /* Custom filtering */
        _fnFilterCustom( oSettings );
      }
      else
      {
        fnSaveFilter( oInput );
      }

      /* Tell the draw function we have been filtering */
      oSettings.bFiltered = true;
      $(oSettings.oInstance).trigger('filter', oSettings);

      /* Redraw the table */
      oSettings._iDisplayStart = 0;
      _fnCalculateEnd( oSettings );
      _fnDraw( oSettings );

      /* Rebuild search array 'offline' */
      _fnBuildSearchArray( oSettings, 0 );
    }


    /**
     * Apply custom filtering functions
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnFilterCustom( oSettings )
    {
      var afnFilters = DataTable.ext.afnFiltering;
      var aiFilterColumns = _fnGetColumns( oSettings, 'bSearchable' );

      for ( var i=0, iLen=afnFilters.length ; i<iLen ; i++ )
      {
        var iCorrector = 0;
        for ( var j=0, jLen=oSettings.aiDisplay.length ; j<jLen ; j++ )
        {
          var iDisIndex = oSettings.aiDisplay[j-iCorrector];
          var bTest = afnFilters[i](
            oSettings,
            _fnGetRowData( oSettings, iDisIndex, 'filter', aiFilterColumns ),
            iDisIndex
          );

          /* Check if we should use this row based on the filtering function */
          if ( !bTest )
          {
            oSettings.aiDisplay.splice( j-iCorrector, 1 );
            iCorrector++;
          }
        }
      }
    }


    /**
     * Filter the table on a per-column basis
     *  @param {object} oSettings dataTables settings object
     *  @param {string} sInput string to filter on
     *  @param {int} iColumn column to filter
     *  @param {bool} bRegex treat search string as a regular expression or not
     *  @param {bool} bSmart use smart filtering or not
     *  @param {bool} bCaseInsensitive Do case insenstive matching or not
     *  @memberof DataTable#oApi
     */
    function _fnFilterColumn ( oSettings, sInput, iColumn, bRegex, bSmart, bCaseInsensitive )
    {
      if ( sInput === "" )
      {
        return;
      }

      var iIndexCorrector = 0;
      var rpSearch = _fnFilterCreateSearch( sInput, bRegex, bSmart, bCaseInsensitive );

      for ( var i=oSettings.aiDisplay.length-1 ; i>=0 ; i-- )
      {
        var sData = _fnDataToSearch( _fnGetCellData( oSettings, oSettings.aiDisplay[i], iColumn, 'filter' ),
          oSettings.aoColumns[iColumn].sType );
        if ( ! rpSearch.test( sData ) )
        {
          oSettings.aiDisplay.splice( i, 1 );
          iIndexCorrector++;
        }
      }
    }


    /**
     * Filter the data table based on user input and draw the table
     *  @param {object} oSettings dataTables settings object
     *  @param {string} sInput string to filter on
     *  @param {int} iForce optional - force a research of the master array (1) or not (undefined or 0)
     *  @param {bool} bRegex treat as a regular expression or not
     *  @param {bool} bSmart perform smart filtering or not
     *  @param {bool} bCaseInsensitive Do case insenstive matching or not
     *  @memberof DataTable#oApi
     */
    function _fnFilter( oSettings, sInput, iForce, bRegex, bSmart, bCaseInsensitive )
    {
      var i;
      var rpSearch = _fnFilterCreateSearch( sInput, bRegex, bSmart, bCaseInsensitive );
      var oPrevSearch = oSettings.oPreviousSearch;

      /* Check if we are forcing or not - optional parameter */
      if ( !iForce )
      {
        iForce = 0;
      }

      /* Need to take account of custom filtering functions - always filter */
      if ( DataTable.ext.afnFiltering.length !== 0 )
      {
        iForce = 1;
      }

      /*
       * If the input is blank - we want the full data set
       */
      if ( sInput.length <= 0 )
      {
        oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length);
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
      }
      else
      {
        /*
         * We are starting a new search or the new search string is smaller 
         * then the old one (i.e. delete). Search from the master array
         */
        if ( oSettings.aiDisplay.length == oSettings.aiDisplayMaster.length ||
          oPrevSearch.sSearch.length > sInput.length || iForce == 1 ||
          sInput.indexOf(oPrevSearch.sSearch) !== 0 )
        {
          /* Nuke the old display array - we are going to rebuild it */
          oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length);

          /* Force a rebuild of the search array */
          _fnBuildSearchArray( oSettings, 1 );

          /* Search through all records to populate the search array
           * The the oSettings.aiDisplayMaster and asDataSearch arrays have 1 to 1 
           * mapping
           */
          for ( i=0 ; i<oSettings.aiDisplayMaster.length ; i++ )
          {
            if ( rpSearch.test(oSettings.asDataSearch[i]) )
            {
              oSettings.aiDisplay.push( oSettings.aiDisplayMaster[i] );
            }
          }
        }
        else
        {
          /* Using old search array - refine it - do it this way for speed
           * Don't have to search the whole master array again
           */
          var iIndexCorrector = 0;

          /* Search the current results */
          for ( i=0 ; i<oSettings.asDataSearch.length ; i++ )
          {
            if ( ! rpSearch.test(oSettings.asDataSearch[i]) )
            {
              oSettings.aiDisplay.splice( i-iIndexCorrector, 1 );
              iIndexCorrector++;
            }
          }
        }
      }
    }


    /**
     * Create an array which can be quickly search through
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iMaster use the master data array - optional
     *  @memberof DataTable#oApi
     */
    function _fnBuildSearchArray ( oSettings, iMaster )
    {
      if ( !oSettings.oFeatures.bServerSide )
      {
        /* Clear out the old data */
        oSettings.asDataSearch = [];

        var aiFilterColumns = _fnGetColumns( oSettings, 'bSearchable' );
        var aiIndex = (iMaster===1) ?
          oSettings.aiDisplayMaster :
          oSettings.aiDisplay;

        for ( var i=0, iLen=aiIndex.length ; i<iLen ; i++ )
        {
          oSettings.asDataSearch[i] = _fnBuildSearchRow(
            oSettings,
            _fnGetRowData( oSettings, aiIndex[i], 'filter', aiFilterColumns )
          );
        }
      }
    }


    /**
     * Create a searchable string from a single data row
     *  @param {object} oSettings dataTables settings object
     *  @param {array} aData Row data array to use for the data to search
     *  @memberof DataTable#oApi
     */
    function _fnBuildSearchRow( oSettings, aData )
    {
      var sSearch = aData.join('  ');

      /* If it looks like there is an HTML entity in the string, attempt to decode it */
      if ( sSearch.indexOf('&') !== -1 )
      {
        sSearch = $('<div>').html(sSearch).text();
      }

      // Strip newline characters
      return sSearch.replace( /[\n\r]/g, " " );
    }

    /**
     * Build a regular expression object suitable for searching a table
     *  @param {string} sSearch string to search for
     *  @param {bool} bRegex treat as a regular expression or not
     *  @param {bool} bSmart perform smart filtering or not
     *  @param {bool} bCaseInsensitive Do case insensitive matching or not
     *  @returns {RegExp} constructed object
     *  @memberof DataTable#oApi
     */
    function _fnFilterCreateSearch( sSearch, bRegex, bSmart, bCaseInsensitive )
    {
      var asSearch, sRegExpString;

      if ( bSmart )
      {
        /* Generate the regular expression to use. Something along the lines of:
         * ^(?=.*?\bone\b)(?=.*?\btwo\b)(?=.*?\bthree\b).*$
         */
        asSearch = bRegex ? sSearch.split( ' ' ) : _fnEscapeRegex( sSearch ).split( ' ' );
        sRegExpString = '^(?=.*?'+asSearch.join( ')(?=.*?' )+').*$';
        return new RegExp( sRegExpString, bCaseInsensitive ? "i" : "" );
      }
      else
      {
        sSearch = bRegex ? sSearch : _fnEscapeRegex( sSearch );
        return new RegExp( sSearch, bCaseInsensitive ? "i" : "" );
      }
    }


    /**
     * Convert raw data into something that the user can search on
     *  @param {string} sData data to be modified
     *  @param {string} sType data type
     *  @returns {string} search string
     *  @memberof DataTable#oApi
     */
    function _fnDataToSearch ( sData, sType )
    {
      if ( typeof DataTable.ext.ofnSearch[sType] === "function" )
      {
        return DataTable.ext.ofnSearch[sType]( sData );
      }
      else if ( sData === null )
      {
        return '';
      }
      else if ( sType == "html" )
      {
        return sData.replace(/[\r\n]/g," ").replace( /<.*?>/g, "" );
      }
      else if ( typeof sData === "string" )
      {
        return sData.replace(/[\r\n]/g," ");
      }
      return sData;
    }


    /**
     * scape a string such that it can be used in a regular expression
     *  @param {string} sVal string to escape
     *  @returns {string} escaped string
     *  @memberof DataTable#oApi
     */
    function _fnEscapeRegex ( sVal )
    {
      var acEscape = [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ];
      var reReplace = new RegExp( '(\\' + acEscape.join('|\\') + ')', 'g' );
      return sVal.replace(reReplace, '\\$1');
    }



    /**
     * Generate the node required for the info display
     *  @param {object} oSettings dataTables settings object
     *  @returns {node} Information element
     *  @memberof DataTable#oApi
     */
    function _fnFeatureHtmlInfo ( oSettings )
    {
      var nInfo = document.createElement( 'div' );
      nInfo.className = oSettings.oClasses.sInfo;

      /* Actions that are to be taken once only for this feature */
      if ( !oSettings.aanFeatures.i )
      {
        /* Add draw callback */
        oSettings.aoDrawCallback.push( {
          "fn": _fnUpdateInfo,
          "sName": "information"
        } );

        /* Add id */
        nInfo.id = oSettings.sTableId+'_info';
      }
      oSettings.nTable.setAttribute( 'aria-describedby', oSettings.sTableId+'_info' );

      return nInfo;
    }


    /**
     * Update the information elements in the display
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnUpdateInfo ( oSettings )
    {
      /* Show information about the table */
      if ( !oSettings.oFeatures.bInfo || oSettings.aanFeatures.i.length === 0 )
      {
        return;
      }

      var
        oLang = oSettings.oLanguage,
        iStart = oSettings._iDisplayStart+1,
        iEnd = oSettings.fnDisplayEnd(),
        iMax = oSettings.fnRecordsTotal(),
        iTotal = oSettings.fnRecordsDisplay(),
        sOut;

      if ( iTotal === 0 && iTotal == iMax )
      {
        /* Empty record set */
        sOut = oLang.sInfoEmpty;
      }
      else if ( iTotal === 0 )
      {
        /* Empty record set after filtering */
        sOut = oLang.sInfoEmpty +' '+ oLang.sInfoFiltered;
      }
      else if ( iTotal == iMax )
      {
        /* Normal record set */
        sOut = oLang.sInfo;
      }
      else
      {
        /* Record set after filtering */
        sOut = oLang.sInfo +' '+ oLang.sInfoFiltered;
      }

      // Convert the macros
      sOut += oLang.sInfoPostFix;
      sOut = _fnInfoMacros( oSettings, sOut );

      if ( oLang.fnInfoCallback !== null )
      {
        sOut = oLang.fnInfoCallback.call( oSettings.oInstance,
          oSettings, iStart, iEnd, iMax, iTotal, sOut );
      }

      var n = oSettings.aanFeatures.i;
      for ( var i=0, iLen=n.length ; i<iLen ; i++ )
      {
        $(n[i]).html( sOut );
      }
    }


    function _fnInfoMacros ( oSettings, str )
    {
      var
        iStart = oSettings._iDisplayStart+1,
        sStart = oSettings.fnFormatNumber( iStart ),
        iEnd = oSettings.fnDisplayEnd(),
        sEnd = oSettings.fnFormatNumber( iEnd ),
        iTotal = oSettings.fnRecordsDisplay(),
        sTotal = oSettings.fnFormatNumber( iTotal ),
        iMax = oSettings.fnRecordsTotal(),
        sMax = oSettings.fnFormatNumber( iMax );

      // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
      // internally
      if ( oSettings.oScroll.bInfinite )
      {
        sStart = oSettings.fnFormatNumber( 1 );
      }

      return str.
        replace('_START_', sStart).
        replace('_END_',   sEnd).
        replace('_TOTAL_', sTotal).
        replace('_MAX_',   sMax);
    }



    /**
     * Draw the table for the first time, adding all required features
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnInitialise ( oSettings )
    {
      var i, iLen, iAjaxStart=oSettings.iInitDisplayStart;

      /* Ensure that the table data is fully initialised */
      if ( oSettings.bInitialised === false )
      {
        setTimeout( function(){ _fnInitialise( oSettings ); }, 200 );
        return;
      }

      /* Show the display HTML options */
      _fnAddOptionsHtml( oSettings );

      /* Build and draw the header / footer for the table */
      _fnBuildHead( oSettings );
      _fnDrawHead( oSettings, oSettings.aoHeader );
      if ( oSettings.nTFoot )
      {
        _fnDrawHead( oSettings, oSettings.aoFooter );
      }

      /* Okay to show that something is going on now */
      _fnProcessingDisplay( oSettings, true );

      /* Calculate sizes for columns */
      if ( oSettings.oFeatures.bAutoWidth )
      {
        _fnCalculateColumnWidths( oSettings );
      }

      for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        if ( oSettings.aoColumns[i].sWidth !== null )
        {
          oSettings.aoColumns[i].nTh.style.width = _fnStringToCss( oSettings.aoColumns[i].sWidth );
        }
      }

      /* If there is default sorting required - let's do it. The sort function will do the
       * drawing for us. Otherwise we draw the table regardless of the Ajax source - this allows
       * the table to look initialised for Ajax sourcing data (show 'loading' message possibly)
       */
      if ( oSettings.oFeatures.bSort )
      {
        _fnSort( oSettings );
      }
      else if ( oSettings.oFeatures.bFilter )
      {
        _fnFilterComplete( oSettings, oSettings.oPreviousSearch );
      }
      else
      {
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        _fnCalculateEnd( oSettings );
        _fnDraw( oSettings );
      }

      /* if there is an ajax source load the data */
      if ( oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide )
      {
        var aoData = [];
        _fnServerParams( oSettings, aoData );
        oSettings.fnServerData.call( oSettings.oInstance, oSettings.sAjaxSource, aoData, function(json) {
          var aData = (oSettings.sAjaxDataProp !== "") ?
            _fnGetObjectDataFn( oSettings.sAjaxDataProp )(json) : json;

          /* Got the data - add it to the table */
          for ( i=0 ; i<aData.length ; i++ )
          {
            _fnAddData( oSettings, aData[i] );
          }

          /* Reset the init display for cookie saving. We've already done a filter, and
           * therefore cleared it before. So we need to make it appear 'fresh'
           */
          oSettings.iInitDisplayStart = iAjaxStart;

          if ( oSettings.oFeatures.bSort )
          {
            _fnSort( oSettings );
          }
          else
          {
            oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
            _fnCalculateEnd( oSettings );
            _fnDraw( oSettings );
          }

          _fnProcessingDisplay( oSettings, false );
          _fnInitComplete( oSettings, json );
        }, oSettings );
        return;
      }

      /* Server-side processing initialisation complete is done at the end of _fnDraw */
      if ( !oSettings.oFeatures.bServerSide )
      {
        _fnProcessingDisplay( oSettings, false );
        _fnInitComplete( oSettings );
      }
    }


    /**
     * Draw the table for the first time, adding all required features
     *  @param {object} oSettings dataTables settings object
     *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
     *    with client-side processing (optional)
     *  @memberof DataTable#oApi
     */
    function _fnInitComplete ( oSettings, json )
    {
      oSettings._bInitComplete = true;
      _fnCallbackFire( oSettings, 'aoInitComplete', 'init', [oSettings, json] );
    }


    /**
     * Language compatibility - when certain options are given, and others aren't, we
     * need to duplicate the values over, in order to provide backwards compatibility
     * with older language files.
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnLanguageCompat( oLanguage )
    {
      var oDefaults = DataTable.defaults.oLanguage;

      /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
       * sZeroRecords - assuming that is given.
       */
      if ( !oLanguage.sEmptyTable && oLanguage.sZeroRecords &&
        oDefaults.sEmptyTable === "No data available in table" )
      {
        _fnMap( oLanguage, oLanguage, 'sZeroRecords', 'sEmptyTable' );
      }

      /* Likewise with loading records */
      if ( !oLanguage.sLoadingRecords && oLanguage.sZeroRecords &&
        oDefaults.sLoadingRecords === "Loading..." )
      {
        _fnMap( oLanguage, oLanguage, 'sZeroRecords', 'sLoadingRecords' );
      }
    }



    /**
     * Generate the node required for user display length changing
     *  @param {object} oSettings dataTables settings object
     *  @returns {node} Display length feature node
     *  @memberof DataTable#oApi
     */
    function _fnFeatureHtmlLength ( oSettings )
    {
      if ( oSettings.oScroll.bInfinite )
      {
        return null;
      }

      /* This can be overruled by not using the _MENU_ var/macro in the language variable */
      var sName = 'name="'+oSettings.sTableId+'_length"';
      var sStdMenu = '<select size="1" '+sName+'>';
      var i, iLen;
      var aLengthMenu = oSettings.aLengthMenu;

      if ( aLengthMenu.length == 2 && typeof aLengthMenu[0] === 'object' &&
        typeof aLengthMenu[1] === 'object' )
      {
        for ( i=0, iLen=aLengthMenu[0].length ; i<iLen ; i++ )
        {
          sStdMenu += '<option value="'+aLengthMenu[0][i]+'">'+aLengthMenu[1][i]+'</option>';
        }
      }
      else
      {
        for ( i=0, iLen=aLengthMenu.length ; i<iLen ; i++ )
        {
          sStdMenu += '<option value="'+aLengthMenu[i]+'">'+aLengthMenu[i]+'</option>';
        }
      }
      sStdMenu += '</select>';

      var nLength = document.createElement( 'div' );
      if ( !oSettings.aanFeatures.l )
      {
        nLength.id = oSettings.sTableId+'_length';
      }
      nLength.className = oSettings.oClasses.sLength;
      nLength.innerHTML = '<label>'+oSettings.oLanguage.sLengthMenu.replace( '_MENU_', sStdMenu )+'</label>';

      /*
       * Set the length to the current display length - thanks to Andrea Pavlovic for this fix,
       * and Stefan Skopnik for fixing the fix!
       */
      $('select option[value="'+oSettings._iDisplayLength+'"]', nLength).attr("selected", true);

      $('select', nLength).bind( 'change.DT', function(e) {
        var iVal = $(this).val();

        /* Update all other length options for the new display */
        var n = oSettings.aanFeatures.l;
        for ( i=0, iLen=n.length ; i<iLen ; i++ )
        {
          if ( n[i] != this.parentNode )
          {
            $('select', n[i]).val( iVal );
          }
        }

        /* Redraw the table */
        oSettings._iDisplayLength = parseInt(iVal, 10);
        _fnCalculateEnd( oSettings );

        /* If we have space to show extra rows (backing up from the end point - then do so */
        if ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() )
        {
          oSettings._iDisplayStart = oSettings.fnDisplayEnd() - oSettings._iDisplayLength;
          if ( oSettings._iDisplayStart < 0 )
          {
            oSettings._iDisplayStart = 0;
          }
        }

        if ( oSettings._iDisplayLength == -1 )
        {
          oSettings._iDisplayStart = 0;
        }

        _fnDraw( oSettings );
      } );


      $('select', nLength).attr('aria-controls', oSettings.sTableId);

      return nLength;
    }


    /**
     * Recalculate the end point based on the start point
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnCalculateEnd( oSettings )
    {
      if ( oSettings.oFeatures.bPaginate === false )
      {
        oSettings._iDisplayEnd = oSettings.aiDisplay.length;
      }
      else
      {
        /* Set the end point of the display - based on how many elements there are
         * still to display
         */
        if ( oSettings._iDisplayStart + oSettings._iDisplayLength > oSettings.aiDisplay.length ||
          oSettings._iDisplayLength == -1 )
        {
          oSettings._iDisplayEnd = oSettings.aiDisplay.length;
        }
        else
        {
          oSettings._iDisplayEnd = oSettings._iDisplayStart + oSettings._iDisplayLength;
        }
      }
    }



    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Note that most of the paging logic is done in 
     * DataTable.ext.oPagination
     */

    /**
     * Generate the node required for default pagination
     *  @param {object} oSettings dataTables settings object
     *  @returns {node} Pagination feature node
     *  @memberof DataTable#oApi
     */
    function _fnFeatureHtmlPaginate ( oSettings )
    {
      if ( oSettings.oScroll.bInfinite )
      {
        return null;
      }

      var nPaginate = document.createElement( 'div' );
      nPaginate.className = oSettings.oClasses.sPaging+oSettings.sPaginationType;

      DataTable.ext.oPagination[ oSettings.sPaginationType ].fnInit( oSettings, nPaginate,
        function( oSettings ) {
          _fnCalculateEnd( oSettings );
          _fnDraw( oSettings );
        }
      );

      /* Add a draw callback for the pagination on first instance, to update the paging display */
      if ( !oSettings.aanFeatures.p )
      {
        oSettings.aoDrawCallback.push( {
          "fn": function( oSettings ) {
            DataTable.ext.oPagination[ oSettings.sPaginationType ].fnUpdate( oSettings, function( oSettings ) {
              _fnCalculateEnd( oSettings );
              _fnDraw( oSettings );
            } );
          },
          "sName": "pagination"
        } );
      }
      return nPaginate;
    }


    /**
     * Alter the display settings to change the page
     *  @param {object} oSettings dataTables settings object
     *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
     *    or page number to jump to (integer)
     *  @returns {bool} true page has changed, false - no change (no effect) eg 'first' on page 1
     *  @memberof DataTable#oApi
     */
    function _fnPageChange ( oSettings, mAction )
    {
      var iOldStart = oSettings._iDisplayStart;

      if ( typeof mAction === "number" )
      {
        oSettings._iDisplayStart = mAction * oSettings._iDisplayLength;
        if ( oSettings._iDisplayStart > oSettings.fnRecordsDisplay() )
        {
          oSettings._iDisplayStart = 0;
        }
      }
      else if ( mAction == "first" )
      {
        oSettings._iDisplayStart = 0;
      }
      else if ( mAction == "previous" )
      {
        oSettings._iDisplayStart = oSettings._iDisplayLength>=0 ?
          oSettings._iDisplayStart - oSettings._iDisplayLength :
          0;

        /* Correct for under-run */
        if ( oSettings._iDisplayStart < 0 )
        {
          oSettings._iDisplayStart = 0;
        }
      }
      else if ( mAction == "next" )
      {
        if ( oSettings._iDisplayLength >= 0 )
        {
          /* Make sure we are not over running the display array */
          if ( oSettings._iDisplayStart + oSettings._iDisplayLength < oSettings.fnRecordsDisplay() )
          {
            oSettings._iDisplayStart += oSettings._iDisplayLength;
          }
        }
        else
        {
          oSettings._iDisplayStart = 0;
        }
      }
      else if ( mAction == "last" )
      {
        if ( oSettings._iDisplayLength >= 0 )
        {
          var iPages = parseInt( (oSettings.fnRecordsDisplay()-1) / oSettings._iDisplayLength, 10 ) + 1;
          oSettings._iDisplayStart = (iPages-1) * oSettings._iDisplayLength;
        }
        else
        {
          oSettings._iDisplayStart = 0;
        }
      }
      else
      {
        _fnLog( oSettings, 0, "Unknown paging action: "+mAction );
      }
      $(oSettings.oInstance).trigger('page', oSettings);

      return iOldStart != oSettings._iDisplayStart;
    }



    /**
     * Generate the node required for the processing node
     *  @param {object} oSettings dataTables settings object
     *  @returns {node} Processing element
     *  @memberof DataTable#oApi
     */
    function _fnFeatureHtmlProcessing ( oSettings )
    {
      var nProcessing = document.createElement( 'div' );

      if ( !oSettings.aanFeatures.r )
      {
        nProcessing.id = oSettings.sTableId+'_processing';
      }
      nProcessing.innerHTML = oSettings.oLanguage.sProcessing;
      nProcessing.className = oSettings.oClasses.sProcessing;
      oSettings.nTable.parentNode.insertBefore( nProcessing, oSettings.nTable );

      return nProcessing;
    }


    /**
     * Display or hide the processing indicator
     *  @param {object} oSettings dataTables settings object
     *  @param {bool} bShow Show the processing indicator (true) or not (false)
     *  @memberof DataTable#oApi
     */
    function _fnProcessingDisplay ( oSettings, bShow )
    {
      if ( oSettings.oFeatures.bProcessing )
      {
        var an = oSettings.aanFeatures.r;
        for ( var i=0, iLen=an.length ; i<iLen ; i++ )
        {
          an[i].style.visibility = bShow ? "visible" : "hidden";
        }
      }

      $(oSettings.oInstance).trigger('processing', [oSettings, bShow]);
    }



    /**
     * Add any control elements for the table - specifically scrolling
     *  @param {object} oSettings dataTables settings object
     *  @returns {node} Node to add to the DOM
     *  @memberof DataTable#oApi
     */
    function _fnFeatureHtmlTable ( oSettings )
    {
      /* Check if scrolling is enabled or not - if not then leave the DOM unaltered */
      if ( oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "" )
      {
        return oSettings.nTable;
      }

      /*
       * The HTML structure that we want to generate in this function is:
       *  div - nScroller
       *    div - nScrollHead
       *      div - nScrollHeadInner
       *        table - nScrollHeadTable
       *          thead - nThead
       *    div - nScrollBody
       *      table - oSettings.nTable
       *        thead - nTheadSize
       *        tbody - nTbody
       *    div - nScrollFoot
       *      div - nScrollFootInner
       *        table - nScrollFootTable
       *          tfoot - nTfoot
       */
      var
        nScroller = document.createElement('div'),
        nScrollHead = document.createElement('div'),
        nScrollHeadInner = document.createElement('div'),
        nScrollBody = document.createElement('div'),
        nScrollFoot = document.createElement('div'),
        nScrollFootInner = document.createElement('div'),
        nScrollHeadTable = oSettings.nTable.cloneNode(false),
        nScrollFootTable = oSettings.nTable.cloneNode(false),
        nThead = oSettings.nTable.getElementsByTagName('thead')[0],
        nTfoot = oSettings.nTable.getElementsByTagName('tfoot').length === 0 ? null :
          oSettings.nTable.getElementsByTagName('tfoot')[0],
        oClasses = oSettings.oClasses;

      nScrollHead.appendChild( nScrollHeadInner );
      nScrollFoot.appendChild( nScrollFootInner );
      nScrollBody.appendChild( oSettings.nTable );
      nScroller.appendChild( nScrollHead );
      nScroller.appendChild( nScrollBody );
      nScrollHeadInner.appendChild( nScrollHeadTable );
      nScrollHeadTable.appendChild( nThead );
      if ( nTfoot !== null )
      {
        nScroller.appendChild( nScrollFoot );
        nScrollFootInner.appendChild( nScrollFootTable );
        nScrollFootTable.appendChild( nTfoot );
      }

      nScroller.className = oClasses.sScrollWrapper;
      nScrollHead.className = oClasses.sScrollHead;
      nScrollHeadInner.className = oClasses.sScrollHeadInner;
      nScrollBody.className = oClasses.sScrollBody;
      nScrollFoot.className = oClasses.sScrollFoot;
      nScrollFootInner.className = oClasses.sScrollFootInner;

      if ( oSettings.oScroll.bAutoCss )
      {
        nScrollHead.style.overflow = "hidden";
        nScrollHead.style.position = "relative";
        nScrollFoot.style.overflow = "hidden";
        nScrollBody.style.overflow = "auto";
      }

      nScrollHead.style.border = "0";
      nScrollHead.style.width = "100%";
      nScrollFoot.style.border = "0";
      nScrollHeadInner.style.width = oSettings.oScroll.sXInner !== "" ?
        oSettings.oScroll.sXInner : "100%"; /* will be overwritten */

      /* Modify attributes to respect the clones */
      nScrollHeadTable.removeAttribute('id');
      nScrollHeadTable.style.marginLeft = "0";
      oSettings.nTable.style.marginLeft = "0";
      if ( nTfoot !== null )
      {
        nScrollFootTable.removeAttribute('id');
        nScrollFootTable.style.marginLeft = "0";
      }

      /* Move caption elements from the body to the header, footer or leave where it is
       * depending on the configuration. Note that the DTD says there can be only one caption */
      var nCaption = $(oSettings.nTable).children('caption');
      if ( nCaption.length > 0 )
      {
        nCaption = nCaption[0];
        if ( nCaption._captionSide === "top" )
        {
          nScrollHeadTable.appendChild( nCaption );
        }
        else if ( nCaption._captionSide === "bottom" && nTfoot )
        {
          nScrollFootTable.appendChild( nCaption );
        }
      }

      /*
       * Sizing
       */
      /* When x-scrolling add the width and a scroller to move the header with the body */
      if ( oSettings.oScroll.sX !== "" )
      {
        nScrollHead.style.width = _fnStringToCss( oSettings.oScroll.sX );
        nScrollBody.style.width = _fnStringToCss( oSettings.oScroll.sX );

        if ( nTfoot !== null )
        {
          nScrollFoot.style.width = _fnStringToCss( oSettings.oScroll.sX );
        }

        /* When the body is scrolled, then we also want to scroll the headers */
        $(nScrollBody).scroll( function (e) {
          nScrollHead.scrollLeft = this.scrollLeft;

          if ( nTfoot !== null )
          {
            nScrollFoot.scrollLeft = this.scrollLeft;
          }
        } );
      }

      /* When yscrolling, add the height */
      if ( oSettings.oScroll.sY !== "" )
      {
        nScrollBody.style.height = _fnStringToCss( oSettings.oScroll.sY );
      }

      /* Redraw - align columns across the tables */
      oSettings.aoDrawCallback.push( {
        "fn": _fnScrollDraw,
        "sName": "scrolling"
      } );

      /* Infinite scrolling event handlers */
      if ( oSettings.oScroll.bInfinite )
      {
        $(nScrollBody).scroll( function() {
          /* Use a blocker to stop scrolling from loading more data while other data is still loading */
          if ( !oSettings.bDrawing && $(this).scrollTop() !== 0 )
          {
            /* Check if we should load the next data set */
            if ( $(this).scrollTop() + $(this).height() >
              $(oSettings.nTable).height() - oSettings.oScroll.iLoadGap )
            {
              /* Only do the redraw if we have to - we might be at the end of the data */
              if ( oSettings.fnDisplayEnd() < oSettings.fnRecordsDisplay() )
              {
                _fnPageChange( oSettings, 'next' );
                _fnCalculateEnd( oSettings );
                _fnDraw( oSettings );
              }
            }
          }
        } );
      }

      oSettings.nScrollHead = nScrollHead;
      oSettings.nScrollFoot = nScrollFoot;

      return nScroller;
    }


    /**
     * Update the various tables for resizing. It's a bit of a pig this function, but
     * basically the idea to:
     *   1. Re-create the table inside the scrolling div
     *   2. Take live measurements from the DOM
     *   3. Apply the measurements
     *   4. Clean up
     *  @param {object} o dataTables settings object
     *  @returns {node} Node to add to the DOM
     *  @memberof DataTable#oApi
     */
    function _fnScrollDraw ( o )
    {
      var
        nScrollHeadInner = o.nScrollHead.getElementsByTagName('div')[0],
        nScrollHeadTable = nScrollHeadInner.getElementsByTagName('table')[0],
        nScrollBody = o.nTable.parentNode,
        i, iLen, j, jLen, anHeadToSize, anHeadSizers, anFootSizers, anFootToSize, oStyle, iVis,
        nTheadSize, nTfootSize,
        iWidth, aApplied=[], iSanityWidth,
        nScrollFootInner = (o.nTFoot !== null) ? o.nScrollFoot.getElementsByTagName('div')[0] : null,
        nScrollFootTable = (o.nTFoot !== null) ? nScrollFootInner.getElementsByTagName('table')[0] : null,
        ie67 = o.oBrowser.bScrollOversize;

      /*
       * 1. Re-create the table inside the scrolling div
       */

      /* Remove the old minimised thead and tfoot elements in the inner table */
      $(o.nTable).children('thead, tfoot').remove();

      /* Clone the current header and footer elements and then place it into the inner table */
      nTheadSize = $(o.nTHead).clone()[0];
      o.nTable.insertBefore( nTheadSize, o.nTable.childNodes[0] );

      if ( o.nTFoot !== null )
      {
        nTfootSize = $(o.nTFoot).clone()[0];
        o.nTable.insertBefore( nTfootSize, o.nTable.childNodes[1] );
      }

      /*
       * 2. Take live measurements from the DOM - do not alter the DOM itself!
       */

      /* Remove old sizing and apply the calculated column widths
       * Get the unique column headers in the newly created (cloned) header. We want to apply the
       * calculated sizes to this header
       */
      if ( o.oScroll.sX === "" )
      {
        nScrollBody.style.width = '100%';
        nScrollHeadInner.parentNode.style.width = '100%';
      }

      var nThs = _fnGetUniqueThs( o, nTheadSize );
      for ( i=0, iLen=nThs.length ; i<iLen ; i++ )
      {
        iVis = _fnVisibleToColumnIndex( o, i );
        nThs[i].style.width = o.aoColumns[iVis].sWidth;
      }

      if ( o.nTFoot !== null )
      {
        _fnApplyToChildren( function(n) {
          n.style.width = "";
        }, nTfootSize.getElementsByTagName('tr') );
      }

      // If scroll collapse is enabled, when we put the headers back into the body for sizing, we
      // will end up forcing the scrollbar to appear, making our measurements wrong for when we
      // then hide it (end of this function), so add the header height to the body scroller.
      if ( o.oScroll.bCollapse && o.oScroll.sY !== "" )
      {
        nScrollBody.style.height = (nScrollBody.offsetHeight + o.nTHead.offsetHeight)+"px";
      }

      /* Size the table as a whole */
      iSanityWidth = $(o.nTable).outerWidth();
      if ( o.oScroll.sX === "" )
      {
        /* No x scrolling */
        o.nTable.style.width = "100%";

        /* I know this is rubbish - but IE7 will make the width of the table when 100% include
         * the scrollbar - which is shouldn't. When there is a scrollbar we need to take this
         * into account.
         */
        if ( ie67 && ($('tbody', nScrollBody).height() > nScrollBody.offsetHeight ||
          $(nScrollBody).css('overflow-y') == "scroll")  )
        {
          o.nTable.style.width = _fnStringToCss( $(o.nTable).outerWidth() - o.oScroll.iBarWidth);
        }
      }
      else
      {
        if ( o.oScroll.sXInner !== "" )
        {
          /* x scroll inner has been given - use it */
          o.nTable.style.width = _fnStringToCss(o.oScroll.sXInner);
        }
        else if ( iSanityWidth == $(nScrollBody).width() &&
          $(nScrollBody).height() < $(o.nTable).height() )
        {
          /* There is y-scrolling - try to take account of the y scroll bar */
          o.nTable.style.width = _fnStringToCss( iSanityWidth-o.oScroll.iBarWidth );
          if ( $(o.nTable).outerWidth() > iSanityWidth-o.oScroll.iBarWidth )
          {
            /* Not possible to take account of it */
            o.nTable.style.width = _fnStringToCss( iSanityWidth );
          }
        }
        else
        {
          /* All else fails */
          o.nTable.style.width = _fnStringToCss( iSanityWidth );
        }
      }

      /* Recalculate the sanity width - now that we've applied the required width, before it was
       * a temporary variable. This is required because the column width calculation is done
       * before this table DOM is created.
       */
      iSanityWidth = $(o.nTable).outerWidth();

      /* We want the hidden header to have zero height, so remove padding and borders. Then
       * set the width based on the real headers
       */
      anHeadToSize = o.nTHead.getElementsByTagName('tr');
      anHeadSizers = nTheadSize.getElementsByTagName('tr');

      _fnApplyToChildren( function(nSizer, nToSize) {
        oStyle = nSizer.style;
        oStyle.paddingTop = "0";
        oStyle.paddingBottom = "0";
        oStyle.borderTopWidth = "0";
        oStyle.borderBottomWidth = "0";
        oStyle.height = 0;

        iWidth = $(nSizer).width();
        nToSize.style.width = _fnStringToCss( iWidth );
        aApplied.push( iWidth );
      }, anHeadSizers, anHeadToSize );
      $(anHeadSizers).height(0);

      if ( o.nTFoot !== null )
      {
        /* Clone the current footer and then place it into the body table as a "hidden header" */
        anFootSizers = nTfootSize.getElementsByTagName('tr');
        anFootToSize = o.nTFoot.getElementsByTagName('tr');

        _fnApplyToChildren( function(nSizer, nToSize) {
          oStyle = nSizer.style;
          oStyle.paddingTop = "0";
          oStyle.paddingBottom = "0";
          oStyle.borderTopWidth = "0";
          oStyle.borderBottomWidth = "0";
          oStyle.height = 0;

          iWidth = $(nSizer).width();
          nToSize.style.width = _fnStringToCss( iWidth );
          aApplied.push( iWidth );
        }, anFootSizers, anFootToSize );
        $(anFootSizers).height(0);
      }

      /*
       * 3. Apply the measurements
       */

      /* "Hide" the header and footer that we used for the sizing. We want to also fix their width
       * to what they currently are
       */
      _fnApplyToChildren( function(nSizer) {
        nSizer.innerHTML = "";
        nSizer.style.width = _fnStringToCss( aApplied.shift() );
      }, anHeadSizers );

      if ( o.nTFoot !== null )
      {
        _fnApplyToChildren( function(nSizer) {
          nSizer.innerHTML = "";
          nSizer.style.width = _fnStringToCss( aApplied.shift() );
        }, anFootSizers );
      }

      /* Sanity check that the table is of a sensible width. If not then we are going to get
       * misalignment - try to prevent this by not allowing the table to shrink below its min width
       */
      if ( $(o.nTable).outerWidth() < iSanityWidth )
      {
        /* The min width depends upon if we have a vertical scrollbar visible or not */
        var iCorrection = ((nScrollBody.scrollHeight > nScrollBody.offsetHeight ||
          $(nScrollBody).css('overflow-y') == "scroll")) ?
          iSanityWidth+o.oScroll.iBarWidth : iSanityWidth;

        /* IE6/7 are a law unto themselves... */
        if ( ie67 && (nScrollBody.scrollHeight >
          nScrollBody.offsetHeight || $(nScrollBody).css('overflow-y') == "scroll")  )
        {
          o.nTable.style.width = _fnStringToCss( iCorrection-o.oScroll.iBarWidth );
        }

        /* Apply the calculated minimum width to the table wrappers */
        nScrollBody.style.width = _fnStringToCss( iCorrection );
        nScrollHeadInner.parentNode.style.width = _fnStringToCss( iCorrection );

        if ( o.nTFoot !== null )
        {
          nScrollFootInner.parentNode.style.width = _fnStringToCss( iCorrection );
        }

        /* And give the user a warning that we've stopped the table getting too small */
        if ( o.oScroll.sX === "" )
        {
          _fnLog( o, 1, "The table cannot fit into the current element which will cause column"+
            " misalignment. The table has been drawn at its minimum possible width." );
        }
        else if ( o.oScroll.sXInner !== "" )
        {
          _fnLog( o, 1, "The table cannot fit into the current element which will cause column"+
            " misalignment. Increase the sScrollXInner value or remove it to allow automatic"+
            " calculation" );
        }
      }
      else
      {
        nScrollBody.style.width = _fnStringToCss( '100%' );
        nScrollHeadInner.parentNode.style.width = _fnStringToCss( '100%' );

        if ( o.nTFoot !== null )
        {
          nScrollFootInner.parentNode.style.width = _fnStringToCss( '100%' );
        }
      }


      /*
       * 4. Clean up
       */
      if ( o.oScroll.sY === "" )
      {
        /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
         * the scrollbar height from the visible display, rather than adding it on. We need to
         * set the height in order to sort this. Don't want to do it in any other browsers.
         */
        if ( ie67 )
        {
          nScrollBody.style.height = _fnStringToCss( o.nTable.offsetHeight+o.oScroll.iBarWidth );
        }
      }

      if ( o.oScroll.sY !== "" && o.oScroll.bCollapse )
      {
        nScrollBody.style.height = _fnStringToCss( o.oScroll.sY );

        var iExtra = (o.oScroll.sX !== "" && o.nTable.offsetWidth > nScrollBody.offsetWidth) ?
          o.oScroll.iBarWidth : 0;
        if ( o.nTable.offsetHeight < nScrollBody.offsetHeight )
        {
          nScrollBody.style.height = _fnStringToCss( o.nTable.offsetHeight+iExtra );
        }
      }

      /* Finally set the width's of the header and footer tables */
      var iOuterWidth = $(o.nTable).outerWidth();
      nScrollHeadTable.style.width = _fnStringToCss( iOuterWidth );
      nScrollHeadInner.style.width = _fnStringToCss( iOuterWidth );

      // Figure out if there are scrollbar present - if so then we need a the header and footer to
      // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
      var bScrolling = $(o.nTable).height() > nScrollBody.clientHeight || $(nScrollBody).css('overflow-y') == "scroll";
      nScrollHeadInner.style.paddingRight = bScrolling ? o.oScroll.iBarWidth+"px" : "0px";

      if ( o.nTFoot !== null )
      {
        nScrollFootTable.style.width = _fnStringToCss( iOuterWidth );
        nScrollFootInner.style.width = _fnStringToCss( iOuterWidth );
        nScrollFootInner.style.paddingRight = bScrolling ? o.oScroll.iBarWidth+"px" : "0px";
      }

      /* Adjust the position of the header in case we loose the y-scrollbar */
      $(nScrollBody).scroll();

      /* If sorting or filtering has occurred, jump the scrolling back to the top */
      if ( o.bSorted || o.bFiltered )
      {
        nScrollBody.scrollTop = 0;
      }
    }


    /**
     * Apply a given function to the display child nodes of an element array (typically
     * TD children of TR rows
     *  @param {function} fn Method to apply to the objects
     *  @param array {nodes} an1 List of elements to look through for display children
     *  @param array {nodes} an2 Another list (identical structure to the first) - optional
     *  @memberof DataTable#oApi
     */
    function _fnApplyToChildren( fn, an1, an2 )
    {
      for ( var i=0, iLen=an1.length ; i<iLen ; i++ )
      {
        for ( var j=0, jLen=an1[i].childNodes.length ; j<jLen ; j++ )
        {
          if ( an1[i].childNodes[j].nodeType == 1 )
          {
            if ( an2 )
            {
              fn( an1[i].childNodes[j], an2[i].childNodes[j] );
            }
            else
            {
              fn( an1[i].childNodes[j] );
            }
          }
        }
      }
    }



    /**
     * Convert a CSS unit width to pixels (e.g. 2em)
     *  @param {string} sWidth width to be converted
     *  @param {node} nParent parent to get the with for (required for relative widths) - optional
     *  @returns {int} iWidth width in pixels
     *  @memberof DataTable#oApi
     */
    function _fnConvertToWidth ( sWidth, nParent )
    {
      if ( !sWidth || sWidth === null || sWidth === '' )
      {
        return 0;
      }

      if ( !nParent )
      {
        nParent = document.getElementsByTagName('body')[0];
      }

      var iWidth;
      var nTmp = document.createElement( "div" );
      nTmp.style.width = _fnStringToCss( sWidth );

      nParent.appendChild( nTmp );
      iWidth = nTmp.offsetWidth;
      nParent.removeChild( nTmp );

      return ( iWidth );
    }


    /**
     * Calculate the width of columns for the table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnCalculateColumnWidths ( oSettings )
    {
      var iTableWidth = oSettings.nTable.offsetWidth;
      var iUserInputs = 0;
      var iTmpWidth;
      var iVisibleColumns = 0;
      var iColums = oSettings.aoColumns.length;
      var i, iIndex, iCorrector, iWidth;
      var oHeaders = $('th', oSettings.nTHead);
      var widthAttr = oSettings.nTable.getAttribute('width');

      /* Convert any user input sizes into pixel sizes */
      for ( i=0 ; i<iColums ; i++ )
      {
        if ( oSettings.aoColumns[i].bVisible )
        {
          iVisibleColumns++;

          if ( oSettings.aoColumns[i].sWidth !== null )
          {
            iTmpWidth = _fnConvertToWidth( oSettings.aoColumns[i].sWidthOrig,
              oSettings.nTable.parentNode );
            if ( iTmpWidth !== null )
            {
              oSettings.aoColumns[i].sWidth = _fnStringToCss( iTmpWidth );
            }

            iUserInputs++;
          }
        }
      }

      /* If the number of columns in the DOM equals the number that we have to process in 
       * DataTables, then we can use the offsets that are created by the web-browser. No custom 
       * sizes can be set in order for this to happen, nor scrolling used
       */
      if ( iColums == oHeaders.length && iUserInputs === 0 && iVisibleColumns == iColums &&
        oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "" )
      {
        for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
        {
          iTmpWidth = $(oHeaders[i]).width();
          if ( iTmpWidth !== null )
          {
            oSettings.aoColumns[i].sWidth = _fnStringToCss( iTmpWidth );
          }
        }
      }
      else
      {
        /* Otherwise we are going to have to do some calculations to get the width of each column.
         * Construct a 1 row table with the widest node in the data, and any user defined widths,
         * then insert it into the DOM and allow the browser to do all the hard work of
         * calculating table widths.
         */
        var
          nCalcTmp = oSettings.nTable.cloneNode( false ),
          nTheadClone = oSettings.nTHead.cloneNode(true),
          nBody = document.createElement( 'tbody' ),
          nTr = document.createElement( 'tr' ),
          nDivSizing;

        nCalcTmp.removeAttribute( "id" );
        nCalcTmp.appendChild( nTheadClone );
        if ( oSettings.nTFoot !== null )
        {
          nCalcTmp.appendChild( oSettings.nTFoot.cloneNode(true) );
          _fnApplyToChildren( function(n) {
            n.style.width = "";
          }, nCalcTmp.getElementsByTagName('tr') );
        }

        nCalcTmp.appendChild( nBody );
        nBody.appendChild( nTr );

        /* Remove any sizing that was previously applied by the styles */
        var jqColSizing = $('thead th', nCalcTmp);
        if ( jqColSizing.length === 0 )
        {
          jqColSizing = $('tbody tr:eq(0)>td', nCalcTmp);
        }

        /* Apply custom sizing to the cloned header */
        var nThs = _fnGetUniqueThs( oSettings, nTheadClone );
        iCorrector = 0;
        for ( i=0 ; i<iColums ; i++ )
        {
          var oColumn = oSettings.aoColumns[i];
          if ( oColumn.bVisible && oColumn.sWidthOrig !== null && oColumn.sWidthOrig !== "" )
          {
            nThs[i-iCorrector].style.width = _fnStringToCss( oColumn.sWidthOrig );
          }
          else if ( oColumn.bVisible )
          {
            nThs[i-iCorrector].style.width = "";
          }
          else
          {
            iCorrector++;
          }
        }

        /* Find the biggest td for each column and put it into the table */
        for ( i=0 ; i<iColums ; i++ )
        {
          if ( oSettings.aoColumns[i].bVisible )
          {
            var nTd = _fnGetWidestNode( oSettings, i );
            if ( nTd !== null )
            {
              nTd = nTd.cloneNode(true);
              if ( oSettings.aoColumns[i].sContentPadding !== "" )
              {
                nTd.innerHTML += oSettings.aoColumns[i].sContentPadding;
              }
              nTr.appendChild( nTd );
            }
          }
        }

        /* Build the table and 'display' it */
        var nWrapper = oSettings.nTable.parentNode;
        nWrapper.appendChild( nCalcTmp );

        /* When scrolling (X or Y) we want to set the width of the table as appropriate. However,
         * when not scrolling leave the table width as it is. This results in slightly different,
         * but I think correct behaviour
         */
        if ( oSettings.oScroll.sX !== "" && oSettings.oScroll.sXInner !== "" )
        {
          nCalcTmp.style.width = _fnStringToCss(oSettings.oScroll.sXInner);
        }
        else if ( oSettings.oScroll.sX !== "" )
        {
          nCalcTmp.style.width = "";
          if ( $(nCalcTmp).width() < nWrapper.offsetWidth )
          {
            nCalcTmp.style.width = _fnStringToCss( nWrapper.offsetWidth );
          }
        }
        else if ( oSettings.oScroll.sY !== "" )
        {
          nCalcTmp.style.width = _fnStringToCss( nWrapper.offsetWidth );
        }
        else if ( widthAttr )
        {
          nCalcTmp.style.width = _fnStringToCss( widthAttr );
        }
        nCalcTmp.style.visibility = "hidden";

        /* Scrolling considerations */
        _fnScrollingWidthAdjust( oSettings, nCalcTmp );

        /* Read the width's calculated by the browser and store them for use by the caller. We
         * first of all try to use the elements in the body, but it is possible that there are
         * no elements there, under which circumstances we use the header elements
         */
        var oNodes = $("tbody tr:eq(0)", nCalcTmp).children();
        if ( oNodes.length === 0 )
        {
          oNodes = _fnGetUniqueThs( oSettings, $('thead', nCalcTmp)[0] );
        }

        /* Browsers need a bit of a hand when a width is assigned to any columns when 
         * x-scrolling as they tend to collapse the table to the min-width, even if
         * we sent the column widths. So we need to keep track of what the table width
         * should be by summing the user given values, and the automatic values
         */
        if ( oSettings.oScroll.sX !== "" )
        {
          var iTotal = 0;
          iCorrector = 0;
          for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
          {
            if ( oSettings.aoColumns[i].bVisible )
            {
              if ( oSettings.aoColumns[i].sWidthOrig === null )
              {
                iTotal += $(oNodes[iCorrector]).outerWidth();
              }
              else
              {
                iTotal += parseInt(oSettings.aoColumns[i].sWidth.replace('px',''), 10) +
                  ($(oNodes[iCorrector]).outerWidth() - $(oNodes[iCorrector]).width());
              }
              iCorrector++;
            }
          }

          nCalcTmp.style.width = _fnStringToCss( iTotal );
          oSettings.nTable.style.width = _fnStringToCss( iTotal );
        }

        iCorrector = 0;
        for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
        {
          if ( oSettings.aoColumns[i].bVisible )
          {
            iWidth = $(oNodes[iCorrector]).width();
            if ( iWidth !== null && iWidth > 0 )
            {
              oSettings.aoColumns[i].sWidth = _fnStringToCss( iWidth );
            }
            iCorrector++;
          }
        }

        var cssWidth = $(nCalcTmp).css('width');
        oSettings.nTable.style.width = (cssWidth.indexOf('%') !== -1) ?
          cssWidth : _fnStringToCss( $(nCalcTmp).outerWidth() );
        nCalcTmp.parentNode.removeChild( nCalcTmp );
      }

      if ( widthAttr )
      {
        oSettings.nTable.style.width = _fnStringToCss( widthAttr );
      }
    }


    /**
     * Adjust a table's width to take account of scrolling
     *  @param {object} oSettings dataTables settings object
     *  @param {node} n table node
     *  @memberof DataTable#oApi
     */
    function _fnScrollingWidthAdjust ( oSettings, n )
    {
      if ( oSettings.oScroll.sX === "" && oSettings.oScroll.sY !== "" )
      {
        /* When y-scrolling only, we want to remove the width of the scroll bar so the table
         * + scroll bar will fit into the area avaialble.
         */
        var iOrigWidth = $(n).width();
        n.style.width = _fnStringToCss( $(n).outerWidth()-oSettings.oScroll.iBarWidth );
      }
      else if ( oSettings.oScroll.sX !== "" )
      {
        /* When x-scrolling both ways, fix the table at it's current size, without adjusting */
        n.style.width = _fnStringToCss( $(n).outerWidth() );
      }
    }


    /**
     * Get the widest node
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iCol column of interest
     *  @returns {string} max string length for each column
     *  @memberof DataTable#oApi
     */
    function _fnGetWidestNode( oSettings, iCol )
    {
      var iMaxIndex = _fnGetMaxLenString( oSettings, iCol );
      if ( iMaxIndex < 0 )
      {
        return null;
      }

      if ( oSettings.aoData[iMaxIndex].nTr === null )
      {
        var n = document.createElement('td');
        n.innerHTML = _fnGetCellData( oSettings, iMaxIndex, iCol, '' );
        return n;
      }
      return _fnGetTdNodes(oSettings, iMaxIndex)[iCol];
    }


    /**
     * Get the maximum strlen for each data column
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iCol column of interest
     *  @returns {string} max string length for each column
     *  @memberof DataTable#oApi
     */
    function _fnGetMaxLenString( oSettings, iCol )
    {
      var iMax = -1;
      var iMaxIndex = -1;

      for ( var i=0 ; i<oSettings.aoData.length ; i++ )
      {
        var s = _fnGetCellData( oSettings, i, iCol, 'display' )+"";
        s = s.replace( /<.*?>/g, "" );
        if ( s.length > iMax )
        {
          iMax = s.length;
          iMaxIndex = i;
        }
      }

      return iMaxIndex;
    }


    /**
     * Append a CSS unit (only if required) to a string
     *  @param {array} aArray1 first array
     *  @param {array} aArray2 second array
     *  @returns {int} 0 if match, 1 if length is different, 2 if no match
     *  @memberof DataTable#oApi
     */
    function _fnStringToCss( s )
    {
      if ( s === null )
      {
        return "0px";
      }

      if ( typeof s == 'number' )
      {
        if ( s < 0 )
        {
          return "0px";
        }
        return s+"px";
      }

      /* Check if the last character is not 0-9 */
      var c = s.charCodeAt( s.length-1 );
      if (c < 0x30 || c > 0x39)
      {
        return s;
      }
      return s+"px";
    }


    /**
     * Get the width of a scroll bar in this browser being used
     *  @returns {int} width in pixels
     *  @memberof DataTable#oApi
     */
    function _fnScrollBarWidth ()
    {
      var inner = document.createElement('p');
      var style = inner.style;
      style.width = "100%";
      style.height = "200px";
      style.padding = "0px";

      var outer = document.createElement('div');
      style = outer.style;
      style.position = "absolute";
      style.top = "0px";
      style.left = "0px";
      style.visibility = "hidden";
      style.width = "200px";
      style.height = "150px";
      style.padding = "0px";
      style.overflow = "hidden";
      outer.appendChild(inner);

      document.body.appendChild(outer);
      var w1 = inner.offsetWidth;
      outer.style.overflow = 'scroll';
      var w2 = inner.offsetWidth;
      if ( w1 == w2 )
      {
        w2 = outer.clientWidth;
      }

      document.body.removeChild(outer);
      return (w1 - w2);
    }



    /**
     * Change the order of the table
     *  @param {object} oSettings dataTables settings object
     *  @param {bool} bApplyClasses optional - should we apply classes or not
     *  @memberof DataTable#oApi
     */
    function _fnSort ( oSettings, bApplyClasses )
    {
      var
        i, iLen, j, jLen, k, kLen,
        sDataType, nTh,
        aaSort = [],
        aiOrig = [],
        oSort = DataTable.ext.oSort,
        aoData = oSettings.aoData,
        aoColumns = oSettings.aoColumns,
        oAria = oSettings.oLanguage.oAria;

      /* No sorting required if server-side or no sorting array */
      if ( !oSettings.oFeatures.bServerSide &&
        (oSettings.aaSorting.length !== 0 || oSettings.aaSortingFixed !== null) )
      {
        aaSort = ( oSettings.aaSortingFixed !== null ) ?
          oSettings.aaSortingFixed.concat( oSettings.aaSorting ) :
          oSettings.aaSorting.slice();

        /* If there is a sorting data type, and a function belonging to it, then we need to
         * get the data from the developer's function and apply it for this column
         */
        for ( i=0 ; i<aaSort.length ; i++ )
        {
          var iColumn = aaSort[i][0];
          var iVisColumn = _fnColumnIndexToVisible( oSettings, iColumn );
          sDataType = oSettings.aoColumns[ iColumn ].sSortDataType;
          if ( DataTable.ext.afnSortData[sDataType] )
          {
            var aData = DataTable.ext.afnSortData[sDataType].call(
              oSettings.oInstance, oSettings, iColumn, iVisColumn
            );
            if ( aData.length === aoData.length )
            {
              for ( j=0, jLen=aoData.length ; j<jLen ; j++ )
              {
                _fnSetCellData( oSettings, j, iColumn, aData[j] );
              }
            }
            else
            {
              _fnLog( oSettings, 0, "Returned data sort array (col "+iColumn+") is the wrong length" );
            }
          }
        }

        /* Create a value - key array of the current row positions such that we can use their
         * current position during the sort, if values match, in order to perform stable sorting
         */
        for ( i=0, iLen=oSettings.aiDisplayMaster.length ; i<iLen ; i++ )
        {
          aiOrig[ oSettings.aiDisplayMaster[i] ] = i;
        }

        /* Build an internal data array which is specific to the sort, so we can get and prep
         * the data to be sorted only once, rather than needing to do it every time the sorting
         * function runs. This make the sorting function a very simple comparison
         */
        var iSortLen = aaSort.length;
        var fnSortFormat, aDataSort;
        for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
        {
          for ( j=0 ; j<iSortLen ; j++ )
          {
            aDataSort = aoColumns[ aaSort[j][0] ].aDataSort;

            for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
            {
              sDataType = aoColumns[ aDataSort[k] ].sType;
              fnSortFormat = oSort[ (sDataType ? sDataType : 'string')+"-pre" ];

              aoData[i]._aSortData[ aDataSort[k] ] = fnSortFormat ?
                fnSortFormat( _fnGetCellData( oSettings, i, aDataSort[k], 'sort' ) ) :
                _fnGetCellData( oSettings, i, aDataSort[k], 'sort' );
            }
          }
        }

        /* Do the sort - here we want multi-column sorting based on a given data source (column)
         * and sorting function (from oSort) in a certain direction. It's reasonably complex to
         * follow on it's own, but this is what we want (example two column sorting):
         *  fnLocalSorting = function(a,b){
         *  	var iTest;
         *  	iTest = oSort['string-asc']('data11', 'data12');
         *  	if (iTest !== 0)
         *  		return iTest;
         *    iTest = oSort['numeric-desc']('data21', 'data22');
         *    if (iTest !== 0)
         *  		return iTest;
         *  	return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
         *  }
         * Basically we have a test for each sorting column, if the data in that column is equal,
         * test the next column. If all columns match, then we use a numeric sort on the row 
         * positions in the original data array to provide a stable sort.
         */
        oSettings.aiDisplayMaster.sort( function ( a, b ) {
          var k, l, lLen, iTest, aDataSort, sDataType;
          for ( k=0 ; k<iSortLen ; k++ )
          {
            aDataSort = aoColumns[ aaSort[k][0] ].aDataSort;

            for ( l=0, lLen=aDataSort.length ; l<lLen ; l++ )
            {
              sDataType = aoColumns[ aDataSort[l] ].sType;

              iTest = oSort[ (sDataType ? sDataType : 'string')+"-"+aaSort[k][1] ](
                aoData[a]._aSortData[ aDataSort[l] ],
                aoData[b]._aSortData[ aDataSort[l] ]
              );

              if ( iTest !== 0 )
              {
                return iTest;
              }
            }
          }

          return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
        } );
      }

      /* Alter the sorting classes to take account of the changes */
      if ( (bApplyClasses === undefined || bApplyClasses) && !oSettings.oFeatures.bDeferRender )
      {
        _fnSortingClasses( oSettings );
      }

      for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        var sTitle = aoColumns[i].sTitle.replace( /<.*?>/g, "" );
        nTh = aoColumns[i].nTh;
        nTh.removeAttribute('aria-sort');
        nTh.removeAttribute('aria-label');

        /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
        if ( aoColumns[i].bSortable )
        {
          if ( aaSort.length > 0 && aaSort[0][0] == i )
          {
            nTh.setAttribute('aria-sort', aaSort[0][1]=="asc" ? "ascending" : "descending" );

            var nextSort = (aoColumns[i].asSorting[ aaSort[0][2]+1 ]) ?
              aoColumns[i].asSorting[ aaSort[0][2]+1 ] : aoColumns[i].asSorting[0];
            nTh.setAttribute('aria-label', sTitle+
              (nextSort=="asc" ? oAria.sSortAscending : oAria.sSortDescending) );
          }
          else
          {
            nTh.setAttribute('aria-label', sTitle+
              (aoColumns[i].asSorting[0]=="asc" ? oAria.sSortAscending : oAria.sSortDescending) );
          }
        }
        else
        {
          nTh.setAttribute('aria-label', sTitle);
        }
      }

      /* Tell the draw function that we have sorted the data */
      oSettings.bSorted = true;
      $(oSettings.oInstance).trigger('sort', oSettings);

      /* Copy the master data into the draw array and re-draw */
      if ( oSettings.oFeatures.bFilter )
      {
        /* _fnFilter() will redraw the table for us */
        _fnFilterComplete( oSettings, oSettings.oPreviousSearch, 1 );
      }
      else
      {
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        oSettings._iDisplayStart = 0; /* reset display back to page 0 */
        _fnCalculateEnd( oSettings );
        _fnDraw( oSettings );
      }
    }


    /**
     * Attach a sort handler (click) to a node
     *  @param {object} oSettings dataTables settings object
     *  @param {node} nNode node to attach the handler to
     *  @param {int} iDataIndex column sorting index
     *  @param {function} [fnCallback] callback function
     *  @memberof DataTable#oApi
     */
    function _fnSortAttachListener ( oSettings, nNode, iDataIndex, fnCallback )
    {
      _fnBindAction( nNode, {}, function (e) {
        /* If the column is not sortable - don't to anything */
        if ( oSettings.aoColumns[iDataIndex].bSortable === false )
        {
          return;
        }

        /*
         * This is a little bit odd I admit... I declare a temporary function inside the scope of
         * _fnBuildHead and the click handler in order that the code presented here can be used 
         * twice - once for when bProcessing is enabled, and another time for when it is 
         * disabled, as we need to perform slightly different actions.
         *   Basically the issue here is that the Javascript engine in modern browsers don't 
         * appear to allow the rendering engine to update the display while it is still executing
         * it's thread (well - it does but only after long intervals). This means that the 
         * 'processing' display doesn't appear for a table sort. To break the js thread up a bit
         * I force an execution break by using setTimeout - but this breaks the expected 
         * thread continuation for the end-developer's point of view (their code would execute
         * too early), so we only do it when we absolutely have to.
         */
        var fnInnerSorting = function () {
          var iColumn, iNextSort;

          /* If the shift key is pressed then we are multiple column sorting */
          if ( e.shiftKey )
          {
            /* Are we already doing some kind of sort on this column? */
            var bFound = false;
            for ( var i=0 ; i<oSettings.aaSorting.length ; i++ )
            {
              if ( oSettings.aaSorting[i][0] == iDataIndex )
              {
                bFound = true;
                iColumn = oSettings.aaSorting[i][0];
                iNextSort = oSettings.aaSorting[i][2]+1;

                if ( !oSettings.aoColumns[iColumn].asSorting[iNextSort] )
                {
                  /* Reached the end of the sorting options, remove from multi-col sort */
                  oSettings.aaSorting.splice( i, 1 );
                }
                else
                {
                  /* Move onto next sorting direction */
                  oSettings.aaSorting[i][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
                  oSettings.aaSorting[i][2] = iNextSort;
                }
                break;
              }
            }

            /* No sort yet - add it in */
            if ( bFound === false )
            {
              oSettings.aaSorting.push( [ iDataIndex,
                oSettings.aoColumns[iDataIndex].asSorting[0], 0 ] );
            }
          }
          else
          {
            /* If no shift key then single column sort */
            if ( oSettings.aaSorting.length == 1 && oSettings.aaSorting[0][0] == iDataIndex )
            {
              iColumn = oSettings.aaSorting[0][0];
              iNextSort = oSettings.aaSorting[0][2]+1;
              if ( !oSettings.aoColumns[iColumn].asSorting[iNextSort] )
              {
                iNextSort = 0;
              }
              oSettings.aaSorting[0][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
              oSettings.aaSorting[0][2] = iNextSort;
            }
            else
            {
              oSettings.aaSorting.splice( 0, oSettings.aaSorting.length );
              oSettings.aaSorting.push( [ iDataIndex,
                oSettings.aoColumns[iDataIndex].asSorting[0], 0 ] );
            }
          }

          /* Run the sort */
          _fnSort( oSettings );
        }; /* /fnInnerSorting */

        if ( !oSettings.oFeatures.bProcessing )
        {
          fnInnerSorting();
        }
        else
        {
          _fnProcessingDisplay( oSettings, true );
          setTimeout( function() {
            fnInnerSorting();
            if ( !oSettings.oFeatures.bServerSide )
            {
              _fnProcessingDisplay( oSettings, false );
            }
          }, 0 );
        }

        /* Call the user specified callback function - used for async user interaction */
        if ( typeof fnCallback == 'function' )
        {
          fnCallback( oSettings );
        }
      } );
    }


    /**
     * Set the sorting classes on the header, Note: it is safe to call this function
     * when bSort and bSortClasses are false
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnSortingClasses( oSettings )
    {
      var i, iLen, j, jLen, iFound;
      var aaSort, sClass;
      var iColumns = oSettings.aoColumns.length;
      var oClasses = oSettings.oClasses;

      for ( i=0 ; i<iColumns ; i++ )
      {
        if ( oSettings.aoColumns[i].bSortable )
        {
          $(oSettings.aoColumns[i].nTh).removeClass( oClasses.sSortAsc +" "+ oClasses.sSortDesc +
            " "+ oSettings.aoColumns[i].sSortingClass );
        }
      }

      if ( oSettings.aaSortingFixed !== null )
      {
        aaSort = oSettings.aaSortingFixed.concat( oSettings.aaSorting );
      }
      else
      {
        aaSort = oSettings.aaSorting.slice();
      }

      /* Apply the required classes to the header */
      for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
      {
        if ( oSettings.aoColumns[i].bSortable )
        {
          sClass = oSettings.aoColumns[i].sSortingClass;
          iFound = -1;
          for ( j=0 ; j<aaSort.length ; j++ )
          {
            if ( aaSort[j][0] == i )
            {
              sClass = ( aaSort[j][1] == "asc" ) ?
                oClasses.sSortAsc : oClasses.sSortDesc;
              iFound = j;
              break;
            }
          }
          $(oSettings.aoColumns[i].nTh).addClass( sClass );

          if ( oSettings.bJUI )
          {
            /* jQuery UI uses extra markup */
            var jqSpan = $("span."+oClasses.sSortIcon,  oSettings.aoColumns[i].nTh);
            jqSpan.removeClass(oClasses.sSortJUIAsc +" "+ oClasses.sSortJUIDesc +" "+
              oClasses.sSortJUI +" "+ oClasses.sSortJUIAscAllowed +" "+ oClasses.sSortJUIDescAllowed );

            var sSpanClass;
            if ( iFound == -1 )
            {
              sSpanClass = oSettings.aoColumns[i].sSortingClassJUI;
            }
            else if ( aaSort[iFound][1] == "asc" )
            {
              sSpanClass = oClasses.sSortJUIAsc;
            }
            else
            {
              sSpanClass = oClasses.sSortJUIDesc;
            }

            jqSpan.addClass( sSpanClass );
          }
        }
        else
        {
          /* No sorting on this column, so add the base class. This will have been assigned by
           * _fnAddColumn
           */
          $(oSettings.aoColumns[i].nTh).addClass( oSettings.aoColumns[i].sSortingClass );
        }
      }

      /* 
       * Apply the required classes to the table body
       * Note that this is given as a feature switch since it can significantly slow down a sort
       * on large data sets (adding and removing of classes is always slow at the best of times..)
       * Further to this, note that this code is admittedly fairly ugly. It could be made a lot 
       * simpler using jQuery selectors and add/removeClass, but that is significantly slower
       * (on the order of 5 times slower) - hence the direct DOM manipulation here.
       * Note that for deferred drawing we do use jQuery - the reason being that taking the first
       * row found to see if the whole column needs processed can miss classes since the first
       * column might be new.
       */
      sClass = oClasses.sSortColumn;

      if ( oSettings.oFeatures.bSort && oSettings.oFeatures.bSortClasses )
      {
        var nTds = _fnGetTdNodes( oSettings );

        /* Remove the old classes */
        if ( oSettings.oFeatures.bDeferRender )
        {
          $(nTds).removeClass(sClass+'1 '+sClass+'2 '+sClass+'3');
        }
        else if ( nTds.length >= iColumns )
        {
          for ( i=0 ; i<iColumns ; i++ )
          {
            if ( nTds[i].className.indexOf(sClass+"1") != -1 )
            {
              for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
              {
                nTds[(iColumns*j)+i].className =
                  $.trim( nTds[(iColumns*j)+i].className.replace( sClass+"1", "" ) );
              }
            }
            else if ( nTds[i].className.indexOf(sClass+"2") != -1 )
            {
              for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
              {
                nTds[(iColumns*j)+i].className =
                  $.trim( nTds[(iColumns*j)+i].className.replace( sClass+"2", "" ) );
              }
            }
            else if ( nTds[i].className.indexOf(sClass+"3") != -1 )
            {
              for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
              {
                nTds[(iColumns*j)+i].className =
                  $.trim( nTds[(iColumns*j)+i].className.replace( " "+sClass+"3", "" ) );
              }
            }
          }
        }

        /* Add the new classes to the table */
        var iClass = 1, iTargetCol;
        for ( i=0 ; i<aaSort.length ; i++ )
        {
          iTargetCol = parseInt( aaSort[i][0], 10 );
          for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
          {
            nTds[(iColumns*j)+iTargetCol].className += " "+sClass+iClass;
          }

          if ( iClass < 3 )
          {
            iClass++;
          }
        }
      }
    }



    /**
     * Save the state of a table in a cookie such that the page can be reloaded
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnSaveState ( oSettings )
    {
      if ( !oSettings.oFeatures.bStateSave || oSettings.bDestroying )
      {
        return;
      }

      /* Store the interesting variables */
      var i, iLen, bInfinite=oSettings.oScroll.bInfinite;
      var oState = {
        "iCreate":      new Date().getTime(),
        "iStart":       (bInfinite ? 0 : oSettings._iDisplayStart),
        "iEnd":         (bInfinite ? oSettings._iDisplayLength : oSettings._iDisplayEnd),
        "iLength":      oSettings._iDisplayLength,
        "aaSorting":    $.extend( true, [], oSettings.aaSorting ),
        "oSearch":      $.extend( true, {}, oSettings.oPreviousSearch ),
        "aoSearchCols": $.extend( true, [], oSettings.aoPreSearchCols ),
        "abVisCols":    []
      };

      for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        oState.abVisCols.push( oSettings.aoColumns[i].bVisible );
      }

      _fnCallbackFire( oSettings, "aoStateSaveParams", 'stateSaveParams', [oSettings, oState] );

      oSettings.fnStateSave.call( oSettings.oInstance, oSettings, oState );
    }


    /**
     * Attempt to load a saved table state from a cookie
     *  @param {object} oSettings dataTables settings object
     *  @param {object} oInit DataTables init object so we can override settings
     *  @memberof DataTable#oApi
     */
    function _fnLoadState ( oSettings, oInit )
    {
      if ( !oSettings.oFeatures.bStateSave )
      {
        return;
      }

      var oData = oSettings.fnStateLoad.call( oSettings.oInstance, oSettings );
      if ( !oData )
      {
        return;
      }

      /* Allow custom and plug-in manipulation functions to alter the saved data set and
       * cancelling of loading by returning false
       */
      var abStateLoad = _fnCallbackFire( oSettings, 'aoStateLoadParams', 'stateLoadParams', [oSettings, oData] );
      if ( $.inArray( false, abStateLoad ) !== -1 )
      {
        return;
      }

      /* Store the saved state so it might be accessed at any time */
      oSettings.oLoadedState = $.extend( true, {}, oData );

      /* Restore key features */
      oSettings._iDisplayStart    = oData.iStart;
      oSettings.iInitDisplayStart = oData.iStart;
      oSettings._iDisplayEnd      = oData.iEnd;
      oSettings._iDisplayLength   = oData.iLength;
      oSettings.aaSorting         = oData.aaSorting.slice();
      oSettings.saved_aaSorting   = oData.aaSorting.slice();

      /* Search filtering  */
      $.extend( oSettings.oPreviousSearch, oData.oSearch );
      $.extend( true, oSettings.aoPreSearchCols, oData.aoSearchCols );

      /* Column visibility state
       * Pass back visibility settings to the init handler, but to do not here override
       * the init object that the user might have passed in
       */
      oInit.saved_aoColumns = [];
      for ( var i=0 ; i<oData.abVisCols.length ; i++ )
      {
        oInit.saved_aoColumns[i] = {};
        oInit.saved_aoColumns[i].bVisible = oData.abVisCols[i];
      }

      _fnCallbackFire( oSettings, 'aoStateLoaded', 'stateLoaded', [oSettings, oData] );
    }


    /**
     * Create a new cookie with a value to store the state of a table
     *  @param {string} sName name of the cookie to create
     *  @param {string} sValue the value the cookie should take
     *  @param {int} iSecs duration of the cookie
     *  @param {string} sBaseName sName is made up of the base + file name - this is the base
     *  @param {function} fnCallback User definable function to modify the cookie
     *  @memberof DataTable#oApi
     */
    function _fnCreateCookie ( sName, sValue, iSecs, sBaseName, fnCallback )
    {
      var date = new Date();
      date.setTime( date.getTime()+(iSecs*1000) );

      /* 
       * Shocking but true - it would appear IE has major issues with having the path not having
       * a trailing slash on it. We need the cookie to be available based on the path, so we
       * have to append the file name to the cookie name. Appalling. Thanks to vex for adding the
       * patch to use at least some of the path
       */
      var aParts = window.location.pathname.split('/');
      var sNameFile = sName + '_' + aParts.pop().replace(/[\/:]/g,"").toLowerCase();
      var sFullCookie, oData;

      if ( fnCallback !== null )
      {
        oData = (typeof $.parseJSON === 'function') ?
          $.parseJSON( sValue ) : eval( '('+sValue+')' );
        sFullCookie = fnCallback( sNameFile, oData, date.toGMTString(),
          aParts.join('/')+"/" );
      }
      else
      {
        sFullCookie = sNameFile + "=" + encodeURIComponent(sValue) +
          "; expires=" + date.toGMTString() +"; path=" + aParts.join('/')+"/";
      }

      /* Are we going to go over the cookie limit of 4KiB? If so, try to delete a cookies
       * belonging to DataTables. This is FAR from bullet proof
       */
      var sOldName="", iOldTime=9999999999999;
      var iLength = _fnReadCookie( sNameFile )!==null ? document.cookie.length :
        sFullCookie.length + document.cookie.length;

      if ( iLength+10 > 4096 ) /* Magic 10 for padding */
      {
        var aCookies =document.cookie.split(';');
        for ( var i=0, iLen=aCookies.length ; i<iLen ; i++ )
        {
          if ( aCookies[i].indexOf( sBaseName ) != -1 )
          {
            /* It's a DataTables cookie, so eval it and check the time stamp */
            var aSplitCookie = aCookies[i].split('=');
            try { oData = eval( '('+decodeURIComponent(aSplitCookie[1])+')' ); }
            catch( e ) { continue; }

            if ( oData.iCreate && oData.iCreate < iOldTime )
            {
              sOldName = aSplitCookie[0];
              iOldTime = oData.iCreate;
            }
          }
        }

        if ( sOldName !== "" )
        {
          document.cookie = sOldName+"=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path="+
            aParts.join('/') + "/";
        }
      }

      document.cookie = sFullCookie;
    }


    /**
     * Read an old cookie to get a cookie with an old table state
     *  @param {string} sName name of the cookie to read
     *  @returns {string} contents of the cookie - or null if no cookie with that name found
     *  @memberof DataTable#oApi
     */
    function _fnReadCookie ( sName )
    {
      var
        aParts = window.location.pathname.split('/'),
        sNameEQ = sName + '_' + aParts[aParts.length-1].replace(/[\/:]/g,"").toLowerCase() + '=',
        sCookieContents = document.cookie.split(';');

      for( var i=0 ; i<sCookieContents.length ; i++ )
      {
        var c = sCookieContents[i];

        while (c.charAt(0)==' ')
        {
          c = c.substring(1,c.length);
        }

        if (c.indexOf(sNameEQ) === 0)
        {
          return decodeURIComponent( c.substring(sNameEQ.length,c.length) );
        }
      }
      return null;
    }



    /**
     * Return the settings object for a particular table
     *  @param {node} nTable table we are using as a dataTable
     *  @returns {object} Settings object - or null if not found
     *  @memberof DataTable#oApi
     */
    function _fnSettingsFromNode ( nTable )
    {
      for ( var i=0 ; i<DataTable.settings.length ; i++ )
      {
        if ( DataTable.settings[i].nTable === nTable )
        {
          return DataTable.settings[i];
        }
      }

      return null;
    }


    /**
     * Return an array with the TR nodes for the table
     *  @param {object} oSettings dataTables settings object
     *  @returns {array} TR array
     *  @memberof DataTable#oApi
     */
    function _fnGetTrNodes ( oSettings )
    {
      var aNodes = [];
      var aoData = oSettings.aoData;
      for ( var i=0, iLen=aoData.length ; i<iLen ; i++ )
      {
        if ( aoData[i].nTr !== null )
        {
          aNodes.push( aoData[i].nTr );
        }
      }
      return aNodes;
    }


    /**
     * Return an flat array with all TD nodes for the table, or row
     *  @param {object} oSettings dataTables settings object
     *  @param {int} [iIndividualRow] aoData index to get the nodes for - optional
     *    if not given then the return array will contain all nodes for the table
     *  @returns {array} TD array
     *  @memberof DataTable#oApi
     */
    function _fnGetTdNodes ( oSettings, iIndividualRow )
    {
      var anReturn = [];
      var iCorrector;
      var anTds;
      var iRow, iRows=oSettings.aoData.length,
        iColumn, iColumns, oData, sNodeName, iStart=0, iEnd=iRows;

      /* Allow the collection to be limited to just one row */
      if ( iIndividualRow !== undefined )
      {
        iStart = iIndividualRow;
        iEnd = iIndividualRow+1;
      }

      for ( iRow=iStart ; iRow<iEnd ; iRow++ )
      {
        oData = oSettings.aoData[iRow];
        if ( oData.nTr !== null )
        {
          /* get the TD child nodes - taking into account text etc nodes */
          anTds = [];
          for ( iColumn=0, iColumns=oData.nTr.childNodes.length ; iColumn<iColumns ; iColumn++ )
          {
            sNodeName = oData.nTr.childNodes[iColumn].nodeName.toLowerCase();
            if ( sNodeName == 'td' || sNodeName == 'th' )
            {
              anTds.push( oData.nTr.childNodes[iColumn] );
            }
          }

          iCorrector = 0;
          for ( iColumn=0, iColumns=oSettings.aoColumns.length ; iColumn<iColumns ; iColumn++ )
          {
            if ( oSettings.aoColumns[iColumn].bVisible )
            {
              anReturn.push( anTds[iColumn-iCorrector] );
            }
            else
            {
              anReturn.push( oData._anHidden[iColumn] );
              iCorrector++;
            }
          }
        }
      }

      return anReturn;
    }


    /**
     * Log an error message
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iLevel log error messages, or display them to the user
     *  @param {string} sMesg error message
     *  @memberof DataTable#oApi
     */
    function _fnLog( oSettings, iLevel, sMesg )
    {
      var sAlert = (oSettings===null) ?
        "DataTables warning: "+sMesg :
        "DataTables warning (table id = '"+oSettings.sTableId+"'): "+sMesg;

      if ( iLevel === 0 )
      {
        if ( DataTable.ext.sErrMode == 'alert' )
        {
          alert( sAlert );
        }
        else
        {
          throw new Error(sAlert);
        }
        return;
      }
      else if ( window.console && console.log )
      {
        console.log( sAlert );
      }
    }


    /**
     * See if a property is defined on one object, if so assign it to the other object
     *  @param {object} oRet target object
     *  @param {object} oSrc source object
     *  @param {string} sName property
     *  @param {string} [sMappedName] name to map too - optional, sName used if not given
     *  @memberof DataTable#oApi
     */
    function _fnMap( oRet, oSrc, sName, sMappedName )
    {
      if ( sMappedName === undefined )
      {
        sMappedName = sName;
      }
      if ( oSrc[sName] !== undefined )
      {
        oRet[sMappedName] = oSrc[sName];
      }
    }


    /**
     * Extend objects - very similar to jQuery.extend, but deep copy objects, and shallow
     * copy arrays. The reason we need to do this, is that we don't want to deep copy array
     * init values (such as aaSorting) since the dev wouldn't be able to override them, but
     * we do want to deep copy arrays.
     *  @param {object} oOut Object to extend
     *  @param {object} oExtender Object from which the properties will be applied to oOut
     *  @returns {object} oOut Reference, just for convenience - oOut === the return.
     *  @memberof DataTable#oApi
     *  @todo This doesn't take account of arrays inside the deep copied objects.
     */
    function _fnExtend( oOut, oExtender )
    {
      var val;

      for ( var prop in oExtender )
      {
        if ( oExtender.hasOwnProperty(prop) )
        {
          val = oExtender[prop];

          if ( typeof oInit[prop] === 'object' && val !== null && $.isArray(val) === false )
          {
            $.extend( true, oOut[prop], val );
          }
          else
          {
            oOut[prop] = val;
          }
        }
      }

      return oOut;
    }


    /**
     * Bind an event handers to allow a click or return key to activate the callback.
     * This is good for accessibility since a return on the keyboard will have the
     * same effect as a click, if the element has focus.
     *  @param {element} n Element to bind the action to
     *  @param {object} oData Data object to pass to the triggered function
     *  @param {function} fn Callback function for when the event is triggered
     *  @memberof DataTable#oApi
     */
    function _fnBindAction( n, oData, fn )
    {
      $(n)
        .bind( 'click.DT', oData, function (e) {
          n.blur(); // Remove focus outline for mouse users
          fn(e);
        } )
        .bind( 'keypress.DT', oData, function (e){
          if ( e.which === 13 ) {
            fn(e);
          } } )
        .bind( 'selectstart.DT', function () {
          /* Take the brutal approach to cancelling text selection */
          return false;
        } );
    }


    /**
     * Register a callback function. Easily allows a callback function to be added to
     * an array store of callback functions that can then all be called together.
     *  @param {object} oSettings dataTables settings object
     *  @param {string} sStore Name of the array storage for the callbacks in oSettings
     *  @param {function} fn Function to be called back
     *  @param {string} sName Identifying name for the callback (i.e. a label)
     *  @memberof DataTable#oApi
     */
    function _fnCallbackReg( oSettings, sStore, fn, sName )
    {
      if ( fn )
      {
        oSettings[sStore].push( {
          "fn": fn,
          "sName": sName
        } );
      }
    }


    /**
     * Fire callback functions and trigger events. Note that the loop over the callback
     * array store is done backwards! Further note that you do not want to fire off triggers
     * in time sensitive applications (for example cell creation) as its slow.
     *  @param {object} oSettings dataTables settings object
     *  @param {string} sStore Name of the array storage for the callbacks in oSettings
     *  @param {string} sTrigger Name of the jQuery custom event to trigger. If null no trigger
     *    is fired
     *  @param {array} aArgs Array of arguments to pass to the callback function / trigger
     *  @memberof DataTable#oApi
     */
    function _fnCallbackFire( oSettings, sStore, sTrigger, aArgs )
    {
      var aoStore = oSettings[sStore];
      var aRet =[];

      for ( var i=aoStore.length-1 ; i>=0 ; i-- )
      {
        aRet.push( aoStore[i].fn.apply( oSettings.oInstance, aArgs ) );
      }

      if ( sTrigger !== null )
      {
        $(oSettings.oInstance).trigger(sTrigger, aArgs);
      }

      return aRet;
    }


    /**
     * JSON stringify. If JSON.stringify it provided by the browser, json2.js or any other
     * library, then we use that as it is fast, safe and accurate. If the function isn't
     * available then we need to built it ourselves - the inspiration for this function comes
     * from Craig Buckler ( http://www.sitepoint.com/javascript-json-serialization/ ). It is
     * not perfect and absolutely should not be used as a replacement to json2.js - but it does
     * do what we need, without requiring a dependency for DataTables.
     *  @param {object} o JSON object to be converted
     *  @returns {string} JSON string
     *  @memberof DataTable#oApi
     */
    var _fnJsonString = (window.JSON) ? JSON.stringify : function( o )
    {
      /* Not an object or array */
      var sType = typeof o;
      if (sType !== "object" || o === null)
      {
        // simple data type
        if (sType === "string")
        {
          o = '"'+o+'"';
        }
        return o+"";
      }

      /* If object or array, need to recurse over it */
      var
        sProp, mValue,
        json = [],
        bArr = $.isArray(o);

      for (sProp in o)
      {
        mValue = o[sProp];
        sType = typeof mValue;

        if (sType === "string")
        {
          mValue = '"'+mValue+'"';
        }
        else if (sType === "object" && mValue !== null)
        {
          mValue = _fnJsonString(mValue);
        }

        json.push((bArr ? "" : '"'+sProp+'":') + mValue);
      }

      return (bArr ? "[" : "{") + json + (bArr ? "]" : "}");
    };


    /**
     * From some browsers (specifically IE6/7) we need special handling to work around browser
     * bugs - this function is used to detect when these workarounds are needed.
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */
    function _fnBrowserDetect( oSettings )
    {
      /* IE6/7 will oversize a width 100% element inside a scrolling element, to include the
       * width of the scrollbar, while other browsers ensure the inner element is contained
       * without forcing scrolling
       */
      var n = $(
        '<div style="position:absolute; top:0; left:0; height:1px; width:1px; overflow:hidden">'+
          '<div style="position:absolute; top:1px; left:1px; width:100px; height:50px; overflow:scroll;">'+
          '<div id="DT_BrowserTest" style="width:100%; height:10px;"></div>'+
          '</div>'+
          '</div>')[0];

      document.body.appendChild( n );
      oSettings.oBrowser.bScrollOversize = $('#DT_BrowserTest', n)[0].offsetWidth === 100 ? true : false;
      document.body.removeChild( n );
    }




    /**
     * Perform a jQuery selector action on the table's TR elements (from the tbody) and
     * return the resulting jQuery object.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
     *    criterion ("applied") or all TR elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {object} jQuery object, filtered by the given selector.
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
		 *    } );
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to rows with 'Webkit' in them, add a background colour and then
		 *      // remove the filter, thus highlighting the 'Webkit' rows only.
		 *      oTable.fnFilter('Webkit');
		 *      oTable.$('tr', {"filter": "applied"}).css('backgroundColor', 'blue');
		 *      oTable.fnFilter('');
		 *    } );
     */
    this.$ = function ( sSelector, oOpts )
    {
      var i, iLen, a = [], tr;
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      var aoData = oSettings.aoData;
      var aiDisplay = oSettings.aiDisplay;
      var aiDisplayMaster = oSettings.aiDisplayMaster;

      if ( !oOpts )
      {
        oOpts = {};
      }

      oOpts = $.extend( {}, {
        "filter": "none", // applied
        "order": "current", // "original"
        "page": "all" // current
      }, oOpts );

      // Current page implies that order=current and fitler=applied, since it is fairly
      // senseless otherwise
      if ( oOpts.page == 'current' )
      {
        for ( i=oSettings._iDisplayStart, iLen=oSettings.fnDisplayEnd() ; i<iLen ; i++ )
        {
          tr = aoData[ aiDisplay[i] ].nTr;
          if ( tr )
          {
            a.push( tr );
          }
        }
      }
      else if ( oOpts.order == "current" && oOpts.filter == "none" )
      {
        for ( i=0, iLen=aiDisplayMaster.length ; i<iLen ; i++ )
        {
          tr = aoData[ aiDisplayMaster[i] ].nTr;
          if ( tr )
          {
            a.push( tr );
          }
        }
      }
      else if ( oOpts.order == "current" && oOpts.filter == "applied" )
      {
        for ( i=0, iLen=aiDisplay.length ; i<iLen ; i++ )
        {
          tr = aoData[ aiDisplay[i] ].nTr;
          if ( tr )
          {
            a.push( tr );
          }
        }
      }
      else if ( oOpts.order == "original" && oOpts.filter == "none" )
      {
        for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
        {
          tr = aoData[ i ].nTr ;
          if ( tr )
          {
            a.push( tr );
          }
        }
      }
      else if ( oOpts.order == "original" && oOpts.filter == "applied" )
      {
        for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
        {
          tr = aoData[ i ].nTr;
          if ( $.inArray( i, aiDisplay ) !== -1 && tr )
          {
            a.push( tr );
          }
        }
      }
      else
      {
        _fnLog( oSettings, 1, "Unknown selection options" );
      }

      /* We need to filter on the TR elements and also 'find' in their descendants
       * to make the selector act like it would in a full table - so we need
       * to build both results and then combine them together
       */
      var jqA = $(a);
      var jqTRs = jqA.filter( sSelector );
      var jqDescendants = jqA.find( sSelector );

      return $( [].concat($.makeArray(jqTRs), $.makeArray(jqDescendants)) );
    };


    /**
     * Almost identical to $ in operation, but in this case returns the data for the matched
     * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
     * rather than any descendants, so the data can be obtained for the row/cell. If matching
     * rows are found, the data returned is the original data array/object that was used to
     * create the row (or a generated array if from a DOM source).
     *
     * This method is often useful in-combination with $ where both functions are given the
     * same parameters and the array indexes will match identically.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
     *    criterion ("applied") or all elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the data in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {array} Data for the matched elements. If any elements, as a result of the
     *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
     *    entry in the array.
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._('tr:first');
		 *
		 *      // Do something useful with the data
		 *      alert( "First cell is: "+data[0] );
		 *    } );
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to 'Webkit' and get all data for 
		 *      oTable.fnFilter('Webkit');
		 *      var data = oTable._('tr', {"filter": "applied"});
		 *      
		 *      // Do something with the data
		 *      alert( data.length+" rows matched the filter" );
		 *    } );
     */
    this._ = function ( sSelector, oOpts )
    {
      var aOut = [];
      var i, iLen, iIndex;
      var aTrs = this.$( sSelector, oOpts );

      for ( i=0, iLen=aTrs.length ; i<iLen ; i++ )
      {
        aOut.push( this.fnGetData(aTrs[i]) );
      }

      return aOut;
    };


    /**
     * Add a single new row or multiple rows of data to the table. Please note
     * that this is suitable for client-side processing only - if you are using
     * server-side processing (i.e. "bServerSide": true), then to add data, you
     * must add it to the data source, i.e. the server-side, through an Ajax call.
     *  @param {array|object} mData The data to be added to the table. This can be:
     *    <ul>
     *      <li>1D array of data - add a single row with the data provided</li>
     *      <li>2D array of arrays - add multiple rows in a single call</li>
     *      <li>object - data object when using <i>mData</i></li>
     *      <li>array of objects - multiple data objects when using <i>mData</i></li>
     *    </ul>
     *  @param {bool} [bRedraw=true] redraw the table or not
     *  @returns {array} An array of integers, representing the list of indexes in
     *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
     *    the table.
     *  @dtopt API
     *
     *  @example
     *    // Global var for counter
     *    var giCount = 2;
     *
     *    $(document).ready(function() {
		 *      $('#example').dataTable();
		 *    } );
     *
     *    function fnClickAddRow() {
		 *      $('#example').dataTable().fnAddData( [
		 *        giCount+".1",
		 *        giCount+".2",
		 *        giCount+".3",
		 *        giCount+".4" ]
		 *      );
		 *        
		 *      giCount++;
		 *    }
     */
    this.fnAddData = function( mData, bRedraw )
    {
      if ( mData.length === 0 )
      {
        return [];
      }

      var aiReturn = [];
      var iTest;

      /* Find settings from table node */
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

      /* Check if we want to add multiple rows or not */
      if ( typeof mData[0] === "object" && mData[0] !== null )
      {
        for ( var i=0 ; i<mData.length ; i++ )
        {
          iTest = _fnAddData( oSettings, mData[i] );
          if ( iTest == -1 )
          {
            return aiReturn;
          }
          aiReturn.push( iTest );
        }
      }
      else
      {
        iTest = _fnAddData( oSettings, mData );
        if ( iTest == -1 )
        {
          return aiReturn;
        }
        aiReturn.push( iTest );
      }

      oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

      if ( bRedraw === undefined || bRedraw )
      {
        _fnReDraw( oSettings );
      }
      return aiReturn;
    };


    /**
     * This function will make DataTables recalculate the column sizes, based on the data
     * contained in the table and the sizes applied to the columns (in the DOM, CSS or
     * through the sWidth parameter). This can be useful when the width of the table's
     * parent element changes (for example a window resize).
     *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *      
		 *      $(window).bind('resize', function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
     */
    this.fnAdjustColumnSizing = function ( bRedraw )
    {
      var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
      _fnAdjustColumnSizing( oSettings );

      if ( bRedraw === undefined || bRedraw )
      {
        this.fnDraw( false );
      }
      else if ( oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "" )
      {
        /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
        this.oApi._fnScrollDraw(oSettings);
      }
    };


    /**
     * Quickly and simply clear a table
     *  @param {bool} [bRedraw=true] redraw the table or not
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
     */
    this.fnClearTable = function( bRedraw )
    {
      /* Find settings from table node */
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      _fnClearTable( oSettings );

      if ( bRedraw === undefined || bRedraw )
      {
        _fnDraw( oSettings );
      }
    };


    /**
     * The exact opposite of 'opening' a row, this function will close any rows which
     * are currently 'open'.
     *  @param {node} nTr the table row to 'close'
     *  @returns {int} 0 on success, or 1 if failed (can't find the row)
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
     */
    this.fnClose = function( nTr )
    {
      /* Find settings from table node */
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

      for ( var i=0 ; i<oSettings.aoOpenRows.length ; i++ )
      {
        if ( oSettings.aoOpenRows[i].nParent == nTr )
        {
          var nTrParent = oSettings.aoOpenRows[i].nTr.parentNode;
          if ( nTrParent )
          {
            /* Remove it if it is currently on display */
            nTrParent.removeChild( oSettings.aoOpenRows[i].nTr );
          }
          oSettings.aoOpenRows.splice( i, 1 );
          return 0;
        }
      }
      return 1;
    };


    /**
     * Remove a row for the table
     *  @param {mixed} mTarget The index of the row from aoData to be deleted, or
     *    the TR element you want to delete
     *  @param {function|null} [fnCallBack] Callback function
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @returns {array} The row that was deleted
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
     */
    this.fnDeleteRow = function( mTarget, fnCallBack, bRedraw )
    {
      /* Find settings from table node */
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      var i, iLen, iAODataIndex;

      iAODataIndex = (typeof mTarget === 'object') ?
        _fnNodeToDataIndex(oSettings, mTarget) : mTarget;

      /* Return the data array from this row */
      var oData = oSettings.aoData.splice( iAODataIndex, 1 );

      /* Update the _DT_RowIndex parameter */
      for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
      {
        if ( oSettings.aoData[i].nTr !== null )
        {
          oSettings.aoData[i].nTr._DT_RowIndex = i;
        }
      }

      /* Remove the target row from the search array */
      var iDisplayIndex = $.inArray( iAODataIndex, oSettings.aiDisplay );
      oSettings.asDataSearch.splice( iDisplayIndex, 1 );

      /* Delete from the display arrays */
      _fnDeleteIndex( oSettings.aiDisplayMaster, iAODataIndex );
      _fnDeleteIndex( oSettings.aiDisplay, iAODataIndex );

      /* If there is a user callback function - call it */
      if ( typeof fnCallBack === "function" )
      {
        fnCallBack.call( this, oSettings, oData );
      }

      /* Check for an 'overflow' they case for displaying the table */
      if ( oSettings._iDisplayStart >= oSettings.fnRecordsDisplay() )
      {
        oSettings._iDisplayStart -= oSettings._iDisplayLength;
        if ( oSettings._iDisplayStart < 0 )
        {
          oSettings._iDisplayStart = 0;
        }
      }

      if ( bRedraw === undefined || bRedraw )
      {
        _fnCalculateEnd( oSettings );
        _fnDraw( oSettings );
      }

      return oData;
    };


    /**
     * Restore the table to it's original state in the DOM by removing all of DataTables
     * enhancements, alterations to the DOM structure of the table and event listeners.
     *  @param {boolean} [bRemove=false] Completely remove the table from the DOM
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnDestroy();
		 *    } );
     */
    this.fnDestroy = function ( bRemove )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      var nOrig = oSettings.nTableWrapper.parentNode;
      var nBody = oSettings.nTBody;
      var i, iLen;

      bRemove = (bRemove===undefined) ? false : true;

      /* Flag to note that the table is currently being destroyed - no action should be taken */
      oSettings.bDestroying = true;

      /* Fire off the destroy callbacks for plug-ins etc */
      _fnCallbackFire( oSettings, "aoDestroyCallback", "destroy", [oSettings] );

      /* Restore hidden columns */
      for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
      {
        if ( oSettings.aoColumns[i].bVisible === false )
        {
          this.fnSetColumnVis( i, true );
        }
      }

      /* Blitz all DT events */
      $(oSettings.nTableWrapper).find('*').andSelf().unbind('.DT');

      /* If there is an 'empty' indicator row, remove it */
      $('tbody>tr>td.'+oSettings.oClasses.sRowEmpty, oSettings.nTable).parent().remove();

      /* When scrolling we had to break the table up - restore it */
      if ( oSettings.nTable != oSettings.nTHead.parentNode )
      {
        $(oSettings.nTable).children('thead').remove();
        oSettings.nTable.appendChild( oSettings.nTHead );
      }

      if ( oSettings.nTFoot && oSettings.nTable != oSettings.nTFoot.parentNode )
      {
        $(oSettings.nTable).children('tfoot').remove();
        oSettings.nTable.appendChild( oSettings.nTFoot );
      }

      /* Remove the DataTables generated nodes, events and classes */
      oSettings.nTable.parentNode.removeChild( oSettings.nTable );
      $(oSettings.nTableWrapper).remove();

      oSettings.aaSorting = [];
      oSettings.aaSortingFixed = [];
      _fnSortingClasses( oSettings );

      $(_fnGetTrNodes( oSettings )).removeClass( oSettings.asStripeClasses.join(' ') );

      $('th, td', oSettings.nTHead).removeClass( [
        oSettings.oClasses.sSortable,
        oSettings.oClasses.sSortableAsc,
        oSettings.oClasses.sSortableDesc,
        oSettings.oClasses.sSortableNone ].join(' ')
      );
      if ( oSettings.bJUI )
      {
        $('th span.'+oSettings.oClasses.sSortIcon
          + ', td span.'+oSettings.oClasses.sSortIcon, oSettings.nTHead).remove();

        $('th, td', oSettings.nTHead).each( function () {
          var jqWrapper = $('div.'+oSettings.oClasses.sSortJUIWrapper, this);
          var kids = jqWrapper.contents();
          $(this).append( kids );
          jqWrapper.remove();
        } );
      }

      /* Add the TR elements back into the table in their original order */
      if ( !bRemove && oSettings.nTableReinsertBefore )
      {
        nOrig.insertBefore( oSettings.nTable, oSettings.nTableReinsertBefore );
      }
      else if ( !bRemove )
      {
        nOrig.appendChild( oSettings.nTable );
      }

      for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
      {
        if ( oSettings.aoData[i].nTr !== null )
        {
          nBody.appendChild( oSettings.aoData[i].nTr );
        }
      }

      /* Restore the width of the original table */
      if ( oSettings.oFeatures.bAutoWidth === true )
      {
        oSettings.nTable.style.width = _fnStringToCss(oSettings.sDestroyWidth);
      }

      /* If the were originally odd/even type classes - then we add them back here. Note
       * this is not fool proof (for example if not all rows as odd/even classes - but 
       * it's a good effort without getting carried away
       */
      $(nBody).children('tr:even').addClass( oSettings.asDestroyStripes[0] );
      $(nBody).children('tr:odd').addClass( oSettings.asDestroyStripes[1] );

      /* Remove the settings object from the settings array */
      for ( i=0, iLen=DataTable.settings.length ; i<iLen ; i++ )
      {
        if ( DataTable.settings[i] == oSettings )
        {
          DataTable.settings.splice( i, 1 );
        }
      }

      /* End it all */
      oSettings = null;
    };


    /**
     * Redraw the table
     *  @param {bool} [bComplete=true] Re-filter and resort (if enabled) the table before the draw.
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
		 *      oTable.fnDraw();
		 *    } );
     */
    this.fnDraw = function( bComplete )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      if ( bComplete === false )
      {
        _fnCalculateEnd( oSettings );
        _fnDraw( oSettings );
      }
      else
      {
        _fnReDraw( oSettings );
      }
    };


    /**
     * Filter the input based on data
     *  @param {string} sInput String to filter the table on
     *  @param {int|null} [iColumn] Column to limit filtering to
     *  @param {bool} [bRegex=false] Treat as regular expression or not
     *  @param {bool} [bSmart=true] Perform smart filtering or not
     *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
     *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( 'test string' );
		 *    } );
     */
    this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

      if ( !oSettings.oFeatures.bFilter )
      {
        return;
      }

      if ( bRegex === undefined || bRegex === null )
      {
        bRegex = false;
      }

      if ( bSmart === undefined || bSmart === null )
      {
        bSmart = true;
      }

      if ( bShowGlobal === undefined || bShowGlobal === null )
      {
        bShowGlobal = true;
      }

      if ( bCaseInsensitive === undefined || bCaseInsensitive === null )
      {
        bCaseInsensitive = true;
      }

      if ( iColumn === undefined || iColumn === null )
      {
        /* Global filter */
        _fnFilterComplete( oSettings, {
          "sSearch":sInput+"",
          "bRegex": bRegex,
          "bSmart": bSmart,
          "bCaseInsensitive": bCaseInsensitive
        }, 1 );

        if ( bShowGlobal && oSettings.aanFeatures.f )
        {
          var n = oSettings.aanFeatures.f;
          for ( var i=0, iLen=n.length ; i<iLen ; i++ )
          {
            $(n[i]._DT_Input).val( sInput );
          }
        }
      }
      else
      {
        /* Single column filter */
        $.extend( oSettings.aoPreSearchCols[ iColumn ], {
          "sSearch": sInput+"",
          "bRegex": bRegex,
          "bSmart": bSmart,
          "bCaseInsensitive": bCaseInsensitive
        } );
        _fnFilterComplete( oSettings, oSettings.oPreviousSearch, 1 );
      }
    };


    /**
     * Get the data for the whole table, an individual row or an individual cell based on the
     * provided parameters.
     *  @param {int|node} [mRow] A TR row node, TD/TH cell node or an integer. If given as
     *    a TR node then the data source for the whole row will be returned. If given as a
     *    TD/TH cell node then iCol will be automatically calculated and the data for the
     *    cell returned. If given as an integer, then this is treated as the aoData internal
     *    data index for the row (see fnGetPosition) and the data for that row used.
     *  @param {int} [iCol] Optional column index that you want the data of.
     *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
     *    returned. If mRow is defined, just data for that row, and is iCol is
     *    defined, only data for the designated cell is returned.
     *  @dtopt API
     *
     *  @example
     *    // Row data
     *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('tr').click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
     *
     *  @example
     *    // Individual cell data
     *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('td').click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( 'The cell clicked on had the value of '+sData );
		 *      } );
		 *    } );
     */
    this.fnGetData = function( mRow, iCol )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

      if ( mRow !== undefined )
      {
        var iRow = mRow;
        if ( typeof mRow === 'object' )
        {
          var sNode = mRow.nodeName.toLowerCase();
          if (sNode === "tr" )
          {
            iRow = _fnNodeToDataIndex(oSettings, mRow);
          }
          else if ( sNode === "td" )
          {
            iRow = _fnNodeToDataIndex(oSettings, mRow.parentNode);
            iCol = _fnNodeToColumnIndex( oSettings, iRow, mRow );
          }
        }

        if ( iCol !== undefined )
        {
          return _fnGetCellData( oSettings, iRow, iCol, '' );
        }
        return (oSettings.aoData[iRow]!==undefined) ?
          oSettings.aoData[iRow]._aData : null;
      }
      return _fnGetDataMaster( oSettings );
    };


    /**
     * Get an array of the TR nodes that are used in the table's body. Note that you will
     * typically want to use the '$' API method in preference to this as it is more
     * flexible.
     *  @param {int} [iRow] Optional row index for the TR element you want
     *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
     *    in the table's body, or iRow is defined, just the TR element requested.
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
     */
    this.fnGetNodes = function( iRow )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

      if ( iRow !== undefined ) {
        return (oSettings.aoData[iRow]!==undefined) ?
          oSettings.aoData[iRow].nTr : null;
      }
      return _fnGetTrNodes( oSettings );
    };


    /**
     * Get the array indexes of a particular cell from it's DOM element
     * and column index including hidden columns
     *  @param {node} nNode this can either be a TR, TD or TH in the table's body
     *  @returns {int} If nNode is given as a TR, then a single index is returned, or
     *    if given as a cell, an array of [row index, column index (visible)] is given.
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      $('#example tbody td').click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *        
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *        
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = 'clicked';
		 *        this.innerHTML = 'clicked';
		 *      } );
		 *      
		 *      // Init DataTables
		 *      oTable = $('#example').dataTable();
		 *    } );
     */
    this.fnGetPosition = function( nNode )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      var sNodeName = nNode.nodeName.toUpperCase();

      if ( sNodeName == "TR" )
      {
        return _fnNodeToDataIndex(oSettings, nNode);
      }
      else if ( sNodeName == "TD" || sNodeName == "TH" )
      {
        var iDataIndex = _fnNodeToDataIndex( oSettings, nNode.parentNode );
        var iColumnIndex = _fnNodeToColumnIndex( oSettings, iDataIndex, nNode );
        return [ iDataIndex, _fnColumnIndexToVisible(oSettings, iColumnIndex ), iColumnIndex ];
      }
      return null;
    };


    /**
     * Check to see if a row is 'open' or not.
     *  @param {node} nTr the table row to check
     *  @returns {boolean} true if the row is currently open, false otherwise
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
     */
    this.fnIsOpen = function( nTr )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      var aoOpenRows = oSettings.aoOpenRows;

      for ( var i=0 ; i<oSettings.aoOpenRows.length ; i++ )
      {
        if ( oSettings.aoOpenRows[i].nParent == nTr )
        {
          return true;
        }
      }
      return false;
    };


    /**
     * This function will place a new row directly after a row which is currently
     * on display on the page, with the HTML contents that is passed into the
     * function. This can be used, for example, to ask for confirmation that a
     * particular record should be deleted.
     *  @param {node} nTr The table row to 'open'
     *  @param {string|node|jQuery} mHtml The HTML to put into the row
     *  @param {string} sClass Class to give the new TD cell
     *  @returns {node} The row opened. Note that if the table row passed in as the
     *    first parameter, is not found in the table, this method will silently
     *    return.
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
     */
    this.fnOpen = function( nTr, mHtml, sClass )
    {
      /* Find settings from table node */
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

      /* Check that the row given is in the table */
      var nTableRows = _fnGetTrNodes( oSettings );
      if ( $.inArray(nTr, nTableRows) === -1 )
      {
        return;
      }

      /* the old open one if there is one */
      this.fnClose( nTr );

      var nNewRow = document.createElement("tr");
      var nNewCell = document.createElement("td");
      nNewRow.appendChild( nNewCell );
      nNewCell.className = sClass;
      nNewCell.colSpan = _fnVisbleColumns( oSettings );

      if (typeof mHtml === "string")
      {
        nNewCell.innerHTML = mHtml;
      }
      else
      {
        $(nNewCell).html( mHtml );
      }

      /* If the nTr isn't on the page at the moment - then we don't insert at the moment */
      var nTrs = $('tr', oSettings.nTBody);
      if ( $.inArray(nTr, nTrs) != -1  )
      {
        $(nNewRow).insertAfter(nTr);
      }

      oSettings.aoOpenRows.push( {
        "nTr": nNewRow,
        "nParent": nTr
      } );

      return nNewRow;
    };


    /**
     * Change the pagination - provides the internal logic for pagination in a simple API
     * function. With this function you can have a DataTables table go to the next,
     * previous, first or last pages.
     *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
     *    or page number to jump to (integer), note that page 0 is the first page.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnPageChange( 'next' );
		 *    } );
     */
    this.fnPageChange = function ( mAction, bRedraw )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      _fnPageChange( oSettings, mAction );
      _fnCalculateEnd( oSettings );

      if ( bRedraw === undefined || bRedraw )
      {
        _fnDraw( oSettings );
      }
    };


    /**
     * Show a particular column
     *  @param {int} iCol The column whose display should be changed
     *  @param {bool} bShow Show (true) or hide (false) the column
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
     */
    this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      var i, iLen;
      var aoColumns = oSettings.aoColumns;
      var aoData = oSettings.aoData;
      var nTd, bAppend, iBefore;

      /* No point in doing anything if we are requesting what is already true */
      if ( aoColumns[iCol].bVisible == bShow )
      {
        return;
      }

      /* Show the column */
      if ( bShow )
      {
        var iInsert = 0;
        for ( i=0 ; i<iCol ; i++ )
        {
          if ( aoColumns[i].bVisible )
          {
            iInsert++;
          }
        }

        /* Need to decide if we should use appendChild or insertBefore */
        bAppend = (iInsert >= _fnVisbleColumns( oSettings ));

        /* Which coloumn should we be inserting before? */
        if ( !bAppend )
        {
          for ( i=iCol ; i<aoColumns.length ; i++ )
          {
            if ( aoColumns[i].bVisible )
            {
              iBefore = i;
              break;
            }
          }
        }

        for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
        {
          if ( aoData[i].nTr !== null )
          {
            if ( bAppend )
            {
              aoData[i].nTr.appendChild(
                aoData[i]._anHidden[iCol]
              );
            }
            else
            {
              aoData[i].nTr.insertBefore(
                aoData[i]._anHidden[iCol],
                _fnGetTdNodes( oSettings, i )[iBefore] );
            }
          }
        }
      }
      else
      {
        /* Remove a column from display */
        for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
        {
          if ( aoData[i].nTr !== null )
          {
            nTd = _fnGetTdNodes( oSettings, i )[iCol];
            aoData[i]._anHidden[iCol] = nTd;
            nTd.parentNode.removeChild( nTd );
          }
        }
      }

      /* Clear to set the visible flag */
      aoColumns[iCol].bVisible = bShow;

      /* Redraw the header and footer based on the new column visibility */
      _fnDrawHead( oSettings, oSettings.aoHeader );
      if ( oSettings.nTFoot )
      {
        _fnDrawHead( oSettings, oSettings.aoFooter );
      }

      /* If there are any 'open' rows, then we need to alter the colspan for this col change */
      for ( i=0, iLen=oSettings.aoOpenRows.length ; i<iLen ; i++ )
      {
        oSettings.aoOpenRows[i].nTr.colSpan = _fnVisbleColumns( oSettings );
      }

      /* Do a redraw incase anything depending on the table columns needs it 
       * (built-in: scrolling) 
       */
      if ( bRedraw === undefined || bRedraw )
      {
        _fnAdjustColumnSizing( oSettings );
        _fnDraw( oSettings );
      }

      _fnSaveState( oSettings );
    };


    /**
     * Get the settings for a particular table for external manipulation
     *  @returns {object} DataTables settings object. See
     *    {@link DataTable.models.oSettings}
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *      
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
     */
    this.fnSettings = function()
    {
      return _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
    };


    /**
     * Sort the table by a particular column
     *  @param {int} iCol the data index to sort on. Note that this will not match the
     *    'display index' if you have hidden data entries
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
		 *    } );
     */
    this.fnSort = function( aaSort )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      oSettings.aaSorting = aaSort;
      _fnSort( oSettings );
    };


    /**
     * Attach a sort listener to an element for a given column
     *  @param {node} nNode the element to attach the sort listener to
     *  @param {int} iColumn the column that a click on this node will sort on
     *  @param {function} [fnCallback] callback function when sort is run
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sort on column 1, when 'sorter' is clicked on
		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
		 *    } );
     */
    this.fnSortListener = function( nNode, iColumn, fnCallback )
    {
      _fnSortAttachListener( _fnSettingsFromNode( this[DataTable.ext.iApiIndex] ), nNode, iColumn,
        fnCallback );
    };


    /**
     * Update a table cell or row - this method will accept either a single value to
     * update the cell with, an array of values with one element for each column or
     * an object in the same format as the original data source. The function is
     * self-referencing in order to make the multi column updates easier.
     *  @param {object|array|string} mData Data to update the cell/row with
     *  @param {node|int} mRow TR element you want to update or the aoData index
     *  @param {int} [iColumn] The column to update (not used of mData is an array or object)
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @param {bool} [bAction=true] Perform pre-draw actions or not
     *  @returns {int} 0 on success, 1 on error
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], 1, 0 ); // Row
		 *    } );
     */
    this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
    {
      var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
      var i, iLen, sDisplay;
      var iRow = (typeof mRow === 'object') ?
        _fnNodeToDataIndex(oSettings, mRow) : mRow;

      if ( $.isArray(mData) && iColumn === undefined )
      {
        /* Array update - update the whole row */
        oSettings.aoData[iRow]._aData = mData.slice();

        /* Flag to the function that we are recursing */
        for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
        {
          this.fnUpdate( _fnGetCellData( oSettings, iRow, i ), iRow, i, false, false );
        }
      }
      else if ( $.isPlainObject(mData) && iColumn === undefined )
      {
        /* Object update - update the whole row - assume the developer gets the object right */
        oSettings.aoData[iRow]._aData = $.extend( true, {}, mData );

        for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
        {
          this.fnUpdate( _fnGetCellData( oSettings, iRow, i ), iRow, i, false, false );
        }
      }
      else
      {
        /* Individual cell update */
        _fnSetCellData( oSettings, iRow, iColumn, mData );
        sDisplay = _fnGetCellData( oSettings, iRow, iColumn, 'display' );

        var oCol = oSettings.aoColumns[iColumn];
        if ( oCol.fnRender !== null )
        {
          sDisplay = _fnRender( oSettings, iRow, iColumn );
          if ( oCol.bUseRendered )
          {
            _fnSetCellData( oSettings, iRow, iColumn, sDisplay );
          }
        }

        if ( oSettings.aoData[iRow].nTr !== null )
        {
          /* Do the actual HTML update */
          _fnGetTdNodes( oSettings, iRow )[iColumn].innerHTML = sDisplay;
        }
      }

      /* Modify the search index for this row (strictly this is likely not needed, since fnReDraw
       * will rebuild the search array - however, the redraw might be disabled by the user)
       */
      var iDisplayIndex = $.inArray( iRow, oSettings.aiDisplay );
      oSettings.asDataSearch[iDisplayIndex] = _fnBuildSearchRow(
        oSettings,
        _fnGetRowData( oSettings, iRow, 'filter', _fnGetColumns( oSettings, 'bSearchable' ) )
      );

      /* Perform pre-draw actions */
      if ( bAction === undefined || bAction )
      {
        _fnAdjustColumnSizing( oSettings );
      }

      /* Redraw the table */
      if ( bRedraw === undefined || bRedraw )
      {
        _fnReDraw( oSettings );
      }
      return 0;
    };


    /**
     * Provide a common method for plug-ins to check the version of DataTables being used, in order
     * to ensure compatibility.
     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
     *    formats "X" and "X.Y" are also acceptable.
     *  @returns {boolean} true if this version of DataTables is greater or equal to the required
     *    version, or false if this version of DataTales is not suitable
     *  @method
     *  @dtopt API
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
     */
    this.fnVersionCheck = DataTable.ext.fnVersionCheck;


    /*
     * This is really a good bit rubbish this method of exposing the internal methods
     * publicly... - To be fixed in 2.0 using methods on the prototype
     */


    /**
     * Create a wrapper function for exporting an internal functions to an external API.
     *  @param {string} sFunc API function name
     *  @returns {function} wrapped function
     *  @memberof DataTable#oApi
     */
    function _fnExternApiFunc (sFunc)
    {
      return function() {
        var aArgs = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
          Array.prototype.slice.call(arguments) );
        return DataTable.ext.oApi[sFunc].apply( this, aArgs );
      };
    }


    /**
     * Reference to internal functions for use by plug-in developers. Note that these
     * methods are references to internal functions and are considered to be private.
     * If you use these methods, be aware that they are liable to change between versions
     * (check the upgrade notes).
     *  @namespace
     */
    this.oApi = {
      "_fnExternApiFunc": _fnExternApiFunc,
      "_fnInitialise": _fnInitialise,
      "_fnInitComplete": _fnInitComplete,
      "_fnLanguageCompat": _fnLanguageCompat,
      "_fnAddColumn": _fnAddColumn,
      "_fnColumnOptions": _fnColumnOptions,
      "_fnAddData": _fnAddData,
      "_fnCreateTr": _fnCreateTr,
      "_fnGatherData": _fnGatherData,
      "_fnBuildHead": _fnBuildHead,
      "_fnDrawHead": _fnDrawHead,
      "_fnDraw": _fnDraw,
      "_fnReDraw": _fnReDraw,
      "_fnAjaxUpdate": _fnAjaxUpdate,
      "_fnAjaxParameters": _fnAjaxParameters,
      "_fnAjaxUpdateDraw": _fnAjaxUpdateDraw,
      "_fnServerParams": _fnServerParams,
      "_fnAddOptionsHtml": _fnAddOptionsHtml,
      "_fnFeatureHtmlTable": _fnFeatureHtmlTable,
      "_fnScrollDraw": _fnScrollDraw,
      "_fnAdjustColumnSizing": _fnAdjustColumnSizing,
      "_fnFeatureHtmlFilter": _fnFeatureHtmlFilter,
      "_fnFilterComplete": _fnFilterComplete,
      "_fnFilterCustom": _fnFilterCustom,
      "_fnFilterColumn": _fnFilterColumn,
      "_fnFilter": _fnFilter,
      "_fnBuildSearchArray": _fnBuildSearchArray,
      "_fnBuildSearchRow": _fnBuildSearchRow,
      "_fnFilterCreateSearch": _fnFilterCreateSearch,
      "_fnDataToSearch": _fnDataToSearch,
      "_fnSort": _fnSort,
      "_fnSortAttachListener": _fnSortAttachListener,
      "_fnSortingClasses": _fnSortingClasses,
      "_fnFeatureHtmlPaginate": _fnFeatureHtmlPaginate,
      "_fnPageChange": _fnPageChange,
      "_fnFeatureHtmlInfo": _fnFeatureHtmlInfo,
      "_fnUpdateInfo": _fnUpdateInfo,
      "_fnFeatureHtmlLength": _fnFeatureHtmlLength,
      "_fnFeatureHtmlProcessing": _fnFeatureHtmlProcessing,
      "_fnProcessingDisplay": _fnProcessingDisplay,
      "_fnVisibleToColumnIndex": _fnVisibleToColumnIndex,
      "_fnColumnIndexToVisible": _fnColumnIndexToVisible,
      "_fnNodeToDataIndex": _fnNodeToDataIndex,
      "_fnVisbleColumns": _fnVisbleColumns,
      "_fnCalculateEnd": _fnCalculateEnd,
      "_fnConvertToWidth": _fnConvertToWidth,
      "_fnCalculateColumnWidths": _fnCalculateColumnWidths,
      "_fnScrollingWidthAdjust": _fnScrollingWidthAdjust,
      "_fnGetWidestNode": _fnGetWidestNode,
      "_fnGetMaxLenString": _fnGetMaxLenString,
      "_fnStringToCss": _fnStringToCss,
      "_fnDetectType": _fnDetectType,
      "_fnSettingsFromNode": _fnSettingsFromNode,
      "_fnGetDataMaster": _fnGetDataMaster,
      "_fnGetTrNodes": _fnGetTrNodes,
      "_fnGetTdNodes": _fnGetTdNodes,
      "_fnEscapeRegex": _fnEscapeRegex,
      "_fnDeleteIndex": _fnDeleteIndex,
      "_fnReOrderIndex": _fnReOrderIndex,
      "_fnColumnOrdering": _fnColumnOrdering,
      "_fnLog": _fnLog,
      "_fnClearTable": _fnClearTable,
      "_fnSaveState": _fnSaveState,
      "_fnLoadState": _fnLoadState,
      "_fnCreateCookie": _fnCreateCookie,
      "_fnReadCookie": _fnReadCookie,
      "_fnDetectHeader": _fnDetectHeader,
      "_fnGetUniqueThs": _fnGetUniqueThs,
      "_fnScrollBarWidth": _fnScrollBarWidth,
      "_fnApplyToChildren": _fnApplyToChildren,
      "_fnMap": _fnMap,
      "_fnGetRowData": _fnGetRowData,
      "_fnGetCellData": _fnGetCellData,
      "_fnSetCellData": _fnSetCellData,
      "_fnGetObjectDataFn": _fnGetObjectDataFn,
      "_fnSetObjectDataFn": _fnSetObjectDataFn,
      "_fnApplyColumnDefs": _fnApplyColumnDefs,
      "_fnBindAction": _fnBindAction,
      "_fnExtend": _fnExtend,
      "_fnCallbackReg": _fnCallbackReg,
      "_fnCallbackFire": _fnCallbackFire,
      "_fnJsonString": _fnJsonString,
      "_fnRender": _fnRender,
      "_fnNodeToColumnIndex": _fnNodeToColumnIndex,
      "_fnInfoMacros": _fnInfoMacros,
      "_fnBrowserDetect": _fnBrowserDetect,
      "_fnGetColumns": _fnGetColumns
    };

    $.extend( DataTable.ext.oApi, this.oApi );

    for ( var sFunc in DataTable.ext.oApi )
    {
      if ( sFunc )
      {
        this[sFunc] = _fnExternApiFunc(sFunc);
      }
    }


    var _that = this;
    return this.each(function() {

      var i=0, iLen, j, jLen, k, kLen;
      var sId = this.getAttribute( 'id' );
      var bInitHandedOff = false;
      var bUsePassedData = false;


      /* Sanity check */
      if ( this.nodeName.toLowerCase() != 'table' )
      {
        _fnLog( null, 0, "Attempted to initialise DataTables on a node which is not a "+
          "table: "+this.nodeName );
        return;
      }

      /* Check to see if we are re-initialising a table */
      for ( i=0, iLen=DataTable.settings.length ; i<iLen ; i++ )
      {
        /* Base check on table node */
        if ( DataTable.settings[i].nTable == this )
        {
          if ( oInit === undefined || oInit.bRetrieve )
          {
            return DataTable.settings[i].oInstance;
          }
          else if ( oInit.bDestroy )
          {
            DataTable.settings[i].oInstance.fnDestroy();
            break;
          }
          else
          {
            _fnLog( DataTable.settings[i], 0, "Cannot reinitialise DataTable.\n\n"+
              "To retrieve the DataTables object for this table, pass no arguments or see "+
              "the docs for bRetrieve and bDestroy" );
            return;
          }
        }

        /* If the element we are initialising has the same ID as a table which was previously
         * initialised, but the table nodes don't match (from before) then we destroy the old
         * instance by simply deleting it. This is under the assumption that the table has been
         * destroyed by other methods. Anyone using non-id selectors will need to do this manually
         */
        if ( DataTable.settings[i].sTableId == this.id )
        {
          DataTable.settings.splice( i, 1 );
          break;
        }
      }

      /* Ensure the table has an ID - required for accessibility */
      if ( sId === null || sId === "" )
      {
        sId = "DataTables_Table_"+(DataTable.ext._oExternConfig.iNextUnique++);
        this.id = sId;
      }

      /* Create the settings object for this table and set some of the default parameters */
      var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
        "nTable":        this,
        "oApi":          _that.oApi,
        "oInit":         oInit,
        "sDestroyWidth": $(this).width(),
        "sInstance":     sId,
        "sTableId":      sId
      } );
      DataTable.settings.push( oSettings );

      // Need to add the instance after the instance after the settings object has been added
      // to the settings array, so we can self reference the table instance if more than one
      oSettings.oInstance = (_that.length===1) ? _that : $(this).dataTable();

      /* Setting up the initialisation object */
      if ( !oInit )
      {
        oInit = {};
      }

      // Backwards compatibility, before we apply all the defaults
      if ( oInit.oLanguage )
      {
        _fnLanguageCompat( oInit.oLanguage );
      }

      oInit = _fnExtend( $.extend(true, {}, DataTable.defaults), oInit );

      // Map the initialisation options onto the settings object
      _fnMap( oSettings.oFeatures, oInit, "bPaginate" );
      _fnMap( oSettings.oFeatures, oInit, "bLengthChange" );
      _fnMap( oSettings.oFeatures, oInit, "bFilter" );
      _fnMap( oSettings.oFeatures, oInit, "bSort" );
      _fnMap( oSettings.oFeatures, oInit, "bInfo" );
      _fnMap( oSettings.oFeatures, oInit, "bProcessing" );
      _fnMap( oSettings.oFeatures, oInit, "bAutoWidth" );
      _fnMap( oSettings.oFeatures, oInit, "bSortClasses" );
      _fnMap( oSettings.oFeatures, oInit, "bServerSide" );
      _fnMap( oSettings.oFeatures, oInit, "bDeferRender" );
      _fnMap( oSettings.oScroll, oInit, "sScrollX", "sX" );
      _fnMap( oSettings.oScroll, oInit, "sScrollXInner", "sXInner" );
      _fnMap( oSettings.oScroll, oInit, "sScrollY", "sY" );
      _fnMap( oSettings.oScroll, oInit, "bScrollCollapse", "bCollapse" );
      _fnMap( oSettings.oScroll, oInit, "bScrollInfinite", "bInfinite" );
      _fnMap( oSettings.oScroll, oInit, "iScrollLoadGap", "iLoadGap" );
      _fnMap( oSettings.oScroll, oInit, "bScrollAutoCss", "bAutoCss" );
      _fnMap( oSettings, oInit, "asStripeClasses" );
      _fnMap( oSettings, oInit, "asStripClasses", "asStripeClasses" ); // legacy
      _fnMap( oSettings, oInit, "fnServerData" );
      _fnMap( oSettings, oInit, "fnFormatNumber" );
      _fnMap( oSettings, oInit, "sServerMethod" );
      _fnMap( oSettings, oInit, "aaSorting" );
      _fnMap( oSettings, oInit, "aaSortingFixed" );
      _fnMap( oSettings, oInit, "aLengthMenu" );
      _fnMap( oSettings, oInit, "sPaginationType" );
      _fnMap( oSettings, oInit, "sAjaxSource" );
      _fnMap( oSettings, oInit, "sAjaxDataProp" );
      _fnMap( oSettings, oInit, "iCookieDuration" );
      _fnMap( oSettings, oInit, "sCookiePrefix" );
      _fnMap( oSettings, oInit, "sDom" );
      _fnMap( oSettings, oInit, "bSortCellsTop" );
      _fnMap( oSettings, oInit, "iTabIndex" );
      _fnMap( oSettings, oInit, "oSearch", "oPreviousSearch" );
      _fnMap( oSettings, oInit, "aoSearchCols", "aoPreSearchCols" );
      _fnMap( oSettings, oInit, "iDisplayLength", "_iDisplayLength" );
      _fnMap( oSettings, oInit, "bJQueryUI", "bJUI" );
      _fnMap( oSettings, oInit, "fnCookieCallback" );
      _fnMap( oSettings, oInit, "fnStateLoad" );
      _fnMap( oSettings, oInit, "fnStateSave" );
      _fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );

      /* Callback functions which are array driven */
      _fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
      _fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
      _fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
      _fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
      _fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
      _fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
      _fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
      _fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
      _fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
      _fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
      _fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );

      if ( oSettings.oFeatures.bServerSide && oSettings.oFeatures.bSort &&
        oSettings.oFeatures.bSortClasses )
      {
        /* Enable sort classes for server-side processing. Safe to do it here, since server-side
         * processing must be enabled by the developer
         */
        _fnCallbackReg( oSettings, 'aoDrawCallback', _fnSortingClasses, 'server_side_sort_classes' );
      }
      else if ( oSettings.oFeatures.bDeferRender )
      {
        _fnCallbackReg( oSettings, 'aoDrawCallback', _fnSortingClasses, 'defer_sort_classes' );
      }

      if ( oInit.bJQueryUI )
      {
        /* Use the JUI classes object for display. You could clone the oStdClasses object if 
         * you want to have multiple tables with multiple independent classes 
         */
        $.extend( oSettings.oClasses, DataTable.ext.oJUIClasses );

        if ( oInit.sDom === DataTable.defaults.sDom && DataTable.defaults.sDom === "lfrtip" )
        {
          /* Set the DOM to use a layout suitable for jQuery UI's theming */
          oSettings.sDom = '<"H"lfr>t<"F"ip>';
        }
      }
      else
      {
        $.extend( oSettings.oClasses, DataTable.ext.oStdClasses );
      }
      $(this).addClass( oSettings.oClasses.sTable );

      /* Calculate the scroll bar width and cache it for use later on */
      if ( oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "" )
      {
        oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
      }

      if ( oSettings.iInitDisplayStart === undefined )
      {
        /* Display start point, taking into account the save saving */
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }

      /* Must be done after everything which can be overridden by a cookie! */
      if ( oInit.bStateSave )
      {
        oSettings.oFeatures.bStateSave = true;
        _fnLoadState( oSettings, oInit );
        _fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
      }

      if ( oInit.iDeferLoading !== null )
      {
        oSettings.bDeferLoading = true;
        var tmp = $.isArray( oInit.iDeferLoading );
        oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
        oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
      }

      if ( oInit.aaData !== null )
      {
        bUsePassedData = true;
      }

      /* Language definitions */
      if ( oInit.oLanguage.sUrl !== "" )
      {
        /* Get the language definitions from a file - because this Ajax call makes the language
         * get async to the remainder of this function we use bInitHandedOff to indicate that 
         * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
         */
        oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl;
        $.getJSON( oSettings.oLanguage.sUrl, null, function( json ) {
          _fnLanguageCompat( json );
          $.extend( true, oSettings.oLanguage, oInit.oLanguage, json );
          _fnInitialise( oSettings );
        } );
        bInitHandedOff = true;
      }
      else
      {
        $.extend( true, oSettings.oLanguage, oInit.oLanguage );
      }


      /*
       * Stripes
       */
      if ( oInit.asStripeClasses === null )
      {
        oSettings.asStripeClasses =[
          oSettings.oClasses.sStripeOdd,
          oSettings.oClasses.sStripeEven
        ];
      }

      /* Remove row stripe classes if they are already on the table row */
      var bStripeRemove = false;
      var anRows = $(this).children('tbody').children('tr');
      for ( i=0, iLen=oSettings.asStripeClasses.length ; i<iLen ; i++ )
      {
        if ( anRows.filter(":lt(2)").hasClass( oSettings.asStripeClasses[i]) )
        {
          bStripeRemove = true;
          break;
        }
      }

      if ( bStripeRemove )
      {
        /* Store the classes which we are about to remove so they can be re-added on destroy */
        oSettings.asDestroyStripes = [ '', '' ];
        if ( $(anRows[0]).hasClass(oSettings.oClasses.sStripeOdd) )
        {
          oSettings.asDestroyStripes[0] += oSettings.oClasses.sStripeOdd+" ";
        }
        if ( $(anRows[0]).hasClass(oSettings.oClasses.sStripeEven) )
        {
          oSettings.asDestroyStripes[0] += oSettings.oClasses.sStripeEven;
        }
        if ( $(anRows[1]).hasClass(oSettings.oClasses.sStripeOdd) )
        {
          oSettings.asDestroyStripes[1] += oSettings.oClasses.sStripeOdd+" ";
        }
        if ( $(anRows[1]).hasClass(oSettings.oClasses.sStripeEven) )
        {
          oSettings.asDestroyStripes[1] += oSettings.oClasses.sStripeEven;
        }

        anRows.removeClass( oSettings.asStripeClasses.join(' ') );
      }


      /*
       * Columns
       * See if we should load columns automatically or use defined ones
       */
      var anThs = [];
      var aoColumnsInit;
      var nThead = this.getElementsByTagName('thead');
      if ( nThead.length !== 0 )
      {
        _fnDetectHeader( oSettings.aoHeader, nThead[0] );
        anThs = _fnGetUniqueThs( oSettings );
      }

      /* If not given a column array, generate one with nulls */
      if ( oInit.aoColumns === null )
      {
        aoColumnsInit = [];
        for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
        {
          aoColumnsInit.push( null );
        }
      }
      else
      {
        aoColumnsInit = oInit.aoColumns;
      }

      /* Add the columns */
      for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
      {
        /* Short cut - use the loop to check if we have column visibility state to restore */
        if ( oInit.saved_aoColumns !== undefined && oInit.saved_aoColumns.length == iLen )
        {
          if ( aoColumnsInit[i] === null )
          {
            aoColumnsInit[i] = {};
          }
          aoColumnsInit[i].bVisible = oInit.saved_aoColumns[i].bVisible;
        }

        _fnAddColumn( oSettings, anThs ? anThs[i] : null );
      }

      /* Apply the column definitions */
      _fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
        _fnColumnOptions( oSettings, iCol, oDef );
      } );


      /*
       * Sorting
       * Check the aaSorting array
       */
      for ( i=0, iLen=oSettings.aaSorting.length ; i<iLen ; i++ )
      {
        if ( oSettings.aaSorting[i][0] >= oSettings.aoColumns.length )
        {
          oSettings.aaSorting[i][0] = 0;
        }
        var oColumn = oSettings.aoColumns[ oSettings.aaSorting[i][0] ];

        /* Add a default sorting index */
        if ( oSettings.aaSorting[i][2] === undefined )
        {
          oSettings.aaSorting[i][2] = 0;
        }

        /* If aaSorting is not defined, then we use the first indicator in asSorting */
        if ( oInit.aaSorting === undefined && oSettings.saved_aaSorting === undefined )
        {
          oSettings.aaSorting[i][1] = oColumn.asSorting[0];
        }

        /* Set the current sorting index based on aoColumns.asSorting */
        for ( j=0, jLen=oColumn.asSorting.length ; j<jLen ; j++ )
        {
          if ( oSettings.aaSorting[i][1] == oColumn.asSorting[j] )
          {
            oSettings.aaSorting[i][2] = j;
            break;
          }
        }
      }

      /* Do a first pass on the sorting classes (allows any size changes to be taken into
       * account, and also will apply sorting disabled classes if disabled
       */
      _fnSortingClasses( oSettings );


      /*
       * Final init
       * Cache the header, body and footer as required, creating them if needed
       */

      /* Browser support detection */
      _fnBrowserDetect( oSettings );

      // Work around for Webkit bug 83867 - store the caption-side before removing from doc
      var captions = $(this).children('caption').each( function () {
        this._captionSide = $(this).css('caption-side');
      } );

      var thead = $(this).children('thead');
      if ( thead.length === 0 )
      {
        thead = [ document.createElement( 'thead' ) ];
        this.appendChild( thead[0] );
      }
      oSettings.nTHead = thead[0];

      var tbody = $(this).children('tbody');
      if ( tbody.length === 0 )
      {
        tbody = [ document.createElement( 'tbody' ) ];
        this.appendChild( tbody[0] );
      }
      oSettings.nTBody = tbody[0];
      oSettings.nTBody.setAttribute( "role", "alert" );
      oSettings.nTBody.setAttribute( "aria-live", "polite" );
      oSettings.nTBody.setAttribute( "aria-relevant", "all" );

      var tfoot = $(this).children('tfoot');
      if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") )
      {
        // If we are a scrolling table, and no footer has been given, then we need to create
        // a tfoot element for the caption element to be appended to
        tfoot = [ document.createElement( 'tfoot' ) ];
        this.appendChild( tfoot[0] );
      }

      if ( tfoot.length > 0 )
      {
        oSettings.nTFoot = tfoot[0];
        _fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
      }

      /* Check if there is data passing into the constructor */
      if ( bUsePassedData )
      {
        for ( i=0 ; i<oInit.aaData.length ; i++ )
        {
          _fnAddData( oSettings, oInit.aaData[ i ] );
        }
      }
      else
      {
        /* Grab the data from the page */
        _fnGatherData( oSettings );
      }

      /* Copy the data index array */
      oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

      /* Initialisation complete - table can be drawn */
      oSettings.bInitialised = true;

      /* Check if we need to initialise the table (it might not have been handed off to the
       * language processor)
       */
      if ( bInitHandedOff === false )
      {
        _fnInitialise( oSettings );
      }
    } );
  };



  /**
   * Provide a common method for plug-ins to check the version of DataTables being used, in order
   * to ensure compatibility.
   *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
   *    formats "X" and "X.Y" are also acceptable.
   *  @returns {boolean} true if this version of DataTables is greater or equal to the required
   *    version, or false if this version of DataTales is not suitable
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    alert( $.fn.dataTable.fnVersionCheck( '1.9.0' ) );
   */
  DataTable.fnVersionCheck = function( sVersion )
  {
    /* This is cheap, but effective */
    var fnZPad = function (Zpad, count)
    {
      while(Zpad.length < count) {
        Zpad += '0';
      }
      return Zpad;
    };
    var aThis = DataTable.ext.sVersion.split('.');
    var aThat = sVersion.split('.');
    var sThis = '', sThat = '';

    for ( var i=0, iLen=aThat.length ; i<iLen ; i++ )
    {
      sThis += fnZPad( aThis[i], 3 );
      sThat += fnZPad( aThat[i], 3 );
    }

    return parseInt(sThis, 10) >= parseInt(sThat, 10);
  };


  /**
   * Check if a TABLE node is a DataTable table already or not.
   *  @param {node} nTable The TABLE node to check if it is a DataTable or not (note that other
   *    node types can be passed in, but will always return false).
   *  @returns {boolean} true the table given is a DataTable, or false otherwise
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    var ex = document.getElementById('example');
   *    if ( ! $.fn.DataTable.fnIsDataTable( ex ) ) {
	 *      $(ex).dataTable();
	 *    }
   */
  DataTable.fnIsDataTable = function ( nTable )
  {
    var o = DataTable.settings;

    for ( var i=0 ; i<o.length ; i++ )
    {
      if ( o[i].nTable === nTable || o[i].nScrollHead === nTable || o[i].nScrollFoot === nTable )
      {
        return true;
      }
    }

    return false;
  };


  /**
   * Get all DataTable tables that have been initialised - optionally you can select to
   * get only currently visible tables.
   *  @param {boolean} [bVisible=false] Flag to indicate if you want all (default) or
   *    visible tables only.
   *  @returns {array} Array of TABLE nodes (not DataTable instances) which are DataTables
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    var table = $.fn.dataTable.fnTables(true);
   *    if ( table.length > 0 ) {
	 *      $(table).dataTable().fnAdjustColumnSizing();
	 *    }
   */
  DataTable.fnTables = function ( bVisible )
  {
    var out = [];

    jQuery.each( DataTable.settings, function (i, o) {
      if ( !bVisible || (bVisible === true && $(o.nTable).is(':visible')) )
      {
        out.push( o.nTable );
      }
    } );

    return out;
  };


  /**
   * Version string for plug-ins to check compatibility. Allowed format is
   * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
   * e are optional
   *  @member
   *  @type string
   *  @default Version number
   */
  DataTable.version = "1.9.3";

  /**
   * Private data store, containing all of the settings objects that are created for the
   * tables on a given page.
   *
   * Note that the <i>DataTable.settings</i> object is aliased to <i>jQuery.fn.dataTableExt</i>
   * through which it may be accessed and manipulated, or <i>jQuery.fn.dataTable.settings</i>.
   *  @member
   *  @type array
   *  @default []
   *  @private
   */
  DataTable.settings = [];

  /**
   * Object models container, for the various models that DataTables has available
   * to it. These models define the objects that are used to hold the active state
   * and configuration of the table.
   *  @namespace
   */
  DataTable.models = {};


  /**
   * DataTables extension options and plug-ins. This namespace acts as a collection "area"
   * for plug-ins that can be used to extend the default DataTables behaviour - indeed many
   * of the build in methods use this method to provide their own capabilities (sorting methods
   * for example).
   *
   * Note that this namespace is aliased to jQuery.fn.dataTableExt so it can be readily accessed
   * and modified by plug-ins.
   *  @namespace
   */
  DataTable.models.ext = {
    /**
     * Plug-in filtering functions - this method of filtering is complimentary to the default
     * type based filtering, and a lot more comprehensive as it allows you complete control
     * over the filtering logic. Each element in this array is a function (parameters
     * described below) that is called for every row in the table, and your logic decides if
     * it should be included in the filtered data set or not.
     *   <ul>
     *     <li>
     *       Function input parameters:
     *       <ul>
     *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
     *         <li>{array|object} Data for the row to be processed (same as the original format
     *           that was passed in as the data source, or an array from a DOM data source</li>
     *         <li>{int} Row index in aoData ({@link DataTable.models.oSettings.aoData}), which can
     *           be useful to retrieve the TR element if you need DOM interaction.</li>
     *       </ul>
     *     </li>
     *     <li>
     *       Function return:
     *       <ul>
     *         <li>{boolean} Include the row in the filtered result set (true) or not (false)</li>
     *       </ul>
     *     </il>
     *   </ul>
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom filtering being applied to the fourth column (i.e.
     *    // the aData[3] index) based on two input values from the end-user, matching the data in
     *    // a certain range.
     *    $.fn.dataTableExt.afnFiltering.push(
     *      function( oSettings, aData, iDataIndex ) {
		 *        var iMin = document.getElementById('min').value * 1;
		 *        var iMax = document.getElementById('max').value * 1;
		 *        var iVersion = aData[3] == "-" ? 0 : aData[3]*1;
		 *        if ( iMin == "" && iMax == "" ) {
		 *          return true;
		 *        }
		 *        else if ( iMin == "" && iVersion < iMax ) {
		 *          return true;
		 *        }
		 *        else if ( iMin < iVersion && "" == iMax ) {
		 *          return true;
		 *        }
		 *        else if ( iMin < iVersion && iVersion < iMax ) {
		 *          return true;
		 *        }
		 *        return false;
		 *      }
     *    );
     */
    "afnFiltering": [],


    /**
     * Plug-in sorting functions - this method of sorting is complimentary to the default type
     * based sorting that DataTables does automatically, allowing much greater control over the
     * the data that is being used to sort a column. This is useful if you want to do sorting
     * based on live data (for example the contents of an 'input' element) rather than just the
     * static string that DataTables knows of. The way these plug-ins work is that you create
     * an array of the values you wish to be sorted for the column in question and then return
     * that array. Which pre-sorting function is run here depends on the sSortDataType parameter
     * that is used for the column (if any). This is the corollary of <i>ofnSearch</i> for sort
     * data.
     *   <ul>
     *     <li>
     *       Function input parameters:
     *       <ul>
     *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
     *         <li>{int} Target column index</li>
     *       </ul>
     *     </li>
     *     <li>
     *       Function return:
     *       <ul>
     *         <li>{array} Data for the column to be sorted upon</li>
     *       </ul>
     *     </il>
     *   </ul>
     *
     * Note that as of v1.9, it is typically preferable to use <i>mData</i> to prepare data for
     * the different uses that DataTables can put the data to. Specifically <i>mData</i> when
     * used as a function will give you a 'type' (sorting, filtering etc) that you can use to
     * prepare the data as required for the different types. As such, this method is deprecated.
     *  @type array
     *  @default []
     *  @deprecated
     *
     *  @example
     *    // Updating the cached sorting information with user entered values in HTML input elements
     *    jQuery.fn.dataTableExt.afnSortData['dom-text'] = function ( oSettings, iColumn )
     *    {
		 *      var aData = [];
		 *      $( 'td:eq('+iColumn+') input', oSettings.oApi._fnGetTrNodes(oSettings) ).each( function () {
		 *        aData.push( this.value );
		 *      } );
		 *      return aData;
		 *    }
     */
    "afnSortData": [],


    /**
     * Feature plug-ins - This is an array of objects which describe the feature plug-ins that are
     * available to DataTables. These feature plug-ins are accessible through the sDom initialisation
     * option. As such, each feature plug-in must describe a function that is used to initialise
     * itself (fnInit), a character so the feature can be enabled by sDom (cFeature) and the name
     * of the feature (sFeature). Thus the objects attached to this method must provide:
     *   <ul>
     *     <li>{function} fnInit Initialisation of the plug-in
     *       <ul>
     *         <li>
     *           Function input parameters:
     *           <ul>
     *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
     *           </ul>
     *         </li>
     *         <li>
     *           Function return:
     *           <ul>
     *             <li>{node|null} The element which contains your feature. Note that the return
     *                may also be void if your plug-in does not require to inject any DOM elements
     *                into DataTables control (sDom) - for example this might be useful when
     *                developing a plug-in which allows table control via keyboard entry.</li>
     *           </ul>
     *         </il>
     *       </ul>
     *     </li>
     *     <li>{character} cFeature Character that will be matched in sDom - case sensitive</li>
     *     <li>{string} sFeature Feature name</li>
     *   </ul>
     *  @type array
     *  @default []
     *
     *  @example
     *    // How TableTools initialises itself.
     *    $.fn.dataTableExt.aoFeatures.push( {
		 *      "fnInit": function( oSettings ) {
		 *        return new TableTools( { "oDTSettings": oSettings } );
		 *      },
		 *      "cFeature": "T",
		 *      "sFeature": "TableTools"
		 *    } );
     */
    "aoFeatures": [],


    /**
     * Type detection plug-in functions - DataTables utilises types to define how sorting and
     * filtering behave, and types can be either  be defined by the developer (sType for the
     * column) or they can be automatically detected by the methods in this array. The functions
     * defined in the array are quite simple, taking a single parameter (the data to analyse)
     * and returning the type if it is a known type, or null otherwise.
     *   <ul>
     *     <li>
     *       Function input parameters:
     *       <ul>
     *         <li>{*} Data from the column cell to be analysed</li>
     *       </ul>
     *     </li>
     *     <li>
     *       Function return:
     *       <ul>
     *         <li>{string|null} Data type detected, or null if unknown (and thus pass it
     *           on to the other type detection functions.</li>
     *       </ul>
     *     </il>
     *   </ul>
     *  @type array
     *  @default []
     *
     *  @example
     *    // Currency type detection plug-in:
     *    jQuery.fn.dataTableExt.aTypes.push(
     *      function ( sData ) {
		 *        var sValidChars = "0123456789.-";
		 *        var Char;
		 *        
		 *        // Check the numeric part
		 *        for ( i=1 ; i<sData.length ; i++ ) {
		 *          Char = sData.charAt(i); 
		 *          if (sValidChars.indexOf(Char) == -1) {
		 *            return null;
		 *          }
		 *        }
		 *        
		 *        // Check prefixed by currency
		 *        if ( sData.charAt(0) == '$' || sData.charAt(0) == '&pound;' ) {
		 *          return 'currency';
		 *        }
		 *        return null;
		 *      }
     *    );
     */
    "aTypes": [],


    /**
     * Provide a common method for plug-ins to check the version of DataTables being used,
     * in order to ensure compatibility.
     *  @type function
     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note
     *    that the formats "X" and "X.Y" are also acceptable.
     *  @returns {boolean} true if this version of DataTables is greater or equal to the
     *    required version, or false if this version of DataTales is not suitable
     *
     *  @example
     *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
     */
    "fnVersionCheck": DataTable.fnVersionCheck,


    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @default 0
     */
    "iApiIndex": 0,


    /**
     * Pre-processing of filtering data plug-ins - When you assign the sType for a column
     * (or have it automatically detected for you by DataTables or a type detection plug-in),
     * you will typically be using this for custom sorting, but it can also be used to provide
     * custom filtering by allowing you to pre-processing the data and returning the data in
     * the format that should be filtered upon. This is done by adding functions this object
     * with a parameter name which matches the sType for that target column. This is the
     * corollary of <i>afnSortData</i> for filtering data.
     *   <ul>
     *     <li>
     *       Function input parameters:
     *       <ul>
     *         <li>{*} Data from the column cell to be prepared for filtering</li>
     *       </ul>
     *     </li>
     *     <li>
     *       Function return:
     *       <ul>
     *         <li>{string|null} Formatted string that will be used for the filtering.</li>
     *       </ul>
     *     </il>
     *   </ul>
     *
     * Note that as of v1.9, it is typically preferable to use <i>mData</i> to prepare data for
     * the different uses that DataTables can put the data to. Specifically <i>mData</i> when
     * used as a function will give you a 'type' (sorting, filtering etc) that you can use to
     * prepare the data as required for the different types. As such, this method is deprecated.
     *  @type object
     *  @default {}
     *  @deprecated
     *
     *  @example
     *    $.fn.dataTableExt.ofnSearch['title-numeric'] = function ( sData ) {
		 *      return sData.replace(/\n/g," ").replace( /<.*?>/g, "" );
		 *    }
     */
    "ofnSearch": {},


    /**
     * Container for all private functions in DataTables so they can be exposed externally
     *  @type object
     *  @default {}
     */
    "oApi": {},


    /**
     * Storage for the various classes that DataTables uses
     *  @type object
     *  @default {}
     */
    "oStdClasses": {},


    /**
     * Storage for the various classes that DataTables uses - jQuery UI suitable
     *  @type object
     *  @default {}
     */
    "oJUIClasses": {},


    /**
     * Pagination plug-in methods - The style and controls of the pagination can significantly
     * impact on how the end user interacts with the data in your table, and DataTables allows
     * the addition of pagination controls by extending this object, which can then be enabled
     * through the <i>sPaginationType</i> initialisation parameter. Each pagination type that
     * is added is an object (the property name of which is what <i>sPaginationType</i> refers
     * to) that has two properties, both methods that are used by DataTables to update the
     * control's state.
     *   <ul>
     *     <li>
     *       fnInit -  Initialisation of the paging controls. Called only during initialisation
     *         of the table. It is expected that this function will add the required DOM elements
     *         to the page for the paging controls to work. The element pointer
     *         'oSettings.aanFeatures.p' array is provided by DataTables to contain the paging
     *         controls (note that this is a 2D array to allow for multiple instances of each
     *         DataTables DOM element). It is suggested that you add the controls to this element
     *         as children
     *       <ul>
     *         <li>
     *           Function input parameters:
     *           <ul>
     *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
     *             <li>{node} Container into which the pagination controls must be inserted</li>
     *             <li>{function} Draw callback function - whenever the controls cause a page
     *               change, this method must be called to redraw the table.</li>
     *           </ul>
     *         </li>
     *         <li>
     *           Function return:
     *           <ul>
     *             <li>No return required</li>
     *           </ul>
     *         </il>
     *       </ul>
     *     </il>
     *     <li>
     *       fnInit -  This function is called whenever the paging status of the table changes and is
     *         typically used to update classes and/or text of the paging controls to reflex the new
     *         status.
     *       <ul>
     *         <li>
     *           Function input parameters:
     *           <ul>
     *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
     *             <li>{function} Draw callback function - in case you need to redraw the table again
     *               or attach new event listeners</li>
     *           </ul>
     *         </li>
     *         <li>
     *           Function return:
     *           <ul>
     *             <li>No return required</li>
     *           </ul>
     *         </il>
     *       </ul>
     *     </il>
     *   </ul>
     *  @type object
     *  @default {}
     *
     *  @example
     *    $.fn.dataTableExt.oPagination.four_button = {
		 *      "fnInit": function ( oSettings, nPaging, fnCallbackDraw ) {
		 *        nFirst = document.createElement( 'span' );
		 *        nPrevious = document.createElement( 'span' );
		 *        nNext = document.createElement( 'span' );
		 *        nLast = document.createElement( 'span' );
		 *        
		 *        nFirst.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sFirst ) );
		 *        nPrevious.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sPrevious ) );
		 *        nNext.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sNext ) );
		 *        nLast.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sLast ) );
		 *        
		 *        nFirst.className = "paginate_button first";
		 *        nPrevious.className = "paginate_button previous";
		 *        nNext.className="paginate_button next";
		 *        nLast.className = "paginate_button last";
		 *        
		 *        nPaging.appendChild( nFirst );
		 *        nPaging.appendChild( nPrevious );
		 *        nPaging.appendChild( nNext );
		 *        nPaging.appendChild( nLast );
		 *        
		 *        $(nFirst).click( function () {
		 *          oSettings.oApi._fnPageChange( oSettings, "first" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nPrevious).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "previous" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nNext).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "next" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nLast).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "last" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nFirst).bind( 'selectstart', function () { return false; } );
		 *        $(nPrevious).bind( 'selectstart', function () { return false; } );
		 *        $(nNext).bind( 'selectstart', function () { return false; } );
		 *        $(nLast).bind( 'selectstart', function () { return false; } );
		 *      },
		 *      
		 *      "fnUpdate": function ( oSettings, fnCallbackDraw ) {
		 *        if ( !oSettings.aanFeatures.p ) {
		 *          return;
		 *        }
		 *        
		 *        // Loop over each instance of the pager
		 *        var an = oSettings.aanFeatures.p;
		 *        for ( var i=0, iLen=an.length ; i<iLen ; i++ ) {
		 *          var buttons = an[i].getElementsByTagName('span');
		 *          if ( oSettings._iDisplayStart === 0 ) {
		 *            buttons[0].className = "paginate_disabled_previous";
		 *            buttons[1].className = "paginate_disabled_previous";
		 *          }
		 *          else {
		 *            buttons[0].className = "paginate_enabled_previous";
		 *            buttons[1].className = "paginate_enabled_previous";
		 *          }
		 *          
		 *          if ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) {
		 *            buttons[2].className = "paginate_disabled_next";
		 *            buttons[3].className = "paginate_disabled_next";
		 *          }
		 *          else {
		 *            buttons[2].className = "paginate_enabled_next";
		 *            buttons[3].className = "paginate_enabled_next";
		 *          }
		 *        }
		 *      }
		 *    };
     */
    "oPagination": {},


    /**
     * Sorting plug-in methods - Sorting in DataTables is based on the detected type of the
     * data column (you can add your own type detection functions, or override automatic
     * detection using sType). With this specific type given to the column, DataTables will
     * apply the required sort from the functions in the object. Each sort type must provide
     * two mandatory methods, one each for ascending and descending sorting, and can optionally
     * provide a pre-formatting method that will help speed up sorting by allowing DataTables
     * to pre-format the sort data only once (rather than every time the actual sort functions
     * are run). The two sorting functions are typical Javascript sort methods:
     *   <ul>
     *     <li>
     *       Function input parameters:
     *       <ul>
     *         <li>{*} Data to compare to the second parameter</li>
     *         <li>{*} Data to compare to the first parameter</li>
     *       </ul>
     *     </li>
     *     <li>
     *       Function return:
     *       <ul>
     *         <li>{int} Sorting match: <0 if first parameter should be sorted lower than
     *           the second parameter, ===0 if the two parameters are equal and >0 if
     *           the first parameter should be sorted height than the second parameter.</li>
     *       </ul>
     *     </il>
     *   </ul>
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Case-sensitive string sorting, with no pre-formatting method
     *    $.extend( $.fn.dataTableExt.oSort, {
		 *      "string-case-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-case-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
     *
     *  @example
     *    // Case-insensitive string sorting, with pre-formatting
     *    $.extend( $.fn.dataTableExt.oSort, {
		 *      "string-pre": function(x) {
		 *        return x.toLowerCase();
		 *      },
		 *      "string-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
     */
    "oSort": {},


    /**
     * Version string for plug-ins to check compatibility. Allowed format is
     * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
     * e are optional
     *  @type string
     *  @default Version number
     */
    "sVersion": DataTable.version,


    /**
     * How should DataTables report an error. Can take the value 'alert' or 'throw'
     *  @type string
     *  @default alert
     */
    "sErrMode": "alert",


    /**
     * Store information for DataTables to access globally about other instances
     *  @namespace
     *  @private
     */
    "_oExternConfig": {
      /* int:iNextUnique - next unique number for an instance */
      "iNextUnique": 0
    }
  };




  /**
   * Template object for the way in which DataTables holds information about
   * search information for the global filter and individual column filters.
   *  @namespace
   */
  DataTable.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     *  @type boolean
     *  @default true
     */
    "bCaseInsensitive": true,

    /**
     * Applied search term
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sSearch": "",

    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     *  @type boolean
     *  @default false
     */
    "bRegex": false,

    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     *  @type boolean
     *  @default true
     */
    "bSmart": true
  };




  /**
   * Template object for the way in which DataTables holds information about
   * each individual row. This is the object format used for the settings
   * aoData array.
   *  @namespace
   */
  DataTable.models.oRow = {
    /**
     * TR element for the row
     *  @type node
     *  @default null
     */
    "nTr": null,

    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     *  @type array|object
     *  @default []
     */
    "_aData": [],

    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     *  @type array
     *  @default []
     *  @private
     */
    "_aSortData": [],

    /**
     * Array of TD elements that are cached for hidden rows, so they can be
     * reinserted into the table if a column is made visible again (or to act
     * as a store if a column is made hidden). Only hidden columns have a
     * reference in the array. For non-hidden columns the value is either
     * undefined or null.
     *  @type array nodes
     *  @default []
     *  @private
     */
    "_anHidden": [],

    /**
     * Cache of the class name that DataTables has applied to the row, so we
     * can quickly look at this variable rather than needing to do a DOM check
     * on className for the nTr property.
     *  @type string
     *  @default <i>Empty string</i>
     *  @private
     */
    "_sRowStripe": ""
  };



  /**
   * Template object for the column information object in DataTables. This object
   * is held in the settings aoColumns array and contains all the information that
   * DataTables needs about each individual column.
   *
   * Note that this object is related to {@link DataTable.defaults.columns}
   * but this one is the internal data store for DataTables's cache of columns.
   * It should NOT be manipulated outside of DataTables. Any configuration should
   * be done through the initialisation options.
   *  @namespace
   */
  DataTable.models.oColumn = {
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     *  @type array
     */
    "aDataSort": null,

    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     *  @type array
     */
    "asSorting": null,

    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     *  @type boolean
     */
    "bSearchable": null,

    /**
     * Flag to indicate if the column is sortable or not.
     *  @type boolean
     */
    "bSortable": null,

    /**
     * When using fnRender, you have two options for what to do with the data,
     * and this property serves as the switch. Firstly, you can have the sorting
     * and filtering use the rendered value (true - default), or you can have
     * the sorting and filtering us the original value (false).
     *
     * *NOTE* It is it is advisable now to use mData as a function and make
     * use of the 'type' that it gives, allowing (potentially) different data to
     * be used for sorting, filtering, display and type detection.
     *  @type boolean
     *  @deprecated
     */
    "bUseRendered": null,

    /**
     * Flag to indicate if the column is currently visible in the table or not
     *  @type boolean
     */
    "bVisible": null,

    /**
     * Flag to indicate to the type detection method if the automatic type
     * detection should be used, or if a column type (sType) has been specified
     *  @type boolean
     *  @default true
     *  @private
     */
    "_bAutoType": true,

    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to fnRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available (since it is not when fnRender is called).
     *  @type function
     *  @param {element} nTd The TD node that has been created
     *  @param {*} sData The Data for the cell
     *  @param {array|object} oData The data for the whole row
     *  @param {int} iRow The row index for the aoData data store
     *  @default null
     */
    "fnCreatedCell": null,

    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {string} sSpecific The specific data type you want to get -
     *    'display', 'type' 'filter' 'sort'
     *  @returns {*} The data for the cell from the given row's data
     *  @default null
     */
    "fnGetData": null,

    /**
     * Custom display function that will be called for the display of each cell
     * in this column.
     *  @type function
     *  @param {object} o Object with the following parameters:
     *  @param {int}    o.iDataRow The row in aoData
     *  @param {int}    o.iDataColumn The column in question
     *  @param {array}  o.aData The data for the row in question
     *  @param {object} o.oSettings The settings object for this DataTables instance
     *  @returns {string} The string you which to use in the display
     *  @default null
     */
    "fnRender": null,

    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {*} sValue Value to set
     *  @default null
     */
    "fnSetData": null,

    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     *  @type function|int|string|null
     *  @default null
     */
    "mData": null,

    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     *  @type function|int|string|null
     *  @default null
     */
    "mRender": null,

    /**
     * Unique header TH/TD element for this column - this is what the sorting
     * listener is attached to (if sorting is enabled.)
     *  @type node
     *  @default null
     */
    "nTh": null,

    /**
     * Unique footer TH/TD element for this column (if there is one). Not used
     * in DataTables as such, but can be used for plug-ins to reference the
     * footer for each column.
     *  @type node
     *  @default null
     */
    "nTf": null,

    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     *  @type string
     *  @default null
     */
    "sClass": null,

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     *  @type string
     */
    "sContentPadding": null,

    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     */
    "sDefaultContent": null,

    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     *  @type string
     */
    "sName": null,

    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     *  @type string
     *  @default std
     */
    "sSortDataType": 'std',

    /**
     * Class to be applied to the header element when sorting on this column
     *  @type string
     *  @default null
     */
    "sSortingClass": null,

    /**
     * Class to be applied to the header element when sorting on this column -
     * when jQuery UI theming is used.
     *  @type string
     *  @default null
     */
    "sSortingClassJUI": null,

    /**
     * Title of the column - what is seen in the TH element (nTh).
     *  @type string
     */
    "sTitle": null,

    /**
     * Column sorting and filtering type
     *  @type string
     *  @default null
     */
    "sType": null,

    /**
     * Width of the column
     *  @type string
     *  @default null
     */
    "sWidth": null,

    /**
     * Width of the column when it was first "encountered"
     *  @type string
     *  @default null
     */
    "sWidthOrig": null
  };



  /**
   * Initialisation options that can be given to DataTables at initialisation
   * time.
   *  @namespace
   */
  DataTable.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     *  @type array
     *  @default null
     *  @dtopt Option
     *
     *  @example
     *    // Using a 2D array data source
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "aaData": [
		 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
		 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
		 *        ],
		 *        "aoColumns": [
		 *          { "sTitle": "Engine" },
		 *          { "sTitle": "Browser" },
		 *          { "sTitle": "Platform" },
		 *          { "sTitle": "Version" },
		 *          { "sTitle": "Grade" }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using an array of objects as a data source (mData)
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "aaData": [
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 4.0",
		 *            "platform": "Win 95+",
		 *            "version":  4,
		 *            "grade":    "X"
		 *          },
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 5.0",
		 *            "platform": "Win 95+",
		 *            "version":  5,
		 *            "grade":    "C"
		 *          }
		 *        ],
		 *        "aoColumns": [
		 *          { "sTitle": "Engine",   "mData": "engine" },
		 *          { "sTitle": "Browser",  "mData": "browser" },
		 *          { "sTitle": "Platform", "mData": "platform" },
		 *          { "sTitle": "Version",  "mData": "version" },
		 *          { "sTitle": "Grade",    "mData": "grade" }
		 *        ]
		 *      } );
		 *    } );
     */
    "aaData": null,


    /**
     * If sorting is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed upon,
     * and the sorting direction, with this variable. The aaSorting array should
     * contain an array for each column to be sorted initially containing the
     * column's index and a direction string ('asc' or 'desc').
     *  @type array
     *  @default [[0,'asc']]
     *  @dtopt Option
     *
     *  @example
     *    // Sort by 3rd column first, and then 4th column
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSorting": [[2,'asc'], [3,'desc']]
		 *      } );
		 *    } );
     *
     *    // No initial sorting
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSorting": []
		 *      } );
		 *    } );
     */
    "aaSorting": [[0,'asc']],


    /**
     * This parameter is basically identical to the aaSorting parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting will
     * always be forced on first - any sorting after that (from the user) will
     * then be performed as required. This can be useful for grouping rows
     * together.
     *  @type array
     *  @default null
     *  @dtopt Option
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSortingFixed": [[0,'asc']]
		 *      } );
		 *    } )
     */
    "aaSortingFixed": null,


    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *  @type array
     *  @default [ 10, 25, 50, 100 ]
     *  @dtopt Option
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aLengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Setting the default display length as well as length menu
     *    // This is likely to be wanted if you remove the '10' option which
     *    // is the iDisplayLength default.
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayLength": 25,
		 *        "aLengthMenu": [[25, 50, 100, -1], [25, 50, 100, "All"]]
		 *      } );
		 *    } );
     */
    "aLengthMenu": [ 10, 25, 50, 100 ],


    /**
     * The aoColumns option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.columns}. Note that if you use aoColumns to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     *  @member
     */
    "aoColumns": null,

    /**
     * Very similar to aoColumns, aoColumnDefs allows you to target a specific
     * column, multiple columns, or all columns, using the aTargets property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the aoColumnDefs arrays can be of any length, targeting the
     * columns you specifically want. aoColumnDefs may use any of the column
     * options available: {@link DataTable.defaults.columns}, but it _must_
     * have aTargets defined in each object in the array. Values in the aTargets
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     *  @member
     */
    "aoColumnDefs": null,


    /**
     * Basically the same as oSearch, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * "sSearch" and "bEscapeRegex" (the latter is optional). 'null' is also
     * accepted and the default will be used.
     *  @type array
     *  @default []
     *  @dtopt Option
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoSearchCols": [
		 *          null,
		 *          { "sSearch": "My filter" },
		 *          null,
		 *          { "sSearch": "^[0-9]", "bEscapeRegex": false }
		 *        ]
		 *      } );
		 *    } )
     */
    "aoSearchCols": [],


    /**
     * An array of CSS classes that should be applied to displayed rows. This
     * array may be of any length, and DataTables will apply each class
     * sequentially, looping when required.
     *  @type array
     *  @default null <i>Will take the values determined by the oClasses.sStripe*
     *    options</i>
     *  @dtopt Option
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "asStripeClasses": [ 'strip1', 'strip2', 'strip3' ]
		 *      } );
		 *    } )
     */
    "asStripeClasses": null,


    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using aoColumns.
     *  @type boolean
     *  @default true
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bAutoWidth": false
		 *      } );
		 *    } );
     */
    "bAutoWidth": true,


    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     *  @type boolean
     *  @default false
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/arrays.txt",
		 *        "bDeferRender": true
		 *      } );
		 *    } );
     */
    "bDeferRender": false,


    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     *  @type boolean
     *  @default false
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *      
		 *      // Some time later....
		 *      $('#example').dataTable( {
		 *        "bFilter": false,
		 *        "bDestroy": true
		 *      } );
		 *    } );
     */
    "bDestroy": false,


    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.sDom}.
     *  @type boolean
     *  @default true
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bFilter": false
		 *      } );
		 *    } );
     */
    "bFilter": true,


    /**
     * Enable or disable the table information display. This shows information
     * about the data that is currently visible on the page, including information
     * about filtered data if that action is being performed.
     *  @type boolean
     *  @default true
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bInfo": false
		 *      } );
		 *    } );
     */
    "bInfo": true,


    /**
     * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
     * slightly different and additional mark-up from what DataTables has
     * traditionally used).
     *  @type boolean
     *  @default false
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bJQueryUI": true
		 *      } );
		 *    } );
     */
    "bJQueryUI": false,


    /**
     * Allows the end user to select the size of a formatted page from a select
     * menu (sizes are 10, 25, 50 and 100). Requires pagination (bPaginate).
     *  @type boolean
     *  @default true
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bLengthChange": false
		 *      } );
		 *    } );
     */
    "bLengthChange": true,


    /**
     * Enable or disable pagination.
     *  @type boolean
     *  @default true
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bPaginate": false
		 *      } );
		 *    } );
     */
    "bPaginate": true,


    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     *  @type boolean
     *  @default false
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true
		 *      } );
		 *    } );
     */
    "bProcessing": false,


    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). bDestroy can be used to reinitialise a table if
     * you need.
     *  @type boolean
     *  @default false
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      initTable();
		 *      tableActions();
		 *    } );
     *
     *    function initTable ()
     *    {
		 *      return $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false,
		 *        "bRetrieve": true
		 *      } );
		 *    }
     *
     *    function tableActions ()
     *    {
		 *      var oTable = initTable();
		 *      // perform API operations with oTable 
		 *    }
     */
    "bRetrieve": false,


    /**
     * Indicate if DataTables should be allowed to set the padding / margin
     * etc for the scrolling header elements or not. Typically you will want
     * this.
     *  @type boolean
     *  @default true
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bScrollAutoCss": false,
		 *        "sScrollY": "200px"
		 *      } );
		 *    } );
     */
    "bScrollAutoCss": true,


    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     *  @type boolean
     *  @default false
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200",
		 *        "bScrollCollapse": true
		 *      } );
		 *    } );
     */
    "bScrollCollapse": false,


    /**
     * Enable infinite scrolling for DataTables (to be used in combination with
     * sScrollY). Infinite scrolling means that DataTables will continually load
     * data as a user scrolls through a table, which is very useful for large
     * dataset. This cannot be used with pagination, which is automatically
     * disabled. Note - the Scroller extra for DataTables is recommended in
     * in preference to this option.
     *  @type boolean
     *  @default false
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bScrollInfinite": true,
		 *        "bScrollCollapse": true,
		 *        "sScrollY": "200px"
		 *      } );
		 *    } );
     */
    "bScrollInfinite": false,


    /**
     * Configure DataTables to use server-side processing. Note that the
     * sAjaxSource parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     *  @type boolean
     *  @default false
     *  @dtopt Features
     *  @dtopt Server-side
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "xhr.php"
		 *      } );
		 *    } );
     */
    "bServerSide": false,


    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the "bSortable" option for each column.
     *  @type boolean
     *  @default true
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bSort": false
		 *      } );
		 *    } );
     */
    "bSort": true,


    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     *  @type boolean
     *  @default false
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bSortCellsTop": true
		 *      } );
		 *    } );
     */
    "bSortCellsTop": false,


    /**
     * Enable or disable the addition of the classes 'sorting_1', 'sorting_2' and
     * 'sorting_3' to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     *  @type boolean
     *  @default true
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bSortClasses": false
		 *      } );
		 *    } );
     */
    "bSortClasses": true,


    /**
     * Enable or disable state saving. When enabled a cookie will be used to save
     * table display information such as pagination information, display length,
     * filtering and sorting. As such when the end user reloads the page the
     * display display will match what thy had previously set up.
     *  @type boolean
     *  @default false
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true
		 *      } );
		 *    } );
     */
    "bStateSave": false,


    /**
     * Customise the cookie and / or the parameters being stored when using
     * DataTables with state saving enabled. This function is called whenever
     * the cookie is modified, and it expects a fully formed cookie string to be
     * returned. Note that the data object passed in is a Javascript object which
     * must be converted to a string (JSON.stringify for example).
     *  @type function
     *  @param {string} sName Name of the cookie defined by DataTables
     *  @param {object} oData Data to be stored in the cookie
     *  @param {string} sExpires Cookie expires string
     *  @param {string} sPath Path of the cookie to set
     *  @returns {string} Cookie formatted string (which should be encoded by
     *    using encodeURIComponent())
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "fnCookieCallback": function (sName, oData, sExpires, sPath) {
		 *          // Customise oData or sName or whatever else here
		 *          return sName + "="+JSON.stringify(oData)+"; expires=" + sExpires +"; path=" + sPath;
		 *        }
		 *      } );
		 *    } );
     */
    "fnCookieCallback": null,


    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     *  @type function
     *  @param {node} nRow "TR" element for the current row
     *  @param {array} aData Raw data array for this row
     *  @param {int} iDataIndex The index of this row in aoData
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnCreatedRow": function( nRow, aData, iDataIndex ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( aData[4] == "A" )
		 *          {
		 *            $('td:eq(4)', nRow).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
     */
    "fnCreatedRow": null,


    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnDrawCallback": function( oSettings ) {
		 *          alert( 'DataTables has redrawn the table' );
		 *        }
		 *      } );
		 *    } );
     */
    "fnDrawCallback": null,


    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' even.
     *  @type function
     *  @param {node} nFoot "TR" element for the footer
     *  @param {array} aData Full table data (as derived from the original HTML)
     *  @param {int} iStart Index for the current display starting point in the
     *    display array
     *  @param {int} iEnd Index for the current display ending point in the
     *    display array
     *  @param {array int} aiDisplay Index array to translate the visual position
     *    to the full data array
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnFooterCallback": function( nFoot, aData, iStart, iEnd, aiDisplay ) {
		 *          nFoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+iStart;
		 *        }
		 *      } );
		 *    } )
     */
    "fnFooterCallback": null,


    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     *  @type function
     *  @member
     *  @param {int} iIn number to be formatted
     *  @returns {string} formatted string for DataTables to show the number
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnFormatNumber": function ( iIn ) {
		 *          if ( iIn &lt; 1000 ) {
		 *            return iIn;
		 *          } else {
		 *            var 
		 *              s=(iIn+""), 
		 *              a=s.split(""), out="", 
		 *              iLen=s.length;
		 *            
		 *            for ( var i=0 ; i&lt;iLen ; i++ ) {
		 *              if ( i%3 === 0 &amp;&amp; i !== 0 ) {
		 *                out = "'"+out;
		 *              }
		 *              out = a[iLen-i-1]+out;
		 *            }
		 *          }
		 *          return out;
		 *        };
		 *      } );
		 *    } );
     */
    "fnFormatNumber": function ( iIn ) {
      if ( iIn < 1000 )
      {
        // A small optimisation for what is likely to be the majority of use cases
        return iIn;
      }

      var s=(iIn+""), a=s.split(""), out="", iLen=s.length;

      for ( var i=0 ; i<iLen ; i++ )
      {
        if ( i%3 === 0 && i !== 0 )
        {
          out = this.oLanguage.sInfoThousands+out;
        }
        out = a[iLen-i-1]+out;
      }
      return out;
    },


    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     *  @type function
     *  @param {node} nHead "TR" element for the header
     *  @param {array} aData Full table data (as derived from the original HTML)
     *  @param {int} iStart Index for the current display starting point in the
     *    display array
     *  @param {int} iEnd Index for the current display ending point in the
     *    display array
     *  @param {array int} aiDisplay Index array to translate the visual position
     *    to the full data array
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnHeaderCallback": function( nHead, aData, iStart, iEnd, aiDisplay ) {
		 *          nHead.getElementsByTagName('th')[0].innerHTML = "Displaying "+(iEnd-iStart)+" records";
		 *        }
		 *      } );
		 *    } )
     */
    "fnHeaderCallback": null,


    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {int} iStart Starting position in data for the draw
     *  @param {int} iEnd End position in data for the draw
     *  @param {int} iMax Total number of rows in the table (regardless of
     *    filtering)
     *  @param {int} iTotal Total number of rows in the data set, after filtering
     *  @param {string} sPre The string that DataTables has formatted using it's
     *    own rules
     *  @returns {string} The string to be displayed in the information element.
     *  @dtopt Callbacks
     *
     *  @example
     *    $('#example').dataTable( {
		 *      "fnInfoCallback": function( oSettings, iStart, iEnd, iMax, iTotal, sPre ) {
		 *        return iStart +" to "+ iEnd;
		 *      }
		 *    } );
     */
    "fnInfoCallback": null,


    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnInitComplete": function(oSettings, json) {
		 *          alert( 'DataTables has finished its initialisation.' );
		 *        }
		 *      } );
		 *    } )
     */
    "fnInitComplete": null,


    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @returns {boolean} False will cancel the draw, anything else (including no
     *    return) will allow it to complete.
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnPreDrawCallback": function( oSettings ) {
		 *          if ( $('#test').val() == 1 ) {
		 *            return false;
		 *          }
		 *        }
		 *      } );
		 *    } );
     */
    "fnPreDrawCallback": null,


    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     *  @type function
     *  @param {node} nRow "TR" element for the current row
     *  @param {array} aData Raw data array for this row
     *  @param {int} iDisplayIndex The display index for the current table draw
     *  @param {int} iDisplayIndexFull The index of the data in the full list of
     *    rows (after filtering)
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnRowCallback": function( nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( aData[4] == "A" )
		 *          {
		 *            $('td:eq(4)', nRow).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
     */
    "fnRowCallback": null,


    /**
     * This parameter allows you to override the default function which obtains
     * the data from the server ($.getJSON) so something more suitable for your
     * application. For example you could use POST data, or pull information from
     * a Gears or AIR database.
     *  @type function
     *  @member
     *  @param {string} sSource HTTP source to obtain the data from (sAjaxSource)
     *  @param {array} aoData A key/value pair object containing the data to send
     *    to the server
     *  @param {function} fnCallback to be called on completion of the data get
     *    process that will draw the data on the page.
     *  @param {object} oSettings DataTables settings object
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *
     *  @example
     *    // POST data to server
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true,
		 *        "bServerSide": true,
		 *        "sAjaxSource": "xhr.php",
		 *        "fnServerData": function ( sSource, aoData, fnCallback, oSettings ) {
		 *          oSettings.jqXHR = $.ajax( {
		 *            "dataType": 'json', 
		 *            "type": "POST", 
		 *            "url": sSource, 
		 *            "data": aoData, 
		 *            "success": fnCallback
		 *          } );
		 *        }
		 *      } );
		 *    } );
     */
    "fnServerData": function ( sUrl, aoData, fnCallback, oSettings ) {
      oSettings.jqXHR = $.ajax( {
        "url":  sUrl,
        "data": aoData,
        "success": function (json) {
          if ( json.sError ) {
            oSettings.oApi._fnLog( oSettings, 0, json.sError );
          }

          $(oSettings.oInstance).trigger('xhr', [oSettings, json]);
          fnCallback( json );
        },
        "dataType": "json",
        "cache": false,
        "type": oSettings.sServerMethod,
        "error": function (xhr, error, thrown) {
          if ( error == "parsererror" ) {
            oSettings.oApi._fnLog( oSettings, 0, "DataTables warning: JSON data from "+
              "server could not be parsed. This is caused by a JSON formatting error." );
          }
        }
      } );
    },


    /**
     * It is often useful to send extra data to the server when making an Ajax
     * request - for example custom filtering information, and this callback
     * function makes it trivial to send extra information to the server. The
     * passed in parameter is the data set that has been constructed by
     * DataTables, and you can add to this or modify it as you require.
     *  @type function
     *  @param {array} aoData Data array (array of objects which are name/value
     *    pairs) that has been constructed by DataTables and will be sent to the
     *    server. In the case of Ajax sourced data with server-side processing
     *    this will be an empty array, for server-side processing there will be a
     *    significant number of parameters!
     *  @returns {undefined} Ensure that you modify the aoData array passed in,
     *    as this is passed by reference.
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true,
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "fnServerParams": function ( aoData ) {
		 *          aoData.push( { "name": "more_data", "value": "my_value" } );
		 *        }
		 *      } );
		 *    } );
     */
    "fnServerParams": null,


    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from its state saving
     * cookie, but you might wish to use local storage (HTML5) or a server-side database.
     *  @type function
     *  @member
     *  @param {object} oSettings DataTables settings object
     *  @return {object} The DataTables state object to be loaded
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoad": function (oSettings) {
		 *          var o;
		 *          
		 *          // Send an Ajax request to the server to get the data. Note that
		 *          // this is a synchronous request.
		 *          $.ajax( {
		 *            "url": "/state_load",
		 *            "async": false,
		 *            "dataType": "json",
		 *            "success": function (json) {
		 *              o = json;
		 *            }
		 *          } );
		 *          
		 *          return o;
		 *        }
		 *      } );
		 *    } );
     */
    "fnStateLoad": function ( oSettings ) {
      var sData = this.oApi._fnReadCookie( oSettings.sCookiePrefix+oSettings.sInstance );
      var oData;

      try {
        oData = (typeof $.parseJSON === 'function') ?
          $.parseJSON(sData) : eval( '('+sData+')' );
      } catch (e) {
        oData = null;
      }

      return oData;
    },


    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the 'stateLoadParams' event to load parameters for
     * a plug-in.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {object} oData The state object that is to be loaded
     *  @dtopt Callbacks
     *
     *  @example
     *    // Remove a saved filter, so filtering is never loaded
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoadParams": function (oSettings, oData) {
		 *          oData.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
     *
     *  @example
     *    // Disallow state loading by returning false
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoadParams": function (oSettings, oData) {
		 *          return false;
		 *        }
		 *      } );
		 *    } );
     */
    "fnStateLoadParams": null,


    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {object} oData The state object that was loaded
     *  @dtopt Callbacks
     *
     *  @example
     *    // Show an alert with the filtering value that was saved
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoaded": function (oSettings, oData) {
		 *          alert( 'Saved filter was: '+oData.oSearch.sSearch );
		 *        }
		 *      } );
		 *    } );
     */
    "fnStateLoaded": null,


    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored - by default it will use a cookie, but you
     * might want to use local storage (HTML5) or a server-side database.
     *  @type function
     *  @member
     *  @param {object} oSettings DataTables settings object
     *  @param {object} oData The state object to be saved
     *  @dtopt Callbacks
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateSave": function (oSettings, oData) {
		 *          // Send an Ajax request to the server with the state object
		 *          $.ajax( {
		 *            "url": "/state_save",
		 *            "data": oData,
		 *            "dataType": "json",
		 *            "method": "POST"
		 *            "success": function () {}
		 *          } );
		 *        }
		 *      } );
		 *    } );
     */
    "fnStateSave": function ( oSettings, oData ) {
      this.oApi._fnCreateCookie(
        oSettings.sCookiePrefix+oSettings.sInstance,
        this.oApi._fnJsonString(oData),
        oSettings.iCookieDuration,
        oSettings.sCookiePrefix,
        oSettings.fnCookieCallback
      );
    },


    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the 'stateSaveParams' event to save parameters for a plug-in.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {object} oData The state object to be saved
     *  @dtopt Callbacks
     *
     *  @example
     *    // Remove a saved filter, so filtering is never saved
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateSaveParams": function (oSettings, oData) {
		 *          oData.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
     */
    "fnStateSaveParams": null,


    /**
     * Duration of the cookie which is used for storing session information. This
     * value is given in seconds.
     *  @type int
     *  @default 7200 <i>(2 hours)</i>
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iCookieDuration": 60*60*24; // 1 day
		 *      } );
		 *    } )
     */
    "iCookieDuration": 7200,


    /**
     * When enabled DataTables will not make a request to the server for the first
     * page draw - rather it will use the data already on the page (no sorting etc
     * will be applied to it), thus saving on an XHR at load time. iDeferLoading
     * is used to indicate that deferred loading is required, but it is also used
     * to tell DataTables how many records there are in the full table (allowing
     * the information element and pagination to be displayed correctly). In the case
     * where a filtering is applied to the table on initial load, this can be
     * indicated by giving the parameter as an array, where the first element is
     * the number of records available after filtering and the second element is the
     * number of records without filtering (allowing the table information element
     * to be shown correctly).
     *  @type int | array
     *  @default null
     *  @dtopt Options
     *
     *  @example
     *    // 57 records available in the table, no filtering applied
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "iDeferLoading": 57
		 *      } );
		 *    } );
     *
     *  @example
     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "iDeferLoading": [ 57, 100 ],
		 *        "oSearch": {
		 *          "sSearch": "my_filter"
		 *        }
		 *      } );
		 *    } );
     */
    "iDeferLoading": null,


    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (bLengthChange) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     *  @type int
     *  @default 10
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayLength": 50
		 *      } );
		 *    } )
     */
    "iDisplayLength": 10,


    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     *  @type int
     *  @default 0
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayStart": 20
		 *      } );
		 *    } )
     */
    "iDisplayStart": 0,


    /**
     * The scroll gap is the amount of scrolling that is left to go before
     * DataTables will load the next 'page' of data automatically. You typically
     * want a gap which is big enough that the scrolling will be smooth for the
     * user, while not so large that it will load more data than need.
     *  @type int
     *  @default 100
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bScrollInfinite": true,
		 *        "bScrollCollapse": true,
		 *        "sScrollY": "200px",
		 *        "iScrollLoadGap": 50
		 *      } );
		 *    } );
     */
    "iScrollLoadGap": 100,


    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a tabindex attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     *  @type int
     *  @default 0
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iTabIndex": 1
		 *      } );
		 *    } );
     */
    "iTabIndex": 0,


    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     *  @namespace
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       *  @namespace
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted ascending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *  @dtopt Language
         *
         *  @example
         *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oAria": {
				 *            "sSortAscending": " - click/return to sort ascending"
				 *          }
				 *        }
				 *      } );
				 *    } );
         */
        "sSortAscending": ": activate to sort column ascending",

        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted descending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *  @dtopt Language
         *
         *  @example
         *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oAria": {
				 *            "sSortDescending": " - click/return to sort descending"
				 *          }
				 *        }
				 *      } );
				 *    } );
         */
        "sSortDescending": ": activate to sort column descending"
      },

      /**
       * Pagination string used by DataTables for the two built-in pagination
       * control types ("two_button" and "full_numbers")
       *  @namespace
       */
      "oPaginate": {
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the first page.
         *  @type string
         *  @default First
         *  @dtopt Language
         *
         *  @example
         *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sFirst": "First page"
				 *          }
				 *        }
				 *      } );
				 *    } );
         */
        "sFirst": "First",


        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the last page.
         *  @type string
         *  @default Last
         *  @dtopt Language
         *
         *  @example
         *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sLast": "Last page"
				 *          }
				 *        }
				 *      } );
				 *    } );
         */
        "sLast": "Last",


        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the next page.
         *  @type string
         *  @default Next
         *  @dtopt Language
         *
         *  @example
         *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sNext": "Next page"
				 *          }
				 *        }
				 *      } );
				 *    } );
         */
        "sNext": "Next",


        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the previous page.
         *  @type string
         *  @default Previous
         *  @dtopt Language
         *
         *  @example
         *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sPrevious": "Previous page"
				 *          }
				 *        }
				 *      } );
				 *    } );
         */
        "sPrevious": "Previous"
      },

      /**
       * This string is shown in preference to sZeroRecords when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of sZeroRecords will be used
       * instead (either the default or given value).
       *  @type string
       *  @default No data available in table
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sEmptyTable": "No data available in table"
			 *        }
			 *      } );
			 *    } );
       */
      "sEmptyTable": "No data available in table",


      /**
       * This string gives information to the end user about the information that
       * is current on display on the page. The _START_, _END_ and _TOTAL_
       * variables are all dynamically replaced as the table display updates, and
       * can be freely moved or removed as the language requirements change.
       *  @type string
       *  @default Showing _START_ to _END_ of _TOTAL_ entries
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfo": "Got a total of _TOTAL_ entries to show (_START_ to _END_)"
			 *        }
			 *      } );
			 *    } );
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",


      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match sInfo.
       *  @type string
       *  @default Showing 0 to 0 of 0 entries
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoEmpty": "No entries to show"
			 *        }
			 *      } );
			 *    } );
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 entries",


      /**
       * When a user filters the information in a table, this string is appended
       * to the information (sInfo) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       *  @type string
       *  @default (filtered from _MAX_ total entries)
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoFiltered": " - filtering from _MAX_ records"
			 *        }
			 *      } );
			 *    } );
       */
      "sInfoFiltered": "(filtered from _MAX_ total entries)",


      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the sInfo (sInfoEmpty and sInfoFiltered in whatever combination they are
       * being used) at all times.
       *  @type string
       *  @default <i>Empty string</i>
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoPostFix": "All records shown are derived from real information."
			 *        }
			 *      } );
			 *    } );
       */
      "sInfoPostFix": "",


      /**
       * DataTables has a build in number formatter (fnFormatNumber) which is used
       * to format large numbers that are used in the table information. By
       * default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       *  @type string
       *  @default ,
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoThousands": "'"
			 *        }
			 *      } );
			 *    } );
       */
      "sInfoThousands": ",",


      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       *  @type string
       *  @default Show _MENU_ entries
       *  @dtopt Language
       *
       *  @example
       *    // Language change only
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLengthMenu": "Display _MENU_ records"
			 *        }
			 *      } );
			 *    } );
       *
       *  @example
       *    // Language and options change
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLengthMenu": 'Display <select>'+
			 *            '<option value="10">10</option>'+
			 *            '<option value="20">20</option>'+
			 *            '<option value="30">30</option>'+
			 *            '<option value="40">40</option>'+
			 *            '<option value="50">50</option>'+
			 *            '<option value="-1">All</option>'+
			 *            '</select> records'
			 *        }
			 *      } );
			 *    } );
       */
      "sLengthMenu": "Show _MENU_ entries",


      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       *  @type string
       *  @default Loading...
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLoadingRecords": "Please wait - loading..."
			 *        }
			 *      } );
			 *    } );
       */
      "sLoadingRecords": "Loading...",


      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       *  @type string
       *  @default Processing...
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sProcessing": "DataTables is currently busy"
			 *        }
			 *      } );
			 *    } );
       */
      "sProcessing": "Processing...",


      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       *  @type string
       *  @default Search:
       *  @dtopt Language
       *
       *  @example
       *    // Input text box will be appended at the end automatically
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sSearch": "Filter records:"
			 *        }
			 *      } );
			 *    } );
       *
       *  @example
       *    // Specify where the filter should appear
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sSearch": "Apply filter _INPUT_ to table"
			 *        }
			 *      } );
			 *    } );
       */
      "sSearch": "Search:",


      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       *  @type string
       *  @default <i>Empty string - i.e. disabled</i>
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sUrl": "http://www.sprymedia.co.uk/dataTables/lang.txt"
			 *        }
			 *      } );
			 *    } );
       */
      "sUrl": "",


      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. sEmptyTable is shown when there is simply no
       * information in the table at all (regardless of filtering).
       *  @type string
       *  @default No matching records found
       *  @dtopt Language
       *
       *  @example
       *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sZeroRecords": "No records to display"
			 *        }
			 *      } );
			 *    } );
       */
      "sZeroRecords": "No matching records found"
    },


    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the "sSearch" parameter must be
     * defined, but all other parameters are optional. When "bRegex" is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When "bSmart"
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     *  @namespace
     *  @extends DataTable.models.oSearch
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "oSearch": {"sSearch": "Initial search"}
		 *      } );
		 *    } )
     */
    "oSearch": $.extend( {}, DataTable.models.oSearch ),


    /**
     * By default DataTables will look for the property 'aaData' when obtaining
     * data from an Ajax source or for server-side processing - this parameter
     * allows that property to be changed. You can use Javascript dotted object
     * notation to get a data source for multiple levels of nesting.
     *  @type string
     *  @default aaData
     *  @dtopt Options
     *  @dtopt Server-side
     *
     *  @example
     *    // Get data from { "data": [...] }
     *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/data.txt",
		 *        "sAjaxDataProp": "data"
		 *      } );
		 *    } );
     *
     *  @example
     *    // Get data from { "data": { "inner": [...] } }
     *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/data.txt",
		 *        "sAjaxDataProp": "data.inner"
		 *      } );
		 *    } );
     */
    "sAjaxDataProp": "aaData",


    /**
     * You can instruct DataTables to load data from an external source using this
     * parameter (use aData if you want to pass data in you already have). Simply
     * provide a url a JSON object can be obtained from. This object must include
     * the parameter 'aaData' which is the data source for the table.
     *  @type string
     *  @default null
     *  @dtopt Options
     *  @dtopt Server-side
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sAjaxSource": "http://www.sprymedia.co.uk/dataTables/json.php"
		 *      } );
		 *    } )
     */
    "sAjaxSource": null,


    /**
     * This parameter can be used to override the default prefix that DataTables
     * assigns to a cookie when state saving is enabled.
     *  @type string
     *  @default SpryMedia_DataTables_
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sCookiePrefix": "my_datatable_",
		 *      } );
		 *    } );
     */
    "sCookiePrefix": "SpryMedia_DataTables_",


    /**
     * This initialisation variable allows you to specify exactly where in the
     * DOM you want DataTables to inject the various controls it adds to the page
     * (for example you might want the pagination controls at the top of the
     * table). DIV elements (with or without a custom class) can also be added to
     * aid styling. The follow syntax is used:
     *   <ul>
     *     <li>The following options are allowed:
     *       <ul>
     *         <li>'l' - Length changing</li
     *         <li>'f' - Filtering input</li>
     *         <li>'t' - The table!</li>
     *         <li>'i' - Information</li>
     *         <li>'p' - Pagination</li>
     *         <li>'r' - pRocessing</li>
     *       </ul>
     *     </li>
     *     <li>The following constants are allowed:
     *       <ul>
     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
     *       </ul>
     *     </li>
     *     <li>The following syntax is expected:
     *       <ul>
     *         <li>'&lt;' and '&gt;' - div elements</li>
     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
     *       </ul>
     *     </li>
     *     <li>Examples:
     *       <ul>
     *         <li>'&lt;"wrapper"flipt&gt;'</li>
     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
     *       </ul>
     *     </li>
     *   </ul>
     *  @type string
     *  @default lfrtip <i>(when bJQueryUI is false)</i> <b>or</b>
     *    <"H"lfr>t<"F"ip> <i>(when bJQueryUI is true)</i>
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sDom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
		 *      } );
		 *    } );
     */
    "sDom": "lfrtip",


    /**
     * DataTables features two different built-in pagination interaction methods
     * ('two_button' or 'full_numbers') which present different page controls to
     * the end user. Further methods can be added using the API (see below).
     *  @type string
     *  @default two_button
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sPaginationType": "full_numbers"
		 *      } );
		 *    } )
     */
    "sPaginationType": "two_button",


    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a certain
     * layout, or you have a large number of columns in the table, you can enable
     * x-scrolling to show the table in a viewport, which can be scrolled. This
     * property can be any CSS unit, or a number (in which case it will be treated
     * as a pixel measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollX": "100%",
		 *        "bScrollCollapse": true
		 *      } );
		 *    } );
     */
    "sScrollX": "",


    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *  @dtopt Options
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollX": "100%",
		 *        "sScrollXInner": "110%"
		 *      } );
		 *    } );
     */
    "sScrollXInner": "",


    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *  @dtopt Features
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *    } );
     */
    "sScrollY": "",


    /**
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     *  @type string
     *  @default GET
     *  @dtopt Options
     *  @dtopt Server-side
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/post.php",
		 *        "sServerMethod": "POST"
		 *      } );
		 *    } );
     */
    "sServerMethod": "GET"
  };



  /**
   * Column options that can be given to DataTables at initialisation time.
   *  @namespace
   */
  DataTable.defaults.columns = {
    /**
     * Allows a column's sorting to take multiple columns into account when
     * doing a sort. For example first name / last name columns make sense to
     * do a multi-column sort over the two columns.
     *  @type array
     *  @default null <i>Takes the value of the column index automatically</i>
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "aDataSort": [ 0, 1 ], "aTargets": [ 0 ] },
		 *          { "aDataSort": [ 1, 0 ], "aTargets": [ 1 ] },
		 *          { "aDataSort": [ 2, 3, 4 ], "aTargets": [ 2 ] }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          { "aDataSort": [ 0, 1 ] },
		 *          { "aDataSort": [ 1, 0 ] },
		 *          { "aDataSort": [ 2, 3, 4 ] },
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
     */
    "aDataSort": null,


    /**
     * You can control the default sorting direction, and even alter the behaviour
     * of the sort handler (i.e. only allow ascending sorting etc) using this
     * parameter.
     *  @type array
     *  @default [ 'asc', 'desc' ]
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "asSorting": [ "asc" ], "aTargets": [ 1 ] },
		 *          { "asSorting": [ "desc", "asc", "asc" ], "aTargets": [ 2 ] },
		 *          { "asSorting": [ "desc" ], "aTargets": [ 3 ] }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          null,
		 *          { "asSorting": [ "asc" ] },
		 *          { "asSorting": [ "desc", "asc", "asc" ] },
		 *          { "asSorting": [ "desc" ] },
		 *          null
		 *        ]
		 *      } );
		 *    } );
     */
    "asSorting": [ 'asc', 'desc' ],


    /**
     * Enable or disable filtering on the data in this column.
     *  @type boolean
     *  @default true
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bSearchable": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bSearchable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
     */
    "bSearchable": true,


    /**
     * Enable or disable sorting on this column.
     *  @type boolean
     *  @default true
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bSortable": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bSortable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
     */
    "bSortable": true,


    /**
     * When using fnRender() for a column, you may wish to use the original data
     * (before rendering) for sorting and filtering (the default is to used the
     * rendered data that the user can see). This may be useful for dates etc.
     *
     * *NOTE* This property is now deprecated, and it is suggested that you use
     * mData and / or mRender to render data for the DataTable.
     *  @type boolean
     *  @default true
     *  @dtopt Columns
     *  @deprecated
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "fnRender": function ( oObj ) {
		 *              return oObj.aData[0] +' '+ oObj.aData[3];
		 *            },
		 *            "bUseRendered": false,
		 *            "aTargets": [ 0 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          {
		 *            "fnRender": function ( oObj ) {
		 *              return oObj.aData[0] +' '+ oObj.aData[3];
		 *            },
		 *            "bUseRendered": false
		 *          },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
     */
    "bUseRendered": true,


    /**
     * Enable or disable the display of this column.
     *  @type boolean
     *  @default true
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bVisible": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bVisible": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
     */
    "bVisible": true,


    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to fnRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available (since it is not when fnRender is called).
     *  @type function
     *  @param {element} nTd The TD node that has been created
     *  @param {*} sData The Data for the cell
     *  @param {array|object} oData The data for the whole row
     *  @param {int} iRow The row index for the aoData data store
     *  @param {int} iCol The column index for aoColumns
     *  @dtopt Columns
     *
     *  @example
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [3],
		 *          "fnCreatedCell": function (nTd, sData, oData, iRow, iCol) {
		 *            if ( sData == "1.7" ) {
		 *              $(nTd).css('color', 'blue')
		 *            }
		 *          }
		 *        } ]
		 *      });
		 *    } );
     */
    "fnCreatedCell": null,


    /**
     * Custom display function that will be called for the display of each cell in
     * this column.
     *  @type function
     *  @param {object} o Object with the following parameters:
     *  @param {int}    o.iDataRow The row in aoData
     *  @param {int}    o.iDataColumn The column in question
     *  @param {array}  o.aData The data for the row in question
     *  @param {object} o.oSettings The settings object for this DataTables instance
     *  @param {object} o.mDataProp The data property used for this column
     *  @param {*}      val The current cell value
     *  @returns {string} The string you which to use in the display
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "fnRender": function ( o, val ) {
		 *              return o.aData[0] +' '+ o.aData[3];
		 *            },
		 *            "aTargets": [ 0 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "fnRender": function ( o, val ) {
		 *            return o.aData[0] +' '+ o.aData[3];
		 *          } },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
     */
    "fnRender": null,


    /**
     * The column index (starting from 0!) that you wish a sort to be performed
     * upon when this column is selected for sorting. This can be used for sorting
     * on hidden columns for example.
     *  @type int
     *  @default -1 <i>Use automatically calculated column index</i>
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "iDataSort": 1, "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "iDataSort": 1 },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
     */
    "iDataSort": -1,


    /**
     * This parameter has been replaced by mData in DataTables to ensure naming
     * consistency. mDataProp can still be used, as there is backwards compatibility
     * in DataTables for this option, but it is strongly recommended that you use
     * mData in preference to mDataProp.
     *  @name DataTable.defaults.columns.mDataProp
     */


    /**
     * This property can be used to read data from any JSON data source property,
     * including deeply nested objects / properties. mData can be given in a
     * number of different ways which effect its behaviour:
     *   <ul>
     *     <li>integer - treated as an array index for the data source. This is the
     *       default that DataTables uses (incrementally increased for each column).</li>
     *     <li>string - read an object property from the data source. Note that you can
     *       use Javascript dotted notation to read deep properties / arrays from the
     *       data source.</li>
     *     <li>null - the sDefaultContent option will be used for the cell (null
     *       by default, so you will need to specify the default content you want -
     *       typically an empty string). This can be useful on generated columns such
     *       as edit / delete action columns.</li>
     *     <li>function - the function given will be executed whenever DataTables
     *       needs to set or get the data for a cell in the column. The function
     *       takes three parameters:
     *       <ul>
     *         <li>{array|object} The data source for the row</li>
     *         <li>{string} The type call data requested - this will be 'set' when
     *           setting data or 'filter', 'display', 'type', 'sort' or undefined when
     *           gathering data. Note that when <i>undefined</i> is given for the type
     *           DataTables expects to get the raw data for the object back</li>
     *         <li>{*} Data to set when the second parameter is 'set'.</li>
     *       </ul>
     *       The return value from the function is not required when 'set' is the type
     *       of call, but otherwise the return is what will be used for the data
     *       requested.</li>
     *    </ul>
     *
     * Note that prior to DataTables 1.9.2 mData was called mDataProp. The name change
     * reflects the flexibility of this property and is consistent with the naming of
     * mRender. If 'mDataProp' is given, then it will still be used by DataTables, as
     * it automatically maps the old name to the new if required.
     *  @type string|int|function|null
     *  @default null <i>Use automatically calculated column index</i>
     *  @dtopt Columns
     *
     *  @example
     *    // Read table data from objects
     *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/deep.txt",
		 *        "aoColumns": [
		 *          { "mData": "engine" },
		 *          { "mData": "browser" },
		 *          { "mData": "platform.inner" },
		 *          { "mData": "platform.details.0" },
		 *          { "mData": "platform.details.1" }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using mData as a function to provide different information for
     *    // sorting, filtering and display. In this case, currency (price)
     *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [ 0 ],
		 *          "mData": function ( source, type, val ) {
		 *            if (type === 'set') {
		 *              source.price = val;
		 *              // Store the computed dislay and filter values for efficiency
		 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
		 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
		 *              return;
		 *            }
		 *            else if (type === 'display') {
		 *              return source.price_display;
		 *            }
		 *            else if (type === 'filter') {
		 *              return source.price_filter;
		 *            }
		 *            // 'sort', 'type' and undefined all just use the integer
		 *            return source.price;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
     */
    "mData": null,


    /**
     * This property is the rendering partner to mData and it is suggested that
     * when you want to manipulate data for display (including filtering, sorting etc)
     * but not altering the underlying data for the table, use this property. mData
     * can actually do everything this property can and more, but this parameter is
     * easier to use since there is no 'set' option. Like mData is can be given
     * in a number of different ways to effect its behaviour, with the addition of
     * supporting array syntax for easy outputting of arrays (including arrays of
     * objects):
     *   <ul>
     *     <li>integer - treated as an array index for the data source. This is the
     *       default that DataTables uses (incrementally increased for each column).</li>
     *     <li>string - read an object property from the data source. Note that you can
     *       use Javascript dotted notation to read deep properties / arrays from the
     *       data source and also array brackets to indicate that the data reader should
     *       loop over the data source array. When characters are given between the array
     *       brackets, these characters are used to join the data source array together.
     *       For example: "accounts[, ].name" would result in a comma separated list with
     *       the 'name' value from the 'accounts' array of objects.</li>
     *     <li>function - the function given will be executed whenever DataTables
     *       needs to set or get the data for a cell in the column. The function
     *       takes three parameters:
     *       <ul>
     *         <li>{array|object} The data source for the row (based on mData)</li>
     *         <li>{string} The type call data requested - this will be 'filter', 'display',
     *           'type' or 'sort'.</li>
     *         <li>{array|object} The full data source for the row (not based on mData)</li>
     *       </ul>
     *       The return value from the function is what will be used for the data
     *       requested.</li>
     *    </ul>
     *  @type string|int|function|null
     *  @default null <i>Use mData</i>
     *  @dtopt Columns
     *
     *  @example
     *    // Create a comma separated list from an array of objects
     *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/deep.txt",
		 *        "aoColumns": [
		 *          { "mData": "engine" },
		 *          { "mData": "browser" },
		 *          {
		 *            "mData": "platform",
		 *            "mRender": "[, ].name"
		 *          }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Use as a function to create a link from the data source
     *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *        {
		 *          "aTargets": [ 0 ],
		 *          "mData": "download_link",
		 *          "mRender": function ( data, type, full ) {
		 *            return '<a href="'+data+'">Download</a>';
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
    "mRender": null,


    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     *  @type string
     *  @default td
     *  @dtopt Columns
     *
     *  @example
     *    // Make the first column use TH cells
     *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [ 0 ],
		 *          "sCellType": "th"
		 *        } ]
		 *      } );
		 *    } );
     */
    "sCellType": "td",


    /**
     * Class to give to each cell in this column.
     *  @type string
     *  @default <i>Empty string</i>
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sClass": "my_class", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sClass": "my_class" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
     */
    "sClass": "",

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this, and it is not documented on the
     * general DataTables.net documentation
     *  @type string
     *  @default <i>Empty string<i>
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "sContentPadding": "mmm"
		 *          }
		 *        ]
		 *      } );
		 *    } );
     */
    "sContentPadding": "",


    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "mData": null,
		 *            "sDefaultContent": "Edit",
		 *            "aTargets": [ -1 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "mData": null,
		 *            "sDefaultContent": "Edit"
		 *          }
		 *        ]
		 *      } );
		 *    } );
     */
    "sDefaultContent": null,


    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     *  @type string
     *  @default <i>Empty string</i>
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sName": "engine", "aTargets": [ 0 ] },
		 *          { "sName": "browser", "aTargets": [ 1 ] },
		 *          { "sName": "platform", "aTargets": [ 2 ] },
		 *          { "sName": "version", "aTargets": [ 3 ] },
		 *          { "sName": "grade", "aTargets": [ 4 ] }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sName": "engine" },
		 *          { "sName": "browser" },
		 *          { "sName": "platform" },
		 *          { "sName": "version" },
		 *          { "sName": "grade" }
		 *        ]
		 *      } );
		 *    } );
     */
    "sName": "",


    /**
     * Defines a data source type for the sorting which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to sorting. This allows sorting to occur on user editable
     * elements such as form inputs.
     *  @type string
     *  @default std
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "sSortDataType": "dom-text", "aTargets": [ 2, 3 ] },
		 *          { "sType": "numeric", "aTargets": [ 3 ] },
		 *          { "sSortDataType": "dom-select", "aTargets": [ 4 ] },
		 *          { "sSortDataType": "dom-checkbox", "aTargets": [ 5 ] }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          null,
		 *          null,
		 *          { "sSortDataType": "dom-text" },
		 *          { "sSortDataType": "dom-text", "sType": "numeric" },
		 *          { "sSortDataType": "dom-select" },
		 *          { "sSortDataType": "dom-checkbox" }
		 *        ]
		 *      } );
		 *    } );
     */
    "sSortDataType": "std",


    /**
     * The title of this column.
     *  @type string
     *  @default null <i>Derived from the 'TH' value for this column in the
     *    original HTML table.</i>
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sTitle": "My column title", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sTitle": "My column title" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
     */
    "sTitle": null,


    /**
     * The type allows you to specify how the data for this column will be sorted.
     * Four types (string, numeric, date and html (which will strip HTML tags
     * before sorting)) are currently available. Note that only date formats
     * understood by Javascript's Date() object will be accepted as type date. For
     * example: "Mar 26, 2008 5:03 PM". May take the values: 'string', 'numeric',
     * 'date' or 'html' (by default). Further types can be adding through
     * plug-ins.
     *  @type string
     *  @default null <i>Auto-detected from raw data</i>
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sType": "html", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sType": "html" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
     */
    "sType": null,


    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables apples 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     *  @type string
     *  @default null <i>Automatic</i>
     *  @dtopt Columns
     *
     *  @example
     *    // Using aoColumnDefs
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sWidth": "20%", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
     *
     *  @example
     *    // Using aoColumns
     *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sWidth": "20%" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
     */
    "sWidth": null
  };



  /**
   * DataTables settings object - this holds all the information needed for a
   * given table, including configuration, data and current application of the
   * table options. DataTables does not have a single instance for each DataTable
   * with the settings attached to that instance, but rather instances of the
   * DataTable "class" are created on-the-fly as needed (typically by a
   * $().dataTable() call) and the settings object is then applied to that
   * instance.
   *
   * Note that this object is related to {@link DataTable.defaults} but this
   * one is the internal data store for DataTables's cache of columns. It should
   * NOT be manipulated outside of DataTables. Any configuration should be done
   * through the initialisation options.
   *  @namespace
   *  @todo Really should attach the settings object to individual instances so we
   *    don't need to create new instances on each $().dataTable() call (if the
   *    table already exists). It would also save passing oSettings around and
   *    into every single function. However, this is a very significant
   *    architecture change for DataTables and will almost certainly break
   *    backwards compatibility with older installations. This is something that
   *    will be done in 2.0.
   */
  DataTable.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     *  @namespace
     */
    "oFeatures": {

      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bAutoWidth": null,

      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all fro DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bDeferRender": null,

      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bFilter": null,

      /**
       * Table information element (the 'Showing x of y records' div) enable
       * flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bInfo": null,

      /**
       * Present a user control allowing the end user to change the page size
       * when pagination is enabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bLengthChange": null,

      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bPaginate": null,

      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bProcessing": null,

      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bServerSide": null,

      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSort": null,

      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortClasses": null,

      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bStateSave": null
    },


    /**
     * Scrolling settings for a table.
     *  @namespace
     */
    "oScroll": {
      /**
       * Indicate if DataTables should be allowed to set the padding / margin
       * etc for the scrolling header elements or not. Typically you will want
       * this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bAutoCss": null,

      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bCollapse": null,

      /**
       * Infinite scrolling enablement flag. Now deprecated in favour of
       * using the Scroller plug-in.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bInfinite": null,

      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       *  @type int
       *  @default 0
       */
      "iBarWidth": 0,

      /**
       * Space (in pixels) between the bottom of the scrolling container and
       * the bottom of the scrolling viewport before the next page is loaded
       * when using infinite scrolling.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type int
       */
      "iLoadGap": null,

      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sX": null,

      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @deprecated
       */
      "sXInner": null,

      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sY": null
    },

    /**
     * Language information for the table.
     *  @namespace
     *  @extends DataTable.defaults.oLanguage
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       *  @type function
       *  @default null
       */
      "fnInfoCallback": null
    },

    /**
     * Browser support parameters
     *  @namespace
     */
    "oBrowser": {
      /**
       * Indicate if the browser incorrectly calculates width:100% inside a
       * scrolling element (IE6/7)
       *  @type boolean
       *  @default false
       */
      "bScrollOversize": false
    },

    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aanFeatures": [],

    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     *  @type array
     *  @default []
     */
    "aoData": [],

    /**
     * Array of indexes which are in the current display (after filtering etc)
     *  @type array
     *  @default []
     */
    "aiDisplay": [],

    /**
     * Array of indexes for display - no filtering
     *  @type array
     *  @default []
     */
    "aiDisplayMaster": [],

    /**
     * Store information about each column that is in use
     *  @type array
     *  @default []
     */
    "aoColumns": [],

    /**
     * Store information about the table's header
     *  @type array
     *  @default []
     */
    "aoHeader": [],

    /**
     * Store information about the table's footer
     *  @type array
     *  @default []
     */
    "aoFooter": [],

    /**
     * Search data array for regular expression searching
     *  @type array
     *  @default []
     */
    "asDataSearch": [],

    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @namespace
     *  @extends DataTable.models.oSearch
     */
    "oPreviousSearch": {},

    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     *  @type array
     *  @default []
     */
    "aoPreSearchCols": [],

    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     *   <li>Index 2 - index of asSorting for this column</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @todo These inner arrays should really be objects
     */
    "aaSorting": null,

    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array|null
     *  @default null
     */
    "aaSortingFixed": null,

    /**
     * Classes to use for the striping of a table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "asStripeClasses": null,

    /**
     * If restoring a table - we should restore its striping classes as well
     *  @type array
     *  @default []
     */
    "asDestroyStripes": [],

    /**
     * If restoring a table - we should restore its width
     *  @type int
     *  @default 0
     */
    "sDestroyWidth": 0,

    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     *  @type array
     *  @default []
     */
    "aoRowCallback": [],

    /**
     * Callback functions for the header on each draw.
     *  @type array
     *  @default []
     */
    "aoHeaderCallback": [],

    /**
     * Callback function for the footer on each draw.
     *  @type array
     *  @default []
     */
    "aoFooterCallback": [],

    /**
     * Array of callback functions for draw callback functions
     *  @type array
     *  @default []
     */
    "aoDrawCallback": [],

    /**
     * Array of callback functions for row created function
     *  @type array
     *  @default []
     */
    "aoRowCreatedCallback": [],

    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     *  @type array
     *  @default []
     */
    "aoPreDrawCallback": [],

    /**
     * Callback functions for when the table has been initialised.
     *  @type array
     *  @default []
     */
    "aoInitComplete": [],


    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     *  @type array
     *  @default []
     */
    "aoStateSaveParams": [],

    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     *  @type array
     *  @default []
     */
    "aoStateLoadParams": [],

    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     *  @type array
     *  @default []
     */
    "aoStateLoaded": [],

    /**
     * Cache the table ID for quick access
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sTableId": "",

    /**
     * The TABLE node for the main table
     *  @type node
     *  @default null
     */
    "nTable": null,

    /**
     * Permanent ref to the thead element
     *  @type node
     *  @default null
     */
    "nTHead": null,

    /**
     * Permanent ref to the tfoot element - if it exists
     *  @type node
     *  @default null
     */
    "nTFoot": null,

    /**
     * Permanent ref to the tbody element
     *  @type node
     *  @default null
     */
    "nTBody": null,

    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     *  @type node
     *  @default null
     */
    "nTableWrapper": null,

    /**
     * Indicate if when using server-side processing the loading of data
     * should be deferred until the second draw.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     *  @default false
     */
    "bDeferLoading": false,

    /**
     * Indicate if all required information has been read in
     *  @type boolean
     *  @default false
     */
    "bInitialised": false,

    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     *  @type array
     *  @default []
     */
    "aoOpenRows": [],

    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sDom": null,

    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default two_button
     */
    "sPaginationType": "two_button",

    /**
     * The cookie duration (for bStateSave) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type int
     *  @default 0
     */
    "iCookieDuration": 0,

    /**
     * The cookie name prefix.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sCookiePrefix": "",

    /**
     * Callback function for cookie creation.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     *  @default null
     */
    "fnCookieCallback": null,

    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateSave": [],

    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateLoad": [],

    /**
     * State that was loaded from the cookie. Useful for back reference
     *  @type object
     *  @default null
     */
    "oLoadedState": null,

    /**
     * Source url for AJAX data for the table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sAjaxSource": null,

    /**
     * Property from a given object from which to read the table data from. This
     * can be an empty string (when not server-side processing), in which case
     * it is  assumed an an array is given directly.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sAjaxDataProp": null,

    /**
     * Note if draw should be blocked while getting data
     *  @type boolean
     *  @default true
     */
    "bAjaxDataGet": true,

    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     *  @type object
     *  @default null
     */
    "jqXHR": null,

    /**
     * Function to get the server-side data.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnServerData": null,

    /**
     * Functions which are called prior to sending an Ajax request so extra
     * parameters can easily be sent to the server
     *  @type array
     *  @default []
     */
    "aoServerParams": [],

    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sServerMethod": null,

    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnFormatNumber": null,

    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aLengthMenu": null,

    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     *  @type int
     *  @default 0
     */
    "iDraw": 0,

    /**
     * Indicate if a redraw is being done - useful for Ajax
     *  @type boolean
     *  @default false
     */
    "bDrawing": false,

    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     *  @type int
     *  @default -1
     */
    "iDrawError": -1,

    /**
     * Paging display length
     *  @type int
     *  @default 10
     */
    "_iDisplayLength": 10,

    /**
     * Paging start point - aiDisplay index
     *  @type int
     *  @default 0
     */
    "_iDisplayStart": 0,

    /**
     * Paging end point - aiDisplay index. Use fnDisplayEnd rather than
     * this property to get the end point
     *  @type int
     *  @default 10
     *  @private
     */
    "_iDisplayEnd": 10,

    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type int
     *  @default 0
     *  @private
     */
    "_iRecordsTotal": 0,

    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type boolean
     *  @default 0
     *  @private
     */
    "_iRecordsDisplay": 0,

    /**
     * Flag to indicate if jQuery UI marking and classes should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bJUI": null,

    /**
     * The classes to use for the table
     *  @type object
     *  @default {}
     */
    "oClasses": {},

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bFiltered": false,

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bSorted": false,

    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bSortCellsTop": null,

    /**
     * Initialisation object that is used for the table
     *  @type object
     *  @default null
     */
    "oInit": null,

    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     *  @type array
     *  @default []
     */
    "aoDestroyCallback": [],


    /**
     * Get the number of records in the current record set, before filtering
     *  @type function
     */
    "fnRecordsTotal": function ()
    {
      if ( this.oFeatures.bServerSide ) {
        return parseInt(this._iRecordsTotal, 10);
      } else {
        return this.aiDisplayMaster.length;
      }
    },

    /**
     * Get the number of records in the current record set, after filtering
     *  @type function
     */
    "fnRecordsDisplay": function ()
    {
      if ( this.oFeatures.bServerSide ) {
        return parseInt(this._iRecordsDisplay, 10);
      } else {
        return this.aiDisplay.length;
      }
    },

    /**
     * Set the display end point - aiDisplay index
     *  @type function
     *  @todo Should do away with _iDisplayEnd and calculate it on-the-fly here
     */
    "fnDisplayEnd": function ()
    {
      if ( this.oFeatures.bServerSide ) {
        if ( this.oFeatures.bPaginate === false || this._iDisplayLength == -1 ) {
          return this._iDisplayStart+this.aiDisplay.length;
        } else {
          return Math.min( this._iDisplayStart+this._iDisplayLength,
            this._iRecordsDisplay );
        }
      } else {
        return this._iDisplayEnd;
      }
    },

    /**
     * The DataTables object for this table
     *  @type object
     *  @default null
     */
    "oInstance": null,

    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     *  @type string
     *  @default null
     */
    "sInstance": null,

    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null
  };

  /**
   * Extension object for DataTables that is used to provide all extension options.
   *
   * Note that the <i>DataTable.ext</i> object is available through
   * <i>jQuery.fn.dataTable.ext</i> where it may be accessed and manipulated. It is
   * also aliased to <i>jQuery.fn.dataTableExt</i> for historic reasons.
   *  @namespace
   *  @extends DataTable.models.ext
   */
  DataTable.ext = $.extend( true, {}, DataTable.models.ext );

  $.extend( DataTable.ext.oStdClasses, {
    "sTable": "dataTable",

    /* Two buttons buttons */
    "sPagePrevEnabled": "paginate_enabled_previous",
    "sPagePrevDisabled": "paginate_disabled_previous",
    "sPageNextEnabled": "paginate_enabled_next",
    "sPageNextDisabled": "paginate_disabled_next",
    "sPageJUINext": "",
    "sPageJUIPrev": "",

    /* Full numbers paging buttons */
    "sPageButton": "paginate_button",
    "sPageButtonActive": "paginate_active",
    "sPageButtonStaticDisabled": "paginate_button paginate_button_disabled",
    "sPageFirst": "first",
    "sPagePrevious": "previous",
    "sPageNext": "next",
    "sPageLast": "last",

    /* Striping classes */
    "sStripeOdd": "odd",
    "sStripeEven": "even",

    /* Empty row */
    "sRowEmpty": "dataTables_empty",

    /* Features */
    "sWrapper": "dataTables_wrapper",
    "sFilter": "dataTables_filter",
    "sInfo": "dataTables_info",
    "sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
    "sLength": "dataTables_length",
    "sProcessing": "dataTables_processing",

    /* Sorting */
    "sSortAsc": "sorting_asc",
    "sSortDesc": "sorting_desc",
    "sSortable": "sorting", /* Sortable in both directions */
    "sSortableAsc": "sorting_asc_disabled",
    "sSortableDesc": "sorting_desc_disabled",
    "sSortableNone": "sorting_disabled",
    "sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
    "sSortJUIAsc": "",
    "sSortJUIDesc": "",
    "sSortJUI": "",
    "sSortJUIAscAllowed": "",
    "sSortJUIDescAllowed": "",
    "sSortJUIWrapper": "",
    "sSortIcon": "",

    /* Scrolling */
    "sScrollWrapper": "dataTables_scroll",
    "sScrollHead": "dataTables_scrollHead",
    "sScrollHeadInner": "dataTables_scrollHeadInner",
    "sScrollBody": "dataTables_scrollBody",
    "sScrollFoot": "dataTables_scrollFoot",
    "sScrollFootInner": "dataTables_scrollFootInner",

    /* Misc */
    "sFooterTH": "",
    "sJUIHeader": "",
    "sJUIFooter": ""
  } );


  $.extend( DataTable.ext.oJUIClasses, DataTable.ext.oStdClasses, {
    /* Two buttons buttons */
    "sPagePrevEnabled": "fg-button ui-button ui-state-default ui-corner-left",
    "sPagePrevDisabled": "fg-button ui-button ui-state-default ui-corner-left ui-state-disabled",
    "sPageNextEnabled": "fg-button ui-button ui-state-default ui-corner-right",
    "sPageNextDisabled": "fg-button ui-button ui-state-default ui-corner-right ui-state-disabled",
    "sPageJUINext": "ui-icon ui-icon-circle-arrow-e",
    "sPageJUIPrev": "ui-icon ui-icon-circle-arrow-w",

    /* Full numbers paging buttons */
    "sPageButton": "fg-button ui-button ui-state-default",
    "sPageButtonActive": "fg-button ui-button ui-state-default ui-state-disabled",
    "sPageButtonStaticDisabled": "fg-button ui-button ui-state-default ui-state-disabled",
    "sPageFirst": "first ui-corner-tl ui-corner-bl",
    "sPageLast": "last ui-corner-tr ui-corner-br",

    /* Features */
    "sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "+
      "ui-buttonset-multi paging_", /* Note that the type is postfixed */

    /* Sorting */
    "sSortAsc": "ui-state-default",
    "sSortDesc": "ui-state-default",
    "sSortable": "ui-state-default",
    "sSortableAsc": "ui-state-default",
    "sSortableDesc": "ui-state-default",
    "sSortableNone": "ui-state-default",
    "sSortJUIAsc": "css_right ui-icon ui-icon-triangle-1-n",
    "sSortJUIDesc": "css_right ui-icon ui-icon-triangle-1-s",
    "sSortJUI": "css_right ui-icon ui-icon-carat-2-n-s",
    "sSortJUIAscAllowed": "css_right ui-icon ui-icon-carat-1-n",
    "sSortJUIDescAllowed": "css_right ui-icon ui-icon-carat-1-s",
    "sSortJUIWrapper": "DataTables_sort_wrapper",
    "sSortIcon": "DataTables_sort_icon",

    /* Scrolling */
    "sScrollHead": "dataTables_scrollHead ui-state-default",
    "sScrollFoot": "dataTables_scrollFoot ui-state-default",

    /* Misc */
    "sFooterTH": "ui-state-default",
    "sJUIHeader": "fg-toolbar ui-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix",
    "sJUIFooter": "fg-toolbar ui-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix"
  } );


  /*
   * Variable: oPagination
   * Purpose:  
   * Scope:    jQuery.fn.dataTableExt
   */
  $.extend( DataTable.ext.oPagination, {
    /*
     * Variable: two_button
     * Purpose:  Standard two button (forward/back) pagination
     * Scope:    jQuery.fn.dataTableExt.oPagination
     */
    "two_button": {
      /*
       * Function: oPagination.two_button.fnInit
       * Purpose:  Initialise dom elements required for pagination with forward/back buttons only
       * Returns:  -
       * Inputs:   object:oSettings - dataTables settings object
       *           node:nPaging - the DIV which contains this pagination control
       *           function:fnCallbackDraw - draw function which must be called on update
       */
      "fnInit": function ( oSettings, nPaging, fnCallbackDraw )
      {
        var oLang = oSettings.oLanguage.oPaginate;
        var oClasses = oSettings.oClasses;
        var fnClickHandler = function ( e ) {
          if ( oSettings.oApi._fnPageChange( oSettings, e.data.action ) )
          {
            fnCallbackDraw( oSettings );
          }
        };

        var sAppend = (!oSettings.bJUI) ?
          '<a class="'+oSettings.oClasses.sPagePrevDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oLang.sPrevious+'</a>'+
            '<a class="'+oSettings.oClasses.sPageNextDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oLang.sNext+'</a>'
          :
          '<a class="'+oSettings.oClasses.sPagePrevDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oSettings.oClasses.sPageJUIPrev+'"></span></a>'+
            '<a class="'+oSettings.oClasses.sPageNextDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oSettings.oClasses.sPageJUINext+'"></span></a>';
        $(nPaging).append( sAppend );

        var els = $('a', nPaging);
        var nPrevious = els[0],
          nNext = els[1];

        oSettings.oApi._fnBindAction( nPrevious, {action: "previous"}, fnClickHandler );
        oSettings.oApi._fnBindAction( nNext,     {action: "next"},     fnClickHandler );

        /* ID the first elements only */
        if ( !oSettings.aanFeatures.p )
        {
          nPaging.id = oSettings.sTableId+'_paginate';
          nPrevious.id = oSettings.sTableId+'_previous';
          nNext.id = oSettings.sTableId+'_next';

          nPrevious.setAttribute('aria-controls', oSettings.sTableId);
          nNext.setAttribute('aria-controls', oSettings.sTableId);
        }
      },

      /*
       * Function: oPagination.two_button.fnUpdate
       * Purpose:  Update the two button pagination at the end of the draw
       * Returns:  -
       * Inputs:   object:oSettings - dataTables settings object
       *           function:fnCallbackDraw - draw function to call on page change
       */
      "fnUpdate": function ( oSettings, fnCallbackDraw )
      {
        if ( !oSettings.aanFeatures.p )
        {
          return;
        }

        var oClasses = oSettings.oClasses;
        var an = oSettings.aanFeatures.p;

        /* Loop over each instance of the pager */
        for ( var i=0, iLen=an.length ; i<iLen ; i++ )
        {
          if ( an[i].childNodes.length !== 0 )
          {
            an[i].childNodes[0].className = ( oSettings._iDisplayStart === 0 ) ?
              oClasses.sPagePrevDisabled : oClasses.sPagePrevEnabled;

            an[i].childNodes[1].className = ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) ?
              oClasses.sPageNextDisabled : oClasses.sPageNextEnabled;
          }
        }
      }
    },


    /*
     * Variable: iFullNumbersShowPages
     * Purpose:  Change the number of pages which can be seen
     * Scope:    jQuery.fn.dataTableExt.oPagination
     */
    "iFullNumbersShowPages": 5,

    /*
     * Variable: full_numbers
     * Purpose:  Full numbers pagination
     * Scope:    jQuery.fn.dataTableExt.oPagination
     */
    "full_numbers": {
      /*
       * Function: oPagination.full_numbers.fnInit
       * Purpose:  Initialise dom elements required for pagination with a list of the pages
       * Returns:  -
       * Inputs:   object:oSettings - dataTables settings object
       *           node:nPaging - the DIV which contains this pagination control
       *           function:fnCallbackDraw - draw function which must be called on update
       */
      "fnInit": function ( oSettings, nPaging, fnCallbackDraw )
      {
        var oLang = oSettings.oLanguage.oPaginate;
        var oClasses = oSettings.oClasses;
        var fnClickHandler = function ( e ) {
          if ( oSettings.oApi._fnPageChange( oSettings, e.data.action ) )
          {
            fnCallbackDraw( oSettings );
          }
        };

        $(nPaging).append(
          '<a  tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPageFirst+'">'+oLang.sFirst+'</a>'+
            '<a  tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPagePrevious+'">'+oLang.sPrevious+'</a>'+
            '<span></span>'+
            '<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPageNext+'">'+oLang.sNext+'</a>'+
            '<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPageLast+'">'+oLang.sLast+'</a>'
        );
        var els = $('a', nPaging);
        var nFirst = els[0],
          nPrev = els[1],
          nNext = els[2],
          nLast = els[3];

        oSettings.oApi._fnBindAction( nFirst, {action: "first"},    fnClickHandler );
        oSettings.oApi._fnBindAction( nPrev,  {action: "previous"}, fnClickHandler );
        oSettings.oApi._fnBindAction( nNext,  {action: "next"},     fnClickHandler );
        oSettings.oApi._fnBindAction( nLast,  {action: "last"},     fnClickHandler );

        /* ID the first elements only */
        if ( !oSettings.aanFeatures.p )
        {
          nPaging.id = oSettings.sTableId+'_paginate';
          nFirst.id =oSettings.sTableId+'_first';
          nPrev.id =oSettings.sTableId+'_previous';
          nNext.id =oSettings.sTableId+'_next';
          nLast.id =oSettings.sTableId+'_last';
        }
      },

      /*
       * Function: oPagination.full_numbers.fnUpdate
       * Purpose:  Update the list of page buttons shows
       * Returns:  -
       * Inputs:   object:oSettings - dataTables settings object
       *           function:fnCallbackDraw - draw function to call on page change
       */
      "fnUpdate": function ( oSettings, fnCallbackDraw )
      {
        if ( !oSettings.aanFeatures.p )
        {
          return;
        }

        var iPageCount = DataTable.ext.oPagination.iFullNumbersShowPages;
        var iPageCountHalf = Math.floor(iPageCount / 2);
        var iPages = Math.ceil((oSettings.fnRecordsDisplay()) / oSettings._iDisplayLength);
        var iCurrentPage = Math.ceil(oSettings._iDisplayStart / oSettings._iDisplayLength) + 1;
        var sList = "";
        var iStartButton, iEndButton, i, iLen;
        var oClasses = oSettings.oClasses;
        var anButtons, anStatic, nPaginateList;
        var an = oSettings.aanFeatures.p;
        var fnBind = function (j) {
          oSettings.oApi._fnBindAction( this, {"page": j+iStartButton-1}, function(e) {
            /* Use the information in the element to jump to the required page */
            oSettings.oApi._fnPageChange( oSettings, e.data.page );
            fnCallbackDraw( oSettings );
            e.preventDefault();
          } );
        };

        /* Pages calculation */
        if ( oSettings._iDisplayLength === -1 )
        {
          iStartButton = 1;
          iEndButton = 1;
          iCurrentPage = 1;
        }
        else if (iPages < iPageCount)
        {
          iStartButton = 1;
          iEndButton = iPages;
        }
        else if (iCurrentPage <= iPageCountHalf)
        {
          iStartButton = 1;
          iEndButton = iPageCount;
        }
        else if (iCurrentPage >= (iPages - iPageCountHalf))
        {
          iStartButton = iPages - iPageCount + 1;
          iEndButton = iPages;
        }
        else
        {
          iStartButton = iCurrentPage - Math.ceil(iPageCount / 2) + 1;
          iEndButton = iStartButton + iPageCount - 1;
        }


        /* Build the dynamic list */
        for ( i=iStartButton ; i<=iEndButton ; i++ )
        {
          sList += (iCurrentPage !== i) ?
            '<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+'">'+oSettings.fnFormatNumber(i)+'</a>' :
            '<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButtonActive+'">'+oSettings.fnFormatNumber(i)+'</a>';
        }

        /* Loop over each instance of the pager */
        for ( i=0, iLen=an.length ; i<iLen ; i++ )
        {
          if ( an[i].childNodes.length === 0 )
          {
            continue;
          }

          /* Build up the dynamic list first - html and listeners */
          $('span:eq(0)', an[i])
            .html( sList )
            .children('a').each( fnBind );

          /* Update the permanent button's classes */
          anButtons = an[i].getElementsByTagName('a');
          anStatic = [
            anButtons[0], anButtons[1],
            anButtons[anButtons.length-2], anButtons[anButtons.length-1]
          ];

          $(anStatic).removeClass( oClasses.sPageButton+" "+oClasses.sPageButtonActive+" "+oClasses.sPageButtonStaticDisabled );
          $([anStatic[0], anStatic[1]]).addClass(
            (iCurrentPage==1) ?
              oClasses.sPageButtonStaticDisabled :
              oClasses.sPageButton
          );
          $([anStatic[2], anStatic[3]]).addClass(
            (iPages===0 || iCurrentPage===iPages || oSettings._iDisplayLength===-1) ?
              oClasses.sPageButtonStaticDisabled :
              oClasses.sPageButton
          );
        }
      }
    }
  } );

  $.extend( DataTable.ext.oSort, {
    /*
     * text sorting
     */
    "string-pre": function ( a )
    {
      if ( typeof a != 'string' ) {
        a = (a !== null && a.toString) ? a.toString() : '';
      }
      return a.toLowerCase();
    },

    "string-asc": function ( x, y )
    {
      return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    },

    "string-desc": function ( x, y )
    {
      return ((x < y) ? 1 : ((x > y) ? -1 : 0));
    },


    /*
     * html sorting (ignore html tags)
     */
    "html-pre": function ( a )
    {
      return a.replace( /<.*?>/g, "" ).toLowerCase();
    },

    "html-asc": function ( x, y )
    {
      return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    },

    "html-desc": function ( x, y )
    {
      return ((x < y) ? 1 : ((x > y) ? -1 : 0));
    },


    /*
     * date sorting
     */
    "date-pre": function ( a )
    {
      var x = Date.parse( a );

      if ( isNaN(x) || x==="" )
      {
        x = Date.parse( "01/01/1970 00:00:00" );
      }
      return x;
    },

    "date-asc": function ( x, y )
    {
      return x - y;
    },

    "date-desc": function ( x, y )
    {
      return y - x;
    },


    /*
     * numerical sorting
     */
    "numeric-pre": function ( a )
    {
      return (a=="-" || a==="") ? 0 : a*1;
    },

    "numeric-asc": function ( x, y )
    {
      return x - y;
    },

    "numeric-desc": function ( x, y )
    {
      return y - x;
    }
  } );


  $.extend( DataTable.ext.aTypes, [
    /*
     * Function: -
     * Purpose:  Check to see if a string is numeric
     * Returns:  string:'numeric' or null
     * Inputs:   mixed:sText - string to check
     */
    function ( sData )
    {
      /* Allow zero length strings as a number */
      if ( typeof sData === 'number' )
      {
        return 'numeric';
      }
      else if ( typeof sData !== 'string' )
      {
        return null;
      }

      var sValidFirstChars = "0123456789-";
      var sValidChars = "0123456789.";
      var Char;
      var bDecimal = false;

      /* Check for a valid first char (no period and allow negatives) */
      Char = sData.charAt(0);
      if (sValidFirstChars.indexOf(Char) == -1)
      {
        return null;
      }

      /* Check all the other characters are valid */
      for ( var i=1 ; i<sData.length ; i++ )
      {
        Char = sData.charAt(i);
        if (sValidChars.indexOf(Char) == -1)
        {
          return null;
        }

        /* Only allowed one decimal place... */
        if ( Char == "." )
        {
          if ( bDecimal )
          {
            return null;
          }
          bDecimal = true;
        }
      }

      return 'numeric';
    },

    /*
     * Function: -
     * Purpose:  Check to see if a string is actually a formatted date
     * Returns:  string:'date' or null
     * Inputs:   string:sText - string to check
     */
    function ( sData )
    {
      var iParse = Date.parse(sData);
      if ( (iParse !== null && !isNaN(iParse)) || (typeof sData === 'string' && sData.length === 0) )
      {
        return 'date';
      }
      return null;
    },

    /*
     * Function: -
     * Purpose:  Check to see if a string should be treated as an HTML string
     * Returns:  string:'html' or null
     * Inputs:   string:sText - string to check
     */
    function ( sData )
    {
      if ( typeof sData === 'string' && sData.indexOf('<') != -1 && sData.indexOf('>') != -1 )
      {
        return 'html';
      }
      return null;
    }
  ] );


  // jQuery aliases
  $.fn.DataTable = DataTable;
  $.fn.dataTable = DataTable;
  $.fn.dataTableSettings = DataTable.settings;
  $.fn.dataTableExt = DataTable.ext;


  // Information about events fired by DataTables - for documentation.
  /**
   * Draw event, fired whenever the table is redrawn on the page, at the same point as
   * fnDrawCallback. This may be useful for binding events or performing calculations when
   * the table is altered at all.
   *  @name DataTable#draw
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Filter event, fired when the filtering applied to the table (using the build in global
   * global filter, or column filters) is altered.
   *  @name DataTable#filter
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page change event, fired when the paging of the table is altered.
   *  @name DataTable#page
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Sort event, fired when the sorting applied to the table is altered.
   *  @name DataTable#sort
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * DataTables initialisation complete event, fired when the table is fully drawn,
   * including Ajax data loaded, if Ajax data is required.
   *  @name DataTable#init
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The JSON object request from the server - only
   *    present if client-side Ajax sourced data is used</li></ol>
   */

  /**
   * State save event, fired when the table has changed state a new state save is required.
   * This method allows modification of the state saving object prior to actually doing the
   * save, including addition or other state properties (for plug-ins) or modification
   * of a DataTables core property.
   *  @name DataTable#stateSaveParams
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The state information to be saved
   */

  /**
   * State load event, fired when the table is loading state from the stored data, but
   * prior to the settings object being modified by the saved state - allowing modification
   * of the saved state is required or loading of state for a plug-in.
   *  @name DataTable#stateLoadParams
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * State loaded event, fired when state has been loaded from stored data and the settings
   * object has been modified by the loaded data.
   *  @name DataTable#stateLoaded
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * Processing event, fired when DataTables is doing some kind of processing (be it,
   * sort, filter or anything else). Can be used to indicate to the end user that
   * there is something happening, or that something has finished.
   *  @name DataTable#processing
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {boolean} bShow Flag for if DataTables is doing processing or not
   */

  /**
   * Ajax (XHR) event, fired whenever an Ajax request is completed from a request to
   * made to the server for new data (note that this trigger is called in fnServerData,
   * if you override fnServerData and which to use this event, you need to trigger it in
   * you success function).
   *  @name DataTable#xhr
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {object} json JSON returned from the server
   */

  /**
   * Destroy event, fired when the DataTable is destroyed by calling fnDestroy or passing
   * the bDestroy:true parameter in the initialisation object. This can be used to remove
   * bound events, added DOM nodes, etc.
   *  @name DataTable#destroy
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */
}(jQuery, window, document, undefined));


// assets/js/bundle/third_party/translate.js
/*
  Helper function to mark messages that should be localized.
  Later it may be changed to retrieve actual translations from somewhere.
  It allows to substitute messages - for example tr("Hi {0}, this is {1}", "Bob", "Jerry"); will return "Hi Bob, this is Jerry"
 */
goog.provide("optly.translate");

/**
 * Returns localized version of a string with parameters substituted.
 * Everything after first argument is considered as substitutions.
 * @param {!string} str -  String to localize
 * @param {...*} substitutions - Substitution parameters
 * @returns {string} Localized string
 */
function tr(str, substitutions) {
  var subs = [].slice.call(arguments, 1);
  return str.replace(/\\*{(\d+)}/g, function(match, number) {
    var slashes = match.substring(0, match.indexOf('{'));
    if(slashes.length == 1) {
      // single slash used to escape curly bracket
      return match.substr(1);
    }
    else if(typeof subs[number] === "undefined") {
      return match;
    }
    return slashes + subs[number];
  });
}

/**
 * Formats date according to current locale settings
 * @param date Date object
 * @returns {String} string with localized date string
 */
tr.date = function(date){
  // Just a placeholder for now
  return date.toString();
};

optly.translate = tr;

// assets/js/bundle/third_party/esprima.js
goog.provide('optly.esprima');

/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
throwErrorTolerant: true,
throwError: true, generateStatement: true, peek: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true, parseParams: true, validateParam: true,
parseUnaryExpression: true,
parseStatement: true, parseSourceElement: true */

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        PropertyKind,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: {
            type: 'ArrowParameterPlaceHolder'
        }
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function skipComment() {
        var ch, start;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code, cu1, cu2;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        // UTF-16 Encoding
        if (code <= 0xFFFF) {
            return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) >> 10) + 0xD800;
        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        switch (code) {

        // Check for most common single-character punctuators.
        case 0x2E:  // . dot
        case 0x28:  // ( open bracket
        case 0x29:  // ) close bracket
        case 0x3B:  // ; semicolon
        case 0x2C:  // , comma
        case 0x7B:  // { open curly brace
        case 0x7D:  // } close curly brace
        case 0x5B:  // [
        case 0x5D:  // ]
        case 0x3A:  // :
        case 0x3F:  // ?
        case 0x7E:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 0x28) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 0x7B) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (U+003D) marks an assignment or comparison operator.
            if (code2 === 0x3D) {
                switch (code) {
                case 0x2B:  // +
                case 0x2D:  // -
                case 0x2F:  // /
                case 0x3C:  // <
                case 0x3E:  // >
                case 0x5E:  // ^
                case 0x7C:  // |
                case 0x25:  // %
                case 0x26:  // &
                case 0x2A:  // *
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };

                case 0x21: // !
                case 0x3D: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 0x3D) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
            }
        }

        // 4-character punctuator: >>>=

        ch4 = source.substr(index, 4);

        if (ch4 === '>>>=') {
            index += 4;
            return {
                type: Token.Punctuator,
                value: ch4,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 3-character punctuators: === !== >>> <<= >>=

        ch3 = ch4.substr(0, 3);

        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: ch3,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||
        ch2 = ch3.substr(0, 2);

        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 1-character punctuators: < > = ! + - * % & | ^ /

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(start) {
        var number = '0' + source[index++];
        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: true,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (isOctalDigit(ch)) {
                    return scanOctalLiteral(start);
                }

                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function testRegExp(pattern, flags) {
        var value;
        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }
        return value;
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError({}, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                } else {
                    str += '\\';
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);

        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        ch = source.charCodeAt(index);

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }


        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && ch === 0x2F) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value;

        skipComment();
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            });
        }

        return token;
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    function Position() {
        this.line = lineNumber;
        this.column = index - lineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        if (startToken.type === Token.StringLiteral) {
            this.start = {
                line: startToken.startLineNumber,
                column: startToken.start - startToken.startLineStart
            };
        } else {
            this.start = {
                line: startToken.lineNumber,
                column: startToken.start - startToken.lineStart
            };
        }
        this.end = null;
    }

    function Node() {
        // Skip comment.
        index = lookahead.start;
        if (lookahead.type === Token.StringLiteral) {
            lineNumber = lookahead.startLineNumber;
            lineStart = lookahead.startLineStart;
        } else {
            lineNumber = lookahead.lineNumber;
            lineStart = lookahead.lineStart;
        }
        if (extra.range) {
            this.range = [index, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                if (extra.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = extra.trailingComments;
                    extra.trailingComments = [];
                } else {
                    extra.trailingComments.length = 0;
                }
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            if (last) {
                while (last && last.range[0] >= this.range[0]) {
                    lastChild = last;
                    last = bottomRight.pop();
                }
            }

            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {
                    this.leadingComments = lastChild.leadingComments;
                    lastChild.leadingComments = undefined;
                }
            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= this.range[0]) {
                this.leadingComments = extra.leadingComments;
                extra.leadingComments = [];
            }


            if (trailingComments) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = index;
            }
            if (extra.loc) {
                this.loc.end = new Position();
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body) {
            this.type = Syntax.Program;
            this.body = body;
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, value) {
            this.type = Syntax.Property;
            this.key = key;
            this.value = value;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = guardedHandlers;
            this.handlers = handlers;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        }
    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.start;
            error.lineNumber = token.lineNumber;
            error.column = token.start - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        error.description = msg;
        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    /**
     * @name expectTolerant
     * @description Quietly expect the given token value when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @param {String} value The value we are expecting the lookahead token to have
     * @since 2.0
     */
    function expectTolerant(value) {
        if (extra.errors) {
            var token = lookahead;
            if (token.type !== Token.Punctuator && token.value !== value) {
                throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
            } else {
                lex();
            }
        } else {
            expect(value);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var line;

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B || match(';')) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], node = new Node();

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body, node = new Node();

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return node.finishFunctionExpression(null, param, [], body);
    }

    function parseObjectPropertyKey() {
        var token, node = new Node();

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key, id, value, param, node = new Node();

        token = lookahead;

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                value = parsePropertyFunction([]);
                return node.finishProperty('get', key, value);
            }
            if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    expect(')');
                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                    value = parsePropertyFunction([]);
                } else {
                    param = [ parseVariableIdentifier() ];
                    expect(')');
                    value = parsePropertyFunction(param, token);
                }
                return node.finishProperty('set', key, value);
            }
            expect(':');
            value = parseAssignmentExpression();
            return node.finishProperty('init', id, value);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            value = parseAssignmentExpression();
            return node.finishProperty('init', key, value);
        }
    }

    function parseObjectInitialiser() {
        var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expectTolerant(',');
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        if (match(')')) {
            lex();
            return PlaceHolders.ArrowParameterPlaceHolder;
        }

        ++state.parenthesisCount;

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            expr =  node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                expr = node.finishThisExpression();
            } else {
                throwUnexpected(lex());
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            if (typeof extra.tokens !== 'undefined') {
                expr = node.finishLiteral(collectRegex());
            } else {
                expr = node.finishLiteral(scanRegExp());
            }
            peek();
        } else {
            throwUnexpected(lex());
        }

        return expr;
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expectTolerant(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return node.finishNewExpression(callee, args);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        for (;;) {
            if (match('.')) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        for (;;) {
            if (match('[')) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else {
                break;
            }
        }
        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = parseLeftHandSideExpressionAllowCall();

        if (lookahead.type === Token.Punctuator) {
            if ((match('++') || match('--')) && !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPostfix);
                }

                if (!isLeftHandSide(expr)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = parseUnaryExpression();
        if (left === PlaceHolders.ArrowParameterPlaceHolder) {
            return left;
        }

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = parseBinaryExpression();
        if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
            return expr;
        }
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // [ES6] 14.2 Arrow Function

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return parseAssignmentExpression();
    }

    function reinterpretAsCoverFormalsList(expressions) {
        var i, len, param, params, defaults, defaultCount, options, rest;

        params = [];
        defaults = [];
        defaultCount = 0;
        rest = null;
        options = {
            paramSet: {}
        };

        for (i = 0, len = expressions.length; i < len; i += 1) {
            param = expressions[i];
            if (param.type === Syntax.Identifier) {
                params.push(param);
                defaults.push(null);
                validateParam(options, param, param.name);
            } else if (param.type === Syntax.AssignmentExpression) {
                params.push(param.left);
                defaults.push(param.right);
                ++defaultCount;
                validateParam(options, param.left, param.left.name);
            } else {
                return null;
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            throwError(
                strict ? options.stricted : options.firstRestricted,
                options.message
            );
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            rest: rest,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, body;

        expect('=>');
        previousStrict = strict;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwError(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            throwErrorTolerant(options.stricted, options.message);
        }

        strict = previousStrict;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var oldParenthesisCount, token, expr, right, list, startToken;

        oldParenthesisCount = state.parenthesisCount;

        startToken = lookahead;
        token = lookahead;

        expr = parseConditionalExpression();

        if (expr === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            if (state.parenthesisCount === oldParenthesisCount ||
                    state.parenthesisCount === (oldParenthesisCount + 1)) {
                if (expr.type === Syntax.Identifier) {
                    list = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.AssignmentExpression) {
                    list = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.SequenceExpression) {
                    list = reinterpretAsCoverFormalsList(expr.expressions);
                } else if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
                    list = reinterpretAsCoverFormalsList([]);
                }
                if (list) {
                    return parseArrowFunctionExpression(list, new WrappingNode(startToken));
                }
            }
        }

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            token = lex();
            right = parseAssignmentExpression();
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = parseAssignmentExpression();

        if (match(',')) {
            expressions = [expr];

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(parseAssignmentExpression());
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token, node = new Node();

        token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration(kind) {
        var init = null, id, node = new Node();

        id = parseVariableIdentifier();

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations, 'var');
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations, node = new Node();

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations, kind);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        var node = new Node();
        expect(';');
        return node.finishEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForVariableDeclaration() {
        var token, declarations, node = new Node();

        token = lex();
        declarations = parseVariableDeclarationList();

        return node.finishVariableDeclaration(declarations, token.value);
    }

    function parseForStatement(node) {
        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = previousAllowIn;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                node.finishForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (peekLineTerminator()) {
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            // TODO(ikarienator): Should we update the test cases instead?
            skipComment();
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead);
        }

        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, [], handlers, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }

        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
            node = new Node();

        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;

        return node.finishBlockStatement(sourceElements);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, def;

        token = lookahead;
        param = parseVariableIdentifier();
        validateParam(options, token, token.value);
        if (match('=')) {
            lex();
            def = parseAssignmentExpression();
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (index < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration() {
        var id, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, node = new Node();

        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionDeclaration(id, params, defaults, body);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node();

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionExpression(id, params, defaults, body);
    }

    // 14 Program

    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            /* istanbul ignore if */
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var body, node;

        skipComment();
        peek();
        node = new Node();
        strict = false;

        body = parseSourceElements();
        return node.finishProgram(body);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            parenthesisCount: 0,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.0.0-dev';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
   /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */


// assets/js/bundle/third_party/jquery/tooltip.js
goog.provide("optly.jquery.tooltip");

goog.require("optly.jquery");

/* ===========================================================
 * bootstrap-tooltip.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */

  var Tooltip = function (element, options) {
    this.init('tooltip', element, options)
  }

  Tooltip.prototype = {

    constructor: Tooltip

  , init: function (type, element, options) {
      var eventIn
        , eventOut
        , triggers
        , trigger
        , i

      this.type = type
      this.$element = $(element)
      this.options = this.getOptions(options)
      this.enabled = true

      triggers = this.options.trigger.split(' ')

      for (i = triggers.length; i--;) {
        trigger = triggers[i]
        if (trigger == 'click') {
          this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
        } else if (trigger != 'manual') {
          eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
          eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
          this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
          this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
        }
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    }

  , getOptions: function (options) {
      options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay
        , hide: options.delay
        }
      }

      return options
    }

  , enter: function (e) {
      var defaults = $.fn[this.type].defaults
        , options = {}
        , self

      this._options && $.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value
      }, this)

      self = $(e.currentTarget)[this.type](options).data(this.type)

      if (!self.options.delay || !self.options.delay.show) return self.show()

      clearTimeout(this.timeout)
      self.hoverState = 'in'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    }

  , leave: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (this.timeout) clearTimeout(this.timeout)
      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.hoverState = 'out'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    }

  , show: function () {
      var $tip
        , pos
        , actualWidth
        , actualHeight
        , placement
        , tp
        , e = $.Event('show')

      if (this.hasContent() && this.enabled) {
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $tip = this.tip()
        this.setContent()

        if (this.options.animation) {
          $tip.addClass('fade')
        }

        /**
         * Added by JZ so the tooltip/popover itself will have a reference back
         * to the original item that triggered it.
         */
        $tip.data(this.type, this);

        placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        $tip
          .detach()
          .css({ top: 0, left: 0, display: 'block' })

        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

        pos = this.getPosition()

        actualWidth = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight

        switch (placement.split(' ')[0]) {
          case 'bottom':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'top':
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'left':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
            break
          case 'right':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
            break
        }

        this.applyPlacement(tp, placement)
        this.$element.trigger('shown')
      }
    }

  , applyPlacement: function(offset, placement){
      var $tip = this.tip()
        , width = $tip[0].offsetWidth
        , height = $tip[0].offsetHeight
        , actualWidth
        , actualHeight
        , delta
        , replace

      $tip
        .offset(offset)
        .addClass(placement)
        .addClass('in')

      actualWidth = $tip[0].offsetWidth
      actualHeight = $tip[0].offsetHeight

      if (placement == 'top' && actualHeight != height) {
        offset.top = offset.top + height - actualHeight
        replace = true
      }

      if (placement == 'bottom' || placement == 'top') {
        delta = 0

        if (offset.left < 0){
          delta = offset.left * -2
          offset.left = 0
          $tip.offset(offset)
          actualWidth = $tip[0].offsetWidth
          actualHeight = $tip[0].offsetHeight
        }

        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
      } else {
        this.replaceArrow(actualHeight - height, actualHeight, 'top')
      }

      if (replace) $tip.offset(offset)
    }

  , replaceArrow: function(delta, dimension, position){
      this
        .arrow()
        .css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
    }

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()

      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    }

  , hide: function () {
      var that = this
        , $tip = this.tip()
        , e = $.Event('hide')

      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return

      $tip.removeClass('in')

      function removeWithAnimation() {
        var timeout = setTimeout(function () {
          $tip.off($.support.transition.end).detach()
        }, 500)

        $tip.one($.support.transition.end, function () {
          clearTimeout(timeout)
          $tip.detach()
        })
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        removeWithAnimation() :
        $tip.detach()

      this.$element.trigger('hidden')

      return this
    }

  , fixTitle: function () {
      var $e = this.$element
      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
      }
    }

  , hasContent: function () {
      return this.getTitle()
    }

  , getPosition: function () {
      var el = this.$element[0]
      return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
        width: el.offsetWidth
      , height: el.offsetHeight
      }, this.$element.offset())
    }

  , getTitle: function () {
      var title
        , $e = this.$element
        , o = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    }

  , tip: function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

  , arrow: function(){
      return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }

  , validate: function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options = null
      }
    }

  , enable: function () {
      this.enabled = true
    }

  , disable: function () {
      this.enabled = false
    }

  , toggleEnabled: function () {
      this.enabled = !this.enabled
    }

  , toggle: function (e) {
      var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
      self.tip().hasClass('in') ? self.hide() : self.show()
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  }


 /* TOOLTIP PLUGIN DEFINITION
  * ========================= */

  var old = $.fn.tooltip

  $.fn.tooltip = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tooltip')
        , options = typeof option == 'object' && option
      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip

  $.fn.tooltip.defaults = {
    animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }


 /* TOOLTIP NO CONFLICT
  * =================== */

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);


// assets/js/shared/custom.js
goog.provide("optly.custom");

/**
 * Try to evaluate code and return any error that is thrown
 * @param {Object} code
 * @return {Object | null}
 */
optly.custom.evalOrError = function(code) {
  var jQuery = "$c";
  var codeType;

  if (window.optimizely && window.optimizely.$) {
    jQuery = "optimizely.$";
  }

  eval("var $ = " + jQuery);
  eval("var $j = $;");
  try {
    for (codeType in code) {
      eval(code[codeType]);
    }
  } catch(e) {
    return optly.custom.getErrorDetails(e, codeType);
  }
  return null;
};

/**
 * Get lineNumber, charNumber for error (only really works for Chrome/Safari)
 * @param {Error} error
 * @param codeType
 * @return {Object}
 */
optly.custom.getErrorDetails = function(error, codeType) {
  var result = {
    codeType: codeType,
    columnNumber: 0,
    errorMessage: error.toString(),
    formattedErrorMessage: '',
    inFunction: '',
    lineNumber: 0
  };

  // Chrome:
  //   error.message: "test is not defined"
  //   error.stack (line 1): "at Object.eval (eval at <anonymous> (https://www.optimizely.test/js/
  //                          devel.779884050243189645/bundle-s/inner.js:66912:10), <anonymous>:21:1)"
  // FF:
  //   error.message: "test is not defined"
  //   error.stack (line 1): "https://www.optimizely.test/js/devel.779884050243189645/bundle-s/inner.js:1396optly.
  //                          custom.evalOrError"
  //   error.lineNumber: 1396
  //   error.columnNumber: 0
  // Safari:
  //   error.message: "Can't find variable: test"
  //   error.stack: "eval@[native code]"
  //   error.line: 21
  // IE:
  //   error.message: "'test' is undefined"
  //   error.stack: "at eval code (eval code:21:1)"

  // Safari
  if (error.line) {
    result.lineNumber = error.line;
  }

  if (error.stack) {
    var stack = error.stack;
    var stackLines = stack.split("\n");
    // top of the stack should be the eval
    var stackTop = stackLines[1];
    var match = stackTop.match(/at (\w+).*:(\d+):(\d+)\)$/);
    if (match) {
      // chrome gives super-detailed errors!
      $.extend(result, {
        inFunction: match[1],
        lineNumber: match[2],
        columnNumber: match[3]
      });
    }
  }
  result.formattedErrorMessage = optly.custom.formatErrorMessage(result);
  return result;
};

/**
 * Format errorDetails object as an error message string
 * @param {Object} errorDetails
 */
optly.custom.formatErrorMessage = function(errorDetails) {
  var errorMessage = errorDetails.errorMessage;
  var errorDescriptions = [];
  if (errorDetails.inFunction && errorDetails.inFunction !== "eval" &&
    errorDetails.inFunction !== "Object") {
    errorDescriptions.push("in function " + errorDetails.inFunction);
  }
  if (errorDetails.lineNumber) {
    errorDescriptions.push("line " + errorDetails.lineNumber);
  }
  if (errorDetails.columnNumber) {
    errorDescriptions.push("col " + errorDetails.columnNumber);
  }
  if (errorDescriptions.length > 0) {
    errorMessage += " (" + errorDescriptions.join(", ") + ")";
  }
  return 'Error evaluating ' + optly.edit.CodeType[errorDetails.codeType].name + ':\n' + errorMessage;
};


// assets/js/bundle/third_party/jquery/metadata.js
goog.provide("optly.jquery.metadata");

goog.require("optly.jquery");

/*
 * Metadata - jQuery plugin for parsing metadata from elements
 *
 * Copyright (c) 2006 John Resig, Yehuda Katz, Jrn Zaefferer, Paul McLanahan
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * Revision: $Id: jquery.metadata.js 3640 2007-10-11 18:34:38Z pmclanahan $
 *
 */

/**
 * Sets the type of metadata to use. Metadata is encoded in JSON, and each property
 * in the JSON will become a property of the element itself.
 *
 * There are four supported types of metadata storage:
 *
 *   attr:  Inside an attribute. The name parameter indicates *which* attribute.
 *
 *   class: Inside the class attribute, wrapped in curly braces: { }
 *
 *   elem:  Inside a child element (e.g. a script tag). The
 *          name parameter indicates *which* element.
 *   html5: Values are stored in data-* attributes.
 *
 * The metadata for an element is loaded the first time the element is accessed via jQuery.
 *
 * As a result, you can define the metadata type, use $(expr) to load the metadata into the elements
 * matched by expr, then redefine the metadata type and run another $(expr) for other elements.
 *
 * @name $.metadata.setType
 *
 * @example <p id="one" class="some_class {item_id: 1, item_label: 'Label'}">This is a p</p>
 * @before $.metadata.setType("class")
 * @after $("#one").metadata().item_id == 1; $("#one").metadata().item_label == "Label"
 * @desc Reads metadata from the class attribute
 *
 * @example <p id="one" class="some_class" data="{item_id: 1, item_label: 'Label'}">This is a p</p>
 * @before $.metadata.setType("attr", "data")
 * @after $("#one").metadata().item_id == 1; $("#one").metadata().item_label == "Label"
 * @desc Reads metadata from a "data" attribute
 *
 * @example <p id="one" class="some_class"><script>{item_id: 1, item_label: 'Label'}</script>This is a p</p>
 * @before $.metadata.setType("elem", "script")
 * @after $("#one").metadata().item_id == 1; $("#one").metadata().item_label == "Label"
 * @desc Reads metadata from a nested script element
 *
 * @example <p id="one" class="some_class" data-item_id="1" data-item_label="Label">This is a p</p>
 * @before $.metadata.setType("html5")
 * @after $("#one").metadata().item_id == 1; $("#one").metadata().item_label == "Label"
 * @desc Reads metadata from a series of data-* attributes
 *
 * @param String type The encoding type
 * @param String name The name of the attribute to be used to get metadata (optional)
 * @cat Plugins/Metadata
 * @descr Sets the type of encoding to be used when loading metadata for the first time
 * @type undefined
 * @see metadata()
 */

(function($) {

$.extend({
  metadata : {
    defaults : {
      type: 'class',
      name: 'metadata',
      cre: /({.*})/,
      single: 'metadata'
    },
    setType: function( type, name ){
      this.defaults.type = type;
      this.defaults.name = name;
    },
    get: function( elem, opts ){
      var settings = $.extend({},this.defaults,opts);
      // check for empty string in single property
      if ( !settings.single.length ) settings.single = 'metadata';

      var data = $.data(elem, settings.single);
      // returned cached data if it already exists
      if ( data ) return data;

      data = "{}";

      var getData = function(data) {
        if(typeof data != "string") return data;

        if( data.indexOf('{') < 0 ) {
          data = eval("(" + data + ")");
        }
      }

      var getObject = function(data) {
        if(typeof data != "string") return data;

        data = eval("(" + data + ")");
        return data;
      }

      if ( settings.type == "html5" ) {
        var object = {};
        $( elem.attributes ).each(function() {
          var name = this.nodeName;
          if(name.match(/^data-/)) name = name.replace(/^data-/, '');
          else return true;
          object[name] = getObject(this.nodeValue);
        });
      } else {
        if ( settings.type == "class" ) {
          var m = settings.cre.exec( elem.className );
          if ( m )
            data = m[1];
        } else if ( settings.type == "elem" ) {
          if( !elem.getElementsByTagName ) return;
          var e = elem.getElementsByTagName(settings.name);
          if ( e.length )
            data = $.trim(e[0].innerHTML);
        } else if ( elem.getAttribute != undefined ) {
          var attr = elem.getAttribute( settings.name );
          if ( attr )
            data = attr;
        }
        object = getObject(data.indexOf("{") < 0 ? "{" + data + "}" : data);
      }

      $.data( elem, settings.single, object );
      return object;
    }
  }
});

/**
 * Returns the metadata object for the first member of the jQuery object.
 *
 * @name metadata
 * @descr Returns element's metadata object
 * @param Object opts An object contianing settings to override the defaults
 * @type jQuery
 * @cat Plugins/Metadata
 */
$.fn.metadata = function( opts ){
  return $.metadata.get( this[0], opts );
};

})(jQuery);


// assets/js/bundle/third_party/jquery/form.js
goog.provide("optly.jquery.form");

goog.require("optly.jquery");

/*!
 * jQuery Form Plugin
 * version: 2.83 (11-JUL-2011)
 * @requires jQuery v1.3.2 or later
 *
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */
;(function($) {

/*
  Usage Note:
  -----------
  Do not use both ajaxSubmit and ajaxForm on the same form.  These
  functions are intended to be exclusive.  Use ajaxSubmit if you want
  to bind your own submit handler to the form.  For example,

  $(document).ready(function() {
    $('#myForm').bind('submit', function(e) {
      e.preventDefault(); // <-- important
      $(this).ajaxSubmit({
        target: '#output'
      });
    });
  });

  Use ajaxForm when you want the plugin to manage all the event binding
  for you.  For example,

  $(document).ready(function() {
    $('#myForm').ajaxForm({
      target: '#output'
    });
  });

  When using ajaxForm, the ajaxSubmit function will be invoked for you
  at the appropriate time.
*/

/**
 * ajaxSubmit() provides a mechanism for immediately submitting
 * an HTML form using AJAX.
 */
$.fn.ajaxSubmit = function(options) {
  // fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
  if (!this.length) {
    log('ajaxSubmit: skipping submit process - no element selected');
    return this;
  }

  var method, action, url, $form = this;

  if (typeof options == 'function') {
    options = { success: options };
  }

  method = this.attr('method');
  action = this.attr('action');
  url = (typeof action === 'string') ? $.trim(action) : '';
  url = url || window.location.href || '';
  if (url) {
    // clean url (don't include hash vaue)
    url = (url.match(/^([^#]+)/)||[])[1];
  }

  options = $.extend(true, {
    url:  url,
    success: $.ajaxSettings.success,
    type: method || 'GET',
    iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
  }, options);

  // hook for manipulating the form data before it is extracted;
  // convenient for use with rich editors like tinyMCE or FCKEditor
  var veto = {};
  this.trigger('form-pre-serialize', [this, options, veto]);
  if (veto.veto) {
    log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
    return this;
  }

  // provide opportunity to alter form data before it is serialized
  if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
    log('ajaxSubmit: submit aborted via beforeSerialize callback');
    return this;
  }

  var n,v,a = this.formToArray(options.semantic);
  if (options.data) {
    options.extraData = options.data;
    for (n in options.data) {
      if(options.data[n] instanceof Array) {
        for (var k in options.data[n]) {
          a.push( { name: n, value: options.data[n][k] } );
        }
      }
      else {
        v = options.data[n];
        v = $.isFunction(v) ? v() : v; // if value is fn, invoke it
        a.push( { name: n, value: v } );
      }
    }
  }

  // give pre-submit callback an opportunity to abort the submit
  if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
    log('ajaxSubmit: submit aborted via beforeSubmit callback');
    return this;
  }

  // fire vetoable 'validate' event
  this.trigger('form-submit-validate', [a, this, options, veto]);
  if (veto.veto) {
    log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
    return this;
  }

  var q = $.param(a);

  if (options.type.toUpperCase() == 'GET') {
    options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
    options.data = null;  // data is null for 'get'
  }
  else {
    options.data = q; // data is the query string for 'post'
  }

  var callbacks = [];
  if (options.resetForm) {
    callbacks.push(function() { $form.resetForm(); });
  }
  if (options.clearForm) {
    callbacks.push(function() { $form.clearForm(); });
  }

  // perform a load on the target only if dataType is not provided
  if (!options.dataType && options.target) {
    var oldSuccess = options.success || function(){};
    callbacks.push(function(data) {
      var fn = options.replaceTarget ? 'replaceWith' : 'html';
      $(options.target)[fn](data).each(oldSuccess, arguments);
    });
  }
  else if (options.success) {
    callbacks.push(options.success);
  }

  options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
    var context = options.context || options;   // jQuery 1.4+ supports scope context
    for (var i=0, max=callbacks.length; i < max; i++) {
      callbacks[i].apply(context, [data, status, xhr || $form, $form]);
    }
  };

  // are there files to upload?
  var fileInputs = $('input:file', this).length > 0;
  var mp = 'multipart/form-data';
  var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);

  // options.iframe allows user to force iframe mode
  // 06-NOV-09: now defaulting to iframe mode if file input is detected
   if (options.iframe !== false && (fileInputs || options.iframe || multipart)) {
     // hack to fix Safari hang (thanks to Tim Molendijk for this)
     // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
     if (options.closeKeepAlive) {
       $.get(options.closeKeepAlive, function() { fileUpload(a); });
    }
     else {
       fileUpload(a);
    }
   }
   else {
    // IE7 massage (see issue 57)
    if ($.browser.msie && method == 'get') {
      var ieMeth = $form[0].getAttribute('method');
      if (typeof ieMeth === 'string')
        options.type = ieMeth;
    }
    $.ajax(options);
   }

  // fire 'notify' event
  this.trigger('form-submit-notify', [this, options]);
  return this;


  // private function for handling file uploads (hat tip to YAHOO!)
  function fileUpload(a) {
    var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
        var useProp = !!$.fn.prop;

        if (a) {
          // ensure that every serialized input is still enabled
            for (i=0; i < a.length; i++) {
                el = $(form[a[i].name]);
                el[ useProp ? 'prop' : 'attr' ]('disabled', false);
            }
        }

    if ($(':input[name=submit],:input[id=submit]', form).length) {
      // if there is an input with a name or id of 'submit' then we won't be
      // able to invoke the submit fn on the form (at least not x-browser)
      alert('Error: Form elements must not have name or id of "submit".');
      return;
    }

    s = $.extend(true, {}, $.ajaxSettings, options);
    s.context = s.context || s;
    id = 'jqFormIO' + (new Date().getTime());
    if (s.iframeTarget) {
      $io = $(s.iframeTarget);
      n = $io.attr('name');
      if (n == null)
        $io.attr('name', id);
      else
        id = n;
    }
    else {
      $io = $('<iframe name="' + id + '" src="'+ s.iframeSrc +'" />');
      $io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
    }
    io = $io[0];


    xhr = { // mock object
      aborted: 0,
      responseText: null,
      responseXML: null,
      status: 0,
      statusText: 'n/a',
      getAllResponseHeaders: function() {},
      getResponseHeader: function() {},
      setRequestHeader: function() {},
      abort: function(status) {
        var e = (status === 'timeout' ? 'timeout' : 'aborted');
        log('aborting upload... ' + e);
        this.aborted = 1;
        $io.attr('src', s.iframeSrc); // abort op in progress
        xhr.error = e;
        s.error && s.error.call(s.context, xhr, e, status);
        g && $.event.trigger("ajaxError", [xhr, s, e]);
        s.complete && s.complete.call(s.context, xhr, e);
      }
    };

    g = s.global;
    // trigger ajax global events so that activity/block indicators work like normal
    if (g && ! $.active++) {
      $.event.trigger("ajaxStart");
    }
    if (g) {
      $.event.trigger("ajaxSend", [xhr, s]);
    }

    if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
      if (s.global) {
        $.active--;
      }
      return;
    }
    if (xhr.aborted) {
      return;
    }

    // add submitting element to data if we know it
    sub = form.clk;
    if (sub) {
      n = sub.name;
      if (n && !sub.disabled) {
        s.extraData = s.extraData || {};
        s.extraData[n] = sub.value;
        if (sub.type == "image") {
          s.extraData[n+'.x'] = form.clk_x;
          s.extraData[n+'.y'] = form.clk_y;
        }
      }
    }

    var CLIENT_TIMEOUT_ABORT = 1;
    var SERVER_ABORT = 2;

    function getDoc(frame) {
      var doc = frame.contentWindow ? frame.contentWindow.document : frame.contentDocument ? frame.contentDocument : frame.document;
      return doc;
    }

    // take a breath so that pending repaints get some cpu time before the upload starts
    function doSubmit() {
      // make sure form attrs are set
      var t = $form.attr('target'), a = $form.attr('action');

      // update form attrs in IE friendly way
      form.setAttribute('target',id);
      if (!method) {
        form.setAttribute('method', 'POST');
      }
      if (a != s.url) {
        form.setAttribute('action', s.url);
      }

      // ie borks in some cases when setting encoding
      if (! s.skipEncodingOverride && (!method || /post/i.test(method))) {
        $form.attr({
          encoding: 'multipart/form-data',
          enctype:  'multipart/form-data'
        });
      }

      // support timout
      if (s.timeout) {
        timeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);
      }

      // look for server aborts
      function checkState() {
        try {
          var state = getDoc(io).readyState;
          log('state = ' + state);
          if (state.toLowerCase() == 'uninitialized')
            setTimeout(checkState,50);
        }
        catch(e) {
          log('Server abort: ' , e, ' (', e.name, ')');
          cb(SERVER_ABORT);
          timeoutHandle && clearTimeout(timeoutHandle);
          timeoutHandle = undefined;
        }
      }

      // add "extra" data to form if provided in options
      var extraInputs = [];
      try {
        if (s.extraData) {
          for (var n in s.extraData) {
            extraInputs.push(
              $('<input type="hidden" name="'+n+'" />').attr('value',s.extraData[n])
                .appendTo(form)[0]);
          }
        }

        if (!s.iframeTarget) {
          // add iframe to doc and submit the form
          $io.appendTo('body');
                  io.attachEvent ? io.attachEvent('onload', cb) : io.addEventListener('load', cb, false);
        }
        setTimeout(checkState,15);
        form.submit();
      }
      finally {
        // reset attrs and remove "extra" input elements
        form.setAttribute('action',a);
        if(t) {
          form.setAttribute('target', t);
        } else {
          $form.removeAttr('target');
        }
        $(extraInputs).remove();
      }
    }

    if (s.forceSync) {
      doSubmit();
    }
    else {
      setTimeout(doSubmit, 10); // this lets dom updates render
    }

    var data, doc, domCheckCount = 50, callbackProcessed;

    function cb(e) {
      if (xhr.aborted || callbackProcessed) {
        return;
      }
      try {
        doc = getDoc(io);
      }
      catch(ex) {
        log('cannot access response document: ', ex);
        e = SERVER_ABORT;
      }
      if (e === CLIENT_TIMEOUT_ABORT && xhr) {
        xhr.abort('timeout');
        return;
      }
      else if (e == SERVER_ABORT && xhr) {
        xhr.abort('server abort');
        return;
      }

      if (!doc || doc.location.href == s.iframeSrc) {
        // response not received yet
        if (!timedOut)
          return;
      }
            io.detachEvent ? io.detachEvent('onload', cb) : io.removeEventListener('load', cb, false);

      var status = 'success', errMsg;
      try {
        if (timedOut) {
          throw 'timeout';
        }

        var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
        log('isXml='+isXml);
        if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
          if (--domCheckCount) {
            // in some browsers (Opera) the iframe DOM is not always traversable when
            // the onload callback fires, so we loop a bit to accommodate
            log('requeing onLoad callback, DOM not available');
            setTimeout(cb, 250);
            return;
          }
          // let this fall through because server response could be an empty document
          //log('Could not access iframe DOM after mutiple tries.');
          //throw 'DOMException: not available';
        }

        //log('response detected');
                var docRoot = doc.body ? doc.body : doc.documentElement;
                xhr.responseText = docRoot ? docRoot.innerHTML : null;
        xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
        if (isXml)
          s.dataType = 'xml';
        xhr.getResponseHeader = function(header){
          var headers = {'content-type': s.dataType};
          return headers[header];
        };
                // support for XHR 'status' & 'statusText' emulation :
                if (docRoot) {
                    xhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;
                    xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;
                }

        var dt = s.dataType || '';
        var scr = /(json|script|text)/.test(dt.toLowerCase());
        if (scr || s.textarea) {
          // see if user embedded response in textarea
          var ta = doc.getElementsByTagName('textarea')[0];
          if (ta) {
            xhr.responseText = ta.value;
                        // support for XHR 'status' & 'statusText' emulation :
                        xhr.status = Number( ta.getAttribute('status') ) || xhr.status;
                        xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;
          }
          else if (scr) {
            // account for browsers injecting pre around json response
            var pre = doc.getElementsByTagName('pre')[0];
            var b = doc.getElementsByTagName('body')[0];
            if (pre) {
              xhr.responseText = pre.textContent ? pre.textContent : pre.innerHTML;
            }
            else if (b) {
              xhr.responseText = b.innerHTML;
            }
          }
        }
        else if (s.dataType == 'xml' && !xhr.responseXML && xhr.responseText != null) {
          xhr.responseXML = toXml(xhr.responseText);
        }

                try {
                    data = httpData(xhr, s.dataType, s);
                }
                catch (e) {
                    status = 'parsererror';
                    xhr.error = errMsg = (e || status);
                }
      }
      catch (e) {
        log('error caught: ',e);
        status = 'error';
                xhr.error = errMsg = (e || status);
      }

      if (xhr.aborted) {
        log('upload aborted');
        status = null;
      }

            if (xhr.status) { // we've set xhr.status
                status = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';
            }

      // ordering of these callbacks/triggers is odd, but that's how $.ajax does it
      if (status === 'success') {
        s.success && s.success.call(s.context, data, 'success', xhr);
        g && $.event.trigger("ajaxSuccess", [xhr, s]);
      }
            else if (status) {
        if (errMsg == undefined)
          errMsg = xhr.statusText;
        s.error && s.error.call(s.context, xhr, status, errMsg);
        g && $.event.trigger("ajaxError", [xhr, s, errMsg]);
            }

      g && $.event.trigger("ajaxComplete", [xhr, s]);

      if (g && ! --$.active) {
        $.event.trigger("ajaxStop");
      }

      s.complete && s.complete.call(s.context, xhr, status);

      callbackProcessed = true;
      if (s.timeout)
        clearTimeout(timeoutHandle);

      // clean up
      setTimeout(function() {
        if (!s.iframeTarget)
          $io.remove();
        xhr.responseXML = null;
      }, 100);
    }

    var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
      if (window.ActiveXObject) {
        doc = new ActiveXObject('Microsoft.XMLDOM');
        doc.async = 'false';
        doc.loadXML(s);
      }
      else {
        doc = (new DOMParser()).parseFromString(s, 'text/xml');
      }
      return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;
    };
    var parseJSON = $.parseJSON || function(s) {
      return window['eval']('(' + s + ')');
    };

    var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4

      var ct = xhr.getResponseHeader('content-type') || '',
        xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,
        data = xml ? xhr.responseXML : xhr.responseText;

      if (xml && data.documentElement.nodeName === 'parsererror') {
        $.error && $.error('parsererror');
      }
      if (s && s.dataFilter) {
        data = s.dataFilter(data, type);
      }
      if (typeof data === 'string') {
        if (type === 'json' || !type && ct.indexOf('json') >= 0) {
          data = parseJSON(data);
        } else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
          $.globalEval(data);
        }
      }
      return data;
    };
  }
};

/**
 * ajaxForm() provides a mechanism for fully automating form submission.
 *
 * The advantages of using this method instead of ajaxSubmit() are:
 *
 * 1: This method will include coordinates for <input type="image" /> elements (if the element
 *  is used to submit the form).
 * 2. This method will include the submit element's name/value data (for the element that was
 *  used to submit the form).
 * 3. This method binds the submit() method to the form for you.
 *
 * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
 * passes the options argument along after properly binding events for submit elements and
 * the form itself.
 */
$.fn.ajaxForm = function(options) {
  // in jQuery 1.3+ we can fix mistakes with the ready state
  if (this.length === 0) {
    var o = { s: this.selector, c: this.context };
    if (!$.isReady && o.s) {
      log('DOM not ready, queuing ajaxForm');
      $(function() {
        $(o.s,o.c).ajaxForm(options);
      });
      return this;
    }
    // is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
    log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
    return this;
  }

  return this.ajaxFormUnbind().bind('submit.form-plugin', function(e) {
    if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
      e.preventDefault();
      $(this).ajaxSubmit(options);
    }
  }).bind('click.form-plugin', function(e) {
    var target = e.target;
    var $el = $(target);
    if (!($el.is(":submit,input:image"))) {
      // is this a child element of the submit el?  (ex: a span within a button)
      var t = $el.closest(':submit');
      if (t.length == 0) {
        return;
      }
      target = t[0];
    }
    var form = this;
    form.clk = target;
    if (target.type == 'image') {
      if (e.offsetX != undefined) {
        form.clk_x = e.offsetX;
        form.clk_y = e.offsetY;
      } else if (typeof $.fn.offset == 'function') { // try to use dimensions plugin
        var offset = $el.offset();
        form.clk_x = e.pageX - offset.left;
        form.clk_y = e.pageY - offset.top;
      } else {
        form.clk_x = e.pageX - target.offsetLeft;
        form.clk_y = e.pageY - target.offsetTop;
      }
    }
    // clear form vars
    setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
  });
};

// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
  return this.unbind('submit.form-plugin click.form-plugin');
};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.
 * Each object in the array has both a 'name' and 'value' property.  An example of
 * an array for a simple login form might be:
 *
 * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
 *
 * It is this array that is passed to pre-submit callback functions provided to the
 * ajaxSubmit() and ajaxForm() methods.
 */
$.fn.formToArray = function(semantic) {
  var a = [];
  if (this.length === 0) {
    return a;
  }

  var form = this[0];
  var els = semantic ? form.getElementsByTagName('*') : form.elements;
  if (!els) {
    return a;
  }

  var i,j,n,v,el,max,jmax;
  for(i=0, max=els.length; i < max; i++) {
    el = els[i];
    n = el.name;
    if (!n) {
      continue;
    }

    if (semantic && form.clk && el.type == "image") {
      // handle image inputs on the fly when semantic == true
      if(!el.disabled && form.clk == el) {
        a.push({name: n, value: $(el).val()});
        a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
      }
      continue;
    }

    v = $.fieldValue(el, true);
    if (v && v.constructor == Array) {
      for(j=0, jmax=v.length; j < jmax; j++) {
        a.push({name: n, value: v[j]});
      }
    }
    else if (v !== null && typeof v != 'undefined') {
      a.push({name: n, value: v});
    }
  }

  if (!semantic && form.clk) {
    // input type=='image' are not found in elements array! handle it here
    var $input = $(form.clk), input = $input[0];
    n = input.name;
    if (n && !input.disabled && input.type == 'image') {
      a.push({name: n, value: $input.val()});
      a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
    }
  }
  return a;
};

/**
 * Serializes form data into a 'submittable' string. This method will return a string
 * in the format: name1=value1&amp;name2=value2
 */
$.fn.formSerialize = function(semantic) {
  //hand off to jQuery.param for proper encoding
  return $.param(this.formToArray(semantic));
};

/**
 * Serializes all field elements in the jQuery object into a query string.
 * This method will return a string in the format: name1=value1&amp;name2=value2
 */
$.fn.fieldSerialize = function(successful) {
  var a = [];
  this.each(function() {
    var n = this.name;
    if (!n) {
      return;
    }
    var v = $.fieldValue(this, successful);
    if (v && v.constructor == Array) {
      for (var i=0,max=v.length; i < max; i++) {
        a.push({name: n, value: v[i]});
      }
    }
    else if (v !== null && typeof v != 'undefined') {
      a.push({name: this.name, value: v});
    }
  });
  //hand off to jQuery.param for proper encoding
  return $.param(a);
};

/**
 * Returns the value(s) of the element in the matched set.  For example, consider the following form:
 *
 *  <form><fieldset>
 *    <input name="A" type="text" />
 *    <input name="A" type="text" />
 *    <input name="B" type="checkbox" value="B1" />
 *    <input name="B" type="checkbox" value="B2"/>
 *    <input name="C" type="radio" value="C1" />
 *    <input name="C" type="radio" value="C2" />
 *  </fieldset></form>
 *
 *  var v = $(':text').fieldValue();
 *  // if no values are entered into the text inputs
 *  v == ['','']
 *  // if values entered into the text inputs are 'foo' and 'bar'
 *  v == ['foo','bar']
 *
 *  var v = $(':checkbox').fieldValue();
 *  // if neither checkbox is checked
 *  v === undefined
 *  // if both checkboxes are checked
 *  v == ['B1', 'B2']
 *
 *  var v = $(':radio').fieldValue();
 *  // if neither radio is checked
 *  v === undefined
 *  // if first radio is checked
 *  v == ['C1']
 *
 * The successful argument controls whether or not the field element must be 'successful'
 * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
 * The default value of the successful argument is true.  If this value is false the value(s)
 * for each element is returned.
 *
 * Note: This method *always* returns an array.  If no valid value can be determined the
 *     array will be empty, otherwise it will contain one or more values.
 */
$.fn.fieldValue = function(successful) {
  for (var val=[], i=0, max=this.length; i < max; i++) {
    var el = this[i];
    var v = $.fieldValue(el, successful);
    if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
      continue;
    }
    v.constructor == Array ? $.merge(val, v) : val.push(v);
  }
  return val;
};

/**
 * Returns the value of the field element.
 */
$.fieldValue = function(el, successful) {
  var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
  if (successful === undefined) {
    successful = true;
  }

  if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
    (t == 'checkbox' || t == 'radio') && !el.checked ||
    (t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
    tag == 'select' && el.selectedIndex == -1)) {
      return null;
  }

  if (tag == 'select') {
    var index = el.selectedIndex;
    if (index < 0) {
      return null;
    }
    var a = [], ops = el.options;
    var one = (t == 'select-one');
    var max = (one ? index+1 : ops.length);
    for(var i=(one ? index : 0); i < max; i++) {
      var op = ops[i];
      if (op.selected) {
        var v = op.value;
        if (!v) { // extra pain for IE...
          v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
        }
        if (one) {
          return v;
        }
        a.push(v);
      }
    }
    return a;
  }
  return $(el).val();
};

/**
 * Clears the form data.  Takes the following actions on the form's input fields:
 *  - input text fields will have their 'value' property set to the empty string
 *  - select elements will have their 'selectedIndex' property set to -1
 *  - checkbox and radio inputs will have their 'checked' property set to false
 *  - inputs of type submit, button, reset, and hidden will *not* be effected
 *  - button elements will *not* be effected
 */
$.fn.clearForm = function() {
  return this.each(function() {
    $('input,select,textarea', this).clearFields();
  });
};

/**
 * Clears the selected form elements.
 */
$.fn.clearFields = $.fn.clearInputs = function() {
  var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list
  return this.each(function() {
    var t = this.type, tag = this.tagName.toLowerCase();
    if (re.test(t) || tag == 'textarea') {
      this.value = '';
    }
    else if (t == 'checkbox' || t == 'radio') {
      this.checked = false;
    }
    else if (tag == 'select') {
      this.selectedIndex = -1;
    }
  });
};

/**
 * Resets the form data.  Causes all form elements to be reset to their original value.
 */
$.fn.resetForm = function() {
  return this.each(function() {
    // guard against an input with the name of 'reset'
    // note that IE reports the reset function as an 'object'
    if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
      this.reset();
    }
  });
};

/**
 * Enables or disables any matching elements.
 */
$.fn.enable = function(b) {
  if (b === undefined) {
    b = true;
  }
  return this.each(function() {
    this.disabled = !b;
  });
};

/**
 * Checks/unchecks any matching checkboxes or radio buttons and
 * selects/deselects and matching option elements.
 */
$.fn.selected = function(select) {
  if (select === undefined) {
    select = true;
  }
  return this.each(function() {
    var t = this.type;
    if (t == 'checkbox' || t == 'radio') {
      this.checked = select;
    }
    else if (this.tagName.toLowerCase() == 'option') {
      var $sel = $(this).parent('select');
      if (select && $sel[0] && $sel[0].type == 'select-one') {
        // deselect all other options
        $sel.find('option').selected(false);
      }
      this.selected = select;
    }
  });
};

// ekim: Use log() from common/main.js

// helper fn for console logging
//function log() {
//  var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
//  if (window.console && window.console.log) {
//    window.console.log(msg);
//  }
//  else if (window.opera && window.opera.postError) {
//    window.opera.postError(msg);
//  }
//};

})(jQuery);


// assets/js/bundle/third_party/jquery/FixedColumns.js
goog.provide("optly.jquery.FixedColumns");

goog.require("optly.jquery");

/**
 * @summary     FixedColumns
 * @description Freeze columns in place on a scrolling DataTable
 * @file        FixedColumns.js
 * @version     2.0.3
 * @author      Allan Jardine (www.sprymedia.co.uk)
 * @license     GPL v2 or BSD 3 point style
 * @contact     www.sprymedia.co.uk/contact
 *
 * @copyright Copyright 2010-2011 Allan Jardine, all rights reserved.
 *
 * This source file is free software, under either the GPL v2 license or a
 * BSD style license, available at:
 *   http://datatables.net/license_gpl2
 *   http://datatables.net/license_bsd
 */


/* Global scope for FixedColumns */
var FixedColumns;

(function($, window, document) {


/** 
 * When making use of DataTables' x-axis scrolling feature, you may wish to 
 * fix the left most column in place. This plug-in for DataTables provides 
 * exactly this option (note for non-scrolling tables, please use the  
 * FixedHeader plug-in, which can fix headers, footers and columns). Key 
 * features include:
 *   <ul class="limit_length">
 *     <li>Freezes the left or right most columns to the side of the table</li>
 *     <li>Option to freeze two or more columns</li>
 *     <li>Full integration with DataTables' scrolling options</li>
 *     <li>Speed - FixedColumns is fast in its operation</li>
 *   </ul>
 *
 *  @class
 *  @constructor
 *  @param {object} oDT DataTables instance
 *  @param {object} [oInit={}] Configuration object for FixedColumns. Options are defined by {@link FixedColumns.defaults}
 * 
 *  @requires jQuery 1.3+
 *  @requires DataTables 1.8.0+
 * 
 *  @example
 *  	var oTable = $('#example').dataTable( {
 *  		"sScrollX": "100%"
 *  	} );
 *  	new FixedColumns( oTable );
 */
FixedColumns = function ( oDT, oInit ) {
	/* Sanity check - you just know it will happen */
	if ( ! this instanceof FixedColumns )
	{
		alert( "FixedColumns warning: FixedColumns must be initialised with the 'new' keyword." );
		return;
	}
	
	if ( typeof oInit == 'undefined' )
	{
		oInit = {};
	}
	
	/**
	 * Settings object which contains customisable information for FixedColumns instance
	 * @namespace
	 * @extends FixedColumns.defaults
	 */
	this.s = {
		/** 
		 * DataTables settings objects
		 *  @type     object
		 *  @default  Obtained from DataTables instance
		 */
		"dt": oDT.fnSettings(),
		
		/** 
		 * Number of columns in the DataTable - stored for quick access
		 *  @type     int
		 *  @default  Obtained from DataTables instance
		 */
		"iTableColumns": oDT.fnSettings().aoColumns.length,
		
		/** 
		 * Original widths of the columns as rendered by DataTables
		 *  @type     array.<int>
		 *  @default  []
		 */
		"aiWidths": [],
		
		/** 
		 * Flag to indicate if we are dealing with IE6/7 as these browsers need a little hack
		 * in the odd place
		 *  @type     boolean
		 *  @default  Automatically calculated
		 *  @readonly
		 */
		"bOldIE": ($.browser.msie && ($.browser.version == "6.0" || $.browser.version == "7.0"))
	};
	
	
	/**
	 * DOM elements used by the class instance
	 * @namespace
	 * 
	 */
	this.dom = {
		/**
		 * DataTables scrolling element
		 *  @type     node
		 *  @default  null
		 */
		"scroller": null,
		
		/**
		 * DataTables header table
		 *  @type     node
		 *  @default  null
		 */
		"header": null,
		
		/**
		 * DataTables body table
		 *  @type     node
		 *  @default  null
		 */
		"body": null,
		
		/**
		 * DataTables footer table
		 *  @type     node
		 *  @default  null
		 */
		"footer": null,

		/**
		 * Display grid elements
		 * @namespace
		 */
		"grid": {
			/**
			 * Grid wrapper. This is the container element for the 3x3 grid
			 *  @type     node
			 *  @default  null
			 */
			"wrapper": null,

			/**
			 * DataTables scrolling element. This element is the DataTables
			 * component in the display grid (making up the main table - i.e.
			 * not the fixed columns).
			 *  @type     node
			 *  @default  null
			 */
			"dt": null,

			/**
			 * Left fixed column grid components
			 * @namespace
			 */
			"left": {
				"wrapper": null,
				"head": null,
				"body": null,
				"foot": null
			},

			/**
			 * Right fixed column grid components
			 * @namespace
			 */
			"right": {
				"wrapper": null,
				"head": null,
				"body": null,
				"foot": null
			}
		},
		
		/**
		 * Cloned table nodes
		 * @namespace
		 */
		"clone": {
			/**
			 * Left column cloned table nodes
			 * @namespace
			 */
			"left": {
				/**
				 * Cloned header table
				 *  @type     node
				 *  @default  null
				 */
				"header": null,
		  	
				/**
				 * Cloned body table
				 *  @type     node
				 *  @default  null
				 */
				"body": null,
		  	
				/**
				 * Cloned footer table
				 *  @type     node
				 *  @default  null
				 */
				"footer": null
			},
			
			/**
			 * Right column cloned table nodes
			 * @namespace
			 */
			"right": {
				/**
				 * Cloned header table
				 *  @type     node
				 *  @default  null
				 */
				"header": null,
		  	
				/**
				 * Cloned body table
				 *  @type     node
				 *  @default  null
				 */
				"body": null,
		  	
				/**
				 * Cloned footer table
				 *  @type     node
				 *  @default  null
				 */
				"footer": null
			}
		}
	};

	/* Attach the instance to the DataTables instance so it can be accessed easily */
	this.s.dt.oFixedColumns = this;
	
	/* Let's do it */
	this._fnConstruct( oInit );
};



FixedColumns.prototype = {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	/**
	 * Update the fixed columns - including headers and footers. Note that FixedColumns will
	 * automatically update the display whenever the host DataTable redraws.
	 *  @returns {void}
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	var oFC = new FixedColumns( oTable );
	 *  	
	 *  	// at some later point when the table has been manipulated....
	 *  	oFC.fnUpdate();
	 */
	"fnUpdate": function ()
	{
		this._fnDraw( true );
	},
	
	
	/**
	 * Recalculate the resizes of the 3x3 grid that FixedColumns uses for display of the table.
	 * This is useful if you update the width of the table container. Note that FixedColumns will
	 * perform this function automatically when the window.resize event is fired.
	 *  @returns {void}
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	var oFC = new FixedColumns( oTable );
	 *  	
	 *  	// Resize the table container and then have FixedColumns adjust its layout....
	 *      $('#content').width( 1200 );
	 *  	oFC.fnRedrawLayout();
	 */
	"fnRedrawLayout": function ()
	{
		this._fnGridLayout();
	},
	
	
	/**
	 * Mark a row such that it's height should be recalculated when using 'semiauto' row
	 * height matching. This function will have no effect when 'none' or 'auto' row height
	 * matching is used.
	 *  @param   {Node} nTr TR element that should have it's height recalculated
	 *  @returns {void}
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	var oFC = new FixedColumns( oTable );
	 *  	
	 *  	// manipulate the table - mark the row as needing an update then update the table
	 *  	// this allows the redraw performed by DataTables fnUpdate to recalculate the row
	 *  	// height
	 *  	oFC.fnRecalculateHeight();
	 *  	oTable.fnUpdate( $('#example tbody tr:eq(0)')[0], ["insert date", 1, 2, 3 ... ]);
	 */
	"fnRecalculateHeight": function ( nTr )
	{
		nTr._DTTC_iHeight = null;
		nTr.style.height = 'auto';
	},
	
	
	/**
	 * Set the height of a given row - provides cross browser compatibility
	 *  @param   {Node} nTarget TR element that should have it's height recalculated
	 *  @param   {int} iHeight Height in pixels to set
	 *  @returns {void}
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	var oFC = new FixedColumns( oTable );
	 *  	
	 *  	// You may want to do this after manipulating a row in the fixed column
	 *  	oFC.fnSetRowHeight( $('#example tbody tr:eq(0)')[0], 50 );
	 */
	"fnSetRowHeight": function ( nTarget, iHeight )
	{
		var jqBoxHack = $(nTarget).children(':first');
		var iBoxHack = jqBoxHack.outerHeight() - jqBoxHack.height();

		/* Can we use some kind of object detection here?! This is very nasty - damn browsers */
		if ( $.browser.mozilla || $.browser.opera )
		{
			nTarget.style.height = iHeight+"px";
		}
		else
		{
			$(nTarget).children().height( iHeight-iBoxHack );
		}
	},
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods (they are of course public in JS, but recommended as private)
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	/**
	 * Initialisation for FixedColumns
	 *  @param   {Object} oInit User settings for initialisation
	 *  @returns {void}
	 *  @private
	 */
	"_fnConstruct": function ( oInit )
	{
		var i, iLen, iWidth,
			that = this;
		
		/* Sanity checking */
		if ( typeof this.s.dt.oInstance.fnVersionCheck != 'function' ||
		     this.s.dt.oInstance.fnVersionCheck( '1.8.0' ) !== true )
		{
			alert( "FixedColumns "+FixedColumns.VERSION+" required DataTables 1.8.0 or later. "+
				"Please upgrade your DataTables installation" );
			return;
		}
		
		if ( this.s.dt.oScroll.sX === "" )
		{
			this.s.dt.oInstance.oApi._fnLog( this.s.dt, 1, "FixedColumns is not needed (no "+
				"x-scrolling in DataTables enabled), so no action will be taken. Use 'FixedHeader' for "+
				"column fixing when scrolling is not enabled" );
			return;
		}
		
		/* Apply the settings from the user / defaults */
		this.s = $.extend( true, this.s, FixedColumns.defaults, oInit );

		/* Set up the DOM as we need it and cache nodes */
		this.dom.grid.dt = $(this.s.dt.nTable).parents('div.dataTables_scroll')[0];
		this.dom.scroller = $('div.dataTables_scrollBody', this.dom.grid.dt )[0];

		var iScrollWidth = $(this.dom.grid.dt).width();
		var iLeftWidth = 0;
		var iRightWidth = 0;

		$('tbody>tr:eq(0)>td', this.s.dt.nTable).each( function (i) {
			iWidth = $(this).outerWidth();
			that.s.aiWidths.push( iWidth );
			if ( i < that.s.iLeftColumns )
			{
				iLeftWidth += iWidth;
			}
			if ( that.s.iTableColumns-that.s.iRightColumns <= i )
			{
				iRightWidth += iWidth;
			}
		} );

		if ( this.s.iLeftWidth === null )
		{
			this.s.iLeftWidth = this.s.sLeftWidth == 'fixed' ?
				iLeftWidth : (iLeftWidth/iScrollWidth) * 100; 
		}
		
		if ( this.s.iRightWidth === null )
		{
			this.s.iRightWidth = this.s.sRightWidth == 'fixed' ?
				iRightWidth : (iRightWidth/iScrollWidth) * 100;
		}
		
		/* Set up the DOM that we want for the fixed column layout grid */
		this._fnGridSetup();

		/* Use the DataTables API method fnSetColumnVis to hide the columns we are going to fix */
		for ( i=0 ; i<this.s.iLeftColumns ; i++ )
		{
			this.s.dt.oInstance.fnSetColumnVis( i, false );
		}
		for ( i=this.s.iTableColumns - this.s.iRightColumns ; i<this.s.iTableColumns ; i++ )
		{
			this.s.dt.oInstance.fnSetColumnVis( i, false );
		}

		/* Event handlers */
		$(this.dom.scroller).scroll( function () {
			that.dom.grid.left.body.scrollTop = that.dom.scroller.scrollTop;
			if ( that.s.iRightColumns > 0 )
			{
				that.dom.grid.right.body.scrollTop = that.dom.scroller.scrollTop;
			}
		} );

		$(window).resize( function () {
			that._fnGridLayout.call( that );
		} );
		
		var bFirstDraw = true;
		this.s.dt.aoDrawCallback = [ {
			"fn": function () {
				that._fnDraw.call( that, bFirstDraw );
				that._fnGridHeight( that );
				bFirstDraw = false;
			},
			"sName": "FixedColumns"
		} ].concat( this.s.dt.aoDrawCallback );
		
		/* Get things right to start with - note that due to adjusting the columns, there must be
		 * another redraw of the main table. It doesn't need to be a full redraw however.
		 */
		this._fnGridLayout();
		this._fnGridHeight();
		this.s.dt.oInstance.fnDraw(false);
	},
	
	
	/**
	 * Set up the DOM for the fixed column. The way the layout works is to create a 1x3 grid
	 * for the left column, the DataTable (for which we just reuse the scrolling element DataTable
	 * puts into the DOM) and the right column. In each of he two fixed column elements there is a
	 * grouping wrapper element and then a head, body and footer wrapper. In each of these we then
	 * place the cloned header, body or footer tables. This effectively gives as 3x3 grid structure.
	 *  @returns {void}
	 *  @private
	 */
	"_fnGridSetup": function ()
	{
		var that = this;

		this.dom.body = this.s.dt.nTable;
		this.dom.header = this.s.dt.nTHead.parentNode;
		this.dom.header.parentNode.parentNode.style.position = "relative";
		
		var nSWrapper = 
			$('<div class="DTFC_ScrollWrapper" style="position:relative; clear:both;">'+
				'<div class="DTFC_LeftWrapper" style="position:absolute; top:0; left:0;">'+
					'<div class="DTFC_LeftHeadWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div>'+
					'<div class="DTFC_LeftBodyWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div>'+
					'<div class="DTFC_LeftFootWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div>'+
			  	'</div>'+
				'<div class="DTFC_RightWrapper" style="position:absolute; top:0; left:0;">'+
					'<div class="DTFC_RightHeadWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div>'+
					'<div class="DTFC_RightBodyWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div>'+
					'<div class="DTFC_RightFootWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div>'+
			  	'</div>'+
			  '</div>')[0];
		nLeft = nSWrapper.childNodes[0];
		nRight = nSWrapper.childNodes[1];

		this.dom.grid.wrapper = nSWrapper;
		this.dom.grid.left.wrapper = nLeft;
		this.dom.grid.left.head = nLeft.childNodes[0];
		this.dom.grid.left.body = nLeft.childNodes[1];

		if ( this.s.iRightColumns > 0 )
		{
			this.dom.grid.right.wrapper = nRight;
			this.dom.grid.right.head = nRight.childNodes[0];
			this.dom.grid.right.body = nRight.childNodes[1];
		}
		
		if ( this.s.dt.nTFoot )
		{
			this.dom.footer = this.s.dt.nTFoot.parentNode;
			this.dom.grid.left.foot = nLeft.childNodes[2];
			if ( this.s.iRightColumns > 0 )
			{
				this.dom.grid.right.foot = nRight.childNodes[2];
			}
		}

		nSWrapper.appendChild( nLeft );
		this.dom.grid.dt.parentNode.insertBefore( nSWrapper, this.dom.grid.dt );
		nSWrapper.appendChild( this.dom.grid.dt );

		this.dom.grid.dt.style.position = "absolute";
		this.dom.grid.dt.style.top = "0px";
		this.dom.grid.dt.style.left = this.s.iLeftWidth+"px";
		this.dom.grid.dt.style.width = ($(this.dom.grid.dt).width()-this.s.iLeftWidth-this.s.iRightWidth)+"px";
	},
	
	
	/**
	 * Style and position the grid used for the FixedColumns layout based on the instance settings.
	 * Specifically sLeftWidth ('fixed' or 'absolute'), iLeftWidth (px if fixed, % if absolute) and
	 * there 'right' counterparts.
	 *  @returns {void}
	 *  @private
	 */
	"_fnGridLayout": function ()
	{
		var oGrid = this.dom.grid;
		var iTotal = $(oGrid.wrapper).width();
		var iLeft = 0, iRight = 0, iRemainder = 0;

		if ( this.s.sLeftWidth == 'fixed' )
		{
			iLeft = this.s.iLeftWidth;
		}
		else
		{
			iLeft = ( this.s.iLeftWidth / 100 ) * iTotal;
		}

		if ( this.s.sRightWidth == 'fixed' )
		{
			iRight = this.s.iRightWidth;
		}
		else
		{
			iRight = ( this.s.iRightWidth / 100 ) * iTotal;
		}

		iRemainder = iTotal - iLeft - iRight;

		oGrid.left.wrapper.style.width = iLeft+"px";
		oGrid.dt.style.width = iRemainder+"px";
		oGrid.dt.style.left = iLeft+"px";

		if ( this.s.iRightColumns > 0 )
		{
			oGrid.right.wrapper.style.width = iRight+"px";
			oGrid.right.wrapper.style.left = (iTotal-iRight)+"px";
		}
	},
	
	
	/**
	 * Recalculate and set the height of the grid components used for positioning of the 
	 * FixedColumn display grid.
	 *  @returns {void}
	 *  @private
	 */
	"_fnGridHeight": function ()
	{
		var oGrid = this.dom.grid;
		var iHeight = $(this.dom.grid.dt).height();

		oGrid.wrapper.style.height = iHeight+"px";
		oGrid.left.body.style.height = $(this.dom.scroller).height()+"px";
		oGrid.left.wrapper.style.height = iHeight+"px";
		
		if ( this.s.iRightColumns > 0 )
		{
			oGrid.right.wrapper.style.height = iHeight+"px";
			oGrid.right.body.style.height = $(this.dom.scroller).height()+"px";
		}
	},
	
	
	/**
	 * Clone and position the fixed columns
	 *  @returns {void}
	 *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)
	 *  @private
	 */
	"_fnDraw": function ( bAll )
	{
		this._fnCloneLeft( bAll );
		this._fnCloneRight( bAll );

		/* Draw callback function */
		if ( this.s.fnDrawCallback !== null )
		{
			this.s.fnDrawCallback.call( this, this.dom.clone.left, this.dom.clone.right );
		}

		/* Event triggering */
		$(this).trigger( 'draw', { 
			"leftClone": this.dom.clone.left,
			"rightClone": this.dom.clone.right
		} );
	},
	
	
	/**
	 * Clone the right columns
	 *  @returns {void}
	 *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)
	 *  @private
	 */
	"_fnCloneRight": function ( bAll )
	{
		if ( this.s.iRightColumns <= 0 )
		{
			return;
		}
		
		var that = this,
			i, jq,
			aiColumns = [];

		for ( i=this.s.iTableColumns-this.s.iRightColumns ; i<this.s.iTableColumns ; i++ )
		{
			aiColumns.push( i );
		}

		this._fnClone( this.dom.clone.right, this.dom.grid.right, aiColumns, bAll );
	},
	
	
	/**
	 * Clone the left columns
	 *  @returns {void}
	 *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)
	 *  @private
	 */
	"_fnCloneLeft": function ( bAll )
	{
		if ( this.s.iLeftColumns <= 0 )
		{
			return;
		}
		
		var that = this,
			i, jq,
			aiColumns = [];
		
		for ( i=0 ; i<this.s.iLeftColumns ; i++ )
		{
			aiColumns.push( i );
		}

		this._fnClone( this.dom.clone.left, this.dom.grid.left, aiColumns, bAll );
	},
	
	
	/**
	 * Make a copy of the layout object for a header or footer element from DataTables. Note that
	 * this method will clone the nodes in the layout object.
	 *  @returns {Array} Copy of the layout array
	 *  @param   {Object} aoOriginal Layout array from DataTables (aoHeader or aoFooter)
	 *  @param   {Object} aiColumns Columns to copy
	 *  @private
	 */
	"_fnCopyLayout": function ( aoOriginal, aiColumns )
	{
		var aReturn = [];
		var aClones = [];
		var aCloned = [];

		for ( var i=0, iLen=aoOriginal.length ; i<iLen ; i++ )
		{
			var aRow = [];
			aRow.nTr = $(aoOriginal[i].nTr).clone(true)[0];

			for ( var j=0, jLen=this.s.iTableColumns ; j<jLen ; j++ )
			{
				if ( $.inArray( j, aiColumns ) === -1 )
				{
					continue;
				}

				var iCloned = $.inArray( aoOriginal[i][j].cell, aCloned );
				if ( iCloned === -1 )
				{
					var nClone = $(aoOriginal[i][j].cell).clone(true)[0];
					aClones.push( nClone );
					aCloned.push( aoOriginal[i][j].cell );

					aRow.push( {
						"cell": nClone,
						"unique": aoOriginal[i][j].unique
					} );
				}
				else
				{
					aRow.push( {
						"cell": aClones[ iCloned ],
						"unique": aoOriginal[i][j].unique
					} );
				}
			}
			
			aReturn.push( aRow );
		}

		return aReturn;
	},
	
	
	/**
	 * Clone the DataTable nodes and place them in the DOM (sized correctly)
	 *  @returns {void}
	 *  @param   {Object} oClone Object containing the header, footer and body cloned DOM elements
	 *  @param   {Object} oGrid Grid object containing the display grid elements for the cloned 
	 *                    column (left or right)
	 *  @param   {Array} aiColumns Column indexes which should be operated on from the DataTable
	 *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)
	 *  @private
	 */
	"_fnClone": function ( oClone, oGrid, aiColumns, bAll )
	{
		var that = this,
			i, iLen, j, jLen, jq, nTarget, iColumn, nClone, iIndex;

		/* 
		 * Header
		 */
		if ( bAll )
		{
			if ( oClone.header !== null )
			{
				oClone.header.parentNode.removeChild( oClone.header );
			}
			oClone.header = $(this.dom.header).clone(true)[0];
			oClone.header.className += " DTFC_Cloned";
			oClone.header.style.width = "100%";
			oGrid.head.appendChild( oClone.header );
			
			/* Copy the DataTables layout cache for the header for our floating column */
			var aoCloneLayout = this._fnCopyLayout( this.s.dt.aoHeader, aiColumns );
			var jqCloneThead = $('>thead', oClone.header);
			jqCloneThead.empty();

			/* Add the created cloned TR elements to the table */
			for ( i=0, iLen=aoCloneLayout.length ; i<iLen ; i++ )
			{
				jqCloneThead[0].appendChild( aoCloneLayout[i].nTr );
			}

			/* Use the handy _fnDrawHead function in DataTables to do the rowspan/colspan
			 * calculations for us
			 */
			this.s.dt.oApi._fnDrawHead( this.s.dt, aoCloneLayout, true );
		}
		else
		{
			/* To ensure that we copy cell classes exactly, regardless of colspan, multiple rows
			 * etc, we make a copy of the header from the DataTable again, but don't insert the 
			 * cloned cells, just copy the classes across. To get the matching layout for the
			 * fixed component, we use the DataTables _fnDetectHeader method, allowing 1:1 mapping
			 */
			var aoCloneLayout = this._fnCopyLayout( this.s.dt.aoHeader, aiColumns );
			var aoCurrHeader=[];

			this.s.dt.oApi._fnDetectHeader( aoCurrHeader, $('>thead', oClone.header)[0] );

			for ( i=0, iLen=aoCloneLayout.length ; i<iLen ; i++ )
			{
				for ( j=0, jLen=aoCloneLayout[i].length ; j<jLen ; j++ )
				{
					aoCurrHeader[i][j].cell.className = aoCloneLayout[i][j].cell.className;

					// If jQuery UI theming is used we need to copy those elements as well
					$('span.DataTables_sort_icon', aoCurrHeader[i][j].cell).each( function () {
						this.className = $('span.DataTables_sort_icon', aoCloneLayout[i][j].cell)[0].className;
					} );
				}
			}
		}
		this._fnEqualiseHeights( 'thead', this.dom.header, oClone.header );
		
		/* 
		 * Body
		 */
		if ( this.s.sHeightMatch == 'auto' )
		{
			/* Remove any heights which have been applied already and let the browser figure it out */
			$('>tbody>tr', that.dom.body).css('height', 'auto');
		}
		
		if ( oClone.body !== null )
		{
			oClone.body.parentNode.removeChild( oClone.body );
			oClone.body = null;
		}
		
		oClone.body = $(this.dom.body).clone(true)[0];
		oClone.body.className += " DTFC_Cloned";
		oClone.body.style.paddingBottom = this.s.dt.oScroll.iBarWidth+"px";
		oClone.body.style.marginBottom = (this.s.dt.oScroll.iBarWidth*2)+"px"; /* For IE */
		if ( oClone.body.getAttribute('id') !== null )
		{
			oClone.body.removeAttribute('id');
		}
		
		$('>thead>tr', oClone.body).empty();
		$('>tfoot', oClone.body).remove();
		
		var nBody = $('tbody', oClone.body)[0];
		$(nBody).empty();
		if ( this.s.dt.aiDisplay.length > 0 )
		{
			/* Copy the DataTables' header elements to force the column width in exactly the
			 * same way that DataTables does it - have the header element, apply the width and
			 * colapse it down
			 */
			var nInnerThead = $('>thead>tr', oClone.body)[0];
			for ( iIndex=0 ; iIndex<aiColumns.length ; iIndex++ )
			{
				iColumn = aiColumns[iIndex];

				nClone = this.s.dt.aoColumns[iColumn].nTh;
				nClone.innerHTML = "";

				oStyle = nClone.style;
				oStyle.paddingTop = "0";
				oStyle.paddingBottom = "0";
				oStyle.borderTopWidth = "0";
				oStyle.borderBottomWidth = "0";
				oStyle.height = 0;
				oStyle.width = that.s.aiWidths[iColumn]+"px";

				nInnerThead.appendChild( nClone );
			}

			/* Add in the tbody elements, cloning form the master table */
			$('>tbody>tr', that.dom.body).each( function (z) {
				var n = this.cloneNode(false);
				var i = that.s.dt.oFeatures.bServerSide===false ?
					that.s.dt.aiDisplay[ that.s.dt._iDisplayStart+z ] : z;
				for ( iIndex=0 ; iIndex<aiColumns.length ; iIndex++ )
				{
					iColumn = aiColumns[iIndex];
					if ( typeof that.s.dt.aoData[i]._anHidden[iColumn] != 'undefined' )
					{
						nClone = $(that.s.dt.aoData[i]._anHidden[iColumn]).clone(true)[0];
						n.appendChild( nClone );
					}
				}
				nBody.appendChild( n );
			} );
		}
		else
		{
			$('>tbody>tr', that.dom.body).each( function (z) {
				nClone = this.cloneNode(true);
				nClone.className += ' DTFC_NoData';
				$('td', nClone).html('');
				nBody.appendChild( nClone );
			} );
		}
		
		oClone.body.style.width = "100%";
		oGrid.body.appendChild( oClone.body );

		this._fnEqualiseHeights( 'tbody', that.dom.body, oClone.body );
		
		/*
		 * Footer
		 */
		if ( this.s.dt.nTFoot !== null )
		{
			if ( bAll )
			{
				if ( oClone.footer !== null )
				{
					oClone.footer.parentNode.removeChild( oClone.footer );
				}
				oClone.footer = $(this.dom.footer).clone(true)[0];
				oClone.footer.className += " DTFC_Cloned";
				oClone.footer.style.width = "100%";
				oGrid.foot.appendChild( oClone.footer );

				/* Copy the footer just like we do for the header */
				var aoCloneLayout = this._fnCopyLayout( this.s.dt.aoFooter, aiColumns );
				var jqCloneTfoot = $('>tfoot', oClone.footer);
				jqCloneTfoot.empty();
	
				for ( i=0, iLen=aoCloneLayout.length ; i<iLen ; i++ )
				{
					jqCloneTfoot[0].appendChild( aoCloneLayout[i].nTr );
				}
				this.s.dt.oApi._fnDrawHead( this.s.dt, aoCloneLayout, true );
			}
			else
			{
				var aoCloneLayout = this._fnCopyLayout( this.s.dt.aoFooter, aiColumns );
				var aoCurrFooter=[];

				this.s.dt.oApi._fnDetectHeader( aoCurrFooter, $('>tfoot', oClone.footer)[0] );

				for ( i=0, iLen=aoCloneLayout.length ; i<iLen ; i++ )
				{
					for ( j=0, jLen=aoCloneLayout[i].length ; j<jLen ; j++ )
					{
						aoCurrFooter[i][j].cell.className = aoCloneLayout[i][j].cell.className;
					}
				}
			}
			this._fnEqualiseHeights( 'tfoot', this.dom.footer, oClone.footer );
		}

		/* Equalise the column widths between the header footer and body - body get's priority */
		var anUnique = this.s.dt.oApi._fnGetUniqueThs( this.s.dt, $('>thead', oClone.header)[0] );
		$(anUnique).each( function (i) {
			iColumn = aiColumns[i];
			this.style.width = that.s.aiWidths[iColumn]+"px";
		} );

		if ( that.s.dt.nTFoot !== null )
		{
			anUnique = this.s.dt.oApi._fnGetUniqueThs( this.s.dt, $('>tfoot', oClone.footer)[0] );
			$(anUnique).each( function (i) {
				iColumn = aiColumns[i];
				this.style.width = that.s.aiWidths[iColumn]+"px";
			} );
		}
	},
	
	
	/**
	 * From a given table node (THEAD etc), get a list of TR direct child elements
	 *  @param   {Node} nIn Table element to search for TR elements (THEAD, TBODY or TFOOT element)
	 *  @returns {Array} List of TR elements found
	 *  @private
	 */
	"_fnGetTrNodes": function ( nIn )
	{
		var aOut = [];
		for ( var i=0, iLen=nIn.childNodes.length ; i<iLen ; i++ )
		{
			if ( nIn.childNodes[i].nodeName.toUpperCase() == "TR" )
			{
				aOut.push( nIn.childNodes[i] );
			}
		}
		return aOut;
	},

	
	/**
	 * Equalise the heights of the rows in a given table node in a cross browser way
	 *  @returns {void}
	 *  @param   {String} nodeName Node type - thead, tbody or tfoot
	 *  @param   {Node} original Original node to take the heights from
	 *  @param   {Node} clone Copy the heights to
	 *  @private
	 */
	"_fnEqualiseHeights": function ( nodeName, original, clone )
	{
		if ( this.s.sHeightMatch == 'none' && nodeName !== 'thead' && nodeName !== 'tfoot' )
		{
			return;
		}
		
		var that = this,
			i, iLen, iHeight, iHeight2, iHeightOriginal, iHeightClone,
			rootOriginal = original.getElementsByTagName(nodeName)[0],
			rootClone    = clone.getElementsByTagName(nodeName)[0],
			jqBoxHack    = $('>'+nodeName+'>tr:eq(0)', original).children(':first'),
			iBoxHack     = jqBoxHack.outerHeight() - jqBoxHack.height(),
			anOriginal   = this._fnGetTrNodes( rootOriginal ),
		 	anClone      = this._fnGetTrNodes( rootClone );
		
		for ( i=0, iLen=anClone.length ; i<iLen ; i++ )
		{
			if ( this.s.sHeightMatch == 'semiauto' && typeof anOriginal[i]._DTTC_iHeight != 'undefined' && 
				anOriginal[i]._DTTC_iHeight !== null )
			{
				/* Oddly enough, IE / Chrome seem not to copy the style height - Mozilla and Opera keep it */
				if ( $.browser.msie )
				{
					$(anClone[i]).children().height( anOriginal[i]._DTTC_iHeight-iBoxHack );
				}
				continue;
			}
			
			iHeightOriginal = anOriginal[i].offsetHeight;
			iHeightClone = anClone[i].offsetHeight;
			iHeight = iHeightClone > iHeightOriginal ? iHeightClone : iHeightOriginal;
			
			if ( this.s.sHeightMatch == 'semiauto' )
			{
				anOriginal[i]._DTTC_iHeight = iHeight;
			}
			
			/* Can we use some kind of object detection here?! This is very nasty - damn browsers */
			if ( $.browser.msie && $.browser.version < 8 )
			{
				$(anClone[i]).children().height( iHeight-iBoxHack );
				$(anOriginal[i]).children().height( iHeight-iBoxHack );	
			}
			else
			{
				anClone[i].style.height = iHeight+"px";
				anOriginal[i].style.height = iHeight+"px";
			}
		}
	}
};



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Statics
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/**
 * FixedColumns default settings for initialisation
 *  @namespace
 *  @static
 */
FixedColumns.defaults = {
	/** 
	 * Number of left hand columns to fix in position
	 *  @type     int
	 *  @default  1
	 *  @static
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	new FixedColumns( oTable, {
	 *  		"iLeftColumns": 2
	 *  	} );
	 */
	"iLeftColumns": 1,
	
	/** 
	 * Number of right hand columns to fix in position
	 *  @type     int
	 *  @default  0
	 *  @static
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	new FixedColumns( oTable, {
	 *  		"iRightColumns": 1
	 *  	} );
	 */
	"iRightColumns": 0,
	
	/** 
	 * Draw callback function which is called when FixedColumns has redrawn the fixed assets
	 *  @type     function(object, object):void
	 *  @default  null
	 *  @static
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	new FixedColumns( oTable, {
	 *  		"fnDrawCallback": function () {
	 *				alert( "FixedColumns redraw" );
	 *			}
	 *  	} );
	 */
	"fnDrawCallback": null,
	
	/** 
	 * Type of left column size calculation. Can take the values of "fixed", whereby the iLeftWidth
	 * value will be treated as a pixel value, or "relative" for which case iLeftWidth will be
	 * treated as a percentage value.
	 *  @type     string
	 *  @default  fixed
	 *  @static
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	new FixedColumns( oTable, {
	 *  		"sLeftWidth": "relative",
	 *  		"iLeftWidth": 10 // percentage
	 *  	} );
	 */
	"sLeftWidth": "fixed",
	
	/** 
	 * Width to set for the width of the left fixed column(s) - note that the behaviour of this
	 * property is directly effected by the sLeftWidth property. If not defined then this property
	 * is calculated automatically from what has been assigned by DataTables.
	 *  @type     int
	 *  @default  null
	 *  @static
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	new FixedColumns( oTable, {
	 *  		"iLeftWidth": 100 // pixels
	 *  	} );
	 */
	"iLeftWidth": null,
	
	/** 
	 * Type of right column size calculation. Can take the values of "fixed", whereby the 
	 * iRightWidth value will be treated as a pixel value, or "relative" for which case 
	 * iRightWidth will be treated as a percentage value.
	 *  @type     string
	 *  @default  fixed
	 *  @static
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	new FixedColumns( oTable, {
	 *  		"sRightWidth": "relative",
	 *  		"iRightWidth": 10 // percentage
	 *  	} );
	 */
	"sRightWidth": "fixed",
	
	/**
	 * Width to set for the width of the right fixed column(s) - note that the behaviour of this
	 * property is directly effected by the sRightWidth property. If not defined then this property
	 * is calculated automatically from what has been assigned by DataTables.
	 *  @type     int
	 *  @default  null
	 *  @static
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	new FixedColumns( oTable, {
	 *  		"iRightWidth": 200 // pixels
	 *  	} );
	 */
	"iRightWidth": null,
	
	/** 
	 * Height matching algorthim to use. This can be "none" which will result in no height
	 * matching being applied by FixedColumns (height matching could be forced by CSS in this
	 * case), "semiauto" whereby the height calculation will be performed once, and the result
	 * cached to be used again (fnRecalculateHeight can be used to force recalculation), or
	 * "auto" when height matching is performed on every draw (slowest but must accurate)
	 *  @type     string
	 *  @default  semiauto
	 *  @static
	 *  @example
	 *  	var oTable = $('#example').dataTable( {
	 *  		"sScrollX": "100%"
	 *  	} );
	 *  	new FixedColumns( oTable, {
	 *  		"sHeightMatch": "auto"
	 *  	} );
	 */
	"sHeightMatch": "semiauto"
};




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Constants
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/**
 * Name of this class
 *  @constant CLASS
 *  @type     String
 *  @default  FixedColumns
 */
FixedColumns.prototype.CLASS = "FixedColumns";


/**
 * FixedColumns version
 *  @constant  FixedColumns.VERSION
 *  @type      String
 *  @default   See code
 *  @static
 */
FixedColumns.VERSION = "2.0.3";



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Fired events (for documentation)
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/**
 * Event fired whenever FixedColumns redraws the fixed columns (i.e. clones the table elements from the main DataTable). This will occur whenever the DataTable that the FixedColumns instance is attached does its own draw.
 * @name FixedColumns#draw
 * @event
 * @param {event} e jQuery event object
 * @param {object} o Event parameters from FixedColumns
 * @param {object} o.leftClone Instance's object dom.clone.left for easy reference. This object contains references to the left fixed clumn column's nodes
 * @param {object} o.rightClone Instance's object dom.clone.right for easy reference. This object contains references to the right fixed clumn column's nodes
 */

})(jQuery, window, document);


// assets/js/bundle/third_party/jquery/infieldlabel.js
goog.provide("optly.jquery.infieldlabel");

goog.require("optly.jquery");

/*
 * In-Field Label jQuery Plugin
 * http://fuelyourcoding.com/scripts/infield.html
 *
 * Copyright (c) 2009 Doug Neiner
 * Dual licensed under the MIT and GPL licenses.
 * Uses the same license as jQuery, see:
 * http://docs.jquery.com/License
 *
 * @version 0.1
 */
(function($){

    $.InFieldLabels = function(label,field, options){
        // To avoid scope issues, use 'base' instead of 'this'
        // to reference this class from internal events and functions.
        var base = this;

        // Access to jQuery and DOM versions of each element
        base.$label = $(label);
        base.label = label;

     base.$field = $(field);
    base.field = field;

    base.$label.data("InFieldLabels", base);
    base.showing = true;

        base.init = function(){
      // Merge supplied options with default options
            base.options = $.extend({},$.InFieldLabels.defaultOptions, options);

      // Check if the field is already filled in
      if(base.$field.val() != ""){
        base.$label.hide();
        base.showing = false;
      };

      base.$field.focus(function(){
        base.fadeOnFocus();
      }).blur(function(){
        base.checkForEmpty(true);
      }).bind('keydown.infieldlabel',function(e){
        // Use of a namespace (.infieldlabel) allows us to
        // unbind just this method later
        base.hideOnChange(e);
      }).change(function(e){
        base.checkForEmpty();
      }).bind('onPropertyChange', function(){
        base.checkForEmpty();
      });
        };

    // If the label is currently showing
    // then fade it down to the amount
    // specified in the settings
    base.fadeOnFocus = function(){
      if(base.showing){
        base.setOpacity(base.options.fadeOpacity);
      };
    };

    base.setOpacity = function(opacity){
      base.$label.stop().animate({ opacity: opacity }, base.options.fadeDuration);
      base.showing = (opacity > 0.0);
    };

    // Checks for empty as a fail safe
    // set blur to true when passing from
    // the blur event
    base.checkForEmpty = function(blur){
      if(base.$field.val() == ""){
        base.prepForShow();
        base.setOpacity( blur ? 1.0 : base.options.fadeOpacity );
      } else {
        base.setOpacity(0.0);
      };
    };

    base.prepForShow = function(e){
      if(!base.showing) {
        // Prepare for a animate in...
        base.$label.css({opacity: 0.0}).show();

        // Reattach the keydown event
        base.$field.bind('keydown.infieldlabel',function(e){
          base.hideOnChange(e);
        });
      };
    };

    base.hideOnChange = function(e){
      if(
        (e.keyCode == 16) || // Skip Shift
        (e.keyCode == 9) // Skip Tab
        ) return;

      if(base.showing){
        base.$label.hide();
        base.showing = false;
      };

      // Remove keydown event to save on CPU processing
      base.$field.unbind('keydown.infieldlabel');
    };

    // Run the initialization method
        base.init();
    };

    $.InFieldLabels.defaultOptions = {
        fadeOpacity: 0.5, // Once a field has focus, how transparent should the label be
    fadeDuration: 300 // How long should it take to animate from 1.0 opacity to the fadeOpacity
    };


    $.fn.inFieldLabels = function(options){
        return this.each(function(){
      // Find input or textarea based on for= attribute
      // The for attribute on the label must contain the ID
      // of the input or textarea element
      var for_attr = $(this).attr('for');
      if( !for_attr ) return; // Nothing to attach, since the for field wasn't used


      // Find the referenced input or textarea element
      var $field = $(
        // JZ: HTML5 added more input types, such as email and tel, that this plugin should work with
        // "input#" + for_attr + "[type='text']," +
        // "input#" + for_attr + "[type='password']," +
        "input#" + for_attr + ", " +
        "textarea#" + for_attr
        );

      if( $field.length == 0) return; // Again, nothing to attach

      // Only create object for input or textarea
            (new $.InFieldLabels(this, $field[0], options));
        });
    };

})(jQuery);


// assets/js/bundle/third_party/jquery/popover.js
goog.provide("optly.jquery.popover");

goog.require("optly.jquery");
goog.require("optly.jquery.tooltip");

/* ===================================================
 * bootstrap-transition.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#transitions
 * ===================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


  /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
   * ======================================================= */

  $(function () {

    $.support.transition = (function () {

      var transitionEnd = (function () {

        var el = document.createElement('bootstrap')
          , transEndEventNames = {
               'WebkitTransition' : 'webkitTransitionEnd'
            ,  'MozTransition'    : 'transitionend'
            ,  'OTransition'      : 'oTransitionEnd otransitionend'
            ,  'transition'       : 'transitionend'
            }
          , name

        for (name in transEndEventNames){
          if (el.style[name] !== undefined) {
            return transEndEventNames[name]
          }
        }

      }())

      return transitionEnd && {
        end: transitionEnd
      }

    })()

  })

}(jQuery);

/* ===========================================================
 * bootstrap-popover.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#popovers
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* POPOVER PUBLIC CLASS DEFINITION
  * =============================== */

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }


  /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
     ========================================== */

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {

    constructor: Popover

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()
        , content = this.getContent()

      $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
      $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)

      $tip.removeClass('fade top bottom left right in')
    }

  , hasContent: function () {
      return this.getTitle() || this.getContent()
    }

  , getContent: function () {
      var content
        , $e = this.$element
        , o = this.options

      content = (typeof o.content == 'function' ? o.content.call($e[0]) :  o.content)
        || $e.attr('data-content')

      return content
    }

  , tip: function () {
      if (!this.$tip) {
        this.$tip = $(this.options.template)
      }
      return this.$tip
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  })


 /* POPOVER PLUGIN DEFINITION
  * ======================= */

  var old = $.fn.popover

  $.fn.popover = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('popover')
        , options = typeof option == 'object' && option
      if (!data) $this.data('popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.popover.Constructor = Popover

  $.fn.popover.defaults = $.extend({} , $.fn.tooltip.defaults, {
    placement: 'right'
  , trigger: 'click'
  , content: ''
  , template: '<div class="popover"><div class="popover-arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


 /* POPOVER NO CONFLICT
  * =================== */

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);


// assets/js/bundle/results/event_type.js
goog.provide("optly.results.EventType");

/**
 * Enum for types in events.py.
 *
 * @enum {number}
 */
optly.results.EventType = {
  PAGEVIEW: 1, // simple match
  CUSTOM_PAGEVIEW: 2,
  CUSTOM_EVENT: 3,
  ENGAGEMENT: 4,
  FORM_SUBMISSION: 5,
  CLICK: 6,
  PAGEVIEW_REGEX: 7,
  PAGEVIEW_SUBSTRING: 8,
  PAGEVIEW_EXACT: 9,
  REVENUE: 10
};


// assets/js/bundle/goals/typecode.js
goog.provide("optly.goals.TypeCode");

/**
 * codes for project goal types
 * @enum {number}
 */
optly.goals.TypeCode = {
  CLICK: 0,
  CUSTOM_EVENT: 1,
  ENGAGEMENT: 2,
  PAGEVIEW: 3,
  REVENUE: 4,
  MOBILE_TAP_EVENT_TYPE: 5,
  MOBILE_VIEW_EVENT_TYPE: 6,

  // These three goals may be available on mobile projects.
  // The first is the actual goal whose events are sent to the backend.
  // The second and third are dummy goals that allow users to control the
  // modules that appear on the results page, FROM THE GOALS DIALOG.
  MOBILE_SESSION_GOAL: 7,
  MOBILE_SESSION_LENGTH_GOAL: 8,
  MOBILE_NUM_SESSION_GOAL: 9
};

// assets/js/bundle/goals/goal.js
goog.provide("optly.goals");

goog.require("optly.results.EventType");
goog.require("optly.goals.TypeCode");

/**
 * @enum {number}
 */
optly.goals.PageviewGoalUrlConditionTypeCode = {
  EXACT: 1,
  REGEX: 2,
  SIMPLE: 3,
  SUBSTRING: 4
};

/**
 * strings for project goal types
 *
 * @enum {string}
 */
optly.goals.TypeString = {
  CLICK: "CLICK",
  CUSTOM_EVENT: "CUSTOM_EVENT",
  ENGAGEMENT: "ENGAGEMENT",
  PAGEVIEW: "PAGEVIEW",
  REVENUE: "REVENUE",
  MOBILE_TAP_EVENT_TYPE: "MOBILE_TAP_EVENT_TYPE",
  MOBILE_VIEW_EVENT_TYPE: "MOBILE_VIEW_EVENT_TYPE",
  MOBILE_SESSION_GOAL: "MOBILE_SESSION",
  MOBILE_SESSION_LENGTH_GOAL: "MOBILE_SESSION_LENGTH",
  MOBILE_NUM_SESSION_GOAL: "MOBILE_NUM_SESSIONS"
};

optly.goals.TypeCodeToString = {};
optly.goals.TypeCodeToString[optly.goals.TypeCode.CLICK] = optly.goals.TypeString.CLICK;
optly.goals.TypeCodeToString[optly.goals.TypeCode.CUSTOM_EVENT] = optly.goals.TypeString.CUSTOM_EVENT;
optly.goals.TypeCodeToString[optly.goals.TypeCode.ENGAGEMENT] = optly.goals.TypeString.ENGAGEMENT;
optly.goals.TypeCodeToString[optly.goals.TypeCode.PAGEVIEW] = optly.goals.TypeString.PAGEVIEW;
optly.goals.TypeCodeToString[optly.goals.TypeCode.REVENUE] = optly.goals.TypeString.REVENUE;
optly.goals.TypeCodeToString[optly.goals.TypeCode.MOBILE_TAP_EVENT_TYPE] = optly.goals.TypeString.MOBILE_TAP_EVENT_TYPE;
optly.goals.TypeCodeToString[optly.goals.TypeCode.MOBILE_VIEW_EVENT_TYPE] = optly.goals.TypeString.MOBILE_VIEW_EVENT_TYPE;
optly.goals.TypeCodeToString[optly.goals.TypeCode.MOBILE_SESSION_GOAL] = optly.goals.TypeString.MOBILE_SESSION_GOAL;
optly.goals.TypeCodeToString[optly.goals.TypeCode.MOBILE_SESSION_LENGTH_GOAL] = optly.goals.TypeString.MOBILE_SESSION_LENGTH_GOAL;
optly.goals.TypeCodeToString[optly.goals.TypeCode.MOBILE_NUM_SESSION_GOAL] = optly.goals.TypeString.MOBILE_NUM_SESSION_GOAL;


optly.goals.TypeStringToCode = {};
optly.goals.TypeStringToCode[optly.goals.TypeString.CLICK] = optly.goals.TypeCode.CLICK;
optly.goals.TypeStringToCode[optly.goals.TypeString.CUSTOM_EVENT] = optly.goals.TypeCode.CUSTOM_EVENT;
optly.goals.TypeStringToCode[optly.goals.TypeString.ENGAGEMENT] = optly.goals.TypeCode.ENGAGEMENT;
optly.goals.TypeStringToCode[optly.goals.TypeString.PAGEVIEW] = optly.goals.TypeCode.PAGEVIEW;
optly.goals.TypeStringToCode[optly.goals.TypeString.REVENUE] = optly.goals.TypeCode.REVENUE;
optly.goals.TypeStringToCode[optly.goals.TypeString.MOBILE_TAP_EVENT_TYPE] = optly.goals.TypeCode.MOBILE_TAP_EVENT_TYPE;
optly.goals.TypeStringToCode[optly.goals.TypeString.MOBILE_VIEW_EVENT_TYPE] = optly.goals.TypeCode.MOBILE_VIEW_EVENT_TYPE;
optly.goals.TypeStringToCode[optly.goals.TypeString.MOBILE_SESSION_GOAL] = optly.goals.TypeCode.MOBILE_SESSION_GOAL;
optly.goals.TypeStringToCode[optly.goals.TypeString.MOBILE_NUM_SESSION_GOAL] = optly.goals.TypeCode.MOBILE_NUM_SESSION_GOAL;
optly.goals.TypeStringToCode[optly.goals.TypeString.MOBILE_SESSION_LENGTH_GOAL] = optly.goals.TypeCode.MOBILE_SESSION_LENGTH_GOAL

var generateGoalDescription = function(goal) {
  var goalType = goal.type === undefined ? goal.goal_type : goal.type;
  if (typeof goalType === "function") {
    goalType = optly.goals.TypeStringToCode[goalType()];
  }
  switch (goalType) {
    case optly.goals.TypeCode.CLICK:
      return tr("The percentage of visitors who clicked on a tracked element.");
    case optly.goals.TypeCode.CUSTOM_EVENT:
      return tr("The percentage of visitors who triggered {0} (custom event).", sanitizeHTML(goal.event));
    case optly.goals.TypeCode.ENGAGEMENT:
      return tr("The percentage of visitors who clicked on any part of the experiment page.");
    case optly.goals.TypeCode.REVENUE:
      return tr("The revenue earned per visitor after visiting an experiment page. <a class='help-button' href='https://help.optimizely.com/hc/en-us/articles/200039865' target='_blank'></a>");
    case optly.goals.TypeCode.PAGEVIEW:
      // very rarely (it's an error condition), there are pageview goals with no urls
      if (goal.urls === undefined) {
        return tr('This goal is not set up to track views on any page. Please modify the goal or take a look at <a href="https://help.optimizely.com/hc/en-us/articles/200090069">Setting Up Goals</a> if you need help.');
      }

      var urls = [];
      for (var i = 0; i < goal.urls.length; i++) {
        var type = "";
        switch (goal.url_match_types[i]) {
          case optly.goals.PageviewGoalUrlConditionTypeCode.EXACT:
            type = tr("(exact match)"); break;
          case optly.goals.PageviewGoalUrlConditionTypeCode.REGEX:
            type = tr("(regular expression match)"); break;
          case optly.goals.PageviewGoalUrlConditionTypeCode.SIMPLE:
            type = tr("(simple match)"); break;
          case optly.goals.PageviewGoalUrlConditionTypeCode.SUBSTRING:
            type = tr("(substring match)"); break;
        }
        urls.push(sanitizeHTML(goal.urls[i]) + " " + type);
      }
      return tr("The percentage of visitors who visited {0}.", urls.join(tr(", or ")));
    case optly.goals.TypeCode.MOBILE_TAP_EVENT_TYPE:
      return tr("The percentage of visitors who tapped a specific element in the app.");
    case optly.goals.TypeCode.MOBILE_VIEW_EVENT_TYPE:
      return tr("The percentage of visitors who visited a view in the app.");
    case optly.goals.TypeCode.MOBILE_NUM_SESSION_GOAL:
      return tr("The average number of sessions.");
    case optly.goals.TypeCode.MOBILE_SESSION_LENGTH_GOAL:
      return tr("The average session length.");
    default:
      return "";
  }
};


// assets/js/bundle/third_party/jquery/cookie.js
goog.provide("optly.jquery.cookie");

goog.require("optly.jquery");

/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};


// node_modules/closure-library/goog/string/string.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for string manipulation.
 */


/**
 * Namespace for string utilities
 */
goog.provide('goog.string');
goog.provide('goog.string.Unicode');


/**
 * Common Unicode string characters.
 * @enum {string}
 */
goog.string.Unicode = {
  NBSP: '\xa0'
};


/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix}.
 */
goog.string.startsWith = function(str, prefix) {
  return str.lastIndexOf(prefix, 0) == 0;
};


/**
 * Fast suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix}.
 */
goog.string.endsWith = function(str, suffix) {
  var l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};


/**
 * Case-insensitive prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix  A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveStartsWith = function(str, prefix) {
  return goog.string.caseInsensitiveCompare(
      prefix, str.substr(0, prefix.length)) == 0;
};


/**
 * Case-insensitive suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveEndsWith = function(str, suffix) {
  return goog.string.caseInsensitiveCompare(
      suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
};


/**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} str The string containing the pattern.
 * @param {...*} var_args The items to substitute into the pattern.
 * @return {string} A copy of {@code str} in which each occurrence of
 *     {@code %s} has been replaced an argument from {@code var_args}.
 */
goog.string.subs = function(str, var_args) {
  // This appears to be slow, but testing shows it compares more or less
  // equivalent to the regex.exec method.
  for (var i = 1; i < arguments.length; i++) {
    // We cast to String in case an argument is a Function.  Replacing $&, for
    // example, with $$$& stops the replace from subsituting the whole match
    // into the resultant string.  $$$& in the first replace becomes $$& in the
    //  second, which leaves $& in the resultant string.  Also:
    // $$, $`, $', $n $nn
    var replacement = String(arguments[i]).replace(/\$/g, '$$$$');
    str = str.replace(/\%s/, replacement);
  }
  return str;
};


/**
 * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
 * and tabs) to a single space, and strips leading and trailing whitespace.
 * @param {string} str Input string.
 * @return {string} A copy of {@code str} with collapsed whitespace.
 */
goog.string.collapseWhitespace = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
};


/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} True if {@code str} is empty or whitespace only.
 */
goog.string.isEmpty = function(str) {
  // testing length == 0 first is actually slower in all browsers (about the
  // same in Opera).
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return /^[\s\xa0]*$/.test(str);
};


/**
 * Checks if a string is null, empty or contains only whitespaces.
 * @param {*} str The string to check.
 * @return {boolean} True if{@code str} is null, empty, or whitespace only.
 */
goog.string.isEmptySafe = function(str) {
  return goog.string.isEmpty(goog.string.makeSafe(str));
};


/**
 * Checks if a string is all breaking whitespace.
 * @param {string} str The string to check.
 * @return {boolean} Whether the string is all breaking whitespace.
 */
goog.string.isBreakingWhitespace = function(str) {
  return !/[^\t\n\r ]/.test(str);
};


/**
 * Checks if a string contains all letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} consists entirely of letters.
 */
goog.string.isAlpha = function(str) {
  return !/[^a-zA-Z]/.test(str);
};


/**
 * Checks if a string contains only numbers.
 * @param {*} str string to check. If not a string, it will be
 *     casted to one.
 * @return {boolean} True if {@code str} is numeric.
 */
goog.string.isNumeric = function(str) {
  return !/[^0-9]/.test(str);
};


/**
 * Checks if a string contains only numbers or letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} is alphanumeric.
 */
goog.string.isAlphaNumeric = function(str) {
  return !/[^a-zA-Z0-9]/.test(str);
};


/**
 * Checks if a character is a space character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a space.
 */
goog.string.isSpace = function(ch) {
  return ch == ' ';
};


/**
 * Checks if a character is a valid unicode character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a valid unicode character.
 */
goog.string.isUnicodeChar = function(ch) {
  return ch.length == 1 && ch >= ' ' && ch <= '~' ||
         ch >= '\u0080' && ch <= '\uFFFD';
};


/**
 * Takes a string and replaces newlines with a space. Multiple lines are
 * replaced with a single space.
 * @param {string} str The string from which to strip newlines.
 * @return {string} A copy of {@code str} stripped of newlines.
 */
goog.string.stripNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)+/g, ' ');
};


/**
 * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
 * @param {string} str The string to in which to canonicalize newlines.
 * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
 */
goog.string.canonicalizeNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)/g, '\n');
};


/**
 * Normalizes whitespace in a string, replacing all whitespace chars with
 * a space.
 * @param {string} str The string in which to normalize whitespace.
 * @return {string} A copy of {@code str} with all whitespace normalized.
 */
goog.string.normalizeWhitespace = function(str) {
  return str.replace(/\xa0|\s/g, ' ');
};


/**
 * Normalizes spaces in a string, replacing all consecutive spaces and tabs
 * with a single space. Replaces non-breaking space with a space.
 * @param {string} str The string in which to normalize spaces.
 * @return {string} A copy of {@code str} with all consecutive spaces and tabs
 *    replaced with a single space.
 */
goog.string.normalizeSpaces = function(str) {
  return str.replace(/\xa0|[ \t]+/g, ' ');
};


/**
 * Removes the breaking spaces from the left and right of the string and
 * collapses the sequences of breaking spaces in the middle into single spaces.
 * The original and the result strings render the same way in HTML.
 * @param {string} str A string in which to collapse spaces.
 * @return {string} Copy of the string with normalized breaking spaces.
 */
goog.string.collapseBreakingSpaces = function(str) {
  return str.replace(/[\t\r\n ]+/g, ' ').replace(
      /^[\t\r\n ]+|[\t\r\n ]+$/g, '');
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trim = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
};


/**
 * Trims whitespaces at the left end of a string.
 * @param {string} str The string to left trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimLeft = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+/, '');
};


/**
 * Trims whitespaces at the right end of a string.
 * @param {string} str The string to right trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimRight = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+$/, '');
};


/**
 * A string comparator that ignores case.
 * -1 = str1 less than str2
 *  0 = str1 equals str2
 *  1 = str1 greater than str2
 *
 * @param {string} str1 The string to compare.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} The comparator result, as described above.
 */
goog.string.caseInsensitiveCompare = function(str1, str2) {
  var test1 = String(str1).toLowerCase();
  var test2 = String(str2).toLowerCase();

  if (test1 < test2) {
    return -1;
  } else if (test1 == test2) {
    return 0;
  } else {
    return 1;
  }
};


/**
 * Regular expression used for splitting a string into substrings of fractional
 * numbers, integers, and non-numeric characters.
 * @type {RegExp}
 * @private
 */
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;


/**
 * String comparison function that handles numbers in a way humans might expect.
 * Using this function, the string "File 2.jpg" sorts before "File 10.jpg". The
 * comparison is mostly case-insensitive, though strings that are identical
 * except for case are sorted with the upper-case strings before lower-case.
 *
 * This comparison function is significantly slower (about 500x) than either
 * the default or the case-insensitive compare. It should not be used in
 * time-critical code, but should be fast enough to sort several hundred short
 * strings (like filenames) with a reasonable delay.
 *
 * @param {string} str1 The string to compare in a numerically sensitive way.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
 *     0 if str1 > str2.
 */
goog.string.numerateCompare = function(str1, str2) {
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }

  // Using match to split the entire string ahead of time turns out to be faster
  // for most inputs than using RegExp.exec or iterating over each character.
  var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
  var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);

  var count = Math.min(tokens1.length, tokens2.length);

  for (var i = 0; i < count; i++) {
    var a = tokens1[i];
    var b = tokens2[i];

    // Compare pairs of tokens, returning if one token sorts before the other.
    if (a != b) {

      // Only if both tokens are integers is a special comparison required.
      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').
      var num1 = parseInt(a, 10);
      if (!isNaN(num1)) {
        var num2 = parseInt(b, 10);
        if (!isNaN(num2) && num1 - num2) {
          return num1 - num2;
        }
      }
      return a < b ? -1 : 1;
    }
  }

  // If one string is a substring of the other, the shorter string sorts first.
  if (tokens1.length != tokens2.length) {
    return tokens1.length - tokens2.length;
  }

  // The two strings must be equivalent except for case (perfect equality is
  // tested at the head of the function.) Revert to default ASCII-betical string
  // comparison to stablize the sort.
  return str1 < str2 ? -1 : 1;
};


/**
 * URL-encodes a string
 * @param {*} str The string to url-encode.
 * @return {string} An encoded copy of {@code str} that is safe for urls.
 *     Note that '#', ':', and other characters used to delimit portions
 *     of URLs *will* be encoded.
 */
goog.string.urlEncode = function(str) {
  return encodeURIComponent(String(str));
};


/**
 * URL-decodes the string. We need to specially handle '+'s because
 * the javascript library doesn't convert them to spaces.
 * @param {string} str The string to url decode.
 * @return {string} The decoded {@code str}.
 */
goog.string.urlDecode = function(str) {
  return decodeURIComponent(str.replace(/\+/g, ' '));
};


/**
 * Converts \n to <br>s or <br />s.
 * @param {string} str The string in which to convert newlines.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} A copy of {@code str} with converted newlines.
 */
goog.string.newLineToBr = function(str, opt_xml) {
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};


/**
 * Escape double quote '"' characters in addition to '&', '<', and '>' so that a
 * string can be included in an HTML tag attribute value within double quotes.
 *
 * It should be noted that > doesn't need to be escaped for the HTML or XML to
 * be valid, but it has been decided to escape it for consistency with other
 * implementations.
 *
 * NOTE(user):
 * HtmlEscape is often called during the generation of large blocks of HTML.
 * Using statics for the regular expressions and strings is an optimization
 * that can more than half the amount of time IE spends in this function for
 * large apps, since strings and regexes both contribute to GC allocations.
 *
 * Testing for the presence of a character before escaping increases the number
 * of function calls, but actually provides a speed increase for the average
 * case -- since the average case often doesn't require the escaping of all 4
 * characters and indexOf() is much cheaper than replace().
 * The worst case does suffer slightly from the additional calls, therefore the
 * opt_isLikelyToContainHtmlChars option has been included for situations
 * where all 4 HTML entities are very likely to be present and need escaping.
 *
 * Some benchmarks (times tended to fluctuate +-0.05ms):
 *                                     FireFox                     IE6
 * (no chars / average (mix of cases) / all 4 chars)
 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
 *
 * An additional advantage of checking if replace actually needs to be called
 * is a reduction in the number of object allocations, so as the size of the
 * application grows the difference between the various methods would increase.
 *
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
 *     if the character needs replacing - use this option if you expect each of
 *     the characters to appear often. Leave false if you expect few html
 *     characters to occur in your strings, such as if you are escaping HTML.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {

  if (opt_isLikelyToContainHtmlChars) {
    return str.replace(goog.string.amperRe_, '&amp;')
          .replace(goog.string.ltRe_, '&lt;')
          .replace(goog.string.gtRe_, '&gt;')
          .replace(goog.string.quotRe_, '&quot;');

  } else {
    // quick test helps in the case when there are no chars to replace, in
    // worst case this makes barely a difference to the time taken
    if (!goog.string.allRe_.test(str)) return str;

    // str.indexOf is faster than regex.test in this case
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.amperRe_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.ltRe_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.gtRe_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.quotRe_, '&quot;');
    }
    return str;
  }
};


/**
 * Regular expression that matches an ampersand, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.amperRe_ = /&/g;


/**
 * Regular expression that matches a less than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.ltRe_ = /</g;


/**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.gtRe_ = />/g;


/**
 * Regular expression that matches a double quote, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.quotRe_ = /\"/g;


/**
 * Regular expression that matches any character that needs to be escaped.
 * @type {RegExp}
 * @private
 */
goog.string.allRe_ = /[&<>\"]/;


/**
 * Unescapes an HTML string.
 *
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntities = function(str) {
  if (goog.string.contains(str, '&')) {
    // We are careful not to use a DOM if we do not have one. We use the []
    // notation so that the JSCompiler will not complain about these objects and
    // fields in the case where we have no DOM.
    if ('document' in goog.global) {
      return goog.string.unescapeEntitiesUsingDom_(str);
    } else {
      // Fall back on pure XML entities
      return goog.string.unescapePureXmlEntities_(str);
    }
  }
  return str;
};


/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} The unescaped {@code str} string.
 */
goog.string.unescapeEntitiesUsingDom_ = function(str) {
  var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"'};
  var div = document.createElement('div');
  // Match as many valid entity characters as possible. If the actual entity
  // happens to be shorter, it will still work as innerHTML will return the
  // trailing characters unchanged. Since the entity characters do not include
  // open angle bracket, there is no chance of XSS from the innerHTML use.
  // Since no whitespace is passed to innerHTML, whitespace is preserved.
  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
    // Check for cached entity.
    var value = seen[s];
    if (value) {
      return value;
    }
    // Check for numeric entity.
    if (entity.charAt(0) == '#') {
      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
      var n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    // Fall back to innerHTML otherwise.
    if (!value) {
      // Append a non-entity character to avoid a bug in Webkit that parses
      // an invalid entity at the end of innerHTML text as the empty string.
      div.innerHTML = s + ' ';
      // Then remove the trailing character from the result.
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    // Cache and return.
    return seen[s] = value;
  });
};


/**
 * Unescapes XML entities.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapePureXmlEntities_ = function(str) {
  return str.replace(/&([^;]+);/g, function(s, entity) {
    switch (entity) {
      case 'amp':
        return '&';
      case 'lt':
        return '<';
      case 'gt':
        return '>';
      case 'quot':
        return '"';
      default:
        if (entity.charAt(0) == '#') {
          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
          var n = Number('0' + entity.substr(1));
          if (!isNaN(n)) {
            return String.fromCharCode(n);
          }
        }
        // For invalid entities we just return the entity
        return s;
    }
  });
};


/**
 * Regular expression that matches an HTML entity.
 * See also HTML5: Tokenization / Tokenizing character references.
 * @private
 * @type {!RegExp}
 */
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;


/**
 * Do escaping of whitespace to preserve spatial formatting. We use character
 * entity #160 to make it safer for xml.
 * @param {string} str The string in which to escape whitespace.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.whitespaceEscape = function(str, opt_xml) {
  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
};


/**
 * Strip quote characters around a string.  The second argument is a string of
 * characters to treat as quotes.  This can be a single character or a string of
 * multiple character and in that case each of those are treated as possible
 * quote characters. For example:
 *
 * <pre>
 * goog.string.stripQuotes('"abc"', '"`') --> 'abc'
 * goog.string.stripQuotes('`abc`', '"`') --> 'abc'
 * </pre>
 *
 * @param {string} str The string to strip.
 * @param {string} quoteChars The quote characters to strip.
 * @return {string} A copy of {@code str} without the quotes.
 */
goog.string.stripQuotes = function(str, quoteChars) {
  var length = quoteChars.length;
  for (var i = 0; i < length; i++) {
    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
      return str.substring(1, str.length - 1);
    }
  }
  return str;
};


/**
 * Truncates a string to a certain length and adds '...' if necessary.  The
 * length also accounts for the ellipsis, so a maximum length of 10 and a string
 * 'Hello World!' produces 'Hello W...'.
 * @param {string} str The string to truncate.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cut off in the middle.
 * @return {string} The truncated {@code str} string.
 */
goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (str.length > chars) {
    str = str.substring(0, chars - 3) + '...';
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Truncate a string in the middle, adding "..." if necessary,
 * and favoring the beginning of the string.
 * @param {string} str The string to truncate the middle of.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cutoff in the middle.
 * @param {number=} opt_trailingChars Optional number of trailing characters to
 *     leave at the end of the string, instead of truncating as close to the
 *     middle as possible.
 * @return {string} A truncated copy of {@code str}.
 */
goog.string.truncateMiddle = function(str, chars,
    opt_protectEscapedCharacters, opt_trailingChars) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (opt_trailingChars && str.length > chars) {
    if (opt_trailingChars > chars) {
      opt_trailingChars = chars;
    }
    var endPoint = str.length - opt_trailingChars;
    var startPoint = chars - opt_trailingChars;
    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
  } else if (str.length > chars) {
    // Favor the beginning of the string:
    var half = Math.floor(chars / 2);
    var endPos = str.length - half;
    half += chars % 2;
    str = str.substring(0, half) + '...' + str.substring(endPos);
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Special chars that need to be escaped for goog.string.quote.
 * @private
 * @type {Object}
 */
goog.string.specialEscapeChars_ = {
  '\0': '\\0',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\x0B': '\\x0B', // '\v' is not supported in JScript
  '"': '\\"',
  '\\': '\\\\'
};


/**
 * Character mappings used internally for goog.string.escapeChar.
 * @private
 * @type {Object}
 */
goog.string.jsEscapeCache_ = {
  '\'': '\\\''
};


/**
 * Encloses a string in double quotes and escapes characters so that the
 * string is a valid JS string.
 * @param {string} s The string to quote.
 * @return {string} A copy of {@code s} surrounded by double quotes.
 */
goog.string.quote = function(s) {
  s = String(s);
  if (s.quote) {
    return s.quote();
  } else {
    var sb = ['"'];
    for (var i = 0; i < s.length; i++) {
      var ch = s.charAt(i);
      var cc = ch.charCodeAt(0);
      sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
          ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));
    }
    sb.push('"');
    return sb.join('');
  }
};


/**
 * Takes a string and returns the escaped string for that character.
 * @param {string} str The string to escape.
 * @return {string} An escaped string representing {@code str}.
 */
goog.string.escapeString = function(str) {
  var sb = [];
  for (var i = 0; i < str.length; i++) {
    sb[i] = goog.string.escapeChar(str.charAt(i));
  }
  return sb.join('');
};


/**
 * Takes a character and returns the escaped string for that character. For
 * example escapeChar(String.fromCharCode(15)) -> "\\x0E".
 * @param {string} c The character to escape.
 * @return {string} An escaped string representing {@code c}.
 */
goog.string.escapeChar = function(c) {
  if (c in goog.string.jsEscapeCache_) {
    return goog.string.jsEscapeCache_[c];
  }

  if (c in goog.string.specialEscapeChars_) {
    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
  }

  var rv = c;
  var cc = c.charCodeAt(0);
  if (cc > 31 && cc < 127) {
    rv = c;
  } else {
    // tab is 9 but handled above
    if (cc < 256) {
      rv = '\\x';
      if (cc < 16 || cc > 256) {
        rv += '0';
      }
    } else {
      rv = '\\u';
      if (cc < 4096) { // \u1000
        rv += '0';
      }
    }
    rv += cc.toString(16).toUpperCase();
  }

  return goog.string.jsEscapeCache_[c] = rv;
};


/**
 * Takes a string and creates a map (Object) in which the keys are the
 * characters in the string. The value for the key is set to true. You can
 * then use goog.object.map or goog.array.map to change the values.
 * @param {string} s The string to build the map from.
 * @return {Object} The map of characters used.
 */
// TODO(arv): It seems like we should have a generic goog.array.toMap. But do
//            we want a dependency on goog.array in goog.string?
goog.string.toMap = function(s) {
  var rv = {};
  for (var i = 0; i < s.length; i++) {
    rv[s.charAt(i)] = true;
  }
  return rv;
};


/**
 * Checks whether a string contains a given substring.
 * @param {string} s The string to test.
 * @param {string} ss The substring to test for.
 * @return {boolean} True if {@code s} contains {@code ss}.
 */
goog.string.contains = function(s, ss) {
  return s.indexOf(ss) != -1;
};


/**
 * Returns the non-overlapping occurrences of ss in s.
 * If either s or ss evalutes to false, then returns zero.
 * @param {string} s The string to look in.
 * @param {string} ss The string to look for.
 * @return {number} Number of occurrences of ss in s.
 */
goog.string.countOf = function(s, ss) {
  return s && ss ? s.split(ss).length - 1 : 0;
};


/**
 * Removes a substring of a specified length at a specific
 * index in a string.
 * @param {string} s The base string from which to remove.
 * @param {number} index The index at which to remove the substring.
 * @param {number} stringLength The length of the substring to remove.
 * @return {string} A copy of {@code s} with the substring removed or the full
 *     string if nothing is removed or the input is invalid.
 */
goog.string.removeAt = function(s, index, stringLength) {
  var resultStr = s;
  // If the index is greater or equal to 0 then remove substring
  if (index >= 0 && index < s.length && stringLength > 0) {
    resultStr = s.substr(0, index) +
        s.substr(index + stringLength, s.length - index - stringLength);
  }
  return resultStr;
};


/**
 *  Removes the first occurrence of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.remove = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), '');
  return s.replace(re, '');
};


/**
 *  Removes all occurrences of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.removeAll = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), 'g');
  return s.replace(re, '');
};


/**
 * Escapes characters in the string that are not safe to use in a RegExp.
 * @param {*} s The string to escape. If not a string, it will be casted
 *     to one.
 * @return {string} A RegExp safe, escaped copy of {@code s}.
 */
goog.string.regExpEscape = function(s) {
  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
      replace(/\x08/g, '\\x08');
};


/**
 * Repeats a string n times.
 * @param {string} string The string to repeat.
 * @param {number} length The number of times to repeat.
 * @return {string} A string containing {@code length} repetitions of
 *     {@code string}.
 */
goog.string.repeat = function(string, length) {
  return new Array(length + 1).join(string);
};


/**
 * Pads number to given length and optionally rounds it to a given precision.
 * For example:
 * <pre>padNumber(1.25, 2, 3) -> '01.250'
 * padNumber(1.25, 2) -> '01.25'
 * padNumber(1.25, 2, 1) -> '01.3'
 * padNumber(1.25, 0) -> '1.25'</pre>
 *
 * @param {number} num The number to pad.
 * @param {number} length The desired length.
 * @param {number=} opt_precision The desired precision.
 * @return {string} {@code num} as a string with the given options.
 */
goog.string.padNumber = function(num, length, opt_precision) {
  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
  var index = s.indexOf('.');
  if (index == -1) {
    index = s.length;
  }
  return goog.string.repeat('0', Math.max(0, length - index)) + s;
};


/**
 * Returns a string representation of the given object, with
 * null and undefined being returned as the empty string.
 *
 * @param {*} obj The object to convert.
 * @return {string} A string representation of the {@code obj}.
 */
goog.string.makeSafe = function(obj) {
  return obj == null ? '' : String(obj);
};


/**
 * Concatenates string expressions. This is useful
 * since some browsers are very inefficient when it comes to using plus to
 * concat strings. Be careful when using null and undefined here since
 * these will not be included in the result. If you need to represent these
 * be sure to cast the argument to a String first.
 * For example:
 * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'
 * buildString(null, undefined) -> ''
 * </pre>
 * @param {...*} var_args A list of strings to concatenate. If not a string,
 *     it will be casted to one.
 * @return {string} The concatenation of {@code var_args}.
 */
goog.string.buildString = function(var_args) {
  return Array.prototype.join.call(arguments, '');
};


/**
 * Returns a string with at least 64-bits of randomness.
 *
 * Doesn't trust Javascript's random function entirely. Uses a combination of
 * random and current timestamp, and then encodes the string in base-36 to
 * make it shorter.
 *
 * @return {string} A random string, e.g. sn1s7vb4gcic.
 */
goog.string.getRandomString = function() {
  var x = 2147483648;
  return Math.floor(Math.random() * x).toString(36) +
         Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if {@code version1} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code version2} is higher.
 */
goog.string.compareVersions = function(version1, version2) {
  var order = 0;
  // Trim leading and trailing whitespace and split the versions into
  // subversions.
  var v1Subs = goog.string.trim(String(version1)).split('.');
  var v2Subs = goog.string.trim(String(version2)).split('.');
  var subCount = Math.max(v1Subs.length, v2Subs.length);

  // Iterate over the subversions, as long as they appear to be equivalent.
  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    var v1Sub = v1Subs[subIdx] || '';
    var v2Sub = v2Subs[subIdx] || '';

    // Split the subversions into pairs of numbers and qualifiers (like 'b').
    // Two different RegExp objects are needed because they are both using
    // the 'g' flag.
    var v1CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    var v2CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    do {
      var v1Comp = v1CompParser.exec(v1Sub) || ['', '', ''];
      var v2Comp = v2CompParser.exec(v2Sub) || ['', '', ''];
      // Break if there are no more matches.
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }

      // Parse the numeric part of the subversion. A missing number is
      // equivalent to 0.
      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);

      // Compare the subversion components. The number has the highest
      // precedence. Next, if the numbers are equal, a subversion without any
      // qualifier is always higher than a subversion with any qualifier. Next,
      // the qualifiers are compared as strings.
      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
          goog.string.compareElements_(v1Comp[2].length == 0,
              v2Comp[2].length == 0) ||
          goog.string.compareElements_(v1Comp[2], v2Comp[2]);
      // Stop as soon as an inequality is discovered.
    } while (order == 0);
  }

  return order;
};


/**
 * Compares elements of a version number.
 *
 * @param {string|number|boolean} left An element from a version number.
 * @param {string|number|boolean} right An element from a version number.
 *
 * @return {number}  1 if {@code left} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code right} is higher.
 * @private
 */
goog.string.compareElements_ = function(left, right) {
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};


/**
 * Maximum value of #goog.string.hashCode, exclusive. 2^32.
 * @type {number}
 * @private
 */
goog.string.HASHCODE_MAX_ = 0x100000000;


/**
 * String hash function similar to java.lang.String.hashCode().
 * The hash code for a string is computed as
 * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
 * where s[i] is the ith character of the string and n is the length of
 * the string. We mod the result to make it between 0 (inclusive) and 2^32
 * (exclusive).
 * @param {string} str A string.
 * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32
 *  (exclusive). The empty string returns 0.
 */
goog.string.hashCode = function(str) {
  var result = 0;
  for (var i = 0; i < str.length; ++i) {
    result = 31 * result + str.charCodeAt(i);
    // Normalize to 4 byte range, 0 ... 2^32.
    result %= goog.string.HASHCODE_MAX_;
  }
  return result;
};


/**
 * The most recent unique ID. |0 is equivalent to Math.floor in this case.
 * @type {number}
 * @private
 */
goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;


/**
 * Generates and returns a string which is unique in the current document.
 * This is useful, for example, to create unique IDs for DOM elements.
 * @return {string} A unique id.
 */
goog.string.createUniqueString = function() {
  return 'goog_' + goog.string.uniqueStringCounter_++;
};


/**
 * Converts the supplied string to a number, which may be Ininity or NaN.
 * This function strips whitespace: (toNumber(' 123') === 123)
 * This function accepts scientific notation: (toNumber('1e1') === 10)
 *
 * This is better than Javascript's built-in conversions because, sadly:
 *     (Number(' ') === 0) and (parseFloat('123a') === 123)
 *
 * @param {string} str The string to convert.
 * @return {number} The number the supplied string represents, or NaN.
 */
goog.string.toNumber = function(str) {
  var num = Number(str);
  if (num == 0 && goog.string.isEmpty(str)) {
    return NaN;
  }
  return num;
};


/**
 * Converts a string from selector-case to camelCase (e.g. from
 * "multi-part-string" to "multiPartString"), useful for converting
 * CSS selectors and HTML dataset keys to their equivalent JS properties.
 * @param {string} str The string in selector-case form.
 * @return {string} The string in camelCase form.
 */
goog.string.toCamelCase = function(str) {
  return String(str).replace(/\-([a-z])/g, function(all, match) {
    return match.toUpperCase();
  });
};


/**
 * Converts a string from camelCase to selector-case (e.g. from
 * "multiPartString" to "multi-part-string"), useful for converting JS
 * style and dataset properties to equivalent CSS selectors and HTML keys.
 * @param {string} str The string in camelCase form.
 * @return {string} The string in selector-case form.
 */
goog.string.toSelectorCase = function(str) {
  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
};


/**
 * Converts a string into TitleCase. First character of the string is always
 * capitalized in addition to the first letter of every subsequent word.
 * Words are delimited by one or more whitespaces by default. Custom delimiters
 * can optionally be specified to replace the default, which doesn't preserve
 * whitespace delimiters and instead must be explicitly included if needed.
 *
 * Default delimiter => " ":
 *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three')  => 'One Two Three'
 *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '
 *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'
 *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'
 *
 * Custom delimiter => "_-.":
 *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'
 *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '
 *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'
 *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'
 *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'
 *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'
 *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'
 *
 * @param {string} str String value in camelCase form.
 * @param {string=} opt_delimiters Custom delimiter character set used to
 *      distinguish words in the string value. Each character represents a
 *      single delimiter. When provided, default whitespace delimiter is
 *      overridden and must be explicitly included if needed.
 * @return {string} String value in TitleCase form.
 */
goog.string.toTitleCase = function(str, opt_delimiters) {
  var delimiters = goog.isString(opt_delimiters) ?
      goog.string.regExpEscape(opt_delimiters) : '\\s';

  // For IE8, we need to prevent using an empty character set. Otherwise,
  // incorrect matching will occur.
  delimiters = delimiters ? '|[' + delimiters + ']+' : '';

  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
  return str.replace(regexp, function(all, p1, p2) {
    return p1 + p2.toUpperCase();
  });
};


/**
 * Parse a string in decimal or hexidecimal ('0xFFFF') form.
 *
 * To parse a particular radix, please use parseInt(string, radix) directly. See
 * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
 *
 * This is a wrapper for the built-in parseInt function that will only parse
 * numbers as base 10 or base 16.  Some JS implementations assume strings
 * starting with "0" are intended to be octal. ES3 allowed but discouraged
 * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.
 *
 * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj
 *
 * @param {string|number|null|undefined} value The value to be parsed.
 * @return {number} The number, parsed. If the string failed to parse, this
 *     will be NaN.
 */
goog.string.parseInt = function(value) {
  // Force finite numbers to strings.
  if (isFinite(value)) {
    value = String(value);
  }

  if (goog.isString(value)) {
    // If the string starts with '0x' or '-0x', parse as hex.
    return /^\s*-?0x/i.test(value) ?
        parseInt(value, 16) : parseInt(value, 10);
  }

  return NaN;
};


// node_modules/closure-library/goog/useragent/useragent.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Rendering engine detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For information on the browser brand (such as Safari versus Chrome), see
 * goog.userAgent.product.
 * @see ../demos/useragent.html
 */

goog.provide('goog.userAgent');

goog.require('goog.string');


/**
 * @define {boolean} Whether we know at compile-time that the browser is IE.
 */
goog.userAgent.ASSUME_IE = false;


/**
 * @define {boolean} Whether we know at compile-time that the browser is GECKO.
 */
goog.userAgent.ASSUME_GECKO = false;


/**
 * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
 */
goog.userAgent.ASSUME_WEBKIT = false;


/**
 * @define {boolean} Whether we know at compile-time that the browser is a
 *     mobile device running WebKit e.g. iPhone or Android.
 */
goog.userAgent.ASSUME_MOBILE_WEBKIT = false;


/**
 * @define {boolean} Whether we know at compile-time that the browser is OPERA.
 */
goog.userAgent.ASSUME_OPERA = false;


/**
 * @define {boolean} Whether the {@code goog.userAgent.isVersion} function will
 *     return true for any version.
 */
goog.userAgent.ASSUME_ANY_VERSION = false;


/**
 * Whether we know the browser engine at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.BROWSER_KNOWN_ =
    goog.userAgent.ASSUME_IE ||
    goog.userAgent.ASSUME_GECKO ||
    goog.userAgent.ASSUME_MOBILE_WEBKIT ||
    goog.userAgent.ASSUME_WEBKIT ||
    goog.userAgent.ASSUME_OPERA;


/**
 * Returns the userAgent string for the current browser.
 * Some user agents (I'm thinking of you, Gears WorkerPool) do not expose a
 * navigator object off the global scope.  In that case we return null.
 *
 * @return {?string} The userAgent string or null if there is none.
 */
goog.userAgent.getUserAgentString = function() {
  return goog.global['navigator'] ? goog.global['navigator'].userAgent : null;
};


/**
 * @return {Object} The native navigator object.
 */
goog.userAgent.getNavigator = function() {
  // Need a local navigator reference instead of using the global one,
  // to avoid the rare case where they reference different objects.
  // (in a WorkerPool, for example).
  return goog.global['navigator'];
};


/**
 * Initializer for goog.userAgent.
 *
 * This is a named function so that it can be stripped via the jscompiler
 * option for stripping types.
 * @private
 */
goog.userAgent.init_ = function() {
  /**
   * Whether the user agent string denotes Opera.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedOpera_ = false;

  /**
   * Whether the user agent string denotes Internet Explorer. This includes
   * other browsers using Trident as its rendering engine. For example AOL
   * and Netscape 8
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIe_ = false;

  /**
   * Whether the user agent string denotes WebKit. WebKit is the rendering
   * engine that Safari, Android and others use.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedWebkit_ = false;

  /**
   * Whether the user agent string denotes a mobile device.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedMobile_ = false;

  /**
   * Whether the user agent string denotes Gecko. Gecko is the rendering
   * engine used by Mozilla, Mozilla Firefox, Camino and many more.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedGecko_ = false;

  var ua;
  if (!goog.userAgent.BROWSER_KNOWN_ &&
      (ua = goog.userAgent.getUserAgentString())) {
    var navigator = goog.userAgent.getNavigator();
    goog.userAgent.detectedOpera_ = ua.indexOf('Opera') == 0;
    goog.userAgent.detectedIe_ = !goog.userAgent.detectedOpera_ &&
        ua.indexOf('MSIE') != -1;
    goog.userAgent.detectedWebkit_ = !goog.userAgent.detectedOpera_ &&
        ua.indexOf('WebKit') != -1;
    // WebKit also gives navigator.product string equal to 'Gecko'.
    goog.userAgent.detectedMobile_ = goog.userAgent.detectedWebkit_ &&
        ua.indexOf('Mobile') != -1;
    goog.userAgent.detectedGecko_ = !goog.userAgent.detectedOpera_ &&
        !goog.userAgent.detectedWebkit_ && navigator.product == 'Gecko';
  }
};


if (!goog.userAgent.BROWSER_KNOWN_) {
  goog.userAgent.init_();
}


/**
 * Whether the user agent is Opera.
 * @type {boolean}
 */
goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_OPERA : goog.userAgent.detectedOpera_;


/**
 * Whether the user agent is Internet Explorer. This includes other browsers
 * using Trident as its rendering engine. For example AOL and Netscape 8
 * @type {boolean}
 */
goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_IE : goog.userAgent.detectedIe_;


/**
 * Whether the user agent is Gecko. Gecko is the rendering engine used by
 * Mozilla, Mozilla Firefox, Camino and many more.
 * @type {boolean}
 */
goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_GECKO :
    goog.userAgent.detectedGecko_;


/**
 * Whether the user agent is WebKit. WebKit is the rendering engine that
 * Safari, Android and others use.
 * @type {boolean}
 */
goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :
    goog.userAgent.detectedWebkit_;


/**
 * Whether the user agent is running on a mobile device.
 * @type {boolean}
 */
goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT ||
                        goog.userAgent.detectedMobile_;


/**
 * Used while transitioning code to use WEBKIT instead.
 * @type {boolean}
 * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.
 * TODO(nicksantos): Delete this from goog.userAgent.
 */
goog.userAgent.SAFARI = goog.userAgent.WEBKIT;


/**
 * @return {string} the platform (operating system) the user agent is running
 *     on. Default to empty string because navigator.platform may not be defined
 *     (on Rhino, for example).
 * @private
 */
goog.userAgent.determinePlatform_ = function() {
  var navigator = goog.userAgent.getNavigator();
  return navigator && navigator.platform || '';
};


/**
 * The platform (operating system) the user agent is running on. Default to
 * empty string because navigator.platform may not be defined (on Rhino, for
 * example).
 * @type {string}
 */
goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();


/**
 * @define {boolean} Whether the user agent is running on a Macintosh operating
 *     system.
 */
goog.userAgent.ASSUME_MAC = false;


/**
 * @define {boolean} Whether the user agent is running on a Windows operating
 *     system.
 */
goog.userAgent.ASSUME_WINDOWS = false;


/**
 * @define {boolean} Whether the user agent is running on a Linux operating
 *     system.
 */
goog.userAgent.ASSUME_LINUX = false;


/**
 * @define {boolean} Whether the user agent is running on a X11 windowing
 *     system.
 */
goog.userAgent.ASSUME_X11 = false;


/**
 * @type {boolean}
 * @private
 */
goog.userAgent.PLATFORM_KNOWN_ =
    goog.userAgent.ASSUME_MAC ||
    goog.userAgent.ASSUME_WINDOWS ||
    goog.userAgent.ASSUME_LINUX ||
    goog.userAgent.ASSUME_X11;


/**
 * Initialize the goog.userAgent constants that define which platform the user
 * agent is running on.
 * @private
 */
goog.userAgent.initPlatform_ = function() {
  /**
   * Whether the user agent is running on a Macintosh operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedMac_ = goog.string.contains(goog.userAgent.PLATFORM,
      'Mac');

  /**
   * Whether the user agent is running on a Windows operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedWindows_ = goog.string.contains(
      goog.userAgent.PLATFORM, 'Win');

  /**
   * Whether the user agent is running on a Linux operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedLinux_ = goog.string.contains(goog.userAgent.PLATFORM,
      'Linux');

  /**
   * Whether the user agent is running on a X11 windowing system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedX11_ = !!goog.userAgent.getNavigator() &&
      goog.string.contains(goog.userAgent.getNavigator()['appVersion'] || '',
          'X11');
};


if (!goog.userAgent.PLATFORM_KNOWN_) {
  goog.userAgent.initPlatform_();
}


/**
 * Whether the user agent is running on a Macintosh operating system.
 * @type {boolean}
 */
goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_MAC : goog.userAgent.detectedMac_;


/**
 * Whether the user agent is running on a Windows operating system.
 * @type {boolean}
 */
goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_WINDOWS : goog.userAgent.detectedWindows_;


/**
 * Whether the user agent is running on a Linux operating system.
 * @type {boolean}
 */
goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_LINUX : goog.userAgent.detectedLinux_;


/**
 * Whether the user agent is running on a X11 windowing system.
 * @type {boolean}
 */
goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_X11 : goog.userAgent.detectedX11_;


/**
 * @return {string} The string that describes the version number of the user
 *     agent.
 * @private
 */
goog.userAgent.determineVersion_ = function() {
  // All browsers have different ways to detect the version and they all have
  // different naming schemes.

  // version is a string rather than a number because it may contain 'b', 'a',
  // and so on.
  var version = '', re;

  if (goog.userAgent.OPERA && goog.global['opera']) {
    var operaVersion = goog.global['opera'].version;
    version = typeof operaVersion == 'function' ? operaVersion() : operaVersion;
  } else {
    if (goog.userAgent.GECKO) {
      re = /rv\:([^\);]+)(\)|;)/;
    } else if (goog.userAgent.IE) {
      re = /MSIE\s+([^\);]+)(\)|;)/;
    } else if (goog.userAgent.WEBKIT) {
      // WebKit/125.4
      re = /WebKit\/(\S+)/;
    }
    if (re) {
      var arr = re.exec(goog.userAgent.getUserAgentString());
      version = arr ? arr[1] : '';
    }
  }
  if (goog.userAgent.IE) {
    // IE9 can be in document mode 9 but be reporting an inconsistent user agent
    // version.  If it is identifying as a version lower than 9 we take the
    // documentMode as the version instead.  IE8 has similar behavior.
    // It is recommended to set the X-UA-Compatible header to ensure that IE9
    // uses documentMode 9.
    var docMode = goog.userAgent.getDocumentMode_();
    if (docMode > parseFloat(version)) {
      return String(docMode);
    }
  }
  return version;
};


/**
 * @return {number|undefined} Returns the document mode (for testing).
 * @private
 */
goog.userAgent.getDocumentMode_ = function() {
  // NOTE(user): goog.userAgent may be used in context where there is no DOM.
  var doc = goog.global['document'];
  return doc ? doc['documentMode'] : undefined;
};


/**
 * The version of the user agent. This is a string because it might contain
 * 'b' (as in beta) as well as multiple dots.
 * @type {string}
 */
goog.userAgent.VERSION = goog.userAgent.determineVersion_();


/**
 * Compares two version numbers.
 *
 * @param {string} v1 Version of first item.
 * @param {string} v2 Version of second item.
 *
 * @return {number}  1 if first argument is higher
 *                   0 if arguments are equal
 *                  -1 if second argument is higher.
 * @deprecated Use goog.string.compareVersions.
 */
goog.userAgent.compare = function(v1, v2) {
  return goog.string.compareVersions(v1, v2);
};


/**
 * Cache for {@link goog.userAgent.isVersion}. Calls to compareVersions are
 * surprisingly expensive and as a browsers version number is unlikely to change
 * during a session we cache the results.
 * @type {Object}
 * @private
 */
goog.userAgent.isVersionCache_ = {};


/**
 * Whether the user agent version is higher or the same as the given version.
 * NOTE: When checking the version numbers for Firefox and Safari, be sure to
 * use the engine's version, not the browser's version number.  For example,
 * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.
 * Opera and Internet Explorer versions match the product release number.<br>
 * @see <a href="http://en.wikipedia.org/wiki/Safari_version_history">
 *     Webkit</a>
 * @see <a href="http://en.wikipedia.org/wiki/Gecko_engine">Gecko</a>
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 */
goog.userAgent.isVersion = function(version) {
  return goog.userAgent.ASSUME_ANY_VERSION ||
      goog.userAgent.isVersionCache_[version] ||
      (goog.userAgent.isVersionCache_[version] =
          goog.string.compareVersions(goog.userAgent.VERSION, version) >= 0);
};


/**
 * Cache for {@link goog.userAgent.isDocumentMode}.
 * Browsers document mode version number is unlikely to change during a session
 * we cache the results.
 * @type {Object}
 * @private
 */
goog.userAgent.isDocumentModeCache_ = {};


/**
 * Whether the IE effective document mode is higher or the same as the given
 * document mode version.
 * NOTE: Only for IE, return false for another browser.
 *
 * @param {number} documentMode The document mode version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *     same as the given version.
 */
goog.userAgent.isDocumentMode = function(documentMode) {
  return goog.userAgent.isDocumentModeCache_[documentMode] ||
      (goog.userAgent.isDocumentModeCache_[documentMode] = goog.userAgent.IE &&
      !!document.documentMode && document.documentMode >= documentMode);
};


// node_modules/closure-library/goog/debug/error.js
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
 * sufficient.
 *
 */

goog.provide('goog.debug.Error');



/**
 * Base class for custom error objects.
 * @param {*=} opt_msg The message associated with the error.
 * @constructor
 * @extends {Error}
 */
goog.debug.Error = function(opt_msg) {

  // Ensure there is a stack trace.
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, goog.debug.Error);
  } else {
    this.stack = new Error().stack || '';
  }

  if (opt_msg) {
    this.message = String(opt_msg);
  }
};
goog.inherits(goog.debug.Error, Error);


/** @override */
goog.debug.Error.prototype.name = 'CustomError';


// node_modules/closure-library/goog/asserts/asserts.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package should be given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will restrict <code>foo</code> to a truthy value.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 */

goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');

goog.require('goog.debug.Error');
goog.require('goog.string');


/**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */
goog.asserts.ENABLE_ASSERTS = goog.DEBUG;



/**
 * Error object for failed assertions.
 * @param {string} messagePattern The pattern that was used to form message.
 * @param {!Array.<*>} messageArgs The items to substitute into the pattern.
 * @constructor
 * @extends {goog.debug.Error}
 */
goog.asserts.AssertionError = function(messagePattern, messageArgs) {
  messageArgs.unshift(messagePattern);
  goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
  // Remove the messagePattern afterwards to avoid permenantly modifying the
  // passed in array.
  messageArgs.shift();

  /**
   * The message pattern used to format the error message. Error handlers can
   * use this to uniquely identify the assertion.
   * @type {string}
   */
  this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);


/** @override */
goog.asserts.AssertionError.prototype.name = 'AssertionError';


/**
 * Throws an exception with the given message and "Assertion failed" prefixed
 * onto it.
 * @param {string} defaultMessage The message to use if givenMessage is empty.
 * @param {Array.<*>} defaultArgs The substitution arguments for defaultMessage.
 * @param {string|undefined} givenMessage Message supplied by the caller.
 * @param {Array.<*>} givenArgs The substitution arguments for givenMessage.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 * @private
 */
goog.asserts.doAssertFailure_ =
    function(defaultMessage, defaultArgs, givenMessage, givenArgs) {
  var message = 'Assertion failed';
  if (givenMessage) {
    message += ': ' + givenMessage;
    var args = givenArgs;
  } else if (defaultMessage) {
    message += ': ' + defaultMessage;
    args = defaultArgs;
  }
  // The '' + works around an Opera 10 bug in the unit tests. Without it,
  // a stack trace is added to var message above. With this, a stack trace is
  // not added until this line (it causes the extra garbage to be added after
  // the assertion message instead of in the middle of it).
  throw new goog.asserts.AssertionError('' + message, args || []);
};


/**
 * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
 * true.
 * @param {*} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {*} The value of the condition.
 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
 */
goog.asserts.assert = function(condition, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !condition) {
    goog.asserts.doAssertFailure_('', null, opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};


/**
 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
 * when we want to add a check in the unreachable area like switch-case
 * statement:
 *
 * <pre>
 *  switch(type) {
 *    case FOO: doSomething(); break;
 *    case BAR: doSomethingElse(); break;
 *    default: goog.assert.fail('Unrecognized type: ' + type);
 *      // We have only 2 types - "default:" section is unreachable code.
 *  }
 * </pre>
 *
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} Failure.
 */
goog.asserts.fail = function(opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS) {
    throw new goog.asserts.AssertionError(
        'Failure' + (opt_message ? ': ' + opt_message : ''),
        Array.prototype.slice.call(arguments, 1));
  }
};


/**
 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {number} The value, guaranteed to be a number when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 */
goog.asserts.assertNumber = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
    goog.asserts.doAssertFailure_('Expected number but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {number} */ (value);
};


/**
 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {string} The value, guaranteed to be a string when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a string.
 */
goog.asserts.assertString = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
    goog.asserts.doAssertFailure_('Expected string but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {string} */ (value);
};


/**
 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Function} The value, guaranteed to be a function when asserts
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a function.
 */
goog.asserts.assertFunction = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
    goog.asserts.doAssertFailure_('Expected function but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Function} */ (value);
};


/**
 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Object} The value, guaranteed to be a non-null object.
 * @throws {goog.asserts.AssertionError} When the value is not an object.
 */
goog.asserts.assertObject = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
    goog.asserts.doAssertFailure_('Expected object but got %s: %s.',
        [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Object} */ (value);
};


/**
 * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Array} The value, guaranteed to be a non-null array.
 * @throws {goog.asserts.AssertionError} When the value is not an array.
 */
goog.asserts.assertArray = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
    goog.asserts.doAssertFailure_('Expected array but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Array} */ (value);
};


/**
 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {boolean} The value, guaranteed to be a boolean when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */
goog.asserts.assertBoolean = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
    goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {boolean} */ (value);
};


/**
 * Checks if the value is an instance of the user-defined type if
 * goog.asserts.ENABLE_ASSERTS is true.
 *
 * The compiler may tighten the type returned by this function.
 *
 * @param {*} value The value to check.
 * @param {!Function} type A user-defined constructor.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} When the value is not an instance of
 *     type.
 * @return {!Object}
 */
goog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
    goog.asserts.doAssertFailure_('instanceof check failed.', null,
        opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return /** @type {!Object} */(value);
};



// node_modules/closure-library/goog/uri/utils.js
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Simple utilities for dealing with URI strings.
 *
 * This is intended to be a lightweight alternative to constructing goog.Uri
 * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless
 * of how much of its functionality you use, this is designed to be a set of
 * mostly-independent utilities so that the compiler includes only what is
 * necessary for the task.  Estimated savings of porting is 5k pre-gzip and
 * 1.5k post-gzip.  To ensure the savings remain, future developers should
 * avoid adding new functionality to existing functions, but instead create
 * new ones and factor out shared code.
 *
 * Many of these utilities have limited functionality, tailored to common
 * cases.  The query parameter utilities assume that the parameter keys are
 * already encoded, since most keys are compile-time alphanumeric strings.  The
 * query parameter mutation utilities also do not tolerate fragment identifiers.
 *
 * By design, these functions can be slower than goog.Uri equivalents.
 * Repeated calls to some of functions may be quadratic in behavior for IE,
 * although the effect is somewhat limited given the 2kb limit.
 *
 * One advantage of the limited functionality here is that this approach is
 * less sensitive to differences in URI encodings than goog.Uri, since these
 * functions modify the strings in place, rather than decoding and
 * re-encoding.
 *
 * Uses features of RFC 3986 for parsing/formatting URIs:
 *   http://gbiv.com/protocols/uri/rfc/rfc3986.html
 *
 * @author gboyer@google.com (Garrett Boyer) - The "lightened" design.
 * @author msamuel@google.com (Mike Samuel) - Domain knowledge and regexes.
 */

goog.provide('goog.uri.utils');
goog.provide('goog.uri.utils.ComponentIndex');
goog.provide('goog.uri.utils.QueryArray');
goog.provide('goog.uri.utils.QueryValue');
goog.provide('goog.uri.utils.StandardQueryParam');

goog.require('goog.asserts');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Character codes inlined to avoid object allocations due to charCode.
 * @enum {number}
 * @private
 */
goog.uri.utils.CharCode_ = {
  AMPERSAND: 38,
  EQUAL: 61,
  HASH: 35,
  QUESTION: 63
};


/**
 * Builds a URI string from already-encoded parts.
 *
 * No encoding is performed.  Any component may be omitted as either null or
 * undefined.
 *
 * @param {?string=} opt_scheme The scheme such as 'http'.
 * @param {?string=} opt_userInfo The user name before the '@'.
 * @param {?string=} opt_domain The domain such as 'www.google.com', already
 *     URI-encoded.
 * @param {(string|number|null)=} opt_port The port number.
 * @param {?string=} opt_path The path, already URI-encoded.  If it is not
 *     empty, it must begin with a slash.
 * @param {?string=} opt_queryData The URI-encoded query data.
 * @param {?string=} opt_fragment The URI-encoded fragment identifier.
 * @return {string} The fully combined URI.
 */
goog.uri.utils.buildFromEncodedParts = function(opt_scheme, opt_userInfo,
    opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
  var out = [];

  if (opt_scheme) {
    out.push(opt_scheme, ':');
  }

  if (opt_domain) {
    out.push('//');

    if (opt_userInfo) {
      out.push(opt_userInfo, '@');
    }

    out.push(opt_domain);

    if (opt_port) {
      out.push(':', opt_port);
    }
  }

  if (opt_path) {
    out.push(opt_path);
  }

  if (opt_queryData) {
    out.push('?', opt_queryData);
  }

  if (opt_fragment) {
    out.push('#', opt_fragment);
  }

  return out.join('');
};


/**
 * A regular expression for breaking a URI into its component parts.
 *
 * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
 * As the "first-match-wins" algorithm is identical to the "greedy"
 * disambiguation method used by POSIX regular expressions, it is natural and
 * commonplace to use a regular expression for parsing the potential five
 * components of a URI reference.
 *
 * The following line is the regular expression for breaking-down a
 * well-formed URI reference into its components.
 *
 * <pre>
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 * </pre>
 *
 * The numbers in the second line above are only to assist readability; they
 * indicate the reference points for each subexpression (i.e., each paired
 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
 * For example, matching the above expression to
 * <pre>
 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
 * </pre>
 * results in the following subexpression matches:
 * <pre>
 *    $1 = http:
 *    $2 = http
 *    $3 = //www.ics.uci.edu
 *    $4 = www.ics.uci.edu
 *    $5 = /pub/ietf/uri/
 *    $6 = <undefined>
 *    $7 = <undefined>
 *    $8 = #Related
 *    $9 = Related
 * </pre>
 * where <undefined> indicates that the component is not present, as is the
 * case for the query component in the above example. Therefore, we can
 * determine the value of the five components as
 * <pre>
 *    scheme    = $2
 *    authority = $4
 *    path      = $5
 *    query     = $7
 *    fragment  = $9
 * </pre>
 *
 * The regular expression has been modified slightly to expose the
 * userInfo, domain, and port separately from the authority.
 * The modified version yields
 * <pre>
 *    $1 = http              scheme
 *    $2 = <undefined>       userInfo -\
 *    $3 = www.ics.uci.edu   domain     | authority
 *    $4 = <undefined>       port     -/
 *    $5 = /pub/ietf/uri/    path
 *    $6 = <undefined>       query without ?
 *    $7 = Related           fragment without #
 * </pre>
 * @type {!RegExp}
 * @private
 */
goog.uri.utils.splitRe_ = new RegExp(
    '^' +
    '(?:' +
      '([^:/?#.]+)' +                     // scheme - ignore special characters
                                          // used by other URL parts such as :,
                                          // ?, /, #, and .
    ':)?' +
    '(?://' +
      '(?:([^/?#]*)@)?' +                 // userInfo
      '([\\w\\d\\-\\u0100-\\uffff.%]*)' + // domain - restrict to letters,
                                          // digits, dashes, dots, percent
                                          // escapes, and unicode characters.
      '(?::([0-9]+))?' +                  // port
    ')?' +
    '([^?#]+)?' +                         // path
    '(?:\\?([^#]*))?' +                   // query
    '(?:#(.*))?' +                        // fragment
    '$');


/**
 * The index of each URI component in the return value of goog.uri.utils.split.
 * @enum {number}
 */
goog.uri.utils.ComponentIndex = {
  SCHEME: 1,
  USER_INFO: 2,
  DOMAIN: 3,
  PORT: 4,
  PATH: 5,
  QUERY_DATA: 6,
  FRAGMENT: 7
};


/**
 * Splits a URI into its component parts.
 *
 * Each component can be accessed via the component indices; for example:
 * <pre>
 * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
 * </pre>
 *
 * @param {string} uri The URI string to examine.
 * @return {!Array.<string|undefined>} Each component still URI-encoded.
 *     Each component that is present will contain the encoded value, whereas
 *     components that are not present will be undefined or empty, depending
 *     on the browser's regular expression implementation.  Never null, since
 *     arbitrary strings may still look like path names.
 */
goog.uri.utils.split = function(uri) {

  // See @return comment -- never null.
  return /** @type {!Array.<string|undefined>} */ (
      uri.match(goog.uri.utils.splitRe_));
};




/**
 * @param {?string} uri A possibly null string.
 * @return {?string} The string URI-decoded, or null if uri is null.
 * @private
 */
goog.uri.utils.decodeIfPossible_ = function(uri) {
  return uri && decodeURIComponent(uri);
};


/**
 * Gets a URI component by index.
 *
 * It is preferred to use the getPathEncoded() variety of functions ahead,
 * since they are more readable.
 *
 * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.
 * @param {string} uri The URI to examine.
 * @return {?string} The still-encoded component, or null if the component
 *     is not present.
 * @private
 */
goog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {
  // Convert undefined, null, and empty string into null.
  return goog.uri.utils.split(uri)[componentIndex] || null;
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The protocol or scheme, or null if none.  Does not
 *     include trailing colons or slashes.
 */
goog.uri.utils.getScheme = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.SCHEME, uri);
};


/**
 * Gets the effective scheme for the URL.  If the URL is relative then the
 * scheme is derived from the page's location.
 * @param {string} uri The URI to examine.
 * @return {string} The protocol or scheme, always lower case.
 */
goog.uri.utils.getEffectiveScheme = function(uri) {
  var scheme = goog.uri.utils.getScheme(uri);
  if (!scheme && self.location) {
    var protocol = self.location.protocol;
    scheme = protocol.substr(0, protocol.length - 1);
  }
  // NOTE: When called from a web worker in Firefox 3.5, location maybe null.
  // All other browsers with web workers support self.location from the worker.
  return scheme ? scheme.toLowerCase() : '';
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The user name still encoded, or null if none.
 */
goog.uri.utils.getUserInfoEncoded = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.USER_INFO, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded user info, or null if none.
 */
goog.uri.utils.getUserInfo = function(uri) {
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getUserInfoEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The domain name still encoded, or null if none.
 */
goog.uri.utils.getDomainEncoded = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.DOMAIN, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded domain, or null if none.
 */
goog.uri.utils.getDomain = function(uri) {
  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getDomainEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?number} The port number, or null if none.
 */
goog.uri.utils.getPort = function(uri) {
  // Coerce to a number.  If the result of getComponentByIndex_ is null or
  // non-numeric, the number coersion yields NaN.  This will then return
  // null for all non-numeric cases (though also zero, which isn't a relevant
  // port number).
  return Number(goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.PORT, uri)) || null;
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The path still encoded, or null if none. Includes the
 *     leading slash, if any.
 */
goog.uri.utils.getPathEncoded = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.PATH, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded path, or null if none.  Includes the leading
 *     slash, if any.
 */
goog.uri.utils.getPath = function(uri) {
  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getPathEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The query data still encoded, or null if none.  Does not
 *     include the question mark itself.
 */
goog.uri.utils.getQueryData = function(uri) {
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The fragment identifier, or null if none.  Does not
 *     include the hash mark itself.
 */
goog.uri.utils.getFragmentEncoded = function(uri) {
  // The hash mark may not appear in any other part of the URL.
  var hashIndex = uri.indexOf('#');
  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);
};


/**
 * @param {string} uri The URI to examine.
 * @param {?string} fragment The encoded fragment identifier, or null if none.
 *     Does not include the hash mark itself.
 * @return {string} The URI with the fragment set.
 */
goog.uri.utils.setFragmentEncoded = function(uri, fragment) {
  return goog.uri.utils.removeFragment(uri) + (fragment ? '#' + fragment : '');
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded fragment identifier, or null if none.  Does
 *     not include the hash mark.
 */
goog.uri.utils.getFragment = function(uri) {
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getFragmentEncoded(uri));
};


/**
 * Extracts everything up to the port of the URI.
 * @param {string} uri The URI string.
 * @return {string} Everything up to and including the port.
 */
goog.uri.utils.getHost = function(uri) {
  var pieces = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(
      pieces[goog.uri.utils.ComponentIndex.SCHEME],
      pieces[goog.uri.utils.ComponentIndex.USER_INFO],
      pieces[goog.uri.utils.ComponentIndex.DOMAIN],
      pieces[goog.uri.utils.ComponentIndex.PORT]);
};


/**
 * Extracts the path of the URL and everything after.
 * @param {string} uri The URI string.
 * @return {string} The URI, starting at the path and including the query
 *     parameters and fragment identifier.
 */
goog.uri.utils.getPathAndAfter = function(uri) {
  var pieces = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(null, null, null, null,
      pieces[goog.uri.utils.ComponentIndex.PATH],
      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],
      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);
};


/**
 * Gets the URI with the fragment identifier removed.
 * @param {string} uri The URI to examine.
 * @return {string} Everything preceding the hash mark.
 */
goog.uri.utils.removeFragment = function(uri) {
  // The hash mark may not appear in any other part of the URL.
  var hashIndex = uri.indexOf('#');
  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);
};


/**
 * Ensures that two URI's have the exact same domain, scheme, and port.
 *
 * Unlike the version in goog.Uri, this checks protocol, and therefore is
 * suitable for checking against the browser's same-origin policy.
 *
 * @param {string} uri1 The first URI.
 * @param {string} uri2 The second URI.
 * @return {boolean} Whether they have the same domain and port.
 */
goog.uri.utils.haveSameDomain = function(uri1, uri2) {
  var pieces1 = goog.uri.utils.split(uri1);
  var pieces2 = goog.uri.utils.split(uri2);
  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
             pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&
         pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==
             pieces2[goog.uri.utils.ComponentIndex.SCHEME] &&
         pieces1[goog.uri.utils.ComponentIndex.PORT] ==
             pieces2[goog.uri.utils.ComponentIndex.PORT];
};


/**
 * Asserts that there are no fragment or query identifiers, only in uncompiled
 * mode.
 * @param {string} uri The URI to examine.
 * @private
 */
goog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {
  // NOTE: would use goog.asserts here, but jscompiler doesn't know that
  // indexOf has no side effects.
  if (goog.DEBUG && (uri.indexOf('#') >= 0 || uri.indexOf('?') >= 0)) {
    throw Error('goog.uri.utils: Fragment or query identifiers are not ' +
        'supported: [' + uri + ']');
  }
};


/**
 * Supported query parameter values by the parameter serializing utilities.
 *
 * If a value is null or undefined, the key-value pair is skipped, as an easy
 * way to omit parameters conditionally.  Non-array parameters are converted
 * to a string and URI encoded.  Array values are expanded into multiple
 * &key=value pairs, with each element stringized and URI-encoded.
 *
 * @typedef {*}
 */
goog.uri.utils.QueryValue;


/**
 * An array representing a set of query parameters with alternating keys
 * and values.
 *
 * Keys are assumed to be URI encoded already and live at even indices.  See
 * goog.uri.utils.QueryValue for details on how parameter values are encoded.
 *
 * Example:
 * <pre>
 * var data = [
 *   // Simple param: ?name=BobBarker
 *   'name', 'BobBarker',
 *   // Conditional param -- may be omitted entirely.
 *   'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,
 *   // Multi-valued param: &house=LosAngeles&house=NewYork&house=null
 *   'house', ['LosAngeles', 'NewYork', null]
 * ];
 * </pre>
 *
 * @typedef {!Array.<string|goog.uri.utils.QueryValue>}
 */
goog.uri.utils.QueryArray;


/**
 * Appends a URI and query data in a string buffer with special preconditions.
 *
 * Internal implementation utility, performing very few object allocations.
 *
 * @param {!Array.<string|undefined>} buffer A string buffer.  The first element
 *     must be the base URI, and may have a fragment identifier.  If the array
 *     contains more than one element, the second element must be an ampersand,
 *     and may be overwritten, depending on the base URI.  Undefined elements
 *     are treated as empty-string.
 * @return {string} The concatenated URI and query data.
 * @private
 */
goog.uri.utils.appendQueryData_ = function(buffer) {
  if (buffer[1]) {
    // At least one query parameter was added.  We need to check the
    // punctuation mark, which is currently an ampersand, and also make sure
    // there aren't any interfering fragment identifiers.
    var baseUri = /** @type {string} */ (buffer[0]);
    var hashIndex = baseUri.indexOf('#');
    if (hashIndex >= 0) {
      // Move the fragment off the base part of the URI into the end.
      buffer.push(baseUri.substr(hashIndex));
      buffer[0] = baseUri = baseUri.substr(0, hashIndex);
    }
    var questionIndex = baseUri.indexOf('?');
    if (questionIndex < 0) {
      // No question mark, so we need a question mark instead of an ampersand.
      buffer[1] = '?';
    } else if (questionIndex == baseUri.length - 1) {
      // Question mark is the very last character of the existing URI, so don't
      // append an additional delimiter.
      buffer[1] = undefined;
    }
  }

  return buffer.join('');
};


/**
 * Appends key=value pairs to an array, supporting multi-valued objects.
 * @param {string} key The key prefix.
 * @param {goog.uri.utils.QueryValue} value The value to serialize.
 * @param {!Array.<string>} pairs The array to which the 'key=value' strings
 *     should be appended.
 * @private
 */
goog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {
  if (goog.isArray(value)) {
    // Convince the compiler it's an array.
    goog.asserts.assertArray(value);
    for (var j = 0; j < value.length; j++) {
      // Convert to string explicitly, to short circuit the null and array
      // logic in this function -- this ensures that null and undefined get
      // written as literal 'null' and 'undefined', and arrays don't get
      // expanded out but instead encoded in the default way.
      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);
    }
  } else if (value != null) {
    // Skip a top-level null or undefined entirely.
    pairs.push('&', key,
        // Check for empty string. Zero gets encoded into the url as literal
        // strings.  For empty string, skip the equal sign, to be consistent
        // with UriBuilder.java.
        value === '' ? '' : '=',
        goog.string.urlEncode(value));
  }
};


/**
 * Builds a buffer of query data from a sequence of alternating keys and values.
 *
 * @param {!Array.<string|undefined>} buffer A string buffer to append to.  The
 *     first element appended will be an '&', and may be replaced by the caller.
 * @param {goog.uri.utils.QueryArray|Arguments} keysAndValues An array with
 *     alternating keys and values -- see the typedef.
 * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.
 * @return {!Array.<string|undefined>} The buffer argument.
 * @private
 */
goog.uri.utils.buildQueryDataBuffer_ = function(
    buffer, keysAndValues, opt_startIndex) {
  goog.asserts.assert(Math.max(keysAndValues.length - (opt_startIndex || 0),
      0) % 2 == 0, 'goog.uri.utils: Key/value lists must be even in length.');

  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {
    goog.uri.utils.appendKeyValuePairs_(
        keysAndValues[i], keysAndValues[i + 1], buffer);
  }

  return buffer;
};


/**
 * Builds a query data string from a sequence of alternating keys and values.
 * Currently generates "&key&" for empty args.
 *
 * @param {goog.uri.utils.QueryArray} keysAndValues Alternating keys and
 *     values.  See the typedef.
 * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.
 * @return {string} The encoded query string, in the for 'a=1&b=2'.
 */
goog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {
  var buffer = goog.uri.utils.buildQueryDataBuffer_(
      [], keysAndValues, opt_startIndex);
  buffer[0] = ''; // Remove the leading ampersand.
  return buffer.join('');
};


/**
 * Builds a buffer of query data from a map.
 *
 * @param {!Array.<string|undefined>} buffer A string buffer to append to.  The
 *     first element appended will be an '&', and may be replaced by the caller.
 * @param {Object.<goog.uri.utils.QueryValue>} map An object where keys are
 *     URI-encoded parameter keys, and the values conform to the contract
 *     specified in the goog.uri.utils.QueryValue typedef.
 * @return {!Array.<string|undefined>} The buffer argument.
 * @private
 */
goog.uri.utils.buildQueryDataBufferFromMap_ = function(buffer, map) {
  for (var key in map) {
    goog.uri.utils.appendKeyValuePairs_(key, map[key], buffer);
  }

  return buffer;
};


/**
 * Builds a query data string from a map.
 * Currently generates "&key&" for empty args.
 *
 * @param {Object} map An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.  Keys with a null value
 *     are dropped.
 * @return {string} The encoded query string, in the for 'a=1&b=2'.
 */
goog.uri.utils.buildQueryDataFromMap = function(map) {
  var buffer = goog.uri.utils.buildQueryDataBufferFromMap_([], map);
  buffer[0] = '';
  return buffer.join('');
};


/**
 * Appends URI parameters to an existing URI.
 *
 * The variable arguments may contain alternating keys and values.  Keys are
 * assumed to be already URI encoded.  The values should not be URI-encoded,
 * and will instead be encoded by this function.
 * <pre>
 * appendParams('http://www.foo.com?existing=true',
 *     'key1', 'value1',
 *     'key2', 'value?willBeEncoded',
 *     'key3', ['valueA', 'valueB', 'valueC'],
 *     'key4', null);
 * result: 'http://www.foo.com?existing=true&' +
 *     'key1=value1&' +
 *     'key2=value%3FwillBeEncoded&' +
 *     'key3=valueA&key3=valueB&key3=valueC'
 * </pre>
 *
 * A single call to this function will not exhibit quadratic behavior in IE,
 * whereas multiple repeated calls may, although the effect is limited by
 * fact that URL's generally can't exceed 2kb.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {...(goog.uri.utils.QueryArray|string|goog.uri.utils.QueryValue)} var_args
 *     An array or argument list conforming to goog.uri.utils.QueryArray.
 * @return {string} The URI with all query parameters added.
 */
goog.uri.utils.appendParams = function(uri, var_args) {
  return goog.uri.utils.appendQueryData_(
      arguments.length == 2 ?
      goog.uri.utils.buildQueryDataBuffer_([uri], arguments[1], 0) :
      goog.uri.utils.buildQueryDataBuffer_([uri], arguments, 1));
};


/**
 * Appends query parameters from a map.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {Object} map An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.  Keys with a null value
 *     are dropped.
 * @return {string} The new parameters.
 */
goog.uri.utils.appendParamsFromMap = function(uri, map) {
  return goog.uri.utils.appendQueryData_(
      goog.uri.utils.buildQueryDataBufferFromMap_([uri], map));
};


/**
 * Appends a single URI parameter.
 *
 * Repeated calls to this can exhibit quadratic behavior in IE6 due to the
 * way string append works, though it should be limited given the 2kb limit.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {string} key The key, which must already be URI encoded.
 * @param {*} value The value, which will be stringized and encoded (assumed
 *     not already to be encoded).
 * @return {string} The URI with the query parameter added.
 */
goog.uri.utils.appendParam = function(uri, key, value) {
  return goog.uri.utils.appendQueryData_(
      [uri, '&', key, '=', goog.string.urlEncode(value)]);
};


/**
 * Finds the next instance of a query parameter with the specified name.
 *
 * Does not instantiate any objects.
 *
 * @param {string} uri The URI to search.  May contain a fragment identifier
 *     if opt_hashIndex is specified.
 * @param {number} startIndex The index to begin searching for the key at.  A
 *     match may be found even if this is one character after the ampersand.
 * @param {string} keyEncoded The URI-encoded key.
 * @param {number} hashOrEndIndex Index to stop looking at.  If a hash
 *     mark is present, it should be its index, otherwise it should be the
 *     length of the string.
 * @return {number} The position of the first character in the key's name,
 *     immediately after either a question mark or a dot.
 * @private
 */
goog.uri.utils.findParam_ = function(
    uri, startIndex, keyEncoded, hashOrEndIndex) {
  var index = startIndex;
  var keyLength = keyEncoded.length;

  // Search for the key itself and post-filter for surronuding punctuation,
  // rather than expensively building a regexp.
  while ((index = uri.indexOf(keyEncoded, index)) >= 0 &&
      index < hashOrEndIndex) {
    var precedingChar = uri.charCodeAt(index - 1);
    // Ensure that the preceding character is '&' or '?'.
    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||
        precedingChar == goog.uri.utils.CharCode_.QUESTION) {
      // Ensure the following character is '&', '=', '#', or NaN
      // (end of string).
      var followingChar = uri.charCodeAt(index + keyLength);
      if (!followingChar ||
          followingChar == goog.uri.utils.CharCode_.EQUAL ||
          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||
          followingChar == goog.uri.utils.CharCode_.HASH) {
        return index;
      }
    }
    index += keyLength + 1;
  }

  return -1;
};


/**
 * Regular expression for finding a hash mark or end of string.
 * @type {RegExp}
 * @private
 */
goog.uri.utils.hashOrEndRe_ = /#|$/;


/**
 * Determines if the URI contains a specific key.
 *
 * Performs no object instantiations.
 *
 * @param {string} uri The URI to process.  May contain a fragment
 *     identifier.
 * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
 * @return {boolean} Whether the key is present.
 */
goog.uri.utils.hasParam = function(uri, keyEncoded) {
  return goog.uri.utils.findParam_(uri, 0, keyEncoded,
      uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;
};


/**
 * Gets the first value of a query parameter.
 * @param {string} uri The URI to process.  May contain a fragment.
 * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
 * @return {?string} The first value of the parameter (URI-decoded), or null
 *     if the parameter is not found.
 */
goog.uri.utils.getParamValue = function(uri, keyEncoded) {
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var foundIndex = goog.uri.utils.findParam_(
      uri, 0, keyEncoded, hashOrEndIndex);

  if (foundIndex < 0) {
    return null;
  } else {
    var endPosition = uri.indexOf('&', foundIndex);
    if (endPosition < 0 || endPosition > hashOrEndIndex) {
      endPosition = hashOrEndIndex;
    }
    // Progress forth to the end of the "key=" or "key&" substring.
    foundIndex += keyEncoded.length + 1;
    // Use substr, because it (unlike substring) will return empty string
    // if foundIndex > endPosition.
    return goog.string.urlDecode(
        uri.substr(foundIndex, endPosition - foundIndex));
  }
};


/**
 * Gets all values of a query parameter.
 * @param {string} uri The URI to process.  May contain a framgnet.
 * @param {string} keyEncoded The URI-encoded key.  Case-snsitive.
 * @return {!Array.<string>} All URI-decoded values with the given key.
 *     If the key is not found, this will have length 0, but never be null.
 */
goog.uri.utils.getParamValues = function(uri, keyEncoded) {
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var position = 0;
  var foundIndex;
  var result = [];

  while ((foundIndex = goog.uri.utils.findParam_(
      uri, position, keyEncoded, hashOrEndIndex)) >= 0) {
    // Find where this parameter ends, either the '&' or the end of the
    // query parameters.
    position = uri.indexOf('&', foundIndex);
    if (position < 0 || position > hashOrEndIndex) {
      position = hashOrEndIndex;
    }

    // Progress forth to the end of the "key=" or "key&" substring.
    foundIndex += keyEncoded.length + 1;
    // Use substr, because it (unlike substring) will return empty string
    // if foundIndex > position.
    result.push(goog.string.urlDecode(uri.substr(
        foundIndex, position - foundIndex)));
  }

  return result;
};


/**
 * Regexp to find trailing question marks and ampersands.
 * @type {RegExp}
 * @private
 */
goog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;


/**
 * Removes all instances of a query parameter.
 * @param {string} uri The URI to process.  Must not contain a fragment.
 * @param {string} keyEncoded The URI-encoded key.
 * @return {string} The URI with all instances of the parameter removed.
 */
goog.uri.utils.removeParam = function(uri, keyEncoded) {
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var position = 0;
  var foundIndex;
  var buffer = [];

  // Look for a query parameter.
  while ((foundIndex = goog.uri.utils.findParam_(
      uri, position, keyEncoded, hashOrEndIndex)) >= 0) {
    // Get the portion of the query string up to, but not including, the ?
    // or & starting the parameter.
    buffer.push(uri.substring(position, foundIndex));
    // Progress to immediately after the '&'.  If not found, go to the end.
    // Avoid including the hash mark.
    position = Math.min((uri.indexOf('&', foundIndex) + 1) || hashOrEndIndex,
        hashOrEndIndex);
  }

  // Append everything that is remaining.
  buffer.push(uri.substr(position));

  // Join the buffer, and remove trailing punctuation that remains.
  return buffer.join('').replace(
      goog.uri.utils.trailingQueryPunctuationRe_, '$1');
};


/**
 * Replaces all existing definitions of a parameter with a single definition.
 *
 * Repeated calls to this can exhibit quadratic behavior due to the need to
 * find existing instances and reconstruct the string, though it should be
 * limited given the 2kb limit.  Consider using appendParams to append multiple
 * parameters in bulk.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {string} keyEncoded The key, which must already be URI encoded.
 * @param {*} value The value, which will be stringized and encoded (assumed
 *     not already to be encoded).
 * @return {string} The URI with the query parameter added.
 */
goog.uri.utils.setParam = function(uri, keyEncoded, value) {
  return goog.uri.utils.appendParam(
      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);
};


/**
 * Generates a URI path using a given URI and a path with checks to
 * prevent consecutive "//". The baseUri passed in must not contain
 * query or fragment identifiers. The path to append may not contain query or
 * fragment identifiers.
 *
 * @param {string} baseUri URI to use as the base.
 * @param {string} path Path to append.
 * @return {string} Updated URI.
 */
goog.uri.utils.appendPath = function(baseUri, path) {
  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);

  // Remove any trailing '/'
  if (goog.string.endsWith(baseUri, '/')) {
    baseUri = baseUri.substr(0, baseUri.length - 1);
  }
  // Remove any leading '/'
  if (goog.string.startsWith(path, '/')) {
    path = path.substr(1);
  }
  return goog.string.buildString(baseUri, '/', path);
};


/**
 * Standard supported query parameters.
 * @enum {string}
 */
goog.uri.utils.StandardQueryParam = {

  /** Unused parameter for unique-ifying. */
  RANDOM: 'zx'
};


/**
 * Sets the zx parameter of a URI to a random value.
 * @param {string} uri Any URI.
 * @return {string} That URI with the "zx" parameter added or replaced to
 *     contain a random string.
 */
goog.uri.utils.makeUnique = function(uri) {
  return goog.uri.utils.setParam(uri,
      goog.uri.utils.StandardQueryParam.RANDOM, goog.string.getRandomString());
};


// node_modules/closure-library/goog/object/object.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 */

goog.provide('goog.object');


/**
 * Calls a function for each element in an object/map/hash.
 *
 * @param {Object} obj The object over which to iterate.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the object)
 *     and the return value is irrelevant.
 * @param {Object=} opt_obj This is used as the 'this' object within f.
 */
goog.object.forEach = function(obj, f, opt_obj) {
  for (var key in obj) {
    f.call(opt_obj, obj[key], key, obj);
  }
};


/**
 * Calls a function for each element in an object/map/hash. If that call returns
 * true, adds the element to a new object.
 *
 * @param {Object} obj The object over which to iterate.
 * @param {Function} f The function to call for every element. This
 *     function takes 3 arguments (the element, the index and the object)
 *     and should return a boolean. If the return value is true the
 *     element is added to the result object. If it is false the
 *     element is not included.
 * @param {Object=} opt_obj This is used as the 'this' object within f.
 * @return {!Object} a new object in which only elements that passed the test
 *     are present.
 */
goog.object.filter = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      res[key] = obj[key];
    }
  }
  return res;
};


/**
 * For every element in an object/map/hash calls a function and inserts the
 * result into a new object.
 *
 * @param {Object} obj The object over which to iterate.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the object)
 *     and should return something. The result will be inserted
 *     into a new object.
 * @param {Object=} opt_obj This is used as the 'this' object within f.
 * @return {!Object} a new object with the results from f.
 */
goog.object.map = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    res[key] = f.call(opt_obj, obj[key], key, obj);
  }
  return res;
};


/**
 * Calls a function for each element in an object/map/hash. If any
 * call returns true, returns true (without checking the rest). If
 * all calls return false, returns false.
 *
 * @param {Object} obj The object to check.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {Object=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} true if any element passes the test.
 */
goog.object.some = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls a function for each element in an object/map/hash. If
 * all calls return true, returns true. If any call returns false, returns
 * false at this point and does not continue to check the remaining elements.
 *
 * @param {Object} obj The object to check.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {Object=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} false if any element fails the test.
 */
goog.object.every = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (!f.call(opt_obj, obj[key], key, obj)) {
      return false;
    }
  }
  return true;
};


/**
 * Returns the number of key-value pairs in the object map.
 *
 * @param {Object} obj The object for which to get the number of key-value
 *     pairs.
 * @return {number} The number of key-value pairs in the object map.
 */
goog.object.getCount = function(obj) {
  // JS1.5 has __count__ but it has been deprecated so it raises a warning...
  // in other words do not use. Also __count__ only includes the fields on the
  // actual object and not in the prototype chain.
  var rv = 0;
  for (var key in obj) {
    rv++;
  }
  return rv;
};


/**
 * Returns one key from the object map, if any exists.
 * For map literals the returned key will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object} obj The object to pick a key from.
 * @return {string|undefined} The key or undefined if the object is empty.
 */
goog.object.getAnyKey = function(obj) {
  for (var key in obj) {
    return key;
  }
};


/**
 * Returns one value from the object map, if any exists.
 * For map literals the returned value will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object} obj The object to pick a value from.
 * @return {*} The value or undefined if the object is empty.
 */
goog.object.getAnyValue = function(obj) {
  for (var key in obj) {
    return obj[key];
  }
};


/**
 * Whether the object/hash/map contains the given object as a value.
 * An alias for goog.object.containsValue(obj, val).
 *
 * @param {Object} obj The object in which to look for val.
 * @param {*} val The object for which to check.
 * @return {boolean} true if val is present.
 */
goog.object.contains = function(obj, val) {
  return goog.object.containsValue(obj, val);
};


/**
 * Returns the values of the object/map/hash.
 *
 * @param {Object} obj The object from which to get the values.
 * @return {!Array} The values in the object/map/hash.
 */
goog.object.getValues = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = obj[key];
  }
  return res;
};


/**
 * Returns the keys of the object/map/hash.
 *
 * @param {Object} obj The object from which to get the keys.
 * @return {!Array.<string>} Array of property keys.
 */
goog.object.getKeys = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = key;
  }
  return res;
};


/**
 * Get a value from an object multiple levels deep.  This is useful for
 * pulling values from deeply nested objects, such as JSON responses.
 * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)
 *
 * @param {!Object} obj An object to get the value from.  Can be array-like.
 * @param {...(string|number|!Array.<number|string>)} var_args A number of keys
 *     (as strings, or nubmers, for array-like objects).  Can also be
 *     specified as a single array of keys.
 * @return {*} The resulting value.  If, at any point, the value for a key
 *     is undefined, returns undefined.
 */
goog.object.getValueByKeys = function(obj, var_args) {
  var isArrayLike = goog.isArrayLike(var_args);
  var keys = isArrayLike ? var_args : arguments;

  // Start with the 2nd parameter for the variable parameters syntax.
  for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {
    obj = obj[keys[i]];
    if (!goog.isDef(obj)) {
      break;
    }
  }

  return obj;
};


/**
 * Whether the object/map/hash contains the given key.
 *
 * @param {Object} obj The object in which to look for key.
 * @param {*} key The key for which to check.
 * @return {boolean} true If the map contains the key.
 */
goog.object.containsKey = function(obj, key) {
  return key in obj;
};


/**
 * Whether the object/map/hash contains the given value. This is O(n).
 *
 * @param {Object} obj The object in which to look for val.
 * @param {*} val The value for which to check.
 * @return {boolean} true If the map contains the value.
 */
goog.object.containsValue = function(obj, val) {
  for (var key in obj) {
    if (obj[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its key.
 * @param {Object} obj The object to search in.
 * @param {function(*, string, Object): boolean} f The function to call for
 *     every element. Takes 3 arguments (the value, the key and the object) and
 *     should return a boolean.
 * @param {Object=} opt_this An optional "this" context for the function.
 * @return {string|undefined} The key of an element for which the function
 *     returns true or undefined if no such element is found.
 */
goog.object.findKey = function(obj, f, opt_this) {
  for (var key in obj) {
    if (f.call(opt_this, obj[key], key, obj)) {
      return key;
    }
  }
  return undefined;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its value.
 * @param {Object} obj The object to search in.
 * @param {function(*, string, Object): boolean} f The function to call for
 *     every element. Takes 3 arguments (the value, the key and the object) and
 *     should return a boolean.
 * @param {Object=} opt_this An optional "this" context for the function.
 * @return {*} The value of an element for which the function returns true or
 *     undefined if no such element is found.
 */
goog.object.findValue = function(obj, f, opt_this) {
  var key = goog.object.findKey(obj, f, opt_this);
  return key && obj[key];
};


/**
 * Whether the object/map/hash is empty.
 *
 * @param {Object} obj The object to test.
 * @return {boolean} true if obj is empty.
 */
goog.object.isEmpty = function(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
};


/**
 * Removes all key value pairs from the object/map/hash.
 *
 * @param {Object} obj The object to clear.
 */
goog.object.clear = function(obj) {
  for (var i in obj) {
    delete obj[i];
  }
};


/**
 * Removes a key-value pair based on the key.
 *
 * @param {Object} obj The object from which to remove the key.
 * @param {*} key The key to remove.
 * @return {boolean} Whether an element was removed.
 */
goog.object.remove = function(obj, key) {
  var rv;
  if ((rv = key in obj)) {
    delete obj[key];
  }
  return rv;
};


/**
 * Adds a key-value pair to the object. Throws an exception if the key is
 * already in use. Use set if you want to change an existing pair.
 *
 * @param {Object} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {*} val The value to add.
 */
goog.object.add = function(obj, key, val) {
  if (key in obj) {
    throw Error('The object already contains the key "' + key + '"');
  }
  goog.object.set(obj, key, val);
};


/**
 * Returns the value for the given key.
 *
 * @param {Object} obj The object from which to get the value.
 * @param {string} key The key for which to get the value.
 * @param {*=} opt_val The value to return if no item is found for the given
 *     key (default is undefined).
 * @return {*} The value for the given key.
 */
goog.object.get = function(obj, key, opt_val) {
  if (key in obj) {
    return obj[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the object/map/hash.
 *
 * @param {Object} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {*} value The value to add.
 */
goog.object.set = function(obj, key, value) {
  obj[key] = value;
};


/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 *
 * @param {Object} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {*} value The value to add if the key wasn't present.
 * @return {*} The value of the entry at the end of the function.
 */
goog.object.setIfUndefined = function(obj, key, value) {
  return key in obj ? obj[key] : (obj[key] = value);
};


/**
 * Does a flat clone of the object.
 *
 * @param {Object} obj Object to clone.
 * @return {!Object} Clone of the input object.
 */
goog.object.clone = function(obj) {
  // We cannot use the prototype trick because a lot of methods depend on where
  // the actual key is set.

  var res = {};
  for (var key in obj) {
    res[key] = obj[key];
  }
  return res;
  // We could also use goog.mixin but I wanted this to be independent from that.
};


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects
 * that refer to themselves will cause infinite recursion.
 *
 * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and
 * copies UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 */
goog.object.unsafeClone = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.object.unsafeClone(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * Returns a new object in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * @param {Object} obj The object to transpose.
 * @return {!Object} The transposed object.
 */
goog.object.transpose = function(obj) {
  var transposed = {};
  for (var key in obj) {
    transposed[obj[key]] = key;
  }
  return transposed;
};


/**
 * The names of the fields that are defined on Object.prototype.
 * @type {Array.<string>}
 * @private
 */
goog.object.PROTOTYPE_FIELDS_ = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/**
 * Extends an object with another object.
 * This operates 'in-place'; it does not create a new Object.
 *
 * Example:
 * var o = {};
 * goog.object.extend(o, {a: 0, b: 1});
 * o; // {a: 0, b: 1}
 * goog.object.extend(o, {c: 2});
 * o; // {a: 0, b: 1, c: 2}
 *
 * @param {Object} target  The object to modify.
 * @param {...Object} var_args The objects from which values will be copied.
 */
goog.object.extend = function(target, var_args) {
  var key, source;
  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      target[key] = source[key];
    }

    // For IE the for-in-loop does not contain any properties that are not
    // enumerable on the prototype object (for example isPrototypeOf from
    // Object.prototype) and it will also not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).

    for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {
      key = goog.object.PROTOTYPE_FIELDS_[j];
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
};


/**
 * Creates a new object built from the key-value pairs provided as arguments.
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise even arguments are used as
 *     the property names and odd arguments are used as the property values.
 * @return {!Object} The new object.
 * @throws {Error} If there are uneven number of arguments or there is only one
 *     non array argument.
 */
goog.object.create = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.create.apply(null, arguments[0]);
  }

  if (argLength % 2) {
    throw Error('Uneven number of arguments');
  }

  var rv = {};
  for (var i = 0; i < argLength; i += 2) {
    rv[arguments[i]] = arguments[i + 1];
  }
  return rv;
};


/**
 * Creates a new object where the property names come from the arguments but
 * the value is always set to true
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise the arguments are used
 *     as the property names.
 * @return {!Object} The new object.
 */
goog.object.createSet = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.createSet.apply(null, arguments[0]);
  }

  var rv = {};
  for (var i = 0; i < argLength; i++) {
    rv[arguments[i]] = true;
  }
  return rv;
};


// node_modules/closure-library/goog/array/array.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating arrays.
 *
 */


goog.provide('goog.array');
goog.provide('goog.array.ArrayLike');

goog.require('goog.asserts');


/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to false forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
 */
goog.NATIVE_ARRAY_PROTOTYPES = true;


/**
 * @typedef {Array|NodeList|Arguments|{length: number{{ '}}' }}
 */
goog.array.ArrayLike;


/**
 * Returns the last element in an array without removing it.
 * @param {goog.array.ArrayLike} array The array.
 * @return {*} Last item in array.
 */
goog.array.peek = function(array) {
  return array[array.length - 1];
};


/**
 * Reference to the original {@code Array.prototype}.
 * @private
 */
goog.array.ARRAY_PROTOTYPE_ = Array.prototype;


// NOTE(arv): Since most of the array functions are generic it allows you to
// pass an array-like object. Strings have a length and are considered array-
// like. However, the 'in' operator does not work on strings so we cannot just
// use the array path even if the browser supports indexing into strings. We
// therefore end up splitting the string.


/**
 * Returns the index of the first element of an array with a specified
 * value, or -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {*} obj The object for which we are searching.
 * @param {number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at index 0.
 * @return {number} The index of the first matching array element.
 */
goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                     goog.array.ARRAY_PROTOTYPE_.indexOf ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.indexOf.call(arr, obj, opt_fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ?
          0 : (opt_fromIndex < 0 ?
               Math.max(0, arr.length + opt_fromIndex) : opt_fromIndex);

      if (goog.isString(arr)) {
        // Array.prototype.indexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.indexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i < arr.length; i++) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Returns the index of the last element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {*} obj The object for which we are searching.
 * @param {?number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at the end of the array.
 * @return {number} The index of the last matching array element.
 */
goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                         goog.array.ARRAY_PROTOTYPE_.lastIndexOf ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      // Firefox treats undefined and null as 0 in the fromIndex argument which
      // leads it to always return -1
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
      return goog.array.ARRAY_PROTOTYPE_.lastIndexOf.call(arr, obj, fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;

      if (fromIndex < 0) {
        fromIndex = Math.max(0, arr.length + fromIndex);
      }

      if (goog.isString(arr)) {
        // Array.prototype.lastIndexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.lastIndexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i >= 0; i--) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Calls a function for each element in an array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element.
 *     This function takes 3 arguments (the element, the index and the array).
 *     The return value is ignored. The function is called only for indexes of
 *     the array which have assigned values; it is not called for indexes which
 *     have been deleted or which have never been assigned values.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @template T,S
 */
goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
                     goog.array.ARRAY_PROTOTYPE_.forEach ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      goog.array.ARRAY_PROTOTYPE_.forEach.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          f.call(opt_obj, arr2[i], i, arr);
        }
      }
    };


/**
 * Calls a function for each element in an array, starting from the last
 * element rather than the first.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @template T,S
 */
goog.array.forEachRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; --i) {
    if (i in arr2) {
      f.call(opt_obj, arr2[i], i, arr);
    }
  }
};


/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean. If the return value is true the element is added to the
 *     result array. If it is false the element is not included.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array} a new array in which only elements that passed the test are
 *     present.
 * @template T,S
 */
goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&
                    goog.array.ARRAY_PROTOTYPE_.filter ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.filter.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = [];
      var resLength = 0;
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          var val = arr2[i];  // in case f mutates arr2
          if (f.call(opt_obj, val, i, arr)) {
            res[resLength++] = val;
          }
        }
      }
      return res;
    };


/**
 * Calls a function for each element in an array and inserts the result into a
 * new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return something. The result will be inserted into a new array.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array} a new array with the results from f.
 * @template T,S
 */
goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&
                 goog.array.ARRAY_PROTOTYPE_.map ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.map.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = new Array(l);
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          res[i] = f.call(opt_obj, arr2[i], i, arr);
        }
      }
      return res;
    };


/**
 * Passes every element of an array into a function and accumulates the result.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
 *
 * For example:
 * var a = [1, 2, 3, 4];
 * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);
 * returns 10
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {R} Result of evaluating f repeatedly across the values of the array.
 * @template T,S,R
 */
goog.array.reduce = function(arr, f, val, opt_obj) {
  if (arr.reduce) {
    if (opt_obj) {
      return arr.reduce(goog.bind(f, opt_obj), val);
    } else {
      return arr.reduce(f, val);
    }
  }
  var rval = val;
  goog.array.forEach(arr, function(val, index) {
    rval = f.call(opt_obj, rval, val, index, arr);
  });
  return rval;
};


/**
 * Passes every element of an array into a function and accumulates the result,
 * starting from the last element and working towards the first.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
 *
 * For example:
 * var a = ['a', 'b', 'c'];
 * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
 * returns 'cba'
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {R} Object returned as a result of evaluating f repeatedly across the
 *     values of the array.
 * @template T,S,R
 */
goog.array.reduceRight = function(arr, f, val, opt_obj) {
  if (arr.reduceRight) {
    if (opt_obj) {
      return arr.reduceRight(goog.bind(f, opt_obj), val);
    } else {
      return arr.reduceRight(f, val);
    }
  }
  var rval = val;
  goog.array.forEachRight(arr, function(val, index) {
    rval = f.call(opt_obj, rval, val, index, arr);
  });
  return rval;
};


/**
 * Calls f for each element of an array. If any call returns true, some()
 * returns true (without checking the remaining elements). If all calls
 * return false, some() returns false.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} true if any element passes the test.
 * @template T,S
 */
goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&
                  goog.array.ARRAY_PROTOTYPE_.some ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.some.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
          return true;
        }
      }
      return false;
    };


/**
 * Call f for each element of an array. If all calls return true, every()
 * returns true. If any call returns false, every() returns false and
 * does not continue to check the remaining elements.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} false if any element fails the test.
 * @template T,S
 */
goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&
                   goog.array.ARRAY_PROTOTYPE_.every ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.every.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && !f.call(opt_obj, arr2[i], i, arr)) {
          return false;
        }
      }
      return true;
    };


/**
 * Search an array for the first element that satisfies a given condition and
 * return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T} The first array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.find = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the first array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndex = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = 0; i < l; i++) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T} The last array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.findRight = function(arr, f, opt_obj) {
  var i = goog.array.findIndexRight(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {Object=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the last array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndexRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; i--) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Whether the array contains the given object.
 * @param {goog.array.ArrayLike} arr The array to test for the presence of the
 *     element.
 * @param {*} obj The object for which to test.
 * @return {boolean} true if obj is present.
 */
goog.array.contains = function(arr, obj) {
  return goog.array.indexOf(arr, obj) >= 0;
};


/**
 * Whether the array is empty.
 * @param {goog.array.ArrayLike} arr The array to test.
 * @return {boolean} true if empty.
 */
goog.array.isEmpty = function(arr) {
  return arr.length == 0;
};


/**
 * Clears the array.
 * @param {goog.array.ArrayLike} arr Array or array like object to clear.
 */
goog.array.clear = function(arr) {
  // For non real arrays we don't have the magic length so we delete the
  // indices.
  if (!goog.isArray(arr)) {
    for (var i = arr.length - 1; i >= 0; i--) {
      delete arr[i];
    }
  }
  arr.length = 0;
};


/**
 * Pushes an item into an array, if it's not already in the array.
 * @param {Array.<T>} arr Array into which to insert the item.
 * @param {T} obj Value to add.
 * @template T
 */
goog.array.insert = function(arr, obj) {
  if (!goog.array.contains(arr, obj)) {
    arr.push(obj);
  }
};


/**
 * Inserts an object at the given index of the array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {*} obj The object to insert.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertAt = function(arr, obj, opt_i) {
  goog.array.splice(arr, opt_i, 0, obj);
};


/**
 * Inserts at the given index of the array, all elements of another array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {goog.array.ArrayLike} elementsToAdd The array of elements to add.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {
  goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);
};


/**
 * Inserts an object into an array before a specified object.
 * @param {Array.<T>} arr The array to modify.
 * @param {T} obj The object to insert.
 * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
 *     is omitted or not found, obj is inserted at the end of the array.
 * @template T
 */
goog.array.insertBefore = function(arr, obj, opt_obj2) {
  var i;
  if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {
    arr.push(obj);
  } else {
    goog.array.insertAt(arr, obj, i);
  }
};


/**
 * Removes the first occurrence of a particular value from an array.
 * @param {goog.array.ArrayLike} arr Array from which to remove value.
 * @param {*} obj Object to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.remove = function(arr, obj) {
  var i = goog.array.indexOf(arr, obj);
  var rv;
  if ((rv = i >= 0)) {
    goog.array.removeAt(arr, i);
  }
  return rv;
};


/**
 * Removes from an array the element at index i
 * @param {goog.array.ArrayLike} arr Array or array like object from which to
 *     remove value.
 * @param {number} i The index to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.removeAt = function(arr, i) {
  goog.asserts.assert(arr.length != null);

  // use generic form of splice
  // splice returns the removed items and if successful the length of that
  // will be 1
  return goog.array.ARRAY_PROTOTYPE_.splice.call(arr, i, 1).length == 1;
};


/**
 * Removes the first value that satisfies the given condition.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {boolean} True if an element was removed.
 * @template T,S
 */
goog.array.removeIf = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  if (i >= 0) {
    goog.array.removeAt(arr, i);
    return true;
  }
  return false;
};


/**
 * Returns a new array that is the result of joining the arguments.  If arrays
 * are passed then their items are added, however, if non-arrays are passed they
 * will be added to the return array as is.
 *
 * Note that ArrayLike objects will be added as is, rather than having their
 * items added.
 *
 * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
 * goog.array.concat(0, [1, 2]) -> [0, 1, 2]
 * goog.array.concat([1, 2], null) -> [1, 2, null]
 *
 * There is bug in all current versions of IE (6, 7 and 8) where arrays created
 * in an iframe become corrupted soon (not immediately) after the iframe is
 * destroyed. This is common if loading data via goog.net.IframeIo, for example.
 * This corruption only affects the concat method which will start throwing
 * Catastrophic Errors (#-2147418113).
 *
 * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
 *
 * Internally goog.array should use this, so that all methods will continue to
 * work on these broken array objects.
 *
 * @param {...*} var_args Items to concatenate.  Arrays will have each item
 *     added, while primitives and objects will be added as is.
 * @return {!Array} The new resultant array.
 */
goog.array.concat = function(var_args) {
  return goog.array.ARRAY_PROTOTYPE_.concat.apply(
      goog.array.ARRAY_PROTOTYPE_, arguments);
};


/**
 * Converts an object to an array.
 * @param {goog.array.ArrayLike} object  The object to convert to an array.
 * @return {!Array} The object converted into an array. If object has a
 *     length property, every property indexed with a non-negative number
 *     less than length will be included in the result. If object does not
 *     have a length property, an empty array will be returned.
 */
goog.array.toArray = function(object) {
  var length = object.length;

  // If length is not a number the following it false. This case is kept for
  // backwards compatibility since there are callers that pass objects that are
  // not array like.
  if (length > 0) {
    var rv = new Array(length);
    for (var i = 0; i < length; i++) {
      rv[i] = object[i];
    }
    return rv;
  }
  return [];
};


/**
 * Does a shallow copy of an array.
 * @param {goog.array.ArrayLike} arr  Array or array-like object to clone.
 * @return {!Array} Clone of the input array.
 */
goog.array.clone = goog.array.toArray;


/**
 * Extends an array with another array, element, or "array like" object.
 * This function operates 'in-place', it does not create a new Array.
 *
 * Example:
 * var a = [];
 * goog.array.extend(a, [0, 1]);
 * a; // [0, 1]
 * goog.array.extend(a, 2);
 * a; // [0, 1, 2]
 *
 * @param {Array} arr1  The array to modify.
 * @param {...*} var_args The elements or arrays of elements to add to arr1.
 */
goog.array.extend = function(arr1, var_args) {
  for (var i = 1; i < arguments.length; i++) {
    var arr2 = arguments[i];
    // If we have an Array or an Arguments object we can just call push
    // directly.
    var isArrayLike;
    if (goog.isArray(arr2) ||
        // Detect Arguments. ES5 says that the [[Class]] of an Arguments object
        // is "Arguments" but only V8 and JSC/Safari gets this right. We instead
        // detect Arguments by checking for array like and presence of "callee".
        (isArrayLike = goog.isArrayLike(arr2)) &&
            // The getter for callee throws an exception in strict mode
            // according to section 10.6 in ES5 so check for presence instead.
            arr2.hasOwnProperty('callee')) {
      arr1.push.apply(arr1, arr2);

    } else if (isArrayLike) {
      // Otherwise loop over arr2 to prevent copying the object.
      var len1 = arr1.length;
      var len2 = arr2.length;
      for (var j = 0; j < len2; j++) {
        arr1[len1 + j] = arr2[j];
      }
    } else {
      arr1.push(arr2);
    }
  }
};


/**
 * Adds or removes elements from an array. This is a generic version of Array
 * splice. This means that it might work on other objects similar to arrays,
 * such as the arguments object.
 *
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {number|undefined} index The index at which to start changing the
 *     array. If not defined, treated as 0.
 * @param {number} howMany How many elements to remove (0 means no removal. A
 *     value below 0 is treated as zero and so is any other non number. Numbers
 *     are floored).
 * @param {...*} var_args Optional, additional elements to insert into the
 *     array.
 * @return {!Array} the removed elements.
 */
goog.array.splice = function(arr, index, howMany, var_args) {
  goog.asserts.assert(arr.length != null);

  return goog.array.ARRAY_PROTOTYPE_.splice.apply(
      arr, goog.array.slice(arguments, 1));
};


/**
 * Returns a new array from a segment of an array. This is a generic version of
 * Array slice. This means that it might work on other objects similar to
 * arrays, such as the arguments object.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array from
 * which to copy a segment.
 * @param {number} start The index of the first element to copy.
 * @param {number=} opt_end The index after the last element to copy.
 * @return {!Array.<T>} A new array containing the specified segment of the
 *     original array.
 * @template T
 */
goog.array.slice = function(arr, start, opt_end) {
  goog.asserts.assert(arr.length != null);

  // passing 1 arg to slice is not the same as passing 2 where the second is
  // null or undefined (in that case the second argument is treated as 0).
  // we could use slice on the arguments object and then use apply instead of
  // testing the length
  if (arguments.length <= 2) {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start);
  } else {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start, opt_end);
  }
};


/**
 * Removes all duplicates from an array (retaining only the first
 * occurrence of each array element).  This function modifies the
 * array in place and doesn't change the order of the non-duplicate items.
 *
 * For objects, duplicates are identified as having the same unique ID as
 * defined by {@link goog.getUid}.
 *
 * Runtime: N,
 * Worstcase space: 2N (no dupes)
 *
 * @param {goog.array.ArrayLike} arr The array from which to remove duplicates.
 * @param {Array=} opt_rv An optional array in which to return the results,
 *     instead of performing the removal inplace.  If specified, the original
 *     array will remain unchanged.
 */
goog.array.removeDuplicates = function(arr, opt_rv) {
  var returnArray = opt_rv || arr;

  var seen = {}, cursorInsert = 0, cursorRead = 0;
  while (cursorRead < arr.length) {
    var current = arr[cursorRead++];

    // Prefix each type with a single character representing the type to
    // prevent conflicting keys (e.g. true and 'true').
    var key = goog.isObject(current) ?
        'o' + goog.getUid(current) :
        (typeof current).charAt(0) + current;

    if (!Object.prototype.hasOwnProperty.call(seen, key)) {
      seen[key] = true;
      returnArray[cursorInsert++] = current;
    }
  }
  returnArray.length = cursorInsert;
};


/**
 * Searches the specified array for the specified target using the binary
 * search algorithm.  If no opt_compareFn is specified, elements are compared
 * using <code>goog.array.defaultCompare</code>, which compares the elements
 * using the built in < and > operators.  This will produce the expected
 * behavior for homogeneous arrays of String(s) and Number(s). The array
 * specified <b>must</b> be sorted in ascending order (as defined by the
 * comparison function).  If the array is not sorted, results are undefined.
 * If the array contains multiple instances of the specified target value, any
 * of these instances may be found.
 *
 * Runtime: O(log n)
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {*} target The sought value.
 * @param {Function=} opt_compareFn Optional comparison function by which the
 *     array is ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 */
goog.array.binarySearch = function(arr, target, opt_compareFn) {
  return goog.array.binarySearch_(arr,
      opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,
      target);
};


/**
 * Selects an index in the specified array using the binary search algorithm.
 * The evaluator receives an element and determines whether the desired index
 * is before, at, or after it.  The evaluator must be consistent (formally,
 * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)
 * must be monotonically non-increasing).
 *
 * Runtime: O(log n)
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {Function} evaluator Evaluator function that receives 3 arguments
 *     (the element, the index and the array). Should return a negative number,
 *     zero, or a positive number depending on whether the desired index is
 *     before, at, or after the element passed to it.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within evaluator.
 * @return {number} Index of the leftmost element matched by the evaluator, if
 *     such exists; otherwise (-(insertion point) - 1). The insertion point is
 *     the index of the first element for which the evaluator returns negative,
 *     or arr.length if no such element exists. The return value is non-negative
 *     iff a match is found.
 */
goog.array.binarySelect = function(arr, evaluator, opt_obj) {
  return goog.array.binarySearch_(arr, evaluator, true /* isEvaluator */,
      undefined /* opt_target */, opt_obj);
};


/**
 * Implementation of a binary search algorithm which knows how to use both
 * comparison functions and evaluators. If an evaluator is provided, will call
 * the evaluator with the given optional data object, conforming to the
 * interface defined in binarySelect. Otherwise, if a comparison function is
 * provided, will call the comparison function against the given data object.
 *
 * This implementation purposefully does not use goog.bind or goog.partial for
 * performance reasons.
 *
 * Runtime: O(log n)
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {Function} compareFn Either an evaluator or a comparison function,
 *     as defined by binarySearch and binarySelect above.
 * @param {boolean} isEvaluator Whether the function is an evaluator or a
 *     comparison function.
 * @param {*=} opt_target If the function is a comparison function, then this is
 *     the target to binary search for.
 * @param {Object=} opt_selfObj If the function is an evaluator, this is an
  *    optional this object for the evaluator.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @private
 */
goog.array.binarySearch_ = function(arr, compareFn, isEvaluator, opt_target,
    opt_selfObj) {
  var left = 0;  // inclusive
  var right = arr.length;  // exclusive
  var found;
  while (left < right) {
    var middle = (left + right) >> 1;
    var compareResult;
    if (isEvaluator) {
      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
    } else {
      compareResult = compareFn(opt_target, arr[middle]);
    }
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      // We are looking for the lowest index so we can't return immediately.
      found = !compareResult;
    }
  }
  // left is the index if found, or the insertion point otherwise.
  // ~left is a shorthand for -left - 1.
  return found ? left : ~left;
};


/**
 * Sorts the specified array into ascending order.  If no opt_compareFn is
 * specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
 * but will give unpredictable results for heterogenous lists of strings and
 * numbers with different numbers of digits.
 *
 * This sort is not guaranteed to be stable.
 *
 * Runtime: Same as <code>Array.prototype.sort</code>
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison
 *     function by which the
 *     array is to be ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @template T
 */
goog.array.sort = function(arr, opt_compareFn) {
  // TODO(arv): Update type annotation since null is not accepted.
  goog.asserts.assert(arr.length != null);

  goog.array.ARRAY_PROTOTYPE_.sort.call(
      arr, opt_compareFn || goog.array.defaultCompare);
};


/**
 * Sorts the specified array into ascending order in a stable way.  If no
 * opt_compareFn is specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s).
 *
 * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional
 * O(n) overhead of copying the array twice.
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T, T): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T
 */
goog.array.stableSort = function(arr, opt_compareFn) {
  for (var i = 0; i < arr.length; i++) {
    arr[i] = {index: i, value: arr[i]};
  }
  var valueCompareFn = opt_compareFn || goog.array.defaultCompare;
  function stableCompareFn(obj1, obj2) {
    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
  };
  goog.array.sort(arr, stableCompareFn);
  for (var i = 0; i < arr.length; i++) {
    arr[i] = arr[i].value;
  }
};


/**
 * Sorts an array of objects by the specified object key and compare
 * function. If no compare function is provided, the key values are
 * compared in ascending order using <code>goog.array.defaultCompare</code>.
 * This won't work for keys that get renamed by the compiler. So use
 * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
 * @param {Array.<Object>} arr An array of objects to sort.
 * @param {string} key The object key to sort by.
 * @param {Function=} opt_compareFn The function to use to compare key
 *     values.
 */
goog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  goog.array.sort(arr, function(a, b) {
    return compare(a[key], b[key]);
  });
};


/**
 * Tells if the array is sorted.
 * @param {!Array.<T>} arr The array.
 * @param {?function(T,T):number=} opt_compareFn Function to compare the
 *     array elements.
 *     Should take 2 arguments to compare, and return a negative number, zero,
 *     or a positive number depending on whether the first argument is less
 *     than, equal to, or greater than the second.
 * @param {boolean=} opt_strict If true no equal elements are allowed.
 * @return {boolean} Whether the array is sorted.
 * @template T
 */
goog.array.isSorted = function(arr, opt_compareFn, opt_strict) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  for (var i = 1; i < arr.length; i++) {
    var compareResult = compare(arr[i - 1], arr[i]);
    if (compareResult > 0 || compareResult == 0 && opt_strict) {
      return false;
    }
  }
  return true;
};


/**
 * Compares two arrays for equality. Two arrays are considered equal if they
 * have the same length and their corresponding elements are equal according to
 * the comparison function.
 *
 * @param {goog.array.ArrayLike} arr1 The first array to compare.
 * @param {goog.array.ArrayLike} arr2 The second array to compare.
 * @param {Function=} opt_equalsFn Optional comparison function.
 *     Should take 2 arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} Whether the two arrays are equal.
 */
goog.array.equals = function(arr1, arr2, opt_equalsFn) {
  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
      arr1.length != arr2.length) {
    return false;
  }
  var l = arr1.length;
  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
  for (var i = 0; i < l; i++) {
    if (!equalsFn(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
};


/**
 * @deprecated Use {@link goog.array.equals}.
 * @param {goog.array.ArrayLike} arr1 See {@link goog.array.equals}.
 * @param {goog.array.ArrayLike} arr2 See {@link goog.array.equals}.
 * @param {Function=} opt_equalsFn See {@link goog.array.equals}.
 * @return {boolean} See {@link goog.array.equals}.
 */
goog.array.compare = function(arr1, arr2, opt_equalsFn) {
  return goog.array.equals(arr1, arr2, opt_equalsFn);
};


/**
 * 3-way array compare function.
 * @param {!goog.array.ArrayLike} arr1 The first array to compare.
 * @param {!goog.array.ArrayLike} arr2 The second array to compare.
 * @param {?function(?, ?): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @return {number} Negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 */
goog.array.compare3 = function(arr1, arr2, opt_compareFn) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  var l = Math.min(arr1.length, arr2.length);
  for (var i = 0; i < l; i++) {
    var result = compare(arr1[i], arr2[i]);
    if (result != 0) {
      return result;
    }
  }
  return goog.array.defaultCompare(arr1.length, arr2.length);
};


/**
 * Compares its two arguments for order, using the built in < and >
 * operators.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
goog.array.defaultCompare = function(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};


/**
 * Compares its two arguments for equality, using the built in === operator.
 * @param {*} a The first object to compare.
 * @param {*} b The second object to compare.
 * @return {boolean} True if the two arguments are equal, false otherwise.
 */
goog.array.defaultCompareEquality = function(a, b) {
  return a === b;
};


/**
 * Inserts a value into a sorted array. The array is not modified if the
 * value is already present.
 * @param {Array.<T>} array The array to modify.
 * @param {T} value The object to insert.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison function by
 *     which the
 *     array is ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {boolean} True if an element was inserted.
 * @template T
 */
goog.array.binaryInsert = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  if (index < 0) {
    goog.array.insertAt(array, value, -(index + 1));
    return true;
  }
  return false;
};


/**
 * Removes a value from a sorted array.
 * @param {Array} array The array to modify.
 * @param {*} value The object to remove.
 * @param {Function=} opt_compareFn Optional comparison function by which the
 *     array is ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {boolean} True if an element was removed.
 */
goog.array.binaryRemove = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  return (index >= 0) ? goog.array.removeAt(array, index) : false;
};


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {Array.<T>} array The array.
 * @param {function(T,number,Array.<T>):?} sorter Function to call for every
 *     element.  This
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a valid object key (a string, number, etc), or undefined, if
 *     that object should not be placed in a bucket.
 * @return {!Object} An object, with keys being all of the unique return values
 *     of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template T
 */
goog.array.bucket = function(array, sorter) {
  var buckets = {};

  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    var key = sorter(value, i, array);
    if (goog.isDef(key)) {
      // Push the value to the right bucket, creating it if necessary.
      var bucket = buckets[key] || (buckets[key] = []);
      bucket.push(value);
    }
  }

  return buckets;
};


/**
 * Returns an array consisting of the given value repeated N times.
 *
 * @param {*} value The value to repeat.
 * @param {number} n The repeat count.
 * @return {!Array} An array with the repeated value.
 */
goog.array.repeat = function(value, n) {
  var array = [];
  for (var i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
};


/**
 * Returns an array consisting of every argument with all arrays
 * expanded in-place recursively.
 *
 * @param {...*} var_args The values to flatten.
 * @return {!Array} An array containing the flattened values.
 */
goog.array.flatten = function(var_args) {
  var result = [];
  for (var i = 0; i < arguments.length; i++) {
    var element = arguments[i];
    if (goog.isArray(element)) {
      result.push.apply(result, goog.array.flatten.apply(null, element));
    } else {
      result.push(element);
    }
  }
  return result;
};


/**
 * Rotates an array in-place. After calling this method, the element at
 * index i will be the element previously at index (i - n) %
 * array.length, for all values of i between 0 and array.length - 1,
 * inclusive.
 *
 * For example, suppose list comprises [t, a, n, k, s]. After invoking
 * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].
 *
 * @param {!Array.<T>} array The array to rotate.
 * @param {number} n The amount to rotate.
 * @return {!Array.<T>} The array.
 * @template T
 */
goog.array.rotate = function(array, n) {
  goog.asserts.assert(array.length != null);

  if (array.length) {
    n %= array.length;
    if (n > 0) {
      goog.array.ARRAY_PROTOTYPE_.unshift.apply(array, array.splice(-n, n));
    } else if (n < 0) {
      goog.array.ARRAY_PROTOTYPE_.push.apply(array, array.splice(0, -n));
    }
  }
  return array;
};


/**
 * Creates a new array for which the element at position i is an array of the
 * ith element of the provided arrays.  The returned array will only be as long
 * as the shortest array provided; additional values are ignored.  For example,
 * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
 *
 * This is similar to the zip() function in Python.  See {@link
 * http://docs.python.org/library/functions.html#zip}
 *
 * @param {...!goog.array.ArrayLike} var_args Arrays to be combined.
 * @return {!Array.<!Array>} A new array of arrays created from provided arrays.
 */
goog.array.zip = function(var_args) {
  if (!arguments.length) {
    return [];
  }
  var result = [];
  for (var i = 0; true; i++) {
    var value = [];
    for (var j = 0; j < arguments.length; j++) {
      var arr = arguments[j];
      // If i is larger than the array length, this is the shortest array.
      if (i >= arr.length) {
        return result;
      }
      value.push(arr[i]);
    }
    result.push(value);
  }
};


/**
 * Shuffles the values in the specified array using the Fisher-Yates in-place
 * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
 * and so resets the state of that random number generator. Similarly, may reset
 * the state of the any other specified random number generator.
 *
 * Runtime: O(n)
 *
 * @param {!Array} arr The array to be shuffled.
 * @param {function():number=} opt_randFn Optional random function to use for
 *     shuffling.
 *     Takes no arguments, and returns a random number on the interval [0, 1).
 *     Defaults to Math.random() using JavaScript's built-in Math library.
 */
goog.array.shuffle = function(arr, opt_randFn) {
  var randFn = opt_randFn || Math.random;

  for (var i = arr.length - 1; i > 0; i--) {
    // Choose a random array index in [0, i] (inclusive with i).
    var j = Math.floor(randFn() * (i + 1));

    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
};


// node_modules/closure-library/goog/iter/iter.js
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Python style iteration utilities.
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.iter');
goog.provide('goog.iter.Iterator');
goog.provide('goog.iter.StopIteration');

goog.require('goog.array');
goog.require('goog.asserts');


// TODO(nnaze): Add more functions from Python's itertools.
// http://docs.python.org/library/itertools.html


/**
 * @typedef {goog.iter.Iterator|{length:number}|{__iterator__{{ '}}' }}
 */
goog.iter.Iterable;


// For script engines that already support iterators.
if ('StopIteration' in goog.global) {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   */
  goog.iter.StopIteration = goog.global['StopIteration'];
} else {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   * @suppress {duplicate}
   */
  goog.iter.StopIteration = Error('StopIteration');
}



/**
 * Class/interface for iterators.  An iterator needs to implement a {@code next}
 * method and it needs to throw a {@code goog.iter.StopIteration} when the
 * iteration passes beyond the end.  Iterators have no {@code hasNext} method.
 * It is recommended to always use the helper functions to iterate over the
 * iterator or in case you are only targeting JavaScript 1.7 for in loops.
 * @constructor
 */
goog.iter.Iterator = function() {};


/**
 * Returns the next value of the iteration.  This will throw the object
 * {@see goog.iter#StopIteration} when the iteration passes the end.
 * @return {*} Any object or value.
 */
goog.iter.Iterator.prototype.next = function() {
  throw goog.iter.StopIteration;
};


/**
 * Returns the {@code Iterator} object itself.  This is used to implement
 * the iterator protocol in JavaScript 1.7
 * @param {boolean=} opt_keys  Whether to return the keys or values. Default is
 *     to only return the values.  This is being used by the for-in loop (true)
 *     and the for-each-in loop (false).  Even though the param gives a hint
 *     about what the iterator will return there is no guarantee that it will
 *     return the keys when true is passed.
 * @return {!goog.iter.Iterator} The object itself.
 */
goog.iter.Iterator.prototype.__iterator__ = function(opt_keys) {
  return this;
};


/**
 * Returns an iterator that knows how to iterate over the values in the object.
 * @param {goog.iter.Iterable} iterable  If the object is an iterator it
 *     will be returned as is.  If the object has a {@code __iterator__} method
 *     that will be called to get the value iterator.  If the object is an
 *     array-like object we create an iterator for that.
 * @return {!goog.iter.Iterator} An iterator that knows how to iterate over the
 *     values in {@code iterable}.
 */
goog.iter.toIterator = function(iterable) {
  if (iterable instanceof goog.iter.Iterator) {
    return iterable;
  }
  if (typeof iterable.__iterator__ == 'function') {
    return iterable.__iterator__(false);
  }
  if (goog.isArrayLike(iterable)) {
    var i = 0;
    var newIter = new goog.iter.Iterator;
    newIter.next = function() {
      while (true) {
        if (i >= iterable.length) {
          throw goog.iter.StopIteration;
        }
        // Don't include deleted elements.
        if (!(i in iterable)) {
          i++;
          continue;
        }
        return iterable[i++];
      }
    };
    return newIter;
  }


  // TODO(arv): Should we fall back on goog.structs.getValues()?
  throw Error('Not implemented');
};


/**
 * Calls a function for each element in the iterator with the element of the
 * iterator passed as argument.
 *
 * @param {goog.iter.Iterable} iterable  The iterator to iterate
 *     over.  If the iterable is an object {@code toIterator} will be called on
 *     it.
 * @param {Function} f  The function to call for every element.  This function
 *     takes 3 arguments (the element, undefined, and the iterator) and the
 *     return value is irrelevant.  The reason for passing undefined as the
 *     second argument is so that the same function can be used in
 *     {@see goog.array#forEach} as well as others.
 * @param {Object=} opt_obj  The object to be used as the value of 'this' within
 *     {@code f}.
 */
goog.iter.forEach = function(iterable, f, opt_obj) {
  if (goog.isArrayLike(iterable)) {
    /** @preserveTry */
    try {
      goog.array.forEach((/** @type {goog.array.ArrayLike} */ iterable), f,
                         opt_obj);
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  } else {
    iterable = goog.iter.toIterator(iterable);
    /** @preserveTry */
    try {
      while (true) {
        f.call(opt_obj, iterable.next(), undefined, iterable);
      }
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  }
};


/**
 * Calls a function for every element in the iterator, and if the function
 * returns true adds the element to a new iterator.
 *
 * @param {goog.iter.Iterable} iterable The iterator to iterate over.
 * @param {Function} f The function to call for every element.  This function
 *     takes 3 arguments (the element, undefined, and the iterator) and should
 *     return a boolean.  If the return value is true the element will be
 *     included  in the returned iteror.  If it is false the element is not
 *     included.
 * @param {Object=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator} A new iterator in which only elements that
 *     passed the test are present.
 */
goog.iter.filter = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      if (f.call(opt_obj, val, undefined, iterator)) {
        return val;
      }
    }
  };
  return newIter;
};


/**
 * Creates a new iterator that returns the values in a range.  This function
 * can take 1, 2 or 3 arguments:
 * <pre>
 * range(5) same as range(0, 5, 1)
 * range(2, 5) same as range(2, 5, 1)
 * </pre>
 *
 * @param {number} startOrStop  The stop value if only one argument is provided.
 *     The start value if 2 or more arguments are provided.  If only one
 *     argument is used the start value is 0.
 * @param {number=} opt_stop  The stop value.  If left out then the first
 *     argument is used as the stop value.
 * @param {number=} opt_step  The number to increment with between each call to
 *     next.  This can be negative.
 * @return {!goog.iter.Iterator} A new iterator that returns the values in the
 *     range.
 */
goog.iter.range = function(startOrStop, opt_stop, opt_step) {
  var start = 0;
  var stop = startOrStop;
  var step = opt_step || 1;
  if (arguments.length > 1) {
    start = startOrStop;
    stop = opt_stop;
  }
  if (step == 0) {
    throw Error('Range step argument must not be zero');
  }

  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    if (step > 0 && start >= stop || step < 0 && start <= stop) {
      throw goog.iter.StopIteration;
    }
    var rv = start;
    start += step;
    return rv;
  };
  return newIter;
};


/**
 * Joins the values in a iterator with a delimiter.
 * @param {goog.iter.Iterable} iterable  The iterator to get the values from.
 * @param {string} deliminator  The text to put between the values.
 * @return {string} The joined value string.
 */
goog.iter.join = function(iterable, deliminator) {
  return goog.iter.toArray(iterable).join(deliminator);
};


/**
 * For every element in the iterator call a function and return a new iterator
 * with that value.
 *
 * @param {goog.iter.Iterable} iterable The iterator to iterate over.
 * @param {Function} f The function to call for every element.  This function
 *     takes 3 arguments (the element, undefined, and the iterator) and should
 *     return a new value.
 * @param {Object=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator} A new iterator that returns the results of
 *     applying the function to each element in the original iterator.
 */
goog.iter.map = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      return f.call(opt_obj, val, undefined, iterator);
    }
  };
  return newIter;
};


/**
 * Passes every element of an iterator into a function and accumulates the
 * result.
 *
 * @param {goog.iter.Iterable} iterable The iterator to iterate over.
 * @param {Function} f The function to call for every element. This function
 *     takes 2 arguments (the function's previous result or the initial value,
 *     and the value of the current element).
 *     function(previousValue, currentElement) : newValue.
 * @param {*} val The initial value to pass into the function on the first call.
 * @param {Object=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {*} Result of evaluating f repeatedly across the values of
 *     the iterator.
 */
goog.iter.reduce = function(iterable, f, val, opt_obj) {
  var rval = val;
  goog.iter.forEach(iterable, function(val) {
    rval = f.call(opt_obj, rval, val);
  });
  return rval;
};


/**
 * Goes through the values in the iterator. Calls f for each these and if any of
 * them returns true, this returns true (without checking the rest). If all
 * return false this will return false.
 *
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {Function} f  The function to call for every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {Object=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if any value passes the test.
 */
goog.iter.some = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (true) {
      if (f.call(opt_obj, iterable.next(), undefined, iterable)) {
        return true;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return false;
};


/**
 * Goes through the values in the iterator. Calls f for each these and if any of
 * them returns false this returns false (without checking the rest). If all
 * return true this will return true.
 *
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {Function} f  The function to call for every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {Object=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if every value passes the test.
 */
goog.iter.every = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (true) {
      if (!f.call(opt_obj, iterable.next(), undefined, iterable)) {
        return false;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return true;
};


/**
 * Takes zero or more iterators and returns one iterator that will iterate over
 * them in the order chained.
 * @param {...goog.iter.Iterator} var_args  Any number of iterator objects.
 * @return {!goog.iter.Iterator} Returns a new iterator that will iterate over
 *     all the given iterators' contents.
 */
goog.iter.chain = function(var_args) {
  var args = arguments;
  var length = args.length;
  var i = 0;
  var newIter = new goog.iter.Iterator;

  /**
   * @return {*} The next item in the iteration.
   * @this {goog.iter.Iterator}
   */
  newIter.next = function() {
    /** @preserveTry */
    try {
      if (i >= length) {
        throw goog.iter.StopIteration;
      }
      var current = goog.iter.toIterator(args[i]);
      return current.next();
    } catch (ex) {
      if (ex !== goog.iter.StopIteration || i >= length) {
        throw ex;
      } else {
        // In case we got a StopIteration increment counter and try again.
        i++;
        return this.next();
      }
    }
  };

  return newIter;
};


/**
 * Builds a new iterator that iterates over the original, but skips elements as
 * long as a supplied function returns true.
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {Function} f  The function to call for every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {Object=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator} A new iterator that drops elements from the
 *     original iterator as long as {@code f} is true.
 */
goog.iter.dropWhile = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  var dropping = true;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      if (dropping && f.call(opt_obj, val, undefined, iterator)) {
        continue;
      } else {
        dropping = false;
      }
      return val;
    }
  };
  return newIter;
};


/**
 * Builds a new iterator that iterates over the original, but only as long as a
 * supplied function returns true.
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {Function} f  The function to call for every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {Object=} opt_obj This is used as the 'this' object in f when called.
 * @return {!goog.iter.Iterator} A new iterator that keeps elements in the
 *     original iterator as long as the function is true.
 */
goog.iter.takeWhile = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  var taking = true;
  newIter.next = function() {
    while (true) {
      if (taking) {
        var val = iterator.next();
        if (f.call(opt_obj, val, undefined, iterator)) {
          return val;
        } else {
          taking = false;
        }
      } else {
        throw goog.iter.StopIteration;
      }
    }
  };
  return newIter;
};


/**
 * Converts the iterator to an array
 * @param {goog.iter.Iterable} iterable  The iterator to convert to an array.
 * @return {!Array} An array of the elements the iterator iterates over.
 */
goog.iter.toArray = function(iterable) {
  // Fast path for array-like.
  if (goog.isArrayLike(iterable)) {
    return goog.array.toArray((/** @type {!goog.array.ArrayLike} */ iterable));
  }
  iterable = goog.iter.toIterator(iterable);
  var array = [];
  goog.iter.forEach(iterable, function(val) {
    array.push(val);
  });
  return array;
};


/**
 * Iterates over 2 iterators and returns true if they contain the same sequence
 * of elements and have the same length.
 * @param {goog.iter.Iterable} iterable1  The first iterable object.
 * @param {goog.iter.Iterable} iterable2  The second iterable object.
 * @return {boolean} true if the iterators contain the same sequence of
 *     elements and have the same length.
 */
goog.iter.equals = function(iterable1, iterable2) {
  iterable1 = goog.iter.toIterator(iterable1);
  iterable2 = goog.iter.toIterator(iterable2);
  var b1, b2;
  /** @preserveTry */
  try {
    while (true) {
      b1 = b2 = false;
      var val1 = iterable1.next();
      b1 = true;
      var val2 = iterable2.next();
      b2 = true;
      if (val1 != val2) {
        return false;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    } else {
      if (b1 && !b2) {
        // iterable1 done but iterable2 is not done.
        return false;
      }
      if (!b2) {
        /** @preserveTry */
        try {
          // iterable2 not done?
          val2 = iterable2.next();
          // iterable2 not done but iterable1 is done
          return false;
        } catch (ex1) {
          if (ex1 !== goog.iter.StopIteration) {
            throw ex1;
          }
          // iterable2 done as well... They are equal
          return true;
        }
      }
    }
  }
  return false;
};


/**
 * Advances the iterator to the next position, returning the given default value
 * instead of throwing an exception if the iterator has no more entries.
 * @param {goog.iter.Iterable} iterable The iterable object.
 * @param {*} defaultValue The value to return if the iterator is empty.
 * @return {*} The next item in the iteration, or defaultValue if the iterator
 *     was empty.
 */
goog.iter.nextOrValue = function(iterable, defaultValue) {
  try {
    return goog.iter.toIterator(iterable).next();
  } catch (e) {
    if (e != goog.iter.StopIteration) {
      throw e;
    }
    return defaultValue;
  }
};


/**
 * Cartesian product of zero or more sets.  Gives an iterator that gives every
 * combination of one element chosen from each set.  For example,
 * ([1, 2], [3, 4]) gives ([1, 3], [1, 4], [2, 3], [2, 4]).
 * @see http://docs.python.org/library/itertools.html#itertools.product
 * @param {...!goog.array.ArrayLike.<*>} var_args Zero or more sets, as arrays.
 * @return {!goog.iter.Iterator} An iterator that gives each n-tuple (as an
 *     array).
 */
goog.iter.product = function(var_args) {
  var someArrayEmpty = goog.array.some(arguments, function(arr) {
    return !arr.length;
  });

  // An empty set in a cartesian product gives an empty set.
  if (someArrayEmpty || !arguments.length) {
    return new goog.iter.Iterator();
  }

  var iter = new goog.iter.Iterator();
  var arrays = arguments;

  // The first indicies are [0, 0, ...]
  var indicies = goog.array.repeat(0, arrays.length);

  iter.next = function() {

    if (indicies) {
      var retVal = goog.array.map(indicies, function(valueIndex, arrayIndex) {
        return arrays[arrayIndex][valueIndex];
      });

      // Generate the next-largest indicies for the next call.
      // Increase the rightmost index. If it goes over, increase the next
      // rightmost (like carry-over addition).
      for (var i = indicies.length - 1; i >= 0; i--) {
        // Assertion prevents compiler warning below.
        goog.asserts.assert(indicies);
        if (indicies[i] < arrays[i].length - 1) {
          indicies[i]++;
          break;
        }

        // We're at the last indicies (the last element of every array), so
        // the iteration is over on the next call.
        if (i == 0) {
          indicies = null;
          break;
        }
        // Reset the index in this column and loop back to increment the
        // next one.
        indicies[i] = 0;
      }
      return retVal;
    }

    throw goog.iter.StopIteration;
  };

  return iter;
};


/**
 * Create an iterator to cycle over the iterable's elements indefinitely.
 * For example, ([1, 2, 3]) would return : 1, 2, 3, 1, 2, 3, ...
 * @see: http://docs.python.org/library/itertools.html#itertools.cycle.
 * @param {!goog.iter.Iterable} iterable The iterable object.
 * @return {!goog.iter.Iterator} An iterator that iterates indefinitely over
 * the values in {@code iterable}.
 */
goog.iter.cycle = function(iterable) {

  var baseIterator = goog.iter.toIterator(iterable);

  // We maintain a cache to store the iterable elements as we iterate
  // over them. The cache is used to return elements once we have
  // iterated over the iterable once.
  var cache = [];
  var cacheIndex = 0;

  var iter = new goog.iter.Iterator();

  // This flag is set after the iterable is iterated over once
  var useCache = false;

  iter.next = function() {
    var returnElement = null;

    // Pull elements off the original iterator if not using cache
    if (!useCache) {

      try {
        // Return the element from the iterable
        returnElement = baseIterator.next();
        cache.push(returnElement);
        return returnElement;
      } catch (e) {
        // If an exception other than StopIteration is thrown
        // or if there are no elements to iterate over (the iterable was empty)
        // throw an exception
        if (e != goog.iter.StopIteration || goog.array.isEmpty(cache)) {
          throw e;
        }
        // set useCache to true after we know that a 'StopIteration' exception
        // was thrown and the cache is not empty (to handle the 'empty iterable'
        // use case)
        useCache = true;
      }
    }

    returnElement = cache[cacheIndex];
    cacheIndex = (cacheIndex + 1) % cache.length;

    return returnElement;
  };

  return iter;
};


// node_modules/closure-library/goog/structs/structs.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Generics method for collection-like classes and objects.
 *
 * @author arv@google.com (Erik Arvidsson)
 *
 * This file contains functions to work with collections. It supports using
 * Map, Set, Array and Object and other classes that implement collection-like
 * methods.
 */


goog.provide('goog.structs');

goog.require('goog.array');
goog.require('goog.object');


// We treat an object as a dictionary if it has getKeys or it is an object that
// isn't arrayLike.


/**
 * Returns the number of values in the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {number} The number of values in the collection-like object.
 */
goog.structs.getCount = function(col) {
  if (typeof col.getCount == 'function') {
    return col.getCount();
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return col.length;
  }
  return goog.object.getCount(col);
};


/**
 * Returns the values of the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {!Array} The values in the collection-like object.
 */
goog.structs.getValues = function(col) {
  if (typeof col.getValues == 'function') {
    return col.getValues();
  }
  if (goog.isString(col)) {
    return col.split('');
  }
  if (goog.isArrayLike(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(col[i]);
    }
    return rv;
  }
  return goog.object.getValues(col);
};


/**
 * Returns the keys of the collection. Some collections have no notion of
 * keys/indexes and this function will return undefined in those cases.
 * @param {Object} col The collection-like object.
 * @return {!Array|undefined} The keys in the collection.
 */
goog.structs.getKeys = function(col) {
  if (typeof col.getKeys == 'function') {
    return col.getKeys();
  }
  // if we have getValues but no getKeys we know this is a key-less collection
  if (typeof col.getValues == 'function') {
    return undefined;
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(i);
    }
    return rv;
  }

  return goog.object.getKeys(col);
};


/**
 * Whether the collection contains the given value. This is O(n) and uses
 * equals (==) to test the existence.
 * @param {Object} col The collection-like object.
 * @param {*} val The value to check for.
 * @return {boolean} True if the map contains the value.
 */
goog.structs.contains = function(col, val) {
  if (typeof col.contains == 'function') {
    return col.contains(val);
  }
  if (typeof col.containsValue == 'function') {
    return col.containsValue(val);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.contains(/** @type {Array} */ (col), val);
  }
  return goog.object.containsValue(col, val);
};


/**
 * Whether the collection is empty.
 * @param {Object} col The collection-like object.
 * @return {boolean} True if empty.
 */
goog.structs.isEmpty = function(col) {
  if (typeof col.isEmpty == 'function') {
    return col.isEmpty();
  }

  // We do not use goog.string.isEmpty because here we treat the string as
  // collection and as such even whitespace matters

  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.isEmpty(/** @type {Array} */ (col));
  }
  return goog.object.isEmpty(col);
};


/**
 * Removes all the elements from the collection.
 * @param {Object} col The collection-like object.
 */
goog.structs.clear = function(col) {
  // NOTE(arv): This should not contain strings because strings are immutable
  if (typeof col.clear == 'function') {
    col.clear();
  } else if (goog.isArrayLike(col)) {
    goog.array.clear((/** @type {goog.array.ArrayLike} */ col));
  } else {
    goog.object.clear(col);
  }
};


/**
 * Calls a function for each value in a collection. The function takes
 * three arguments; the value, the key and the collection.
 *
 * @param {Object} col The collection-like object.
 * @param {Function} f The function to call for every value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and the return value is irrelevant.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 */
goog.structs.forEach = function(col, f, opt_obj) {
  if (typeof col.forEach == 'function') {
    col.forEach(f, opt_obj);
  } else if (goog.isArrayLike(col) || goog.isString(col)) {
    goog.array.forEach(/** @type {Array} */ (col), f, opt_obj);
  } else {
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    for (var i = 0; i < l; i++) {
      f.call(opt_obj, values[i], keys && keys[i], col);
    }
  }
};


/**
 * Calls a function for every value in the collection. When a call returns true,
 * adds the value to a new collection (Array is returned by default).
 *
 * @param {Object} col The collection-like object.
 * @param {Function} f The function to call for every value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean. If the
 *     return value is true the value is added to the result collection. If it
 *     is false the value is not included.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object|!Array} A new collection where the passed values are
 *     present. If col is a key-less collection an array is returned.  If col
 *     has keys and values a plain old JS object is returned.
 */
goog.structs.filter = function(col, f, opt_obj) {
  if (typeof col.filter == 'function') {
    return col.filter(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.filter(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], keys[i], col)) {
        rv[keys[i]] = values[i];
      }
    }
  } else {
    // We should not use goog.array.filter here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], undefined, col)) {
        rv.push(values[i]);
      }
    }
  }
  return rv;
};


/**
 * Calls a function for every value in the collection and adds the result into a
 * new collection (defaults to creating a new Array).
 *
 * @param {Object} col The collection-like object.
 * @param {Function} f The function to call for every value. This function
 *     takes 3 arguments (the value, the key or undefined if the collection has
 *     no notion of keys, and the collection) and should return something. The
 *     result will be used as the value in the new collection.
 * @param {Object=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object|!Array} A new collection with the new values.  If col is a
 *     key-less collection an array is returned.  If col has keys and values a
 *     plain old JS object is returned.
 */
goog.structs.map = function(col, f, opt_obj) {
  if (typeof col.map == 'function') {
    return col.map(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.map(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      rv[keys[i]] = f.call(opt_obj, values[i], keys[i], col);
    }
  } else {
    // We should not use goog.array.map here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      rv[i] = f.call(opt_obj, values[i], undefined, col);
    }
  }
  return rv;
};


/**
 * Calls f for each value in a collection. If any call returns true this returns
 * true (without checking the rest). If all returns false this returns false.
 *
 * @param {Object|Array|string} col The collection-like object.
 * @param {Function} f The function to call for every value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean.
 * @param {Object=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if any value passes the test.
 */
goog.structs.some = function(col, f, opt_obj) {
  if (typeof col.some == 'function') {
    return col.some(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.some(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (f.call(opt_obj, values[i], keys && keys[i], col)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls f for each value in a collection. If all calls return true this return
 * true this returns true. If any returns false this returns false at this point
 *  and does not continue to check the remaining values.
 *
 * @param {Object} col The collection-like object.
 * @param {Function} f The function to call for every value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean.
 * @param {Object=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if all key-value pairs pass the test.
 */
goog.structs.every = function(col, f, opt_obj) {
  if (typeof col.every == 'function') {
    return col.every(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.every(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (!f.call(opt_obj, values[i], keys && keys[i], col)) {
      return false;
    }
  }
  return true;
};


// node_modules/closure-library/goog/structs/map.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Hash Map.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author jonp@google.com (Jon Perlow) Optimized for IE6
 *
 * This file contains an implementation of a Map structure. It implements a lot
 * of the methods used in goog.structs so those functions work on hashes.  For
 * convenience with common usage the methods accept any type for the key, though
 * internally they will be cast to strings.
 */


goog.provide('goog.structs.Map');

goog.require('goog.iter.Iterator');
goog.require('goog.iter.StopIteration');
goog.require('goog.object');
goog.require('goog.structs');



/**
 * Class for Hash Map datastructure.
 * @param {*=} opt_map Map or Object to initialize the map with.
 * @param {...*} var_args If 2 or more arguments are present then they
 *     will be used as key-value pairs.
 * @constructor
 */
goog.structs.Map = function(opt_map, var_args) {

  /**
   * Underlying JS object used to implement the map.
   * @type {!Object}
   * @private
   */
  this.map_ = {};

  /**
   * An array of keys. This is necessary for two reasons:
   *   1. Iterating the keys using for (var key in this.map_) allocates an
   *      object for every key in IE which is really bad for IE6 GC perf.
   *   2. Without a side data structure, we would need to escape all the keys
   *      as that would be the only way we could tell during iteration if the
   *      key was an internal key or a property of the object.
   *
   * This array can contain deleted keys so it's necessary to check the map
   * as well to see if the key is still in the map (this doesn't require a
   * memory allocation in IE).
   * @type {!Array.<string>}
   * @private
   */
  this.keys_ = [];

  var argLength = arguments.length;

  if (argLength > 1) {
    if (argLength % 2) {
      throw Error('Uneven number of arguments');
    }
    for (var i = 0; i < argLength; i += 2) {
      this.set(arguments[i], arguments[i + 1]);
    }
  } else if (opt_map) {
    this.addAll(/** @type {Object} */ (opt_map));
  }
};


/**
 * The number of key value pairs in the map.
 * @private
 * @type {number}
 */
goog.structs.Map.prototype.count_ = 0;


/**
 * Version used to detect changes while iterating.
 * @private
 * @type {number}
 */
goog.structs.Map.prototype.version_ = 0;


/**
 * @return {number} The number of key-value pairs in the map.
 */
goog.structs.Map.prototype.getCount = function() {
  return this.count_;
};


/**
 * Returns the values of the map.
 * @return {!Array} The values in the map.
 */
goog.structs.Map.prototype.getValues = function() {
  this.cleanupKeysArray_();

  var rv = [];
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    rv.push(this.map_[key]);
  }
  return rv;
};


/**
 * Returns the keys of the map.
 * @return {!Array.<string>} Array of string values.
 */
goog.structs.Map.prototype.getKeys = function() {
  this.cleanupKeysArray_();
  return /** @type {!Array.<string>} */ (this.keys_.concat());
};


/**
 * Whether the map contains the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the map contains the key.
 */
goog.structs.Map.prototype.containsKey = function(key) {
  return goog.structs.Map.hasKey_(this.map_, key);
};


/**
 * Whether the map contains the given value. This is O(n).
 * @param {*} val The value to check for.
 * @return {boolean} Whether the map contains the value.
 */
goog.structs.Map.prototype.containsValue = function(val) {
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Whether this map is equal to the argument map.
 * @param {goog.structs.Map} otherMap The map against which to test equality.
 * @param {function(?, ?) : boolean=} opt_equalityFn Optional equality function
 *     to test equality of values. If not specified, this will test whether
 *     the values contained in each map are identical objects.
 * @return {boolean} Whether the maps are equal.
 */
goog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {
  if (this === otherMap) {
    return true;
  }

  if (this.count_ != otherMap.getCount()) {
    return false;
  }

  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;

  this.cleanupKeysArray_();
  for (var key, i = 0; key = this.keys_[i]; i++) {
    if (!equalityFn(this.get(key), otherMap.get(key))) {
      return false;
    }
  }

  return true;
};


/**
 * Default equality test for values.
 * @param {*} a The first value.
 * @param {*} b The second value.
 * @return {boolean} Whether a and b reference the same object.
 */
goog.structs.Map.defaultEquals = function(a, b) {
  return a === b;
};


/**
 * @return {boolean} Whether the map is empty.
 */
goog.structs.Map.prototype.isEmpty = function() {
  return this.count_ == 0;
};


/**
 * Removes all key-value pairs from the map.
 */
goog.structs.Map.prototype.clear = function() {
  this.map_ = {};
  this.keys_.length = 0;
  this.count_ = 0;
  this.version_ = 0;
};


/**
 * Removes a key-value pair based on the key. This is O(logN) amortized due to
 * updating the keys array whenever the count becomes half the size of the keys
 * in the keys array.
 * @param {*} key  The key to remove.
 * @return {boolean} Whether object was removed.
 */
goog.structs.Map.prototype.remove = function(key) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    delete this.map_[key];
    this.count_--;
    this.version_++;

    // clean up the keys array if the threshhold is hit
    if (this.keys_.length > 2 * this.count_) {
      this.cleanupKeysArray_();
    }

    return true;
  }
  return false;
};


/**
 * Cleans up the temp keys array by removing entries that are no longer in the
 * map.
 * @private
 */
goog.structs.Map.prototype.cleanupKeysArray_ = function() {
  if (this.count_ != this.keys_.length) {
    // First remove keys that are no longer in the map.
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (goog.structs.Map.hasKey_(this.map_, key)) {
        this.keys_[destIndex++] = key;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }

  if (this.count_ != this.keys_.length) {
    // If the count still isn't correct, that means we have duplicates. This can
    // happen when the same key is added and removed multiple times. Now we have
    // to allocate one extra Object to remove the duplicates. This could have
    // been done in the first pass, but in the common case, we can avoid
    // allocating an extra object by only doing this when necessary.
    var seen = {};
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (!(goog.structs.Map.hasKey_(seen, key))) {
        this.keys_[destIndex++] = key;
        seen[key] = 1;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }
};


/**
 * Returns the value for the given key.  If the key is not found and the default
 * value is not given this will return {@code undefined}.
 * @param {*} key The key to get the value for.
 * @param {*=} opt_val The value to return if no item is found for the given
 *     key, defaults to undefined.
 * @return {*} The value for the given key.
 */
goog.structs.Map.prototype.get = function(key, opt_val) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    return this.map_[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the map.
 * @param {*} key The key.
 * @param {*} value The value to add.
 * @return {*} Some subclasses return a value.
 */
goog.structs.Map.prototype.set = function(key, value) {
  if (!(goog.structs.Map.hasKey_(this.map_, key))) {
    this.count_++;
    this.keys_.push(key);
    // Only change the version if we add a new key.
    this.version_++;
  }
  this.map_[key] = value;
};


/**
 * Adds multiple key-value pairs from another goog.structs.Map or Object.
 * @param {Object} map  Object containing the data to add.
 */
goog.structs.Map.prototype.addAll = function(map) {
  var keys, values;
  if (map instanceof goog.structs.Map) {
    keys = map.getKeys();
    values = map.getValues();
  } else {
    keys = goog.object.getKeys(map);
    values = goog.object.getValues(map);
  }
  // we could use goog.array.forEach here but I don't want to introduce that
  // dependency just for this.
  for (var i = 0; i < keys.length; i++) {
    this.set(keys[i], values[i]);
  }
};


/**
 * Clones a map and returns a new map.
 * @return {!goog.structs.Map} A new map with the same key-value pairs.
 */
goog.structs.Map.prototype.clone = function() {
  return new goog.structs.Map(this);
};


/**
 * Returns a new map in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * It acts very similarly to {goog.object.transpose(Object)}.
 *
 * @return {!goog.structs.Map} The transposed map.
 */
goog.structs.Map.prototype.transpose = function() {
  var transposed = new goog.structs.Map();
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    var value = this.map_[key];
    transposed.set(value, key);
  }

  return transposed;
};


/**
 * @return {!Object} Object representation of the map.
 */
goog.structs.Map.prototype.toObject = function() {
  this.cleanupKeysArray_();
  var obj = {};
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    obj[key] = this.map_[key];
  }
  return obj;
};


/**
 * Returns an iterator that iterates over the keys in the map.  Removal of keys
 * while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the keys in the map.
 */
goog.structs.Map.prototype.getKeyIterator = function() {
  return this.__iterator__(true);
};


/**
 * Returns an iterator that iterates over the values in the map.  Removal of
 * keys while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the values in the map.
 */
goog.structs.Map.prototype.getValueIterator = function() {
  return this.__iterator__(false);
};


/**
 * Returns an iterator that iterates over the values or the keys in the map.
 * This throws an exception if the map was mutated since the iterator was
 * created.
 * @param {boolean=} opt_keys True to iterate over the keys. False to iterate
 *     over the values.  The default value is false.
 * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.
 */
goog.structs.Map.prototype.__iterator__ = function(opt_keys) {
  // Clean up keys to minimize the risk of iterating over dead keys.
  this.cleanupKeysArray_();

  var i = 0;
  var keys = this.keys_;
  var map = this.map_;
  var version = this.version_;
  var selfObj = this;

  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      if (version != selfObj.version_) {
        throw Error('The map has changed since the iterator was created');
      }
      if (i >= keys.length) {
        throw goog.iter.StopIteration;
      }
      var key = keys[i++];
      return opt_keys ? key : map[key];
    }
  };
  return newIter;
};


/**
 * Safe way to test for hasOwnProperty.  It even allows testing for
 * 'hasOwnProperty'.
 * @param {Object} obj The object to test for presence of the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the object has the key.
 * @private
 */
goog.structs.Map.hasKey_ = function(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
};


// node_modules/closure-library/goog/uri/uri.js
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Class for parsing and formatting URIs.
 *
 * Use goog.Uri(string) to parse a URI string.  Use goog.Uri.create(...) to
 * create a new instance of the goog.Uri object from Uri parts.
 *
 * e.g: <code>var myUri = new goog.Uri(window.location);</code>
 *
 * Implements RFC 3986 for parsing/formatting URIs.
 * http://gbiv.com/protocols/uri/rfc/rfc3986.html
 *
 * Some changes have been made to the interface (more like .NETs), though the
 * internal representation is now of un-encoded parts, this will change the
 * behavior slightly.
 *
 */

goog.provide('goog.Uri');
goog.provide('goog.Uri.QueryData');

goog.require('goog.array');
goog.require('goog.string');
goog.require('goog.structs');
goog.require('goog.structs.Map');
goog.require('goog.uri.utils');
goog.require('goog.uri.utils.ComponentIndex');



/**
 * This class contains setters and getters for the parts of the URI.
 * The <code>getXyz</code>/<code>setXyz</code> methods return the decoded part
 * -- so<code>goog.Uri.parse('/foo%20bar').getPath()</code> will return the
 * decoded path, <code>/foo bar</code>.
 *
 * The constructor accepts an optional unparsed, raw URI string.  The parser
 * is relaxed, so special characters that aren't escaped but don't cause
 * ambiguities will not cause parse failures.
 *
 * All setters return <code>this</code> and so may be chained, a la
 * <code>goog.Uri.parse('/foo').setFragment('part').toString()</code>.
 *
 * @param {*=} opt_uri Optional string URI to parse
 *        (use goog.Uri.create() to create a URI from parts), or if
 *        a goog.Uri is passed, a clone is created.
 * @param {boolean=} opt_ignoreCase If true, #getParameterValue will ignore
 * the case of the parameter name.
 *
 * @constructor
 */
goog.Uri = function(opt_uri, opt_ignoreCase) {
  // Parse in the uri string
  var m;
  if (opt_uri instanceof goog.Uri) {
    this.ignoreCase_ = goog.isDef(opt_ignoreCase) ?
        opt_ignoreCase : opt_uri.getIgnoreCase();
    this.setScheme(opt_uri.getScheme());
    this.setUserInfo(opt_uri.getUserInfo());
    this.setDomain(opt_uri.getDomain());
    this.setPort(opt_uri.getPort());
    this.setPath(opt_uri.getPath());
    this.setQueryData(opt_uri.getQueryData().clone());
    this.setFragment(opt_uri.getFragment());
  } else if (opt_uri && (m = goog.uri.utils.split(String(opt_uri)))) {
    this.ignoreCase_ = !!opt_ignoreCase;

    // Set the parts -- decoding as we do so.
    // COMPATABILITY NOTE - In IE, unmatched fields may be empty strings,
    // whereas in other browsers they will be undefined.
    this.setScheme(m[goog.uri.utils.ComponentIndex.SCHEME] || '', true);
    this.setUserInfo(m[goog.uri.utils.ComponentIndex.USER_INFO] || '', true);
    this.setDomain(m[goog.uri.utils.ComponentIndex.DOMAIN] || '', true);
    this.setPort(m[goog.uri.utils.ComponentIndex.PORT]);
    this.setPath(m[goog.uri.utils.ComponentIndex.PATH] || '', true);
    this.setQueryData(m[goog.uri.utils.ComponentIndex.QUERY_DATA] || '', true);
    this.setFragment(m[goog.uri.utils.ComponentIndex.FRAGMENT] || '', true);

  } else {
    this.ignoreCase_ = !!opt_ignoreCase;
    this.queryData_ = new goog.Uri.QueryData(null, null, this.ignoreCase_);
  }
};


/**
 * If true, we preserve the type of query parameters set programmatically.
 *
 * This means that if you set a parameter to a boolean, and then call
 * getParameterValue, you will get a boolean back.
 *
 * If false, we will coerce parameters to strings, just as they would
 * appear in real URIs.
 *
 * TODO(nicksantos): Remove this once people have time to fix all tests.
 *
 * @type {boolean}
 */
goog.Uri.preserveParameterTypesCompatibilityFlag = false;


/**
 * Parameter name added to stop caching.
 * @type {string}
 */
goog.Uri.RANDOM_PARAM = goog.uri.utils.StandardQueryParam.RANDOM;


/**
 * Scheme such as "http".
 * @type {string}
 * @private
 */
goog.Uri.prototype.scheme_ = '';


/**
 * User credentials in the form "username:password".
 * @type {string}
 * @private
 */
goog.Uri.prototype.userInfo_ = '';


/**
 * Domain part, e.g. "www.google.com".
 * @type {string}
 * @private
 */
goog.Uri.prototype.domain_ = '';


/**
 * Port, e.g. 8080.
 * @type {?number}
 * @private
 */
goog.Uri.prototype.port_ = null;


/**
 * Path, e.g. "/tests/img.png".
 * @type {string}
 * @private
 */
goog.Uri.prototype.path_ = '';


/**
 * Object representing query data.
 * @type {!goog.Uri.QueryData}
 * @private
 */
goog.Uri.prototype.queryData_;


/**
 * The fragment without the #.
 * @type {string}
 * @private
 */
goog.Uri.prototype.fragment_ = '';


/**
 * Whether or not this Uri should be treated as Read Only.
 * @type {boolean}
 * @private
 */
goog.Uri.prototype.isReadOnly_ = false;


/**
 * Whether or not to ignore case when comparing query params.
 * @type {boolean}
 * @private
 */
goog.Uri.prototype.ignoreCase_ = false;


/**
 * @return {string} The string form of the url.
 * @override
 */
goog.Uri.prototype.toString = function() {
  var out = [];

  var scheme = this.getScheme();
  if (scheme) {
    out.push(goog.Uri.encodeSpecialChars_(
        scheme, goog.Uri.reDisallowedInSchemeOrUserInfo_), ':');
  }

  var domain = this.getDomain();
  if (domain) {
    out.push('//');

    var userInfo = this.getUserInfo();
    if (userInfo) {
      out.push(goog.Uri.encodeSpecialChars_(
          userInfo, goog.Uri.reDisallowedInSchemeOrUserInfo_), '@');
    }

    out.push(goog.string.urlEncode(domain));

    var port = this.getPort();
    if (port != null) {
      out.push(':', String(port));
    }
  }

  var path = this.getPath();
  if (path) {
    if (this.hasDomain() && path.charAt(0) != '/') {
      out.push('/');
    }
    out.push(goog.Uri.encodeSpecialChars_(
        path,
        path.charAt(0) == '/' ?
            goog.Uri.reDisallowedInAbsolutePath_ :
            goog.Uri.reDisallowedInRelativePath_));
  }

  var query = this.getEncodedQuery();
  if (query) {
    out.push('?', query);
  }

  var fragment = this.getFragment();
  if (fragment) {
    out.push('#', goog.Uri.encodeSpecialChars_(
        fragment, goog.Uri.reDisallowedInFragment_));
  }
  return out.join('');
};


/**
 * Resolves a relative url string to a this base uri.
 *
 * There are several kinds of relative urls:<br>
 * 1. foo - replaces the last part of the path, the whole query and fragment<br>
 * 2. /foo - replaces the the path, the query and fragment<br>
 * 3. //foo - replaces everything from the domain on.  foo is a domain name<br>
 * 4. ?foo - replace the query and fragment<br>
 * 5. #foo - replace the fragment only
 *
 * Additionally, if relative url has a non-empty path, all ".." and "."
 * segments will be resolved, as described in RFC 3986.
 *
 * @param {goog.Uri} relativeUri The relative url to resolve.
 * @return {!goog.Uri} The resolved URI.
 */
goog.Uri.prototype.resolve = function(relativeUri) {

  var absoluteUri = this.clone();

  // we satisfy these conditions by looking for the first part of relativeUri
  // that is not blank and applying defaults to the rest

  var overridden = relativeUri.hasScheme();

  if (overridden) {
    absoluteUri.setScheme(relativeUri.getScheme());
  } else {
    overridden = relativeUri.hasUserInfo();
  }

  if (overridden) {
    absoluteUri.setUserInfo(relativeUri.getUserInfo());
  } else {
    overridden = relativeUri.hasDomain();
  }

  if (overridden) {
    absoluteUri.setDomain(relativeUri.getDomain());
  } else {
    overridden = relativeUri.hasPort();
  }

  var path = relativeUri.getPath();
  if (overridden) {
    absoluteUri.setPort(relativeUri.getPort());
  } else {
    overridden = relativeUri.hasPath();
    if (overridden) {
      // resolve path properly
      if (path.charAt(0) != '/') {
        // path is relative
        if (this.hasDomain() && !this.hasPath()) {
          // RFC 3986, section 5.2.3, case 1
          path = '/' + path;
        } else {
          // RFC 3986, section 5.2.3, case 2
          var lastSlashIndex = absoluteUri.getPath().lastIndexOf('/');
          if (lastSlashIndex != -1) {
            path = absoluteUri.getPath().substr(0, lastSlashIndex + 1) + path;
          }
        }
      }
      path = goog.Uri.removeDotSegments(path);
    }
  }

  if (overridden) {
    absoluteUri.setPath(path);
  } else {
    overridden = relativeUri.hasQuery();
  }

  if (overridden) {
    absoluteUri.setQueryData(relativeUri.getDecodedQuery());
  } else {
    overridden = relativeUri.hasFragment();
  }

  if (overridden) {
    absoluteUri.setFragment(relativeUri.getFragment());
  }

  return absoluteUri;
};


/**
 * Clones the URI instance.
 * @return {!goog.Uri} New instance of the URI objcet.
 */
goog.Uri.prototype.clone = function() {
  return new goog.Uri(this);
};


/**
 * @return {string} The encoded scheme/protocol for the URI.
 */
goog.Uri.prototype.getScheme = function() {
  return this.scheme_;
};


/**
 * Sets the scheme/protocol.
 * @param {string} newScheme New scheme value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setScheme = function(newScheme, opt_decode) {
  this.enforceReadOnly();
  this.scheme_ = opt_decode ? goog.Uri.decodeOrEmpty_(newScheme) : newScheme;

  // remove an : at the end of the scheme so somebody can pass in
  // window.location.protocol
  if (this.scheme_) {
    this.scheme_ = this.scheme_.replace(/:$/, '');
  }
  return this;
};


/**
 * @return {boolean} Whether the scheme has been set.
 */
goog.Uri.prototype.hasScheme = function() {
  return !!this.scheme_;
};


/**
 * @return {string} The decoded user info.
 */
goog.Uri.prototype.getUserInfo = function() {
  return this.userInfo_;
};


/**
 * Sets the userInfo.
 * @param {string} newUserInfo New userInfo value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setUserInfo = function(newUserInfo, opt_decode) {
  this.enforceReadOnly();
  this.userInfo_ = opt_decode ? goog.Uri.decodeOrEmpty_(newUserInfo) :
                   newUserInfo;
  return this;
};


/**
 * @return {boolean} Whether the user info has been set.
 */
goog.Uri.prototype.hasUserInfo = function() {
  return !!this.userInfo_;
};


/**
 * @return {string} The decoded domain.
 */
goog.Uri.prototype.getDomain = function() {
  return this.domain_;
};


/**
 * Sets the domain.
 * @param {string} newDomain New domain value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setDomain = function(newDomain, opt_decode) {
  this.enforceReadOnly();
  this.domain_ = opt_decode ? goog.Uri.decodeOrEmpty_(newDomain) : newDomain;
  return this;
};


/**
 * @return {boolean} Whether the domain has been set.
 */
goog.Uri.prototype.hasDomain = function() {
  return !!this.domain_;
};


/**
 * @return {?number} The port number.
 */
goog.Uri.prototype.getPort = function() {
  return this.port_;
};


/**
 * Sets the port number.
 * @param {*} newPort Port number. Will be explicitly casted to a number.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setPort = function(newPort) {
  this.enforceReadOnly();

  if (newPort) {
    newPort = Number(newPort);
    if (isNaN(newPort) || newPort < 0) {
      throw Error('Bad port number ' + newPort);
    }
    this.port_ = newPort;
  } else {
    this.port_ = null;
  }

  return this;
};


/**
 * @return {boolean} Whether the port has been set.
 */
goog.Uri.prototype.hasPort = function() {
  return this.port_ != null;
};


/**
  * @return {string} The decoded path.
 */
goog.Uri.prototype.getPath = function() {
  return this.path_;
};


/**
 * Sets the path.
 * @param {string} newPath New path value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setPath = function(newPath, opt_decode) {
  this.enforceReadOnly();
  this.path_ = opt_decode ? goog.Uri.decodeOrEmpty_(newPath) : newPath;
  return this;
};


/**
 * @return {boolean} Whether the path has been set.
 */
goog.Uri.prototype.hasPath = function() {
  return !!this.path_;
};


/**
 * @return {boolean} Whether the query string has been set.
 */
goog.Uri.prototype.hasQuery = function() {
  return this.queryData_.toString() !== '';
};


/**
 * Sets the query data.
 * @param {goog.Uri.QueryData|string|undefined} queryData QueryData object.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 *     Applies only if queryData is a string.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setQueryData = function(queryData, opt_decode) {
  this.enforceReadOnly();

  if (queryData instanceof goog.Uri.QueryData) {
    this.queryData_ = queryData;
    this.queryData_.setIgnoreCase(this.ignoreCase_);
  } else {
    if (!opt_decode) {
      // QueryData accepts encoded query string, so encode it if
      // opt_decode flag is not true.
      queryData = goog.Uri.encodeSpecialChars_(queryData,
                                               goog.Uri.reDisallowedInQuery_);
    }
    this.queryData_ = new goog.Uri.QueryData(queryData, null, this.ignoreCase_);
  }

  return this;
};


/**
 * Sets the URI query.
 * @param {string} newQuery New query value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setQuery = function(newQuery, opt_decode) {
  return this.setQueryData(newQuery, opt_decode);
};


/**
 * @return {string} The encoded URI query, not including the ?.
 */
goog.Uri.prototype.getEncodedQuery = function() {
  return this.queryData_.toString();
};


/**
 * @return {string} The decoded URI query, not including the ?.
 */
goog.Uri.prototype.getDecodedQuery = function() {
  return this.queryData_.toDecodedString();
};


/**
 * Returns the query data.
 * @return {goog.Uri.QueryData} QueryData object.
 */
goog.Uri.prototype.getQueryData = function() {
  return this.queryData_;
};


/**
 * @return {string} The encoded URI query, not including the ?.
 *
 * Warning: This method, unlike other getter methods, returns encoded
 * value, instead of decoded one.
 */
goog.Uri.prototype.getQuery = function() {
  return this.getEncodedQuery();
};


/**
 * Sets the value of the named query parameters, clearing previous values for
 * that key.
 *
 * @param {string} key The parameter to set.
 * @param {*} value The new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setParameterValue = function(key, value) {
  this.enforceReadOnly();
  this.queryData_.set(key, value);
  return this;
};


/**
 * Sets the values of the named query parameters, clearing previous values for
 * that key.  Not new values will currently be moved to the end of the query
 * string.
 *
 * So, <code>goog.Uri.parse('foo?a=b&c=d&e=f').setParameterValues('c', ['new'])
 * </code> yields <tt>foo?a=b&e=f&c=new</tt>.</p>
 *
 * @param {string} key The parameter to set.
 * @param {*} values The new values. If values is a single
 *     string then it will be treated as the sole value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setParameterValues = function(key, values) {
  this.enforceReadOnly();

  if (!goog.isArray(values)) {
    values = [String(values)];
  }

  // TODO(nicksantos): This cast shouldn't be necessary.
  this.queryData_.setValues(key, /** @type {Array} */ (values));

  return this;
};


/**
 * Returns the value<b>s</b> for a given cgi parameter as a list of decoded
 * query parameter values.
 * @param {string} name The parameter to get values for.
 * @return {Array} The values for a given cgi parameter as a list of
 *     decoded query parameter values.
 */
goog.Uri.prototype.getParameterValues = function(name) {
  return this.queryData_.getValues(name);
};


/**
 * Returns the first value for a given cgi parameter or undefined if the given
 * parameter name does not appear in the query string.
 * @param {string} paramName Unescaped parameter name.
 * @return {string|undefined} The first value for a given cgi parameter or
 *     undefined if the given parameter name does not appear in the query
 *     string.
 */
goog.Uri.prototype.getParameterValue = function(paramName) {
  // NOTE(nicksantos): This type-cast is a lie when
  // preserveParameterTypesCompatibilityFlag is set to true.
  // But this should only be set to true in tests.
  return /** @type {string|undefined} */ (this.queryData_.get(paramName));
};


/**
 * @return {string} The URI fragment, not including the #.
 */
goog.Uri.prototype.getFragment = function() {
  return this.fragment_;
};


/**
 * Sets the URI fragment.
 * @param {string} newFragment New fragment value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setFragment = function(newFragment, opt_decode) {
  this.enforceReadOnly();
  this.fragment_ = opt_decode ? goog.Uri.decodeOrEmpty_(newFragment) :
                   newFragment;
  return this;
};


/**
 * @return {boolean} Whether the URI has a fragment set.
 */
goog.Uri.prototype.hasFragment = function() {
  return !!this.fragment_;
};


/**
 * Returns true if this has the same domain as that of uri2.
 * @param {goog.Uri} uri2 The URI object to compare to.
 * @return {boolean} true if same domain; false otherwise.
 */
goog.Uri.prototype.hasSameDomainAs = function(uri2) {
  return ((!this.hasDomain() && !uri2.hasDomain()) ||
          this.getDomain() == uri2.getDomain()) &&
      ((!this.hasPort() && !uri2.hasPort()) ||
          this.getPort() == uri2.getPort());
};


/**
 * Adds a random parameter to the Uri.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.makeUnique = function() {
  this.enforceReadOnly();
  this.setParameterValue(goog.Uri.RANDOM_PARAM, goog.string.getRandomString());

  return this;
};


/**
 * Removes the named query parameter.
 *
 * @param {string} key The parameter to remove.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.removeParameter = function(key) {
  this.enforceReadOnly();
  this.queryData_.remove(key);
  return this;
};


/**
 * Sets whether Uri is read only. If this goog.Uri is read-only,
 * enforceReadOnly_ will be called at the start of any function that may modify
 * this Uri.
 * @param {boolean} isReadOnly whether this goog.Uri should be read only.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.setReadOnly = function(isReadOnly) {
  this.isReadOnly_ = isReadOnly;
  return this;
};


/**
 * @return {boolean} Whether the URI is read only.
 */
goog.Uri.prototype.isReadOnly = function() {
  return this.isReadOnly_;
};


/**
 * Checks if this Uri has been marked as read only, and if so, throws an error.
 * This should be called whenever any modifying function is called.
 */
goog.Uri.prototype.enforceReadOnly = function() {
  if (this.isReadOnly_) {
    throw Error('Tried to modify a read-only Uri');
  }
};


/**
 * Sets whether to ignore case.
 * NOTE: If there are already key/value pairs in the QueryData, and
 * ignoreCase_ is set to false, the keys will all be lower-cased.
 * @param {boolean} ignoreCase whether this goog.Uri should ignore case.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.setIgnoreCase = function(ignoreCase) {
  this.ignoreCase_ = ignoreCase;
  if (this.queryData_) {
    this.queryData_.setIgnoreCase(ignoreCase);
  }
  return this;
};


/**
 * @return {boolean} Whether to ignore case.
 */
goog.Uri.prototype.getIgnoreCase = function() {
  return this.ignoreCase_;
};


//==============================================================================
// Static members
//==============================================================================


/**
 * Creates a uri from the string form.  Basically an alias of new goog.Uri().
 * If a Uri object is passed to parse then it will return a clone of the object.
 *
 * @param {*} uri Raw URI string or instance of Uri
 *     object.
 * @param {boolean=} opt_ignoreCase Whether to ignore the case of parameter
 * names in #getParameterValue.
 * @return {!goog.Uri} The new URI object.
 */
goog.Uri.parse = function(uri, opt_ignoreCase) {
  return uri instanceof goog.Uri ?
         uri.clone() : new goog.Uri(uri, opt_ignoreCase);
};


/**
 * Creates a new goog.Uri object from unencoded parts.
 *
 * @param {?string=} opt_scheme Scheme/protocol or full URI to parse.
 * @param {?string=} opt_userInfo username:password.
 * @param {?string=} opt_domain www.google.com.
 * @param {?number=} opt_port 9830.
 * @param {?string=} opt_path /some/path/to/a/file.html.
 * @param {string|goog.Uri.QueryData=} opt_query a=1&b=2.
 * @param {?string=} opt_fragment The fragment without the #.
 * @param {boolean=} opt_ignoreCase Whether to ignore parameter name case in
 *     #getParameterValue.
 *
 * @return {!goog.Uri} The new URI object.
 */
goog.Uri.create = function(opt_scheme, opt_userInfo, opt_domain, opt_port,
                           opt_path, opt_query, opt_fragment, opt_ignoreCase) {

  var uri = new goog.Uri(null, opt_ignoreCase);

  // Only set the parts if they are defined and not empty strings.
  opt_scheme && uri.setScheme(opt_scheme);
  opt_userInfo && uri.setUserInfo(opt_userInfo);
  opt_domain && uri.setDomain(opt_domain);
  opt_port && uri.setPort(opt_port);
  opt_path && uri.setPath(opt_path);
  opt_query && uri.setQueryData(opt_query);
  opt_fragment && uri.setFragment(opt_fragment);

  return uri;
};


/**
 * Resolves a relative Uri against a base Uri, accepting both strings and
 * Uri objects.
 *
 * @param {*} base Base Uri.
 * @param {*} rel Relative Uri.
 * @return {!goog.Uri} Resolved uri.
 */
goog.Uri.resolve = function(base, rel) {
  if (!(base instanceof goog.Uri)) {
    base = goog.Uri.parse(base);
  }

  if (!(rel instanceof goog.Uri)) {
    rel = goog.Uri.parse(rel);
  }

  return base.resolve(rel);
};


/**
 * Removes dot segments in given path component, as described in
 * RFC 3986, section 5.2.4.
 *
 * @param {string} path A non-empty path component.
 * @return {string} Path component with removed dot segments.
 */
goog.Uri.removeDotSegments = function(path) {
  if (path == '..' || path == '.') {
    return '';

  } else if (!goog.string.contains(path, './') &&
             !goog.string.contains(path, '/.')) {
    // This optimization detects uris which do not contain dot-segments,
    // and as a consequence do not require any processing.
    return path;

  } else {
    var leadingSlash = goog.string.startsWith(path, '/');
    var segments = path.split('/');
    var out = [];

    for (var pos = 0; pos < segments.length; ) {
      var segment = segments[pos++];

      if (segment == '.') {
        if (leadingSlash && pos == segments.length) {
          out.push('');
        }
      } else if (segment == '..') {
        if (out.length > 1 || out.length == 1 && out[0] != '') {
          out.pop();
        }
        if (leadingSlash && pos == segments.length) {
          out.push('');
        }
      } else {
        out.push(segment);
        leadingSlash = true;
      }
    }

    return out.join('/');
  }
};


/**
 * Decodes a value or returns the empty string if it isn't defined or empty.
 * @param {string|undefined} val Value to decode.
 * @return {string} Decoded value.
 * @private
 */
goog.Uri.decodeOrEmpty_ = function(val) {
  // Don't use UrlDecode() here because val is not a query parameter.
  return val ? decodeURIComponent(val) : '';
};


/**
 * If unescapedPart is non null, then escapes any characters in it that aren't
 * valid characters in a url and also escapes any special characters that
 * appear in extra.
 *
 * @param {*} unescapedPart The string to encode.
 * @param {RegExp} extra A character set of characters in [\01-\177].
 * @return {?string} null iff unescapedPart == null.
 * @private
 */
goog.Uri.encodeSpecialChars_ = function(unescapedPart, extra) {
  if (goog.isString(unescapedPart)) {
    return encodeURI(unescapedPart).replace(extra, goog.Uri.encodeChar_);
  }
  return null;
};


/**
 * Converts a character in [\01-\177] to its unicode character equivalent.
 * @param {string} ch One character string.
 * @return {string} Encoded string.
 * @private
 */
goog.Uri.encodeChar_ = function(ch) {
  var n = ch.charCodeAt(0);
  return '%' + ((n >> 4) & 0xf).toString(16) + (n & 0xf).toString(16);
};


/**
 * Regular expression for characters that are disallowed in the scheme or
 * userInfo part of the URI.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInSchemeOrUserInfo_ = /[#\/\?@]/g;


/**
 * Regular expression for characters that are disallowed in a relative path.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInRelativePath_ = /[\#\?:]/g;


/**
 * Regular expression for characters that are disallowed in an absolute path.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInAbsolutePath_ = /[\#\?]/g;


/**
 * Regular expression for characters that are disallowed in the query.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInQuery_ = /[\#\?@]/g;


/**
 * Regular expression for characters that are disallowed in the fragment.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInFragment_ = /#/g;


/**
 * Checks whether two URIs have the same domain.
 * @param {string} uri1String First URI string.
 * @param {string} uri2String Second URI string.
 * @return {boolean} true if the two URIs have the same domain; false otherwise.
 */
goog.Uri.haveSameDomain = function(uri1String, uri2String) {
  // Differs from goog.uri.utils.haveSameDomain, since this ignores scheme.
  // TODO(gboyer): Have this just call goog.uri.util.haveSameDomain.
  var pieces1 = goog.uri.utils.split(uri1String);
  var pieces2 = goog.uri.utils.split(uri2String);
  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
             pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&
         pieces1[goog.uri.utils.ComponentIndex.PORT] ==
             pieces2[goog.uri.utils.ComponentIndex.PORT];
};



/**
 * Class used to represent URI query parameters.  It is essentially a hash of
 * name-value pairs, though a name can be present more than once.
 *
 * Has the same interface as the collections in goog.structs.
 *
 * @param {?string=} opt_query Optional encoded query string to parse into
 *     the object.
 * @param {goog.Uri=} opt_uri Optional uri object that should have its
 *     cache invalidated when this object updates. Deprecated -- this
 *     is no longer required.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @constructor
 */
goog.Uri.QueryData = function(opt_query, opt_uri, opt_ignoreCase) {
  /**
   * Encoded query string, or null if it requires computing from the key map.
   * @type {?string}
   * @private
   */
  this.encodedQuery_ = opt_query || null;

  /**
   * If true, ignore the case of the parameter name in #get.
   * @type {boolean}
   * @private
   */
  this.ignoreCase_ = !!opt_ignoreCase;
};


/**
 * If the underlying key map is not yet initialized, it parses the
 * query string and fills the map with parsed data.
 * @private
 */
goog.Uri.QueryData.prototype.ensureKeyMapInitialized_ = function() {
  if (!this.keyMap_) {
    this.keyMap_ = new goog.structs.Map();
    this.count_ = 0;

    if (this.encodedQuery_) {
      var pairs = this.encodedQuery_.split('&');
      for (var i = 0; i < pairs.length; i++) {
        var indexOfEquals = pairs[i].indexOf('=');
        var name = null;
        var value = null;
        if (indexOfEquals >= 0) {
          name = pairs[i].substring(0, indexOfEquals);
          value = pairs[i].substring(indexOfEquals + 1);
        } else {
          name = pairs[i];
        }
        name = goog.string.urlDecode(name);
        name = this.getKeyName_(name);
        this.add(name, value ? goog.string.urlDecode(value) : '');
      }
    }
  }
};


/**
 * Creates a new query data instance from a map of names and values.
 *
 * @param {!goog.structs.Map|!Object} map Map of string parameter
 *     names to parameter value. If parameter value is an array, it is
 *     treated as if the key maps to each individual value in the
 *     array.
 * @param {goog.Uri=} opt_uri URI object that should have its cache
 *     invalidated when this object updates.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @return {!goog.Uri.QueryData} The populated query data instance.
 */
goog.Uri.QueryData.createFromMap = function(map, opt_uri, opt_ignoreCase) {
  var keys = goog.structs.getKeys(map);
  if (typeof keys == 'undefined') {
    throw Error('Keys are undefined');
  }

  var queryData = new goog.Uri.QueryData(null, null, opt_ignoreCase);
  var values = goog.structs.getValues(map);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = values[i];
    if (!goog.isArray(value)) {
      queryData.add(key, value);
    } else {
      queryData.setValues(key, value);
    }
  }
  return queryData;
};


/**
 * Creates a new query data instance from parallel arrays of parameter names
 * and values. Allows for duplicate parameter names. Throws an error if the
 * lengths of the arrays differ.
 *
 * @param {Array.<string>} keys Parameter names.
 * @param {Array} values Parameter values.
 * @param {goog.Uri=} opt_uri URI object that should have its cache
 *     invalidated when this object updates.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @return {!goog.Uri.QueryData} The populated query data instance.
 */
goog.Uri.QueryData.createFromKeysValues = function(
    keys, values, opt_uri, opt_ignoreCase) {
  if (keys.length != values.length) {
    throw Error('Mismatched lengths for keys/values');
  }
  var queryData = new goog.Uri.QueryData(null, null, opt_ignoreCase);
  for (var i = 0; i < keys.length; i++) {
    queryData.add(keys[i], values[i]);
  }
  return queryData;
};


/**
 * The map containing name/value or name/array-of-values pairs.
 * May be null if it requires parsing from the query string.
 *
 * We need to use a Map because we cannot guarantee that the key names will
 * not be problematic for IE.
 *
 * @type {goog.structs.Map}
 * @private
 */
goog.Uri.QueryData.prototype.keyMap_ = null;


/**
 * The number of params, or null if it requires computing.
 * @type {?number}
 * @private
 */
goog.Uri.QueryData.prototype.count_ = null;


/**
 * @return {?number} The number of parameters.
 */
goog.Uri.QueryData.prototype.getCount = function() {
  this.ensureKeyMapInitialized_();
  return this.count_;
};


/**
 * Adds a key value pair.
 * @param {string} key Name.
 * @param {*} value Value.
 * @return {!goog.Uri.QueryData} Instance of this object.
 */
goog.Uri.QueryData.prototype.add = function(key, value) {
  this.ensureKeyMapInitialized_();
  this.invalidateCache_();

  key = this.getKeyName_(key);
  var values = this.keyMap_.get(key);
  if (!values) {
    this.keyMap_.set(key, (values = []));
  }
  values.push(value);
  this.count_++;
  return this;
};


/**
 * Removes all the params with the given key.
 * @param {string} key Name.
 * @return {boolean} Whether any parameter was removed.
 */
goog.Uri.QueryData.prototype.remove = function(key) {
  this.ensureKeyMapInitialized_();

  key = this.getKeyName_(key);
  if (this.keyMap_.containsKey(key)) {
    this.invalidateCache_();

    // Decrement parameter count.
    this.count_ -= this.keyMap_.get(key).length;
    return this.keyMap_.remove(key);
  }
  return false;
};


/**
 * Clears the parameters.
 */
goog.Uri.QueryData.prototype.clear = function() {
  this.invalidateCache_();
  this.keyMap_ = null;
  this.count_ = 0;
};


/**
 * @return {boolean} Whether we have any parameters.
 */
goog.Uri.QueryData.prototype.isEmpty = function() {
  this.ensureKeyMapInitialized_();
  return this.count_ == 0;
};


/**
 * Whether there is a parameter with the given name
 * @param {string} key The parameter name to check for.
 * @return {boolean} Whether there is a parameter with the given name.
 */
goog.Uri.QueryData.prototype.containsKey = function(key) {
  this.ensureKeyMapInitialized_();
  key = this.getKeyName_(key);
  return this.keyMap_.containsKey(key);
};


/**
 * Whether there is a parameter with the given value.
 * @param {*} value The value to check for.
 * @return {boolean} Whether there is a parameter with the given value.
 */
goog.Uri.QueryData.prototype.containsValue = function(value) {
  // NOTE(arv): This solution goes through all the params even if it was the
  // first param. We can get around this by not reusing code or by switching to
  // iterators.
  var vals = this.getValues();
  return goog.array.contains(vals, value);
};


/**
 * Returns all the keys of the parameters. If a key is used multiple times
 * it will be included multiple times in the returned array
 * @return {!Array} All the keys of the parameters.
 */
goog.Uri.QueryData.prototype.getKeys = function() {
  this.ensureKeyMapInitialized_();
  // We need to get the values to know how many keys to add.
  var vals = /** @type {Array.<Array|*>} */ (this.keyMap_.getValues());
  var keys = this.keyMap_.getKeys();
  var rv = [];
  for (var i = 0; i < keys.length; i++) {
    var val = vals[i];
    for (var j = 0; j < val.length; j++) {
      rv.push(keys[i]);
    }
  }
  return rv;
};


/**
 * Returns all the values of the parameters with the given name. If the query
 * data has no such key this will return an empty array. If no key is given
 * all values wil be returned.
 * @param {string=} opt_key The name of the parameter to get the values for.
 * @return {!Array} All the values of the parameters with the given name.
 */
goog.Uri.QueryData.prototype.getValues = function(opt_key) {
  this.ensureKeyMapInitialized_();
  var rv = [];
  if (opt_key) {
    if (this.containsKey(opt_key)) {
      rv = goog.array.concat(rv, this.keyMap_.get(this.getKeyName_(opt_key)));
    }
  } else {
    // Return all values.
    var values = /** @type {Array.<Array|*>} */ (this.keyMap_.getValues());
    for (var i = 0; i < values.length; i++) {
      rv = goog.array.concat(rv, values[i]);
    }
  }
  return rv;
};


/**
 * Sets a key value pair and removes all other keys with the same value.
 *
 * @param {string} key Name.
 * @param {*} value Value.
 * @return {!goog.Uri.QueryData} Instance of this object.
 */
goog.Uri.QueryData.prototype.set = function(key, value) {
  this.ensureKeyMapInitialized_();
  this.invalidateCache_();

  // TODO(user): This could be better written as
  // this.remove(key), this.add(key, value), but that would reorder
  // the key (since the key is first removed and then added at the
  // end) and we would have to fix unit tests that depend on key
  // ordering.
  key = this.getKeyName_(key);
  if (this.containsKey(key)) {
    this.count_ -= this.keyMap_.get(key).length;
  }
  this.keyMap_.set(key, [value]);
  this.count_++;
  return this;
};


/**
 * Returns the first value associated with the key. If the query data has no
 * such key this will return undefined or the optional default.
 * @param {string} key The name of the parameter to get the value for.
 * @param {*=} opt_default The default value to return if the query data
 *     has no such key.
 * @return {*} The first string value associated with the key, or opt_default
 *     if there's no value.
 */
goog.Uri.QueryData.prototype.get = function(key, opt_default) {
  var values = key ? this.getValues(key) : [];
  if (goog.Uri.preserveParameterTypesCompatibilityFlag) {
    return values.length > 0 ? values[0] : opt_default;
  } else {
    return values.length > 0 ? String(values[0]) : opt_default;
  }
};


/**
 * Sets the values for a key. If the key already exists, this will
 * override all of the existing values that correspond to the key.
 * @param {string} key The key to set values for.
 * @param {Array} values The values to set.
 */
goog.Uri.QueryData.prototype.setValues = function(key, values) {
  this.remove(key);

  if (values.length > 0) {
    this.invalidateCache_();
    this.keyMap_.set(this.getKeyName_(key), goog.array.clone(values));
    this.count_ += values.length;
  }
};


/**
 * @return {string} Encoded query string.
 * @override
 */
goog.Uri.QueryData.prototype.toString = function() {
  if (this.encodedQuery_) {
    return this.encodedQuery_;
  }

  if (!this.keyMap_) {
    return '';
  }

  var sb = [];

  // In the past, we use this.getKeys() and this.getVals(), but that
  // generates a lot of allocations as compared to simply iterating
  // over the keys.
  var keys = this.keyMap_.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var encodedKey = goog.string.urlEncode(key);
    var val = this.getValues(key);
    for (var j = 0; j < val.length; j++) {
      var param = encodedKey;
      // Ensure that null and undefined are encoded into the url as
      // literal strings.
      if (val[j] !== '') {
        param += '=' + goog.string.urlEncode(val[j]);
      }
      sb.push(param);
    }
  }

  return this.encodedQuery_ = sb.join('&');
};


/**
 * @return {string} Decoded query string.
 */
goog.Uri.QueryData.prototype.toDecodedString = function() {
  return goog.Uri.decodeOrEmpty_(this.toString());
};


/**
 * Invalidate the cache.
 * @private
 */
goog.Uri.QueryData.prototype.invalidateCache_ = function() {
  this.encodedQuery_ = null;
};


/**
 * Removes all keys that are not in the provided list. (Modifies this object.)
 * @param {Array.<string>} keys The desired keys.
 * @return {!goog.Uri.QueryData} a reference to this object.
 */
goog.Uri.QueryData.prototype.filterKeys = function(keys) {
  this.ensureKeyMapInitialized_();
  goog.structs.forEach(this.keyMap_,
      /** @this {goog.Uri.QueryData} */
      function(value, key, map) {
        if (!goog.array.contains(keys, key)) {
          this.remove(key);
        }
      }, this);
  return this;
};


/**
 * Clone the query data instance.
 * @return {!goog.Uri.QueryData} New instance of the QueryData object.
 */
goog.Uri.QueryData.prototype.clone = function() {
  var rv = new goog.Uri.QueryData();
  rv.encodedQuery_ = this.encodedQuery_;
  if (this.keyMap_) {
    rv.keyMap_ = this.keyMap_.clone();
  }
  return rv;
};


/**
 * Helper function to get the key name from a JavaScript object. Converts
 * the object to a string, and to lower case if necessary.
 * @private
 * @param {*} arg The object to get a key name from.
 * @return {string} valid key name which can be looked up in #keyMap_.
 */
goog.Uri.QueryData.prototype.getKeyName_ = function(arg) {
  var keyName = String(arg);
  if (this.ignoreCase_) {
    keyName = keyName.toLowerCase();
  }
  return keyName;
};


/**
 * Ignore case in parameter names.
 * NOTE: If there are already key/value pairs in the QueryData, and
 * ignoreCase_ is set to false, the keys will all be lower-cased.
 * @param {boolean} ignoreCase whether this goog.Uri should ignore case.
 */
goog.Uri.QueryData.prototype.setIgnoreCase = function(ignoreCase) {
  var resetKeys = ignoreCase && !this.ignoreCase_;
  if (resetKeys) {
    this.ensureKeyMapInitialized_();
    this.invalidateCache_();
    goog.structs.forEach(this.keyMap_,
        /** @this {goog.Uri.QueryData} */
        function(value, key) {
          var lowerCase = key.toLowerCase();
          if (key != lowerCase) {
            this.remove(key);
            this.setValues(lowerCase, value);
          }
        }, this);
  }
  this.ignoreCase_ = ignoreCase;
};


/**
 * Extends a query data object with another query data or map like object. This
 * operates 'in-place', it does not create a new QueryData object.
 *
 * @param {...(goog.Uri.QueryData|goog.structs.Map|Object)} var_args The object
 *     from which key value pairs will be copied.
 */
goog.Uri.QueryData.prototype.extend = function(var_args) {
  for (var i = 0; i < arguments.length; i++) {
    var data = arguments[i];
    goog.structs.forEach(data,
        /** @this {goog.Uri.QueryData} */
        function(value, key) {
          this.add(key, value);
        }, this);
  }
};


// assets/js/bundle/common/security.js
goog.provide("optly.common.security");

/**
 * Checks a password to ensure that it is complex and does not contain a common
 * word.  If it fails the test, this function returns false, and also sets the
 * value of any element with id common_password_string to the failed word.
 */
var checkComplexPassword = function(password) {
  var message = "message";
  var passed = true;
  if (window && window['IGNORE_COMMON_PASSWORD_CHECK']) {
    // Short circuit this check when we're running an experiment
    // https://www.optimizely.com/edit#experiment_id=114878707
    // https://www.optimizely.com/results?experiment_id=114878707
    passed = true;
  }

  var CHAR_LOWERS = /[a-z]/;
  var CHAR_UPPERS = /[A-Z]/;
  var CHAR_NUMBERS = /[0-9]/;
  var CHAR_SPECIAL = /[?=.*!@#$%^&*]/;
  var CHAR_TYPES = [CHAR_LOWERS,CHAR_UPPERS,CHAR_NUMBERS,CHAR_SPECIAL];

  var counter = 4;
  for (var i=0;i<CHAR_TYPES.length;i++){
    if(!CHAR_TYPES[i].test(password)){
      counter--;
    }
  }

  if (counter<=1){
    message = tr("Use at least 8 characters and a mix of upper/lowercase letters, numbers, or symbols.");
    passed=false;
  }
  
  return {
    passed: passed, 
    message: message
  };
  
};

/**
 * Sanitizes a string of HTML.  If called with an array, the function recursively
 * sanitizes all the elements of the array.
 */
var sanitizeHTML = function(str) {
  if (isArrayLike(str)) {
    for (var i = 0; i < str.length; i++) {
      str[i] = sanitizeHTML(str[i]);
    }
    return str;
  }
  else {
    str = str.replace(/</g, "&lt;");
    str = str.replace(/>/g, "&gt;");
    return str;
  }
};


// assets/js/bundle/common/phone_numbers.js
goog.provide("optly.common.phone_numbers");

// Taken from a stackoverflow article on phone number rexes
// todo(pete): find the URL
var PHONE_NUMBER_REGEX = "(?:(?:\\+?1\\s*(?:[.-]\\s*)?)?(?:\\(\\s*(" +
             "[2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\\s*\\)" +
             "|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\\s*" +
             "(?:[.-]\\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})" +
             "\\s*(?:[.-]\\s*)?([0-9]{4})" +
             "(?:\\s*(?:#|x\\.?|ext\\.?|extension)\\s*(\\d+))?";


/**
 * @param {number|string} text
 *
 * Extracts and returns the first phone number identified in the text.
 */
var extractPhoneNumber = function(text) {
  var match = text.match(PHONE_NUMBER_REGEX);
  if (match && match.length > 0) {
    return match[0];
  } else {
    return null;
  }
};

var DIGITS = '0123456789';

/**
 * @param {number|string} text
 *
 * Strips extraneous characters out of a phone number
 */
var stripPhoneNumber = function(text) {
  var numText = extractPhoneNumber(text);
  if (numText) {
    var finalNumText = ''
    for (var i = 0; i < numText.length; i++) {
      var c = numText[i];
      if (DIGITS.indexOf(c) >= 0) {
        finalNumText += c;
      }
    }
    return finalNumText;
  } else {
    return null;
  }
};


// assets/js/bundle/common/email_lists_input.js
goog.provide("optly.common.validateEmailLists");


var checkValidEmailList = function(csvEmails) {
   /* Given an input csv of emails - a small check to ensure the number of
      '@' in csv email string is equal to the number of emails in the csv string */
   if (csvEmails.match(/\s*[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.\w+\s*/g)) {
     if ((csvEmails.split('@').length - 1) == csvEmails.match(/\s*[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.\w+\s*/g).length) {
       return true;
      }
   }

  return false;
};

// assets/js/bundle/common/format.js
goog.provide("optly.common.format");

var elementFormatInt = function(index, element) {
  var val = $(element).html();
  $(element).html(formatInt(val));
};

/**
 * @param {number|string} number
 * @param {number} decimalPlaces
 * @param {boolean=} includeSign
 * @param {number=} error
 */
var formatAmt = function(number, decimalPlaces, includeSign, error) {
  return formatWithError(number, decimalPlaces, includeSign, error, "$%s", 1);
};

var formatDate = function(date) {
  var day = date.getDate();
  var month = MONTHS[date.getMonth()];
  var year = date.getFullYear();

  return sprintf("%s %d, %d", month, day, year);
};

var formatDateJson = function(date) {
  var year = date.getUTCFullYear();
  var month = date.getUTCMonth() + 1;
  var day = date.getUTCDate();
  var hour = date.getUTCHours();
  var minute = date.getUTCMinutes();
  var seconds = date.getUTCSeconds();

  return sprintf("%04d-%02d-%02dT%02d:%02d:%02dZ",
                 year,
                 month,
                 day,
                 hour,
                 minute,
                 seconds);
};

// Taken from: http://www.tylerfrankenstein.com/user/4/code/javascript-date-time-yyyy-mm-dd-hh-mm-ss
// Returns a string in the format YYYY-MM-DD HH:MM:SS
var formatDateYYYYMMDDHHMMSS = function(date) {
  if (!date) {
    date = new Date();
  }

  var year = "" + date.getFullYear();

  var month = "" + (date.getMonth() + 1);
  if (month.length == 1) { month = "0" + month; }

  var day = "" + date.getDate();
  if (day.length == 1) { day = "0" + day; }

  var hour = "" + date.getHours();
  if (hour.length == 1) { hour = "0" + hour; }

  var minute = "" + date.getMinutes();
  if (minute.length == 1) { minute = "0" + minute; }

  var second = "" + date.getSeconds();
  if (second.length == 1) { second = "0" + second; }

  return year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second;
};

var formatCurrency = function(num) {
  // TODO(jon): Add a locale parameter to this function to use locale-friendly separators
  //            (e.g., commas vs. periods where appropriate).
  // TODO(jon): Revise this function to also consume and prepend the proper currency symbol.
  if (num === 0) {
    return "0";
  }
  var numString = Math.round(num * 100).toString();
  if (numString.substring(numString.length-2) === "00") {
    // remove the trailing 00
    return numString.substring(0, numString.length-2);
  }
  else {
    // insert a decimal between the last two digits and the leading digits
    return numString.substring(0, numString.length-2) + "." + numString.substring(numString.length-2);
  }
};

/**
 * @param {string} string
 */
var formatHtmlEntities = function(string) {
  return $("<div/>").text(string).html();
};

// Adapted from http://www.mredkj.com/javascript/nfbasic.html
var formatInt = function(number) {
  var n = number.toString();
  var regex = /(\d+)(\d{3})/;
  while (regex.test(n)) {
    n = n.replace(regex, '$1' + ',' + '$2');
  }
  return n;
};

/**
 * @param {number|string} number
 * @param {number} decimalPlaces
 * @param {boolean=} includeSign
 * @param {number=} error
 */
var formatPct = function(number, decimalPlaces, includeSign, error) {
  return formatWithError(number, decimalPlaces, includeSign, error, "%s%%", 100);
};

var formatShortDate = function(date) {
  var day = date.getDate();
  var month = SHORT_MONTHS[date.getMonth()];
  var year = date.getFullYear();

  return month + " " + day + ", " + year;
};

var formatShortDateWithoutYear = function(date) {
  if (!date) {
    return "Unknown";
  }
  var day = date.getDate();
  var month = SHORT_MONTHS[date.getMonth()];

  return sprintf("%s %d", month, day);
};

/**
 * @param {Object} date 
 * @param {boolean=} includeTimeZone
 */
var formatTime = function(date, includeTimeZone) {
  includeTimeZone = includeTimeZone || typeof(includeTimeZone)==="undefined" || false;
  var hours = date.getHours();
  var meridiem = hours < 12 ? "AM" : "PM";
  var minutes = date.getMinutes();

  hours = (hours <= 12 ? (hours > 0 ? hours : 12) : hours - 12).toString();
  minutes = (minutes <= 9 ? "0" : "") + minutes;

  var ret = sprintf("%s:%s %s", hours, minutes, meridiem);
  if(includeTimeZone){
    var timeZone = "";
    var timeZoneMatch = date.toTimeString().match(/\((.*)\)/);
    if (timeZoneMatch !== null && timeZoneMatch.length > 0) {
      timeZone = timeZoneMatch[1];
    }
    ret += ", " + timeZone;
  }
  return ret;
};

/**
 * @param {Object} date 
 * @param {boolean=} includeTimeZone
 */
var formatDateTime = function(date, includeTimeZone) {
    return formatShortDate(date)  + " " + formatTime(date, includeTimeZone);
}

var formatTimePeriod = function(periodInSeconds) {
  /*
   * Takes seconds and converts it to days:hours:seconds
   */
  var days = Math.floor(periodInSeconds / 24 / 60 / 60);
  var hours = Math.floor(periodInSeconds / 60 / 60) % 24;
  var minutes = Math.floor(periodInSeconds / 60) % 60;
  var seconds = periodInSeconds % 60;
  return sprintf("%s:%s:%s:%s", days, hours, minutes, seconds);
}

/**
 * @param {Object} date
 */
var formatTwitterTimestamp = function(date) {
  var hours = date.getHours();
  var meridiem = hours < 12 ? "AM" : "PM";
  var minutes = date.getMinutes();

  hours = (hours <= 12 ? (hours > 0 ? hours : 12) : hours - 12).toString();
  minutes = (minutes <= 9 ? "0" : "") + minutes;

  var day = date.getDate();
  var month = SHORT_MONTHS[date.getMonth()];
  var year = date.getFullYear().toString().substr(2, 2);

  return sprintf("%s:%s %s - %s %s %s",
                 hours, minutes, meridiem, day, month, year);
};


/**
 *
 * @param {number} num
 * @param {number|string} inside (= num)
 */
var formatPositiveNegative = function(num, inside) {
  if (!goog.isDef(inside)) {
    inside = num;
  }
  if (num > 0) {
    return "<span class=\"positive\">" + inside + "</span>";
  }
  else if (num < 0) {
    return "<span class=\"negative\">" + inside + "</span>";
  }
  else { // if num === 0, num is NaN, etc
    return "<span>" + inside + "</span>";
  }
};

/**
 * @param {number|string} number
 * @param {number} decimalPlaces
 * @param {boolean=} includeSign
 * @param {number|null=} error
 * @param {string=} symbol
 * @param {number=} multiplier
 */
var formatWithError = function(number, decimalPlaces, includeSign, error, symbol, multiplier) {
  var NO_RESULT = "---";
  if (typeof decimalPlaces == "undefined") {
    decimalPlaces = 1;
  }
  if (typeof includeSign == "undefined") {
    includeSign = false;
  }
  if (number == null || isNaN(number) || number == "N/A" || !isFinite(number)) {
    return NO_RESULT;
  }
  var formatted = sprintf(symbol, (number * multiplier).toFixed(decimalPlaces));
  if (includeSign && number > 0) {
    formatted = "+" + formatted;
  }
  if (goog.isDefAndNotNull(error)) {
    var plusOrMinus = formatWithError(error, decimalPlaces, false, null, symbol, multiplier);
    if (plusOrMinus !== NO_RESULT) {
      formatted += " <span class='uncertainty'>" + plusOrMinus + "</span>";
    }
  }
  return formatted;
};

/**
 * Pluralizes the string if count is 1.
 *
 * @param {number} count
 * @param {string} str
 * @param {string=} pluralStr (= str)
 */
var pluralize = function(count, str, pluralStr) {
  if (!goog.isDef(pluralStr)) {
    pluralStr = str + "s";
  }
  return count === 1 ? str : pluralStr;
};

/**
 * Append "..." for applications where &hellip; doesn't work.
 *
 * @param {string} input
 * @param {number} length
 */
var truncateTextWithDotDotDot = function(input, length) {
  input = input || "";
  if (input.length > length) {
    return input.substring(0, length) + "...";
  }
  return input;
};

/**
 * @param {string} input
 * @param {number} length
 */
var truncateTextWithEllipsis = function(input, length) {
  input = input || "";
  if (input.length > length) {
    return input.substring(0, length) + "&hellip;";
  }
  return input;
};

/**
  * Receive a 24 hour number such as 17:23 and
  * return it as 5:23 pm.
  *
  * @param {number} hour
  * @param {number} minute
  */
var to12Hour = function(hour, minute) {
  var meridiem = (hour < 12 ) ? "am" : "pm";
  return (hour % 12) + ':' + minute + ' ' + meridiem;
}

/**
  * Append 0s to a number until the length
  * reaches the desired length. 
  *
  * @param {number} input
  * @param {number} length
  */
var padNumber = function(input, length) {
  var number = input.toString();
  while (number.length < length) {
    number += '0';
  }
  return number;
}

/**
  * Find URLs in a string and turn them 
  * into clickable links.
  * 
  * Source:
  * http://stackoverflow.com/a/1500501/316602
  *
  * @param {string} text
  */
function autoDetectLinks(text) {
    var urlRegex = /(https?:\/\/[^\s]+)/g;
    return text.replace(urlRegex, function(url) {
        return '<a href="' + url + '">' + url + '</a>';
    });
}


// assets/js/bundle/enums/ui_transition_effects.js
goog.provide('optly.enums.UITransitionEffects');

/**
 * Enum for ui animation values
 *
 */
optly.enums.UITransitionEffects = {
  UI_EFFECT_DURATION: 300,
  UI_EFFECT_DURATION_SHORT: 100,
  UI_EFFECT_DURATION_LONG: 800,
  UI_EFFECT_EASING_IN: "easeInExpo",
  UI_EFFECT_EASING_OUT: "easeOutExpo"
};


// assets/js/bundle/common/ui.js
goog.provide("optly.common.ui");

goog.require("optly.enums.UITransitionEffects");

/** @const */
var ALERT_BOX_HIDDEN_CLASS = "alert-box-hidden";
/** @const */
var DIALOG_SHOWN_CLASS = "dialog-shown";
/** @const */
var DISABLED_CLASS = "disabled";
/** @const */
var ERROR_CLASS = "error";
/** @const */
var EXPANDED_CLASS = "expanded";
/** @const */
var MENU_OVERLAY_CLASS = "menu-overlay";
/** @const */
var NARROW_CLASS = "narrow";
/** @const */
var ORIGINAL_CLASS = "original"; // editor
/** @const */
var SELECTED_CLASS = "selected";
/** @const */
var SHOW_CLASS = "show";
/** @const */
var SUCCESS_CLASS = "success";
/** @const */
var WIDE_CLASS = "wide";

// these are recreated as global variables for bundle-relaxed modal.js and guider.js
var UI_EFFECT_DURATION = optly.enums.UITransitionEffects.UI_EFFECT_DURATION;
var UI_EFFECT_EASING_OUT = optly.enums.UITransitionEffects.UI_EFFECT_EASING_OUT;

/** @const */
var BASELINE_COLOR = "#1f77b4";
/** @const */
var WINNER_COLOR = "#90B71C";
/** @const */
var LOSER_COLOR = "#E75611";
/** @const */
var INCONCLUSIVE_COLOR = "#AAA";

/**
 * Change the HTML of an element with a fade effect.
 *
 * @param {jQueryObject} element
 * @param {string} html
 * @param {number=} fadeDuration
 * @param {function()=} callback
 */
var fadingHtmlChange = function(element, html, fadeDuration, callback) {
  /** @const */
  var NEW_HTML = "fadingHtmlChangeNewHtml";

  // If element is still in animation, change what the new HTML will be.
  if (element.is(":animated")) {
    element.data(NEW_HTML, html);
  }
  else if (element.html() === html) {
    return;
  }
  else {
    fadeDuration = fadeDuration || optly.enums.UITransitionEffects.UI_EFFECT_DURATION;
    element.fadeOut(fadeDuration,
                    optly.enums.UITransitionEffects.UI_EFFECT_EASING_OUT,
                    function() {
                      var newHtml = element.data(NEW_HTML) || html;

                      element.html(/** @type {string} */ (newHtml))
                        .fadeIn(fadeDuration, optly.enums.UITransitionEffects.UI_EFFECT_EASING_OUT, callback);
                      element.removeData(NEW_HTML);
                    });
  }
};

/**
 * Get element's midpoint relative to its offset parent.
 *
 * @param {jQueryObject} element
 */
var getElementMidpoint = function(element) {
  var offset = element.offset();

  return {
      x: offset.left + Math.floor(element[0].offsetWidth / 2),
      y: offset.top + Math.floor(element[0].offsetHeight / 2)
    };
};


// assets/js/shared/constant.js
goog.provide("optly.constant");

/**
 * @const
 * @type {string}
 */
var AUDIENCE_COOKIE_NAME = 'optimizelyAudiences';

/**
 * @const
 * @type {number}
 */
var DAY_IN_SECONDS = 60 * 60 * 24;

/**
 * @const
 * @type {number}
 */
var DEFAULT_TRACKING_COOKIE_EXPIRATION = DAY_IN_SECONDS * 365 * 10; //10 years

/**
 * @const
 * @type {number}
 */
var MINIMUM_TRACKING_COOKIE_EXPIRATION = DAY_IN_SECONDS * 90; //approx 3 months

/**
 * @const
 */
var BUCKET_COOKIE_NAME = "optimizelyBuckets";

/**
 * @const
 */
var CUSTOM_EVENTS_COOKIE_NAME = "optimizelyCustomEvents";

/**
 * @const
 */
var CUSTOM_EVENTS_STORAGE_NAME = "customEvents";

/**
 * Time (in milliseconds) between attempts to evaluate a step.
 *
 * @const
 */
var EVALUATION_WAIT_INTERVAL = 50;

/**
 * Time (in milliseconds) between the first and second attempts to evaluate a
 * step.
 *
 * @const
 */
var FIRST_EVALUATION_WAIT_INTERVAL = 10;

/**
 * @const
 */
var GLOBAL = "optimizely";

/**
 * @const
 */
var GLOBAL_DATA = "data";

/**
 * @const
 */
var GEO_CONDITION_WAIT_INTERVAL = 1000;

/**
 * The number of milliseconds before geo times out / fails.
 * @const
 */
var GEO_TIMEOUT = 2000;

/**
 * @const
 */
var IGNORED_VARIATION_ID = "0";

/**
 * @const
 */
var OPT_OUT_COOKIE_NAME = "optimizelyOptOut";

/**
 * @const
 */
var PENDING_LOG_EVENTS_COOKIE_AGE = 15;

/**
 * @const
 */
var PENDING_LOG_EVENTS_COOKIE_MAX_LENGTH = 1536;

/**
 * @const
 * Name of cookie containing a list of log events that need to be sent.
 */
var PENDING_LOG_EVENTS_COOKIE_NAME = "optimizelyPendingLogEvents";

/** @const */
var PREVIEW_COOKIE_NAME = "optimizelyPreview";

/** @const */
var REDIRECT_COOKIE_FALSE = "false";

/** @const */
var REDIRECT_COOKIE_SECONDS = 5;

/** @const */
var REDIRECT_COOKIE_TRUE = "true";

/**
 * Prevents redirect variations from being executed from any page except
 * the original page, for 5 seconds
 *
 * @const
 */
var REDIRECT_COOKIE_NAME = "optimizelyRedirect";

/**
 * @const
 */
var REFERRAL_CHARTBEAT_COOKIE_NAME = "optimizelyChartbeat";

/**
 * @const
 */
var REFERRER_REDIRECT_COOKIE_NAME = "optimizelyReferrer";

/**
 * @const
 */
var SEGMENTS_COOKIE_NAME = "optimizelySegments";

/**
 * @const
 */
var SELECTOR_DELIMITER = ",";

/**
 * @const Age in days
 */
var SOURCE_COOKIE_AGE = 3;

/**
 * @const
 */
var SOURCE_COOKIE_DELIMITER = "|||";

/**
 * @const Stores lead info that's tracked in Marketo like source, medium, etc.
 */
var SOURCE_COOKIE_NAME = "sourceCookie";

/**
 * @const
 */
var TEST_MODULE = window['OPTIMIZELY_TEST_MODULE'];

/**
 * @const
 */
var TOP_LEVEL_DOMAINS = ["com", "local", "net", "org",
                         "xxx", "edu", "es", "gov", "biz",
                         "info", "fr", "nl", "ca",
                         "de", "kr", "it", "me",
                         "ly", "tv", "mx", "cn",
                         "jp", "il", "in", "iq",
                         "test"];

/**
 * @const
 */
var USER_ID_COOKIE_NAME = "optimizelyEndUserId";

/**
 * @const
 * @type {string}
 */
var PPID_COOKIE_NAME = 'optimizelyPPID';

/**
 * @const
 */
var VARIATION_CODE_DELIMITER = "\n";

/**
 * @const
 */
var VARIATION_ID_DELIMITER = "_";

/**
 * @const
 */
var VARIATION_URL_DELIMITER = " ";

/**
 * @const
 */
var VARIATION_URL_START = "_optimizely_variation_url";

/**
 * @const
 */
var VARIATION_URL_START_RE = /\/\*\s*_optimizely_variation_url( +include="([^"]*)")?( +exclude="([^"]*)")?( +match_type="([^"]*)")?( +include_match_types="([^"]*)")?( +exclude_match_types="([^"]*)")?( +id="([^"]*)")?\s*\*\//;

/**
 * @const
 */
var VARIATION_URL_END = "/* _optimizely_variation_url_end */";

/**
 * @const
 */
var VARIATION_URL_END_RE = /\/\*\s*_optimizely_variation_url_end\s*\*\//;

/**
 * @const
 * @type {string}
 */
var SIGNED_IN_BODY_CLASS = 'signed-in';

/**
 * @const
 * @type {string}
 */
var HOTFIX_ENG_1636_COOKIE = 'optimizelyReportableFix';


// assets/js/bundle/common/analytics.js
goog.provide("optly.common.analytics");

goog.require("goog.Uri");
goog.require("optly.constant");

/**
 * Returns lead source information.
 *
 * 'medium' is one of the following (in this order):
 *   utm_medium URI parameter = visitor came from an ad campaign
 *   "organic" = comes from a search engine
 *   "referred" = comes from a third party non-search website
 *   "direct" = directly typed in url, or otherwise not one of the other three
 */
var getSource = function() {

  var urlParams = $.deparam.querystring();

  for (var param in urlParams) {
    urlParams[param.toLowerCase()] = urlParams[param]
  }
  var campaign = urlParams["utm_campaign"] || "";
  var content = urlParams["utm_content"] || "";
  var medium = urlParams["utm_medium"] || "";
  var source = urlParams["utm_source"] || "";
  var keyword = urlParams["utm_keyword"] || "";
  var otm_campaign = urlParams["otm_campaign"] || "";
  var otm_content = urlParams["otm_content"] || "";
  var otm_medium = urlParams["otm_medium"] || "";
  var otm_source = urlParams["otm_source"] || "";
  var otm_keyword = urlParams["otm_keyword"] || "";
  // Parameter specifies which platform (e.g. ios vs. web) user signed-up from
  var signup_platform = urlParams["signup_platform"] || "";

  // Check for organic search referral if there's no URL param
  if (!medium && !otm_medium) {
    var referrer = document.referrer;
    var isSearchReferral = false;

    // Check if referrer is a search engine
    var SEARCH_TESTS = ["google\\.\\w{2,3}(\\.\\w{2,3})?/(search|url)",
      "bing\\.\\w{2,3}(\\.\\w{2,3})?/(search|url)",
      "yahoo\\.\\w{2,3}(\\.\\w{2,3})?/search",
      "baidu\\.\\w{2,3}(\\.\\w{2,3})?/s?"
    ];

    for (var i = 0, l = SEARCH_TESTS.length; i < l; i++) {
      var searchRegExp = SEARCH_TESTS[i];
      if (referrer.match(searchRegExp)) {
        medium = "organic";
        otm_medium = "organic";
      }
    }
  }

  var sourceCookie = $.cookie(SOURCE_COOKIE_NAME) || "";
  var sourceCookieInfo = sourceCookie.split(SOURCE_COOKIE_DELIMITER);

  if (sourceCookieInfo[0]) {
    campaign = sourceCookieInfo[0];
  }
  if (sourceCookieInfo[1]) {
    content = sourceCookieInfo[1];
  }
  if (sourceCookieInfo[2]) {
    // Prefer the url param or organic over the cookie
    medium = medium || sourceCookieInfo[2];
  }
  if (sourceCookieInfo[3]) {
    source = sourceCookieInfo[3];
  }
  if (sourceCookieInfo[4]) {
    keyword = sourceCookieInfo[4];
  }
  if (sourceCookieInfo[5]) {
    otm_campaign = sourceCookieInfo[5];
  }
  if (sourceCookieInfo[6]) {
    otm_content = sourceCookieInfo[6];
  }
  if (sourceCookieInfo[7]) {
    // Prefer the url param or organic over the cookie
    otm_medium = otm_medium || sourceCookieInfo[7];
  }
  if (sourceCookieInfo[8]) {
    otm_source = sourceCookieInfo[8];
  }
  if (sourceCookieInfo[9]) {
    otm_keyword = sourceCookieInfo[9];
  }
  if (sourceCookie[10]) {
    signup_platform = signup_platform || sourceCookieInfo[10];
  }

  // If there's still no medium check for referred
  if (!medium && !otm_medium) {
      // If the referrer is NOT optimizely.com then this user has been referred
    if (referrer && !referrer.match("optimizely\.com")) {
      medium = "referred";
      otm_medium = "referred";
    }
  }

  // Finally, if it's STILL blank then it must be direct traffic
  if (!medium && !otm_medium) {
    medium = "direct";
    otm_medium = "direct";
  }

  return {
    'campaign': campaign,
    'content': content,
    'medium': medium,
    'source': source,
    'keyword': keyword,
    'otm_campaign': otm_campaign,
    'otm_content': otm_content,
    'otm_medium': otm_medium,
    'otm_source': otm_source,
    'otm_keyword': otm_keyword,
    'signup_platform': signup_platform
  }
};

var saveSource = function() {
  var sourceInfo = getSource();

  if (sourceInfo.source) {
    $.ajax({
      data: {
        "source": sourceInfo.source
      },
      url: "/account/set_source"
    });
  }

  $.cookie(SOURCE_COOKIE_NAME,
           [sourceInfo.campaign, sourceInfo.content,
            sourceInfo.medium, sourceInfo.source, sourceInfo.keyword,
            sourceInfo.otm_campaign, sourceInfo.otm_content, sourceInfo.otm_medium,
            sourceInfo.otm_source, sourceInfo.otm_keyword, sourceInfo.signup_platform].join(SOURCE_COOKIE_DELIMITER));

};

var trackAdwordsConversion = function(google_conversion_label) {
  var google_conversion_id = 1011114068;
  var image = new Image(1,1);
  image.src = "//www.googleadservices.com/pagead/conversion/"+google_conversion_id+"/?label="+google_conversion_label+"&guid=ON&script=0";
};

var trackTradaConversion = function(action) {
  var advertiser = "d1f255a373a3cef72e03aa9d980c7eca";
  var image = new Image(1,1);
  image.src = "//aaf.tradatracker.net/track/conv.gif?advertiser="+advertiser+"&action="+action;
};


/**
 * Tracks events for Google Analytics via _trackEvent.
 * Note that trackEvent below also tracks events in GA, but using _trackPageview.
 * _trackEvent is preferred for new features but the old function is available for continuity.
 * See https://developers.google.com/analytics/devguides/collection/gajs/eventTrackerGuide
 * @param {string} category
 * @param {string=} action
 * @param {string=} label
 * @param {number=} value
 */
var trackEventGA = function(category, action, label, value) {
  try {
    // Note: undefined parameters are ok in GA
    var event = ['_trackEvent', category, action, label, value];
    window._gaq.push(event);
  }
  catch (e) {
    $.noop();
  }
}

var trackEvent = function(event) {
  //log("Tracking event: " + event);
  tryEvalBlock("_gaq.push(['_trackPageview', '" + event + "']);");
  tryEvalBlock("_kmq.push(['record', '" + event + "']);");
  tryEvalBlock("mpq.push(['track', '" + event + "', {}]);");
  tryEvalBlock("optimizely.trackEvent('" + event + "');");
  tryEvalBlock("window.adroll_segments = '" + event + "'; __adroll.render_pixel_code(adroll_adv_id, adroll_pix_id);");

  try {
    var fullEventLikeUrl = "/event";
    if (event && event[0] !== "/") {
      fullEventLikeUrl += "/";
    }
    fullEventLikeUrl += event;
    window['mktoMunchkinFunction']('visitWebPage', {
      url: fullEventLikeUrl
    });
  }
  catch(e) {
    // nothing
  }
};

var trackIdentity = function(email) {
  //log("Tracking identity: " + email);

  // Track in KISSmetrics
  tryEvalBlock("_kmq.push(['identify', '" + email + "']);");
};

/**
 * Tracks lead info in Marketo with the Munchkin associateLead function.
 * @param {Object} leadInfo
 * @param {string} token
 * @param {number=} numTimesForRedundancy
 */
var trackMarketo = function(leadInfo, token, numTimesForRedundancy) {
  if (!leadInfo || !token) {
    return;
  }
  if (numTimesForRedundancy === undefined) {
    numTimesForRedundancy = 5;
  }
  if (numTimesForRedundancy <= 0) {
    return;
  }

  if (leadInfo['FirstName']) {
    leadInfo['FirstName'] = $.trim(leadInfo['FirstName']);
  }
  if (leadInfo['LastName']) {
    leadInfo['LastName'] = $.trim(leadInfo['LastName']);
  }
  if (leadInfo['Company']) {
    leadInfo['Company'] = $.trim(leadInfo['Company']);
  }

  var sourceInfo = getSource();
  if (sourceInfo.campaign) {
    leadInfo['utm_Campaign__c'] = sourceInfo.campaign;
  }
  if (sourceInfo.content) {
    leadInfo['utm_Content__c'] = sourceInfo.content;
  }
  if (sourceInfo.medium) {
    leadInfo['utm_Medium__c'] = sourceInfo.medium;
  }
  if (sourceInfo.source) {
    leadInfo['utm_Source__c'] = sourceInfo.source;
  }
  if (sourceInfo.keyword) {
    leadInfo['utm_Keyword__c'] = sourceInfo.keyword;
  }
  if (sourceInfo.otm_campaign) {
    leadInfo['otm_Campaign__c'] = sourceInfo.otm_campaign;
  }
  if (sourceInfo.otm_content) {
    leadInfo['otm_Content__c'] = sourceInfo.otm_content;
  }
  if (sourceInfo.otm_medium) {
    leadInfo['otm_Medium__c'] = sourceInfo.otm_medium;
  }
  if (sourceInfo.otm_source) {
    leadInfo['otm_Source__c'] = sourceInfo.otm_source;
  }
  if (sourceInfo.otm_keyword) {
    leadInfo['otm_Keyword__c'] = sourceInfo.otm_keyword;
  }
  if (sourceInfo.signup_platform) {
    leadInfo['Signup_Platform__c'] = sourceInfo.signup_platform;
  }

  try {
    // Note: Tracking is blocked during local-testing. 
    // See templates/website/wrapper.html
    window['mktoMunchkinFunction'](
       'associateLead',
       leadInfo,
       token
    );
  }
  catch(e) {
    // do nothing
  }

  setTimeout(goog.partial(trackMarketo, leadInfo, token,
    numTimesForRedundancy - 1), 1000);
};

var trackTransaction = function(plan, value) {
  //log("Tracking transaction, plan = " + plan + " and value = " + value);

  // Track in Google Analytics
  var orderId = (new Date()).getTime().toString();
  tryEvalBlock("_gaq.push(['_addTrans',\
    '" + orderId + "',    // order ID - required\
    '',                   // affiliation or store name\
    '" + value + "',      // total - required\
    '0',                  // tax\
    '0',                  // shipping\
    '',                   // city\
    '',                   // state or province\
    ''                    // country\
  ]);");

   // add item might be called for every item in the shopping cart
   // where your ecommerce engine loops through each item in the cart and
   // prints out _addItem for each
  tryEvalBlock("_gaq.push(['_addItem',\
    '" + orderId + "',    // order ID - required\
    '" + plan + "',       // SKU/code - required\
    '" + plan + "',       // product name\
    '',                   // category or variation\
    '" + value + "',      // unit price - required\
    '1'                   // quantity - required\
  ]);");

  tryEvalBlock("_gaq.push(['_trackTrans']);");

  // Track in Optimizely
  tryEvalBlock("optimizely.push(['trackEvent', '/pricing/dialog/success/value', " + 100 * value + "]);");
  //track revenue
  tryEvalBlock("window.optimizely.push(['trackEvent', 'revenue', {'revenue': " + 100 * value + "}]);");

  // Track in KISSmetrics
  //   example: _kmq.push(['record', '/pricing/dialog/success/value', {'plan':'bronze', 'amount':19}]);
  tryEvalBlock("_kmq.push(['record', '/pricing/dialog/success/value', {'plan':'" + plan + "', 'amount':" + value + "}]);");
};

/**
 * Associates an attribute with a visitor, for our analytics tools.
 *
 * @param {string} name
 * @param {string} value
 * @param {Object=} passedSettings
 */
var trackVisitorAttribute = function(name, value, passedSettings) {
  //log("Tracking attribute, name = " + name + " and value = " + value);

  var settings = {
    gaqSlot: null, // the attribute will not get tracked in GA unless this is set
    gaqOptLevel: 1 // 1 for visitor-level
  };
  if (!goog.isDefAndNotNull(passedSettings)) {
    passedSettings = {};
  }
  $.extend(settings, passedSettings);

  // Track in Google Analytics
  if (goog.isDefAndNotNull(settings.gaqSlot)) {
    tryEvalBlock("_gaq.push(['_setCustomVar'," + settings.gaqSlot + ",'" + name + "','" + value + "'," + settings.gaqOptLevel + "]);");
  }

  // Track in KISSMetrics
  tryEvalBlock("_kmq.push(['set', {'" + name + "':'" + value + "'}]);");
};


// assets/js/bundle/common/signin.js
goog.provide("optly.common.signin");

/**
 * Parses continue_to URL from current URL or uses default destination and performs redirection.
 */
optly.common.signin.handleContinueToUrl = function() {
  var DEFAULT_CONTINUE_TO = "/dashboard";

  //Mobile JS differs from desktop JS in the function used to retrieve querystring params
  var queryParameters = $.deparam ? $.deparam.querystring() : window.deparam(window.location.search);
  var continueTo = ("continue_to" in queryParameters) ?
                   queryParameters.continue_to.toLowerCase() :
                   undefined;

  // Make sure that the continueTo is a valid URL.
  // This regex comes from http://snippets.dzone.com/posts/show/452
  var regexpForURL =
    /(http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;

  if (typeof continueTo !== 'undefined' &&
      optly.domain.check(continueTo)) {
    var continueToHostname = optly.domain.getLocation(continueTo).hostname,
        isRelativePath = !continueToHostname || continueToHostname === window.location.hostname;
    if (isRelativePath || regexpForURL.test(continueTo)) {
      window.location = continueTo;
    }
  }
  else {
    window.location = DEFAULT_CONTINUE_TO;
  }
};


// assets/js/bundle/env.js
/**
 * @author Tyler Brandt (tyler@optimizely.com)
 */
goog.provide('optly.env');

/**
 * Provide a single place through which application "environment" variables can be accessed.
 * Defaults to window.optlyConfig
 * @type {Object}
 */
window.optlyConfig = window.optlyConfig || {};
optly.env = $.extend(true, {}, window.optlyConfig.env);

// assets/js/bundle/util/main.js
goog.provide("optly.util.main");

/** @const */
var ENABLE_LOGGING = true;

/**
 * This function generates a rfc4122 version 4 compliant guid.
 */
optly.util.main.generateGuid = function(){
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
      return v.toString(16);
    }).toUpperCase();
};


optly.util.main.str_repeat = function(i, m) {
  for (var o = []; m > 0; o[--m] = i){};
  return o.join('');
};

/**
 * Note this method is also in bundle_relaxed/sprintf.js
 * @param {...*} args
 */
optly.util.main.sprintf = function(args) {
  var i = 0, a, f = arguments[i++], o = [], m, p, c, x, s = '';
  while (f) {
    if (m = /^[^\x25]+/.exec(f)) {
      o.push(m[0]);
    }
    else if (m = /^\x25{2}/.exec(f)) {
      o.push('%');
    }
    else if (m = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(f)) {
      if (((a = arguments[m[1] || i++]) == null) || (a == undefined)) {
        throw('Too few arguments.');
      }
      if (/[^s]/.test(m[7]) && (typeof(a) != 'number')) {
        throw('Expecting number but found ' + typeof(a));
      }
      switch (m[7]) {
        case 'b': a = a.toString(2); break;
        case 'c': a = String.fromCharCode(a); break;
        case 'd': a = parseInt(a, 10); break;
        case 'e': a = m[6] ? a.toExponential(m[6]) : a.toExponential(); break;
        case 'f': a = m[6] ? parseFloat(a).toFixed(m[6]) : parseFloat(a); break;
        case 'o': a = a.toString(8); break;
        case 's': a = ((a = String(a)) && m[6] ? a.substring(0, /** @type {number} */(m[6])) : a); break;
        case 'u': a = Math.abs(a); break;
        case 'x': a = a.toString(16); break;
        case 'X': a = a.toString(16).toUpperCase(); break;
      }
      a = (/[def]/.test(m[7]) && m[2] && a >= 0 ? '+'+ a : a);
      c = m[3] ? m[3] == '0' ? '0' : m[3].charAt(1) : ' ';
      x = m[5] - String(a).length - s.length;
      p = m[5] ? optly.util.main.str_repeat.str_repeat(c, x) : '';
      o.push(s + (m[4] ? a + p : p + a));
    }
    else {
      throw('Huh ?!');
    }
    f = f.substring(m[0].length);
  }
  return o.join('');
}

/**
 * @param {...*} args
 */
optly.util.main.log = function(args) {
  if (ENABLE_LOGGING && window.console && window.console.log) {
    window.console.log(optly.util.main.sprintf.apply(window, arguments));
  }
};

/**
 * Returns the cartesian product between serveral arrays for example
 * cartesian([1,2], [3,4]) -> [[1,3], [1,4], [2,3], [2,4]]
 * @param {...*} args
 */
optly.util.main.cartesian = function(args) {
    var r = [], arg = arguments, max = arg.length-1;
    function helper(arr, i) {
        for (var j=0, l=arg[i].length; j<l; j++) {
            var a = arr.slice(0); // clone arr
            a.push(arg[i][j])
            if (i==max) {
                r.push(a);
            } else
                helper(a, i+1);
        }
    }
    helper([], 0);
    return r;
};

/**
 * Parses a url returing the various components.
 * @param {string} url
 * @return {Object}
 */
optly.util.main.parseUrl = function(url){
  if(!url) { return null; }
  var anchor = document.createElement("a");
  anchor.href = url;
  //we do not want to just return the location because not all of its
  //properties are available in every browser and this makes clear what
  //to expect from the function.
  return {
    hostname: anchor.hostname,
    protocol: anchor.protocol,
    pathname: anchor.pathname,
    search: anchor.search,
    href: anchor.href,
    fullpath: anchor.pathname + anchor.search,
    fullhostname: anchor.protocol + "//" + anchor.hostname
  };
};

/**
 * Searches a string for an occurance of a filtering string (case insensitive)
 * @param {string} stringToFind    The term to find
 * @param {string} stringToSearch  The string to search for the filter term
 * @return {boolean}
 */
optly.util.main.isFilterTermInItem = function(stringToFind, stringToSearch) {
  var filters,
    i;

  if (!stringToSearch) {
    return false;
  }

  filters = stringToFind.match(/\S+/g) || [];

  for (i = 0; i < filters.length; i++) {
    if (stringToSearch.toLocaleLowerCase().indexOf(filters[i].toLocaleLowerCase()) === -1) {
      return false;
    }
  }
  return true;
};


// assets/js/bundle/common/main.js
goog.provide("optly.common.main");

goog.require("goog.Uri");
goog.require("optly.common.analytics");
goog.require("optly.common.validateEmailLists");
goog.require("optly.common.format");
goog.require("optly.common.phone_numbers");
goog.require("optly.common.security");
goog.require("optly.common.signin");
goog.require("optly.common.ui");
goog.require("optly.util.main");
goog.require('optly.env');

/** @const */
var DAYS = [
  tr("Sunday>"),
  tr("Monday"),
  tr("Tuesday"),
  tr("Wednesday"),
  tr("Thursday"),
  tr("Friday"),
  tr("Saturday")
];

/** @const */
var MONTHS = [
  tr("January"),
  tr("February"),
  tr("March"),
  tr("April"),
  tr("May"),
  tr("June"),
  tr("July"),
  tr("August"),
  tr("September"),
  tr("October"),
  tr("November"),
  tr("December")
];

/** @const */
var SHORT_MONTHS = [
  tr("Jan"),
  tr("Feb"),
  tr("Mar"),
  tr("Apr"),
  tr("May"),
  tr("Jun"),
  tr("Jul"),
  tr("Aug"),
  tr("Sep"),
  tr("Oct"),
  tr("Nov"),
  tr("Dec")
];

/** @const */
var EDITOR_REDIRECT_PREFIX = "https://" + window.location.hostname + "/edit_url/";

/**
* Add a URL parameter (or changing it if it already exists)
*/
var addUrlParam = function(fullUrl, key, val){
  var urlSplit = fullUrl.split("?");
  var url = urlSplit[0];
  var oldQueryString = "?"
  if (urlSplit.length >= 2 && goog.isDefAndNotNull(urlSplit[1])) {
    oldQueryString += urlSplit[1];
  }
  var newParam = key + "=" + val;

  var newQueryString = oldQueryString.replace(new RegExp("([\?&])" + key + "[^&]*"),
                                              "$1" + newParam);

  if (oldQueryString === newQueryString) {
    if (oldQueryString === "?") {
      newQueryString += newParam;
    }
    else {
      newQueryString += '&' + newParam;
    }
  }

  return url + newQueryString;
};

/**
 * Compare two arrays for equality. Arrays cannot contain objects.
 */
var areArraysEqual = function(arr1, arr2) {
  return $.toJSON(arr1) === $.toJSON(arr2);
};

/**
 * @param {Object} element
 */
var cloneElement = function(element) {
  var clone = element.clone(false);
  var cloneCanvases = clone.find("canvas");
  var elementCanvases = element.find("canvas");

  if (element.get(0).tagName === "CANVAS") {
    cloneCanvases = clone.add(cloneCanvases);
    elementCanvases = element.add(elementCanvases);
  }

  goog.asserts.assert(cloneCanvases.length === elementCanvases.length,
                      "clone() produced different number of canvases.");

  for (var index = 0; index < cloneCanvases.length; ++index) {
    try {
      var cloneContext = cloneCanvases[index].getContext("2d");
      var elementContext = elementCanvases[index].getContext("2d");
      var imageData = elementContext.getImageData(0, 0,
                                                  elementContext.canvas.width,
                                                  elementContext.canvas.height);

      cloneContext.putImageData(imageData, 0, 0);
    }
    catch(err) {
      log("cloneElement() had an error: %s", err);
    }
  }

  return clone;
};

/**
 * @param {jQueryObject} elements
 */
var cloneElements = function(elements) {
  var clonedElements = [];

  for (var index = 0; index < elements.length; ++index) {
    var element = $(elements[index]);
    var source = element.attr("src");

    // Appending a cloned <embed> referencing ZClientController.swf causes
    // Chrome in Windows to "Aw, Snap!" so, if that tag is found, we clear the
    // "src" attribute.
    //
    // ZClientController.swf is used by Zopim, a live chat tool.
    if (source && source.indexOf("ZClientController.swf") !== -1) {
      element.attr("src", "");
    }

    clonedElements.push(cloneElement(element)[0]);
  }

  return clonedElements;
};

/**
 * @param {Object} object
 * @return {Object}
 */
var cloneOwnProperties = function(object) {
  var clone = {}

  for (var key in object) {
    if (object.hasOwnProperty(key)) {
      clone[key] = object[key];
    }
  }

  return clone;
};

/**
 * TODO:
 * convertSplunkTimeToJavascript is only used on the legacy results page
 * and should be removed when we remove the legacy results page.
 */
var convertSplunkTimeToJavascript = function(splunkTime) {
  // Remove trailing "+00"
  var result = splunkTime.substring(0, splunkTime.indexOf("+"));

  // Replace the T in the middle with a space
  result = result.replace("T", " ");

  // Replace the dashes in the date with slashes
  result = result.replace(/-/g, "/");

  return result;
};

/**
 * Example:
 * crossProduct([1,2,3], [4,5], [6,7])
 * returns [[1, 4, 6], [2, 4, 6], [3, 4, 6], [1, 5, 6], [2, 5, 6], [3, 5, 6], [1, 4, 7], [2, 4, 7], [3, 4, 7], [1, 5, 7], [2, 5, 7], [3, 5, 7]]
 */
var crossProduct = function() {
  var crossProducts = arguments[0].map(function(elem) { return [elem] });
  var currentCrossProduct = null;
  for (var i = 1; i < arguments.length; i++) {
    currentCrossProduct = crossProducts.slice();
    crossProducts = [];
    var myArray = arguments[i];
    for (var j = 0; j < myArray.length; j++) {
      crossProducts = crossProducts.concat(currentCrossProduct.map(function(elem) {
        return elem.concat([myArray[j]]);
      }));
    }
  }
  return crossProducts;
};

/**
 * This function escapes the meta-characters from the jQuery selector.
 * Note that we're double escaping since the output is intended for a
 * literal string selector in the variation code.
 * (e.g $("myClass\\:rocks"))
 * http://api.jquery.com/category/selectors/
 *
 * @param {string} input
 * @return {string}
 */
var escapeSelector = function(input){
  return input.replace(/([\!\"\#\$\%\&'\(\)\*\+\,\.\/\:\;\<\=\>\?\@\[\\\]\^\`\{\|\}\~])/g, "\\$1");
};

/**
 * Returns the first index of an element in the array passing condition.
 */
var indexMatchingCondition = function(arr, condition) {
  for (var i=0; i < arr.length; i++) {
    if (condition(arr[i])) {
      return i;
    }
  }
  return -1;
};

var isArrayLike = function(object) {
  return object && typeof object === "object" &&
         object.length && typeof object.length === "number";
};

var min = function(a,b) {
  if (a == null && b == null) {
    return null;
  }
  if (a == null || b < a) {
    return b;
  }
  return a;
};

var max = function(a,b) {
  if (a == null && b == null) {
    return null;
  }
  if (a == null || b > a) {
    return b;
  }
  return a;
};

/**
 * This function generates a rfc4122 version 4 compliant guid.
 */
var generateGuid = optly.util.main.generateGuid;

/**
 * This is a workaround for ENG-734, and exploits a FF bug that lets us
 * load insecure content.
 *
 * An example of this being reversed is in shared/shortlink.py
 *
 * @param {string} editUrl The editor URL to potentially redirect.
 * @param {string} userAgent The browser's user agent string.
 * @return {string} The redirected editor URL
 */
var getEditorRedirectWorkaroundUrl = function(editUrl, userAgent) {
  // workaround for ENG-734
  var editorRedirectRequired = /Firefox\/2[3-5]\./.test(userAgent);
  if (editorRedirectRequired && editUrl.indexOf("http://") === 0) {
    log("[Editor] Redirecting to /edit_url: %s", editUrl);
    editUrl = EDITOR_REDIRECT_PREFIX + encodeURIComponent(editUrl);
  }
  return editUrl;
};

/**
 * @param {string} url
 * @param {Object} parameters
 * @param {string=} hostPrefix
 * @param {string=} userAgent
 *
 * Add the supplied query parameters into the URL.
 */
var generateEditUrl = function(url, parameters, hostPrefix, userAgent) {
  if (!userAgent) {
    userAgent = window.navigator.userAgent;
  }

  var editUrl = null;

  // find the portion after a hash tag (if any)
  var matches = /^(.*?)(#.*)?$/.exec(url);

  if (matches) {
    var baseUrl = matches[1];
    var fragment = matches[2];

    editUrl = baseUrl;

    if (editUrl.indexOf("?") === -1) {
      // URL contains no query parameters, so add ?
      editUrl += "?";
    }
    else {
      // URL contains query parameters, so add & to be able to append
      editUrl += "&";
    }

    var parameterSubstrings = [];
    for (var key in parameters) {
      if(typeof(parameters[key]) === "undefined"){ continue; }
      var keyValue = encodeURIComponent(key) + "=" + encodeURIComponent(parameters[key]);
      parameterSubstrings.push(keyValue);
    }

    editUrl += (parameterSubstrings.join("&"));

    if (fragment) {
      editUrl += fragment;
    }

    if (editUrl.indexOf("://") === -1) {
      editUrl = "http://" + editUrl;
    }

    hostPrefix = hostPrefix || "";
    if (editUrl.indexOf('https:') === 0) {
      hostPrefix = hostPrefix.replace('http:', 'https:');
    }

    editUrl = getEditorRedirectWorkaroundUrl(hostPrefix + editUrl, userAgent);
  }

  return editUrl;
};

/**
 * @param {string} frameSource
 * @param {string} selector
 */
var generateJQuery = function(frameSource, selector) {
  var query = sprintf('"%s"', selector);

  if (frameSource) {
    query = sprintf('"%s",$("frame[src$=%s]")[0].contentDocument', selector,
                    frameSource);
  }

  // Escape the escape character for string literal
  query = query.replace(/\\/g, "\\\\");

  return "\n$(" + query + ")";
};

/**
 * @param {Object} element
 */
var getElementBounds = function(element) {
  var offset = element.offset();
  var left = offset.left;
  var top = offset.top;
  // Can't just call .outerWidth() and .outerHeight().  For some reason, these
  // calls end up going to the customer's version of jQuery, which in some
  // cases returns jQuery objects instead of integers when called without
  // arguments.
  var width = element.outerWidth(false);
  var height = element.outerHeight(false);

  var bounds = {
    bottom: top + height,
    left: left,
    right: left + width,
    top: top,
    width: width,
    height: height
  };

  var frame = getElementFrame(element);

  if (frame) {
    bounds.left += frame.offset().left;
    bounds.top += frame.offset().top;

    var body = $("body", frame[0].contentDocument);

    if (body.length > 0) {
      bounds.left -= body.scrollLeft();
      bounds.top -= body.scrollTop();
    }
  }

  return bounds;
};

/**
 * @param {Object} element
 */
var getElementFrame = function(element) {
  var frames = $("frame");

  for (var index = 0; index < frames.length; ++index) {
    if (frames[index].contentDocument === element[0].ownerDocument) {
      return $(frames[index]);
    }
  }

  return null;
};

// http://ovaraksin.blogspot.com/2010/07/cross-browser-solution-to-get-iframe.html
var getIframeBody = function(iframe) {
  if (!iframe) {
    return null;
  }

  var bodyIframe = null;
  if (iframe.contentWindow && iframe.contentWindow.document.body) {
    bodyIframe = iframe.contentWindow.document.body;
  }
  else if (iframe.document && iframe.document.body) {
    bodyIframe = iframe.document.body;
  }
  else if (iframe.contentDocument && iframe.contentDocument.body) {
    bodyIframe = iframe.contentDocument.body;
  }

  return bodyIframe;
};

/**
 * @param {Object} object
 */
var getObjectPropertiesCount = function(object) {
  var count = 0;

  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      count++;
    }
  }

  return count;
};

/**
 * This function takes as input the frameUrl that was loaded in the iframe and
 * returns the final target url (possibly redirected) that was loaded after stripping
 * away optimizely_ query parameters. If frameUrl was proxied, then the
 * EDIT_URL host is also stripped out from the returned url
 *
 * @param {string} frameUrl
 */
var getFinalUrl = function(frameUrl) {
  // Assumes optimizely parameters only appear at the end
  var optimizely_params_index = frameUrl.indexOf("optimizely_");
  var url = frameUrl.substring(0, optimizely_params_index);

  url = url.replace(optly.env.EDIT_URL, '');

  // remove /edit_url/ if present
  if (url.indexOf(EDITOR_REDIRECT_PREFIX) === 0) {
    url = decodeURIComponent(url.replace(EDITOR_REDIRECT_PREFIX, ''));
  }

  // Remove any leading '/' which is likely if EDIT_URL was stripped out)
  if (url[0] === '/') {
    url = url.substring(1, url.length);
  }

  // Remove any trailing '&' or '?'
  var last = url[url.length - 1];
  if (last === '&'|| last === '?') {
    url = url.substring(0, url.length - 1);
  }

  return url;
};

/**
 * With Internet Explorer 11, IE's user agent string no longer matches the previous
 * string scheme, which included the token "MSIE". Our version of jQuery does not
 * understand this scheme in its support for browser detection. The new scheme looks
 * like this:
 *
 * "Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko"
 *
 * In this function, we identify 11-or-later versions of IE by the "Trident" keyword
 * and the number after "rv:".
 *
 * See http://msdn.microsoft.com/en-us/library/ie/bg182625(v=vs.85).aspx#uaString
 * for more context.
 *
 * @return {boolean}
 */
var isSupportedInternetExplorerVersion = function() {
  if ($.browser.name == "msie" && $.browser.versionNumber >= 10) {
    return true;
  }
  // check for conformity to newest IE user agent scheme (for now, all IE versions matching
  // this user agent scheme are supported)
  return /Trident.*rv:/.test(navigator.userAgent);
};

var isBrowserCompatible = function() {
  var browserName = $.browser.name;
  var browserVersion = $.browser.versionNumber;

  if (browserName == "chrome" && browserVersion >= 20) {
    return true;
  }
  else if (browserName == "firefox" && browserVersion >= 4) {
    return true;
  }
  else if (browserName == "safari" && browserVersion >= 5) {
    return true;
  }
  else if (isSupportedInternetExplorerVersion()) {
    return true;
  }
  else {
    return false;
  }
};

/**
 * This function checks whether the browser can block mixed content. It can't
 * check whether it actually blocked any content.
 *
 * It only checks based on browser name and version numbers.
 *
 * @return {(string|boolean)} The name of the user's browser (only "chrome" or
 *   "firefox").
 */
var canBrowserBlockMixedContent = function() {
  var browserName = $.browser.name,
    browserVersion = $.browser.versionNumber;

  if (browserName == "chrome" && browserVersion >= 30) {
    return browserName;
  }
  else if (browserName == "firefox" && browserVersion >= 23) {
    return browserName;
  }
  else {
    return false;
  }
}

/**
 * The following function returns a jQuerified element, given either
 *  1) an element
 *  2) a jQuery element
 *  3) an event, in which case it returns the target of the event
 */
var elemOrEvent = function(elemOrEvent) {
   if (typeof elemOrEvent === "undefined") {
    return undefined;
  }
  else if (typeof elemOrEvent.target !== "undefined") {
    // We have an event triggered by an onclick.
    return $(elemOrEvent.target);
  }
  else if (typeof elemOrEvent.addClass !== "undefined") {
    // We probably have an element passed without making it a jQuery object.
    return $(elemOrEvent);
  } else {
    return elemOrEvent;
  }
};

var isNumeric = function(input) {
   return !isNaN(parseInt(input, 10));
};

/**
 * @param {...*} args
 */
var log = optly.util.main.log;

var parseUTCDate = function(dateString) {
  if (!goog.isDefAndNotNull(dateString)) {
    return null;
  }
  if (dateString instanceof Date) {
    return dateString;
  }
  var datePattern = /(\d\d\d\d)-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)Z/;
  var date = null;
  var matches = dateString.match(datePattern);

  if (matches && matches.length === 7) {
    date = new Date(matches[1],
                    matches[2] - 1,
                    matches[3],
                    matches[4],
                    matches[5],
                    matches[6]);
  }

  return date;
}

var parseDate = function(dateString) {
  if (!goog.isDefAndNotNull(dateString)) {
    return null;
  }
  var datePattern = /(\d\d\d\d)-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)Z/;
  var date = null;
  var milliseconds = Date.parse(dateString);

  if (milliseconds) {
    date = new Date(milliseconds);
  }
  else {
    var matches = dateString.match(datePattern);

    if (matches && matches.length === 7) {
      date = new Date();
      date.setUTCFullYear(+matches[1]);
      date.setUTCMonth(+matches[2] - 1);
      date.setUTCDate(+matches[3]);
      date.setUTCHours(+matches[4]);
      date.setUTCMinutes(+matches[5]);
      date.setUTCSeconds(+matches[6]);
    }
  }

  return date;
};

var resolveUrl = function(baseUrl, relativeUrl) {
  if (relativeUrl.indexOf("://") !== -1) {
    return relativeUrl;
  }
  else {
    try {
      return goog.Uri.resolve(baseUrl, relativeUrl).toString();
    }
    catch (exception) {
      return relativeUrl;
    }
  }
};

/**
 * @param {Object} element
 */
var shouldAvoid = function(element) {
  return element.closest(".optimizely-avoid").length > 0;
};

/**
 * Takes an object and returns a sorted array of the properties.
 *
 * @param {string} propertyName
 * @param {Object} object
 * @param {boolean=} descending
 * @returns {Array.<Object>} a sorted array of the objects
 */
var sortObjectByProperties = function(object, propertyName, descending) {
  var array = [];

  for (var key in object) {
    array.push(object[key]);
  }

  array.sort(function(a, b) {
    var propertyA = a[propertyName].toLowerCase();
    var propertyB = b[propertyName].toLowerCase();

    if (propertyA < propertyB) {
      return (descending) ? 1 : -1;
    }
    if (propertyA > propertyB) {
      return (descending) ? -1 : 1;
    }
    return 0;
  });

  return array;
};

var stringStartsWith = function (string, startsWith) {
  string = string || "";
  if (startsWith.length > string.length) {
      return false;
  }
  return string.substring(0, startsWith.length) === startsWith;
};

var tryEvalBlock = function(block) {
  try {
    eval(block);
  }
  catch (err) {
  }
};

var uniqueArray = function (arr) {
  var uniqueArr = [];
  for (var i=0; i < arr.length; i++) {
    var val = arr[i];
    if ($.inArray(val, uniqueArr) === -1) {
      uniqueArr.push(val);
    }
  }
  return uniqueArr;
};

/**
 * Randomize array element order in-place using Fisher-Yates shuffle algorithm.
 *
 * */

function shuffleArray(array) {
  for (var i = array.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
  return array;
}


// assets/js/bundle/third_party/jquery/readyordone.js
goog.provide("optly.jquery.readyordone");

goog.require("optly.jquery");

// http://friedcellcollective.net/outbreak/2009/02/19/jqueryreadyordone/

(function ($) {
  var time = setTimeout(function () {}, 0),
    lastelm = null;
  $.readyOrDone = function (fn) {
    var s = document.readyState, getLast = function () {
      var elms = document.getElementsByTagName('*');
      return elms[elms.length - 1];
    };
    if (s === 'complete') {
      $.ready();
    } else if (typeof s === 'undefined') {
      lastelm = getLast();
      clearTimeout(time);
      time = setTimeout(function () {
        if (getLast() === lastelm && typeof document.readyState === 'undefined') {
           $.ready();
        }
      }, 1000);
    }
    $(fn);
  };
})($);


// assets/js/bundle/third_party/jquery/farbtastic.js
goog.provide("optly.jquery.farbtastic");

goog.require("optly.jquery");

/**
 * Farbtastic Color Picker 1.2
 * 2008 Steven Wittens
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

(function($) {
var jQuery = $;

jQuery.fn.farbtastic = function (callback, secondCallback) {
  $.farbtastic(this, callback ,secondCallback);
  return this;
};

jQuery.farbtastic = function (container, callback, secondCallback) {
  var container = $(container).get(0);
  container.farbtastic = new jQuery._farbtastic(container, callback, secondCallback);
  return container.farbtastic;
  //return container.farbtastic || (container.farbtastic = new jQuery._farbtastic(container, callback));
};

jQuery._farbtastic = function (container, callback, secondCallback) {
  // Store farbtastic object
  var fb = this;

  // Insert markup
  $(container).html('\
  <div class="farbtastic">\
    <div class="color"></div>\
    <div class="wheel"></div>\
    <div class="hinter"></div>\
    <div class="overlay"></div>\
    <div class="h-marker marker"></div>\
    <div class="sl-marker marker"></div>\
  </div>');

  var e = $('.farbtastic', container);
  fb.wheel = $('.wheel', container).get(0);
  // Dimensions
  fb.radius = 84;
  fb.square = 100;
  fb.width = 194;

  // Fix background PNGs in IE6
  if (navigator.appVersion.match(/MSIE [0-6]\./)) {
    $('*', e).each(function () {
      if (this.currentStyle.backgroundImage != 'none') {
        var image = this.currentStyle.backgroundImage;
        image = this.currentStyle.backgroundImage.substring(5, image.length - 2);
        $(this).css({
          'backgroundImage': 'none',
          'filter': "progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=crop, src='" + image + "')"
        });
      }
    });
  }

  /**
   * Link to the given element(s) or callback.
   */
  fb.linkTo = function (callback) {
    // Unbind previous nodes
    if (typeof fb.callback == 'object') {
      $(fb.callback).unbind('keyup', fb.updateValue);
    }

    // Reset color
    fb.color = null;

    // Bind callback or elements
    if (typeof callback == 'function') {
      fb.callback = callback;
    }
    else if (typeof callback == 'object' || typeof callback == 'string') {
      fb.callback = $(callback);
      fb.callback.bind('keyup', fb.updateValue);
      if (fb.callback.get(0).value) {
        fb.setColor(fb.callback.get(0).value);
      }
    }
    return this;
  };

  fb.updateValue = function (event) {
    try {
      fb.setColor(this.value);
    }
    catch(exception) {
    }
  };

  /**
   * Change color with HTML syntax #123456
   */
  fb.setColor = function (color) {
    var unpack = fb.unpack(color);
    if (fb.color != color && unpack) {
      fb.color = color;
      fb.rgb = unpack;
      fb.hsl = fb.RGBToHSL(fb.rgb);
      fb.updateDisplay();
    }
    return this;
  };

  /**
   * Change color with HSL triplet [0..1, 0..1, 0..1]
   */
  fb.setHSL = function (hsl) {
    fb.hsl = hsl;
    fb.rgb = fb.HSLToRGB(hsl);
    fb.color = fb.pack(fb.rgb);
    fb.updateDisplay();
    return this;
  };

  /////////////////////////////////////////////////////

  /**
   * Retrieve the coordinates of the given event relative to the center
   * of the widget.
   */
  fb.widgetCoords = function (event) {
    var x, y;
    var el = event.target || event.srcElement;
    var reference = fb.wheel;

    if (typeof event.offsetX != 'undefined') {
      // Use offset coordinates and find common offsetParent
      var pos = { x: event.offsetX, y: event.offsetY };

      // Send the coordinates upwards through the offsetParent chain.
      var e = el;
      while (e) {
        e.mouseX = pos.x;
        e.mouseY = pos.y;
        pos.x += e.offsetLeft;
        pos.y += e.offsetTop;
        e = e.offsetParent;
      }

      // Look for the coordinates starting from the wheel widget.
      var e = reference;
      var offset = { x: 0, y: 0 }
      while (e) {
        if (typeof e.mouseX != 'undefined') {
          x = e.mouseX - offset.x;
          y = e.mouseY - offset.y;
          break;
        }
        offset.x += e.offsetLeft;
        offset.y += e.offsetTop;
        e = e.offsetParent;
      }

      // Reset stored coordinates
      e = el;
      while (e) {
        e.mouseX = undefined;
        e.mouseY = undefined;
        e = e.offsetParent;
      }
    }
    else {
      // Use absolute coordinates
      var pos = fb.absolutePosition(reference);
      x = (event.pageX || 0*(event.clientX + $('html').get(0).scrollLeft)) - pos.x;
      y = (event.pageY || 0*(event.clientY + $('html').get(0).scrollTop)) - pos.y;
    }
    // Subtract distance to middle
    return { x: x - fb.width / 2, y: y - fb.width / 2 };
  }

  /**
   * Mousedown handler
   */
  fb.mousedown = function (event) {
    // Capture mouse
    if (!document.dragging) {
      $(document).bind('mousemove', fb.mousemove).bind('mouseup', fb.mouseup);
      document.dragging = true;
    }

    // Check which area is being dragged
    var pos = fb.widgetCoords(event);
    fb.circleDrag = Math.max(Math.abs(pos.x), Math.abs(pos.y)) * 2 > fb.square;

    // Process
    fb.mousemove(event);
    return false;
  };

  /**
   * Mousemove handler
   */
  fb.mousemove = function (event) {
    // Get coordinates relative to color picker center
    var pos = fb.widgetCoords(event);

    // Set new HSL parameters
    if (fb.circleDrag) {
      var hue = Math.atan2(pos.x, -pos.y) / 6.28;
      if (hue < 0) hue += 1;
      fb.setHSL([hue, fb.hsl[1], fb.hsl[2]]);
    }
    else {
      var sat = Math.max(0, Math.min(1, -(pos.x / fb.square) + .5));
      var lum = Math.max(0, Math.min(1, -(pos.y / fb.square) + .5));
      fb.setHSL([fb.hsl[0], sat, lum]);
    }
    return false;
  };

  /**
   * Mouseup handler
   */
  fb.mouseup = function () {
    // Uncapture mouse
    $(document).unbind('mousemove', fb.mousemove);
    $(document).unbind('mouseup', fb.mouseup);
    document.dragging = false;
  };

  /**
   * Update the markers and styles
   */
  fb.updateDisplay = function () {
    // Markers
    var angle = fb.hsl[0] * 6.28;
    $('.h-marker', e).css({
      left: Math.round(Math.sin(angle) * fb.radius + fb.width / 2) + 'px',
      top: Math.round(-Math.cos(angle) * fb.radius + fb.width / 2) + 'px'
    });

    $('.sl-marker', e).css({
      left: Math.round(fb.square * (.5 - fb.hsl[1]) + fb.width / 2) + 'px',
      top: Math.round(fb.square * (.5 - fb.hsl[2]) + fb.width / 2) + 'px'
    });

    // Saturation/Luminance gradient
    $('.color', e).css('backgroundColor', fb.pack(fb.HSLToRGB([fb.hsl[0], 1, 0.5])));

    // Hinter
    $('.hinter', e).css({
      "background-color": fb.color
    });

    // Linked elements or callback
    if (typeof fb.callback == 'object') {
      // Set background/foreground color
      /*$(fb.callback).css({
        backgroundColor: ,
        color: fb.hsl[2] < 0.5 ? '#EEE' : '#111'
      });*/

      // Change linked value
      $(fb.callback).each(function() {
        try {
          this.value = fb.color;
        }
        catch(exception) {
        }
      });
    }
    else if (typeof fb.callback === "function") {
      fb.callback.call(fb, fb.color);
    }

    if (fb.secondCallback && typeof fb.secondCallback === "function") {
      fb.secondCallback.call(fb, fb.color);
    }
  };

  /**
   * Get absolute position of element
   */
  fb.absolutePosition = function (el) {
    var r = { x: el.offsetLeft, y: el.offsetTop };
    // Resolve relative to offsetParent
    if (el.offsetParent) {
      var tmp = fb.absolutePosition(el.offsetParent);
      r.x += tmp.x;
      r.y += tmp.y;
    }
    return r;
  };

  /* Various color utility functions */
  fb.pack = function (rgb) {
    var r = Math.round(rgb[0] * 255);
    var g = Math.round(rgb[1] * 255);
    var b = Math.round(rgb[2] * 255);
    return '#' + (r < 16 ? '0' : '') + r.toString(16) +
           (g < 16 ? '0' : '') + g.toString(16) +
           (b < 16 ? '0' : '') + b.toString(16);
  };

  fb.unpack = function (color) {
    if (color.length == 7) {
      return [parseInt('0x' + color.substring(1, 3)) / 255,
        parseInt('0x' + color.substring(3, 5)) / 255,
        parseInt('0x' + color.substring(5, 7)) / 255];
    }
    else if (color.length == 4) {
      return [parseInt('0x' + color.substring(1, 2)) / 15,
        parseInt('0x' + color.substring(2, 3)) / 15,
        parseInt('0x' + color.substring(3, 4)) / 15];
    }
  };

  fb.HSLToRGB = function (hsl) {
    var m1, m2, r, g, b;
    var h = hsl[0], s = hsl[1], l = hsl[2];
    m2 = (l <= 0.5) ? l * (s + 1) : l + s - l*s;
    m1 = l * 2 - m2;
    return [this.hueToRGB(m1, m2, h+0.33333),
        this.hueToRGB(m1, m2, h),
        this.hueToRGB(m1, m2, h-0.33333)];
  };

  fb.hueToRGB = function (m1, m2, h) {
    h = (h < 0) ? h + 1 : ((h > 1) ? h - 1 : h);
    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1) return m2;
    if (h * 3 < 2) return m1 + (m2 - m1) * (0.66666 - h) * 6;
    return m1;
  };

  fb.RGBToHSL = function (rgb) {
    var min, max, delta, h, s, l;
    var r = rgb[0], g = rgb[1], b = rgb[2];
    min = Math.min(r, Math.min(g, b));
    max = Math.max(r, Math.max(g, b));
    delta = max - min;
    l = (min + max) / 2;
    s = 0;
    if (l > 0 && l < 1) {
      s = delta / (l < 0.5 ? (2 * l) : (2 - 2 * l));
    }
    h = 0;
    if (delta > 0) {
      if (max == r && max != g) h += (g - b) / delta;
      if (max == g && max != b) h += (2 + (b - r) / delta);
      if (max == b && max != r) h += (4 + (r - g) / delta);
      h /= 6;
    }
    return [h, s, l];
  };

  // Install mousedown handler (the others are set on the document on-demand)
  $('*', e).mousedown(fb.mousedown);

    // Init color
  fb.setColor('#000000');

  // Set linked elements/callback
  if (callback) {
    fb.linkTo(callback);
  }
  if (secondCallback) {
    fb.secondCallback = secondCallback;
  }
}

})(jQuery);


// assets/js/bundle/third_party/stats.js
goog.provide("optly.stats");

// JS stats lib taken from http://www.ciphersbyritter.com/JAVASCRP/NORMCHIK.HTM
// Written by Terry Ritter


// UTILITIES

// Test Window

var testWin;
var testWinOpen = 0;  // avoids repeated titles on page
   // 3.0 seems to have problems with true/false Booleans

function OpenTestWin() {
   // window may have been closed and need opening again!
   if ((testWinOpen < 1) || testWin.closed) {
      testWinOpen = 2;
      testWin = window.open( "", "testWin", "toolbar=0,menubar=1,scrollbars=1" );
      testWin.document.writeln( "<HTML><HEAD><TITLE>Statistics Function Tests</TITLE></HEAD><BODY>" );
      testWin.document.writeln( "<H1 ALIGN = CENTER>Statistics Function Tests</H1><P>" );
      testWin.document.writeln( "<PRE>\n" );
      }
   }


// NUMERIC FORMATTING

function Fixed( s, wid, dec ) {
   // many combinations of possibilities

   // maybe prepare for upcoming truncate
   var z = 1
   if (dec > 0) {
      z /= Math.pow( 10, dec );
      if (s < -z)  s -= 0.5 * z;
      else
         if (s > z)  s += 0.5 * z;
         else
            s = 0;
      }

   // assure a string
   s = "" + s;

   // chop neg, if any
   var neg = 0;
   if (s.charAt(0) == "-") {
      neg = 2;
      s = s.substring( 1, s.length );
      }

   // chop exponent, if any
   var exp = "";
   var e = s.lastIndexOf( "E" );
   if (e < 0)  e = s.lastIndexOf( "e" );
   if (e > -1) {
      exp = s.substring( e, s.length );
      s = s.substring( 0, e );
      }

   // if dec > 0 assure "."; dp == index of "."
   var dp = s.indexOf( ".", 0 );
   if (dp == -1) {
      dp = s.length;
      if (dec > 0) {
         s += ".";
         dp = s.length - 1;
         }
      }

   // assure leading digit
   if (dp == 0) {
      s = '0' + s;
      dp = 1;
      }

   // not enough dec pl?  add 0's
   while ((dec > 0) && ((s.length - dp - 1) < dec))
      s += "0";

   // too many dec pl?  take a substring
   var places = s.length - dp - 1;
   if (places > dec) {
      if (dec == 0) {
         s = s.substring( 0, dp );
         }
      else {
         s = s.substring( 0, dp + dec + 1 );
         }
      }

   // recover exponent, if any
   s += exp;

   // recover neg, if any
   if (neg > 0)
      s = "-" + s;

   // if not enough width, add spaces IN FRONT
   //    too many places?  tough!
   while (s.length < wid)
      s = " " + s;

   return s
   }

function Prb( x ) {
   if (x < 0)  x = 0;
   else
      if (x > 1)  x = 1;
   return x;
   }

function PosV( x ) {
   if (x < 0)  x = -x;
   return x;
   }


// FACTORIALS

function Fact( x ) {
   // x factorial
   var  t=1;
   while (x > 1)
      t *= x--;
   return t;
   }

function LnFact( x ) {
   // ln(x!) by Stirling's formula
   //   see Knuth I: 111
   if (x <= 1)  x = 1;

   if (x < 12)
      return Math.log( Fact(Math.round(x)) );
   else {
      var invx = 1 / x;
      var invx2 = invx * invx;
      var invx3 = invx2 * invx;
      var invx5 = invx3 * invx2;
      var invx7 = invx5 * invx2;

      var sum = ((x + 0.5) * Math.log(x)) - x;
      sum += Math.log(2*Math.PI) / 2;
      sum += (invx / 12) - (invx3 / 360);
      sum += (invx5 / 1260) - (invx7 / 1680);

      return sum;
      }
   }


// COMBINATIONS

function LnComb( n, k ) {
   if ((k == 0) || (k == n))  return 0;
   else
      if ((k > n) || (k < 0))  return -1E38;
      else
         return  (LnFact(n) - LnFact(k) - LnFact(n-k));
   }


// NORMAL
/* 
 * CHANGES SHOULD BE MIRRORED to the Python port.
 * _normal_p in helpers/results_stats.py
 */
function NormalP( x ) {
   // Abramowitz & Stegun 26.2.19
   var
      d1 = 0.0498673470,
      d2 = 0.0211410061,
      d3 = 0.0032776263,
      d4 = 0.0000380036,
      d5 = 0.0000488906,
      d6 = 0.0000053830;

   var a = Math.abs(x);
   var t = 1.0 + a*(d1+a*(d2+a*(d3+a*(d4+a*(d5+a*d6)))));

   // to 16th power
   t *= t;  t *= t;  t *= t;  t *= t;
   t = 1.0 / (t+t);  // the MINUS 16th

   if (x >= 0)  t = 1 - t;
   return t;
   }

function InvNormalP( p ) {
   // Odeh & Evans. 1974. AS 70. Applied Statistics. 23: 96-97
   var
      p0 = -0.322232431088,
      p1 = -1.0,
      p2 = -0.342242088547,
      p3 = -0.0204231210245,
      p4 = -0.453642210148E-4,
      q0 =  0.0993484626060,
      q1 =  0.588581570495,
      q2 =  0.531103462366,
      q3 =  0.103537752850,
      q4 =  0.38560700634E-2,
      pp, y, xp;

   // p: 0.0 .. 1.0 -> pp: 0.0 .. 0.5 .. 0.0
   if (p < 0.5)  pp = p;  else  pp = 1 - p;

   if (pp < 1E-12)
      xp = 99;
   else {
      y = Math.sqrt(Math.log(1/(pp*pp)));
      xp = y + ((((y * p4 + p3) * y + p2) * y + p1) * y + p0) /
               ((((y * q4 + q3) * y + q2) * y + q1) * y + q0);
      }

   if (p < 0.5)  return -xp;
   else  return  xp;
   }

var NormCritDone = 0;

function DoInvNorm( aform ) {
   NormCritDone = 2;
   aform.p01.value = Fixed(InvNormalP( 0.01 ),10,4);
   aform.p05.value = Fixed(InvNormalP( 0.05 ),10,4);
   aform.p10.value = Fixed(InvNormalP( 0.10 ),10,4);
   aform.p25.value = Fixed(InvNormalP( 0.25 ),10,4);
   aform.p50.value = Fixed(InvNormalP( 0.50 ),10,4);
   aform.p75.value = Fixed(InvNormalP( 0.75 ),10,4);
   aform.p90.value = Fixed(InvNormalP( 0.90 ),10,4);
   aform.p95.value = Fixed(InvNormalP( 0.95 ),10,4);
   aform.p99.value = Fixed(InvNormalP( 0.99 ),10,4);
   }

function GotVari( aform ) {
   var v = parseFloat(aform.vari.value);
   aform.vari.value = Fixed(v,10,4);
   var s = Math.sqrt(v);
   aform.sdev.value = Fixed(s,10,4);
   }

function GotSdev( aform ) {
   var s = parseFloat(aform.sdev.value);
   aform.sdev.value = Fixed(s,10,4);
   var v = s * s;
   aform.vari.value = Fixed(v,10,4);
   }

function DoNormConv( aform ) {
   var m = parseFloat(aform.mean.value);
   aform.mean.value = Fixed(m,10,4);
   var v = parseFloat(aform.vari.value);
   aform.vari.value = Fixed(v,10,4);
   var s = parseFloat(aform.sdev.value);
   aform.sdev.value = Fixed(s,10,4);
   var y = parseFloat(aform.y.value);
   aform.y.value = Fixed(y,10,4);
   var z = (y - m) / s;
   aform.z.value = Fixed(z,10,4);
   }

function DoNorm( aform ) {
   var z = parseFloat(aform.z.value);
   aform.z.value = Fixed(z,10,4);
   var t = NormalP( z );
   aform.pz.value = Fixed(t,10,4);
   aform.qz.value = Fixed(1-t,10,4);
   if (NormCritDone < 1)
      DoInvNorm( aform );
   }

function DoNormIP( aform ) {
   var pq = parseFloat(aform.porq.value);
   aform.porq.value = Fixed(pq,10,4);
   var t = InvNormalP( pq );
   aform.invz.value = Fixed(t,10,4);
   }

function DoNormIQ( aform ) {
   var pq = parseFloat(aform.porq.value);
   aform.porq.value = Fixed(pq,10,4);
   var t = InvNormalP( 1-pq );
   aform.invz.value = Fixed(t,10,4);
   }


// CHI SQ

function ChiSqPN( degfree, x2 ) {
   // Peizer & Pratt from Ling, 1978, JASA 73: 274-283 }
   var  d, z, s = degfree - 1;

   if (Math.abs(x2 - s) < 0.1) {
      z = (1/3) + (0.08/degfree);
      z = -z / Math.sqrt(s+s);
      }
   else {
      d = x2 - degfree + (2/3) - (0.08/degfree);
      z = Math.sqrt((s * Math.log(s/x2)) + x2 - s);
      z = (d * z) / Math.abs(x2-s);
      }

   return NormalP( z );
   }

function ChiSqP( degfree, x2 ) {
   // found on a web page
   var  p, t, df, k, a;

   df = Math.round( degfree );
   if (df >= 50)  return ChiSqPN( degfree, x2 );
   else {

      p = Math.exp( -x2 / 2 );

      if ((df & 1) > 0)
         p *= Math.sqrt( (x2+x2) / Math.PI );

      k = df;
      while (k >= 2) {
         p *= x2 / k;
         k -= 2;
         }

      t = p;  a = df;
      while (t > (1E-7 * p)) {
         a += 2;
         t *= x2 / a;
         p += t;
         }

      return p;
      }
   }

function InvChiSq( degfree, p ) {
   // find x such that f(x) ~= p

   // basic range protection
   if (p < 0)  p = 0;
   else
      if (p > 1)  p = 1;
   if (degfree < 0)  degfree = 0;

   var a = 0, b = degfree + 0.1, loopct = 0;
   var fc = ChiSqP( degfree, b ), c;

   // hop b until f(b) == fc is above p
   //    fc < 0 is unified error exit
   while ((fc >= 0) && (fc <= p) && (loopct++ < 10)) {
      a = b;  b *= 2;
      fc = ChiSqP( degfree, b );
      }

   // x is bracketed by a and b, so squeeze...
   loopct = -loopct;
   while ((fc >= 0) && (Math.abs(fc-p) > 1E-6) && (loopct++ < 30)) {
      c = a + (b - a) / 2;  // bisection
      fc = ChiSqP( degfree, c );
      if (fc < p)  a = c;
      else  b = c;
      }

   if ((fc < 0) || (loopct >= 30))  return -2;
   else  return c;
   }

var ChiCritDone = 0;

function DoInvChi( aform, df ) {
   ChiCritDone = 2;
   aform.p01.value = Fixed(InvChiSq( df, 0.01 ),10,4);
   aform.p05.value = Fixed(InvChiSq( df, 0.05 ),10,4);
   aform.p10.value = Fixed(InvChiSq( df, 0.10 ),10,4);
   aform.p25.value = Fixed(InvChiSq( df, 0.25 ),10,4);
   aform.p50.value = Fixed(InvChiSq( df, 0.50 ),10,4);
   aform.p75.value = Fixed(InvChiSq( df, 0.75 ),10,4);
   aform.p90.value = Fixed(InvChiSq( df, 0.90 ),10,4);
   aform.p95.value = Fixed(InvChiSq( df, 0.95 ),10,4);
   aform.p99.value = Fixed(InvChiSq( df, 0.99 ),10,4);
   }

function DoChiSq( aform ) {
   var df = PosV(parseInt(aform.df.value));
   aform.df.value = Fixed(df,8,0);
   var x2 = PosV(parseFloat(aform.x.value));
   aform.x.value = Fixed(x2,10,4);
   var t = ChiSqP( df, x2 );
   aform.px.value = Fixed(t,8,4);
   aform.qx.value = Fixed(1-t,8,4);
   if (ChiCritDone < 1)
      DoInvChi( aform, df );
   }

function DoChiIP( aform ) {
   var df = PosV(parseInt(aform.df.value));
   aform.df.value = Fixed(df,8,0);
   var pq = parseFloat(aform.porq.value);
   aform.porq.value = Fixed(pq,10,4);
   var t = InvChiSq( df, pq );
   aform.invx.value = Fixed(t,10,4);
   }

function DoChiIQ( aform ) {
   var df = PosV(parseInt(aform.df.value));
   aform.df.value = Fixed(df,8,0);
   var pq = parseFloat(aform.porq.value);
   aform.porq.value = Fixed(pq,10,4);
   var t = InvChiSq( 1-pq );
   aform.invx.value = Fixed(t,10,4);
   }




// assets/js/bundle/third_party/jquery/json.js
goog.provide("optly.jquery.json");

goog.require("optly.jquery");

/*
 * jQuery JSON Plugin
 * version: 2.1 (2009-08-14)
 *
 * This document is licensed as free software under the terms of the
 * MIT License: http://www.opensource.org/licenses/mit-license.php
 *
 * Brantley Harris wrote this plugin. It is based somewhat on the JSON.org
 * website's http://www.json.org/json2.js, which proclaims:
 * "NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.", a sentiment that
 * I uphold.
 *
 * It is also influenced heavily by MochiKit's serializeJSON, which is
 * copyrighted 2005 by Bob Ippolito.
 */

(function($) {
    /** jQuery.toJSON( json-serializble )
        Converts the given argument into a JSON respresentation.

        If an object has a "toJSON" function, that will be used to get the representation.
        Non-integer/string keys are skipped in the object, as are keys that point to a function.

        json-serializble:
            The *thing* to be converted.
     **/
    $.toJSON = function(o)
    {
        //if (typeof(JSON) == 'object' && JSON.stringify)
        //    return JSON.stringify(o);

        var type = typeof(o);

        if (o === null)
            return "null";

        if (type == "undefined")
            return undefined;

        if (type == "number" || type == "boolean")
            return o + "";

        if (type == "string")
            return $.quoteString(o);

        if (type == 'object')
        {
            //if (typeof o.toJSON == "function")
            //    return $.toJSON( o.toJSON() );

            if (o.constructor === Date)
            {
                var month = o.getUTCMonth() + 1;
                if (month < 10) month = '0' + month;

                var day = o.getUTCDate();
                if (day < 10) day = '0' + day;

                var year = o.getUTCFullYear();

                var hours = o.getUTCHours();
                if (hours < 10) hours = '0' + hours;

                var minutes = o.getUTCMinutes();
                if (minutes < 10) minutes = '0' + minutes;

                var seconds = o.getUTCSeconds();
                if (seconds < 10) seconds = '0' + seconds;

                var milli = o.getUTCMilliseconds();
                if (milli < 100) milli = '0' + milli;
                if (milli < 10) milli = '0' + milli;

                return '"' + year + '-' + month + '-' + day + 'T' +
                             hours + ':' + minutes + ':' + seconds +
                             '.' + milli + 'Z"';
            }

            if (o.constructor === Array)
            {
                var ret = [];
                for (var i = 0; i < o.length; i++)
                    ret.push( $.toJSON(o[i]) || "null" );

                return "[" + ret.join(",") + "]";
            }

            var pairs = [];
            for (var k in o) {
                var name;
                var type = typeof k;

                if (type == "number")
                    name = '"' + k + '"';
                else if (type == "string")
                    name = $.quoteString(k);
                else
                    continue;  //skip non-string or number keys

                if (typeof o[k] == "function")
                    continue;  //skip pairs where the value is a function.

                var val = $.toJSON(o[k]);

                pairs.push(name + ":" + val);
            }

            return "{" + pairs.join(", ") + "}";
        }
    };

    /** jQuery.evalJSON(src)
        Evaluates a given piece of json source.
     **/
    $.evalJSON = function(src)
    {
        //if (typeof(JSON) == 'object' && JSON.parse)
        //    return JSON.parse(src);
        return eval("(" + src + ")");
    };

    /** jQuery.secureEvalJSON(src)
        Evals JSON in a way that is *more* secure.
    **/
    $.secureEvalJSON = function(src)
    {
        //if (typeof(JSON) == 'object' && JSON.parse)
        //    return JSON.parse(src);

        var filtered = src;
        filtered = filtered.replace(/\\["\\\/bfnrtu]/g, '@');
        filtered = filtered.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
        filtered = filtered.replace(/(?:^|:|,)(?:\s*\[)+/g, '');

        if (/^[\],:{}\s]*$/.test(filtered))
            return eval("(" + src + ")");
        else
            throw new SyntaxError("Error parsing JSON, source is not valid.");
    };

    /** jQuery.quoteString(string)
        Returns a string-repr of a string, escaping quotes intelligently.
        Mostly a support function for toJSON.

        Examples:
            >>> jQuery.quoteString("apple")
            "apple"

            >>> jQuery.quoteString('"Where are we going?", she asked.')
            "\"Where are we going?\", she asked."
     **/
    $.quoteString = function(string)
    {
        if (string.match(_escapeable))
        {
            return '"' + string.replace(_escapeable, function (a)
            {
                var c = _meta[a];
                if (typeof c === 'string') return c;
                c = a.charCodeAt();
                return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
            }) + '"';
        }
        return '"' + string + '"';
    };

    var _escapeable = /["\\\x00-\x1f\x7f-\x9f]/g;

    var _meta = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    };
})(jQuery);


// assets/js/bundle/third_party/sprintf.js
goog.provide("optly.sprintf");
// NOTE: this method is also in bundle/common/sprintf.js

/**
sprintf() for JavaScript 0.6

Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of sprintf() for JavaScript nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Changelog:
2007.04.03 - 0.1:
 - initial release
2007.09.11 - 0.2:
 - feature: added argument swapping
2007.09.17 - 0.3:
 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)
2007.10.21 - 0.4:
 - unit test and patch (David Baird)
2010.05.09 - 0.5:
 - bug fix: 0 is now preceeded with a + sign
 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
 - switched from GPL to BSD license
2010.05.22 - 0.6:
 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
 Note:
 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
 who warned me about a bug in 0.5, I discovered that the last update was
 a regress. I appologize for that.
**/

function str_repeat(i, m) {
  for (var o = []; m > 0; o[--m] = i);
  return o.join('');
}

function sprintf() {
  var i = 0, a, f = arguments[i++], o = [], m, p, c, x, s = '';
  while (f) {
    if (m = /^[^\x25]+/.exec(f)) {
      o.push(m[0]);
    }
    else if (m = /^\x25{2}/.exec(f)) {
      o.push('%');
    }
    else if (m = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(f)) {
      if (((a = arguments[m[1] || i++]) == null) || (a == undefined)) {
        throw('Too few arguments.');
      }
      if (/[^s]/.test(m[7]) && (typeof(a) != 'number')) {
        throw('Expecting number but found ' + typeof(a));
      }
      switch (m[7]) {
        case 'b': a = a.toString(2); break;
        case 'c': a = String.fromCharCode(a); break;
        case 'd': a = parseInt(a); break;
        case 'e': a = m[6] ? a.toExponential(m[6]) : a.toExponential(); break;
        case 'f': a = m[6] ? parseFloat(a).toFixed(m[6]) : parseFloat(a); break;
        case 'o': a = a.toString(8); break;
        case 's': a = ((a = String(a)) && m[6] ? a.substring(0, m[6]) : a); break;
        case 'u': a = Math.abs(a); break;
        case 'x': a = a.toString(16); break;
        case 'X': a = a.toString(16).toUpperCase(); break;
      }
      a = (/[def]/.test(m[7]) && m[2] && a >= 0 ? '+'+ a : a);
      c = m[3] ? m[3] == '0' ? '0' : m[3].charAt(1) : ' ';
      x = m[5] - String(a).length - s.length;
      p = m[5] ? str_repeat(c, x) : '';
      o.push(s + (m[4] ? a + p : p + a));
    }
    else {
      throw('Huh ?!');
    }
    f = f.substring(m[0].length);
  }
  return o.join('');
}


// assets/js/bundle/third_party/jquery/bbq.js
goog.provide("optly.jquery.bbq");

goog.require("optly.jquery");

/*!
 * jQuery BBQ: Back Button & Query Library - v1.2.1 - 2/17/2010
 * http://benalman.com/projects/jquery-bbq-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery BBQ: Back Button & Query Library
//
// *Version: 1.2.1, Last updated: 2/17/2010*
//
// Project Home - http://benalman.com/projects/jquery-bbq-plugin/
// GitHub       - http://github.com/cowboy/jquery-bbq/
// Source       - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.js
// (Minified)   - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.min.js (4.0kb)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// Basic AJAX     - http://benalman.com/code/projects/jquery-bbq/examples/fragment-basic/
// Advanced AJAX  - http://benalman.com/code/projects/jquery-bbq/examples/fragment-advanced/
// jQuery UI Tabs - http://benalman.com/code/projects/jquery-bbq/examples/fragment-jquery-ui-tabs/
// Deparam        - http://benalman.com/code/projects/jquery-bbq/examples/deparam/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.7, Safari 3-4,
//                   Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-bbq/unit/
//
// About: Release History
//
// 1.2.1 - (2/17/2010) Actually fixed the stale window.location Safari bug from
//         <jQuery hashchange event> in BBQ, which was the main reason for the
//         previous release!
// 1.2   - (2/16/2010) Integrated <jQuery hashchange event> v1.2, which fixes a
//         Safari bug, the event can now be bound before DOM ready, and IE6/7
//         page should no longer scroll when the event is first bound. Also
//         added the <jQuery.param.fragment.noEscape> method, and reworked the
//         <hashchange event (BBQ)> internal "add" method to be compatible with
//         changes made to the jQuery 1.4.2 special events API.
// 1.1.1 - (1/22/2010) Integrated <jQuery hashchange event> v1.1, which fixes an
//         obscure IE8 EmulateIE7 meta tag compatibility mode bug.
// 1.1   - (1/9/2010) Broke out the jQuery BBQ event.special <hashchange event>
//         functionality into a separate plugin for users who want just the
//         basic event & back button support, without all the extra awesomeness
//         that BBQ provides. This plugin will be included as part of jQuery BBQ,
//         but also be available separately. See <jQuery hashchange event>
//         plugin for more information. Also added the <jQuery.bbq.removeState>
//         method and added additional <jQuery.deparam> examples.
// 1.0.3 - (12/2/2009) Fixed an issue in IE 6 where location.search and
//         location.hash would report incorrectly if the hash contained the ?
//         character. Also <jQuery.param.querystring> and <jQuery.param.fragment>
//         will no longer parse params out of a URL that doesn't contain ? or #,
//         respectively.
// 1.0.2 - (10/10/2009) Fixed an issue in IE 6/7 where the hidden IFRAME caused
//         a "This page contains both secure and nonsecure items." warning when
//         used on an https:// page.
// 1.0.1 - (10/7/2009) Fixed an issue in IE 8. Since both "IE7" and "IE8
//         Compatibility View" modes erroneously report that the browser
//         supports the native window.onhashchange event, a slightly more
//         robust test needed to be added.
// 1.0   - (10/2/2009) Initial release

(function($,window){
  '$:nomunge'; // Used by YUI compressor.

  // Some convenient shortcuts.
  var undefined,
    aps = Array.prototype.slice,
    decode = decodeURIComponent,

    // Method / object references.
    jq_param = $.param,
    jq_param_fragment,
    jq_deparam,
    jq_deparam_fragment,
    jq_bbq = $.bbq = $.bbq || {},
    jq_bbq_pushState,
    jq_bbq_getState,
    jq_elemUrlAttr,
    jq_event_special = $.event.special,

    // Reused strings.
    str_hashchange = 'hashchange',
    str_querystring = 'querystring',
    str_fragment = 'fragment',
    str_elemUrlAttr = 'elemUrlAttr',
    str_location = 'location',
    str_href = 'href',
    str_src = 'src',

    // Reused RegExp.
    re_trim_querystring = /^.*\?|#.*$/g,
    re_trim_fragment = /^.*\#/,
    re_no_escape,

    // Used by jQuery.elemUrlAttr.
    elemUrlAttr_cache = {};

  // A few commonly used bits, broken out to help reduce minified file size.

  function is_string( arg ) {
    return typeof arg === 'string';
  };

  // Why write the same function twice? Let's curry! Mmmm, curry..

  function curry( func ) {
    var args = aps.call( arguments, 1 );

    return function() {
      return func.apply( this, args.concat( aps.call( arguments ) ) );
    };
  };

  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };

  // Get location.search (or what you'd expect location.search to be) sans any
  // leading #. Thanks for making this necessary, IE6!
  function get_querystring( url ) {
    return url.replace( /(?:^[^?#]*\?([^#]*).*$)?.*/, '$1' );
  };

  // Section: Param (to string)
  //
  // Method: jQuery.param.querystring
  //
  // Retrieve the query string from a URL or if no arguments are passed, the
  // current window.location.
  //
  // Usage:
  //
  // > jQuery.param.querystring( [ url ] );
  //
  // Arguments:
  //
  //  url - (String) A URL containing query string params to be parsed. If url
  //    is not passed, the current window.location is used.
  //
  // Returns:
  //
  //  (String) The parsed query string, with any leading "?" removed.
  //

  // Method: jQuery.param.querystring (build url)
  //
  // Merge a URL, with or without pre-existing query string params, plus any
  // object, params string or URL containing query string params into a new URL.
  //
  // Usage:
  //
  // > jQuery.param.querystring( url, params [, merge_mode ] );
  //
  // Arguments:
  //
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing query string params to
  //    be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //
  //    * 0: params in the params argument will override any query string
  //         params in url.
  //    * 1: any query string params in url will override params in the params
  //         argument.
  //    * 2: params argument will completely replace any query string in url.
  //
  // Returns:
  //
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded query string in the format 'a=b&c=d&e=f'.

  // Method: jQuery.param.fragment
  //
  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the
  // current window.location.
  //
  // Usage:
  //
  // > jQuery.param.fragment( [ url ] );
  //
  // Arguments:
  //
  //  url - (String) A URL containing fragment (hash) params to be parsed. If
  //    url is not passed, the current window.location is used.
  //
  // Returns:
  //
  //  (String) The parsed fragment (hash) string, with any leading "#" removed.

  // Method: jQuery.param.fragment (build url)
  //
  // Merge a URL, with or without pre-existing fragment (hash) params, plus any
  // object, params string or URL containing fragment (hash) params into a new
  // URL.
  //
  // Usage:
  //
  // > jQuery.param.fragment( url, params [, merge_mode ] );
  //
  // Arguments:
  //
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing fragment (hash) params
  //    to be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //
  //    * 0: params in the params argument will override any fragment (hash)
  //         params in url.
  //    * 1: any fragment (hash) params in url will override params in the
  //         params argument.
  //    * 2: params argument will completely replace any query string in url.
  //
  // Returns:
  //
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded fragment (hash) in the format 'a=b&c=d&e=f'.

  function jq_param_sub( is_fragment, get_func, url, params, merge_mode ) {
    var result,
      qs,
      matches,
      url_params,
      hash;

    if ( params !== undefined ) {
      // Build URL by merging params into url string.

      // matches[1] = url part that precedes params, not including trailing ?/#
      // matches[2] = params, not including leading ?/#
      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''
      matches = url.match( is_fragment ? /^([^#]*)\#?(.*)$/ : /^([^#?]*)\??([^#]*)(#?.*)/ );

      // Get the hash if in 'querystring' mode, and it exists.
      hash = matches[3] || '';

      if ( merge_mode === 2 && is_string( params ) ) {
        // If merge_mode is 2 and params is a string, merge the fragment / query
        // string into the URL wholesale, without converting it into an object.
        qs = params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' );

      } else {
        // Convert relevant params in url to object.
        url_params = jq_deparam( matches[2] );

        params = is_string( params )

          // Convert passed params string into object.
          ? jq_deparam[ is_fragment ? str_fragment : str_querystring ]( params )

          // Passed params object.
          : params;

        qs = merge_mode === 2 ? params                              // passed params replace url params
          : merge_mode === 1  ? $.extend( {}, params, url_params )  // url params override passed params
          : $.extend( {}, url_params, params );                     // passed params override url params

        // Convert params object to a string.
        qs = jq_param( qs );

        // Unescape characters specified via $.param.noEscape. Since only hash-
        // history users have requested this feature, it's only enabled for
        // fragment-related params strings.
        if ( is_fragment ) {
          qs = qs.replace( re_no_escape, decode );
        }
      }

      // Build URL from the base url, querystring and hash. In 'querystring'
      // mode, ? is only added if a query string exists. In 'fragment' mode, #
      // is always added.
      result = matches[1] + ( is_fragment ? '#' : qs || !matches[1] ? '?' : '' ) + qs + hash;

    } else {
      // If URL was passed in, parse params from URL string, otherwise parse
      // params from window.location.
      result = get_func( url !== undefined ? url : window[ str_location ][ str_href ] );
    }

    return result;
  };

  jq_param[ str_querystring ]                  = curry( jq_param_sub, 0, get_querystring );
  jq_param[ str_fragment ] = jq_param_fragment = curry( jq_param_sub, 1, get_fragment );

  // Method: jQuery.param.fragment.noEscape
  //
  // Specify characters that will be left unescaped when fragments are created
  // or merged using <jQuery.param.fragment>, or when the fragment is modified
  // using <jQuery.bbq.pushState>. This option only applies to serialized data
  // object fragments, and not set-as-string fragments. Does not affect the
  // query string. Defaults to ",/" (comma, forward slash).
  //
  // Note that this is considered a purely aesthetic option, and will help to
  // create URLs that "look pretty" in the address bar or bookmarks, without
  // affecting functionality in any way. That being said, be careful to not
  // unescape characters that are used as delimiters or serve a special
  // purpose, such as the "#?&=+" (octothorpe, question mark, ampersand,
  // equals, plus) characters.
  //
  // Usage:
  //
  // > jQuery.param.fragment.noEscape( [ chars ] );
  //
  // Arguments:
  //
  //  chars - (String) The characters to not escape in the fragment. If
  //    unspecified, defaults to empty string (escape all characters).
  //
  // Returns:
  //
  //  Nothing.

  jq_param_fragment.noEscape = function( chars ) {
    chars = chars || '';
    var arr = $.map( chars.split(''), encodeURIComponent );
    re_no_escape = new RegExp( arr.join('|'), 'g' );
  };

  // A sensible default. These are the characters people seem to complain about
  // "uglifying up the URL" the most.
  jq_param_fragment.noEscape( ',/' );

  // Section: Deparam (from string)
  //
  // Method: jQuery.deparam
  //
  // Deserialize a params string into an object, optionally coercing numbers,
  // booleans, null and undefined values; this method is the counterpart to the
  // internal jQuery.param method.
  //
  // Usage:
  //
  // > jQuery.deparam( params [, coerce ] );
  //
  // Arguments:
  //
  //  params - (String) A params string to be parsed.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  //
  // Returns:
  //
  //  (Object) An object representing the deserialized params string.

  $.deparam = jq_deparam = function( params, coerce ) {
    var obj = {},
      coerce_types = { 'true': !0, 'false': !1, 'null': null };

    // Iterate over all name=value pairs.
    $.each( params.replace( /\+/g, ' ' ).split( '&' ), function(j,v){
      var param = v.split( '=' ),
        key = decode( param[0] ),
        val,
        cur = obj,
        i = 0,

        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
        // into its component parts.
        keys = key.split( '][' ),
        keys_last = keys.length - 1;

      // If the first keys part contains [ and the last ends with ], then []
      // are correctly balanced.
      if ( /\[/.test( keys[0] ) && /\]$/.test( keys[ keys_last ] ) ) {
        // Remove the trailing ] from the last keys part.
        keys[ keys_last ] = keys[ keys_last ].replace( /\]$/, '' );

        // Split first keys part into two parts on the [ and add them back onto
        // the beginning of the keys array.
        keys = keys.shift().split('[').concat( keys );

        keys_last = keys.length - 1;
      } else {
        // Basic 'foo' style key.
        keys_last = 0;
      }

      // Are we dealing with a name=value pair, or just a name?
      if ( param.length === 2 ) {
        val = decode( param[1] );

        // Coerce values.
        if ( coerce ) {
          val = val && !isNaN(val)            ? +val              // number
            : val === 'undefined'             ? undefined         // undefined
            : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
            : val;                                                // string
        }

        if ( keys_last ) {
          // Complex key, build deep object structure based on a few rules:
          // * The 'cur' pointer starts at the object top-level.
          // * [] = array push (n is set to array length), [n] = array if n is
          //   numeric, otherwise object.
          // * If at the last keys part, set the value.
          // * For each keys part, if the current level is undefined create an
          //   object or array based on the type of the next keys part.
          // * Move the 'cur' pointer to the next level.
          // * Rinse & repeat.
          for ( ; i <= keys_last; i++ ) {
            key = keys[i] === '' ? cur.length : keys[i];
            cur = cur[key] = i < keys_last
              ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )
              : val;
          }

        } else {
          // Simple key, even simpler rules, since only scalars and shallow
          // arrays are allowed.

          if ( $.isArray( obj[key] ) ) {
            // val is already an array, so push on the next value.
            obj[key].push( val );

          } else if ( obj[key] !== undefined ) {
            // val isn't an array, but since a second value has been specified,
            // convert val into an array.
            obj[key] = [ obj[key], val ];

          } else {
            // val is a scalar.
            obj[key] = val;
          }
        }

      } else if ( key ) {
        // No value was defined, so set something meaningful.
        obj[key] = coerce
          ? undefined
          : '';
      }
    });

    return obj;
  };

  // Method: jQuery.deparam.querystring
  //
  // Parse the query string from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  //
  // Usage:
  //
  // > jQuery.deparam.querystring( [ url ] [, coerce ] );
  //
  // Arguments:
  //
  //  url - (String) An optional params string or URL containing query string
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  //
  // Returns:
  //
  //  (Object) An object representing the deserialized params string.

  // Method: jQuery.deparam.fragment
  //
  // Parse the fragment (hash) from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  //
  // Usage:
  //
  // > jQuery.deparam.fragment( [ url ] [, coerce ] );
  //
  // Arguments:
  //
  //  url - (String) An optional params string or URL containing fragment (hash)
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  //
  // Returns:
  //
  //  (Object) An object representing the deserialized params string.

  function jq_deparam_sub( is_fragment, url_or_params, coerce ) {
    if ( url_or_params === undefined || typeof url_or_params === 'boolean' ) {
      // url_or_params not specified.
      coerce = url_or_params;
      url_or_params = jq_param[ is_fragment ? str_fragment : str_querystring ]();
    } else {
      url_or_params = is_string( url_or_params )
        ? url_or_params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' )
        : url_or_params;
    }

    return jq_deparam( url_or_params, coerce );
  };

  jq_deparam[ str_querystring ]                    = curry( jq_deparam_sub, 0 );
  jq_deparam[ str_fragment ] = jq_deparam_fragment = curry( jq_deparam_sub, 1 );

  // Section: Element manipulation
  //
  // Method: jQuery.elemUrlAttr
  //
  // Get the internal "Default URL attribute per tag" list, or augment the list
  // with additional tag-attribute pairs, in case the defaults are insufficient.
  //
  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list
  // is used to determine which attribute contains the URL to be modified, if
  // an "attr" param is not specified.
  //
  // Default Tag-Attribute List:
  //
  //  a      - href
  //  base   - href
  //  iframe - src
  //  img    - src
  //  input  - src
  //  form   - action
  //  link   - href
  //  script - src
  //
  // Usage:
  //
  // > jQuery.elemUrlAttr( [ tag_attr ] );
  //
  // Arguments:
  //
  //  tag_attr - (Object) An object containing a list of tag names and their
  //    associated default attribute names in the format { tag: 'attr', ... } to
  //    be merged into the internal tag-attribute list.
  //
  // Returns:
  //
  //  (Object) An object containing all stored tag-attribute values.

  // Only define function and set defaults if function doesn't already exist, as
  // the urlInternal plugin will provide this method as well.
  $[ str_elemUrlAttr ] || ($[ str_elemUrlAttr ] = function( obj ) {
    return $.extend( elemUrlAttr_cache, obj );
  })({
    a: str_href,
    base: str_href,
    iframe: str_src,
    img: str_src,
    input: str_src,
    form: 'action',
    link: str_href,
    script: str_src
  });

  jq_elemUrlAttr = $[ str_elemUrlAttr ];

  // Method: jQuery.fn.querystring
  //
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing query string params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery
  // collection.
  //
  // Usage:
  //
  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );
  //
  // Arguments:
  //
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing query string params, or params string
  //    to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any query string in attr
  //         URL.
  //
  // Returns:
  //
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.

  // Method: jQuery.fn.fragment
  //
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing fragment/hash params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery
  // collection.
  //
  // Usage:
  //
  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );
  //
  // Arguments:
  //
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing fragment (hash) params, or params
  //    string to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any fragment (hash) in attr
  //         URL.
  //
  // Returns:
  //
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.

  function jq_fn_sub( mode, force_attr, params, merge_mode ) {
    if ( !is_string( params ) && typeof params !== 'object' ) {
      // force_attr not specified.
      merge_mode = params;
      params = force_attr;
      force_attr = undefined;
    }

    return this.each(function(){
      var that = $(this),

        // Get attribute specified, or default specified via $.elemUrlAttr.
        attr = force_attr || jq_elemUrlAttr()[ ( this.nodeName || '' ).toLowerCase() ] || '',

        // Get URL value.
        url = attr && that.attr( attr ) || '';

      // Update attribute with new URL.
      that.attr( attr, jq_param[ mode ]( url, params, merge_mode ) );
    });

  };

  $.fn[ str_querystring ] = curry( jq_fn_sub, str_querystring );
  $.fn[ str_fragment ]    = curry( jq_fn_sub, str_fragment );

  // Section: History, hashchange event
  //
  // Method: jQuery.bbq.pushState
  //
  // Adds a 'state' into the browser history at the current position, setting
  // location.hash and triggering any bound <hashchange event> callbacks
  // (provided the new state is different than the previous state).
  //
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  //
  // Usage:
  //
  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );
  //
  // Arguments:
  //
  //  params - (String) A serialized params string or a hash string beginning
  //    with # to merge into location.hash.
  //  params - (Object) A params object to merge into location.hash.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified (unless a hash string beginning with # is specified, in which
  //    case merge behavior defaults to 2), and is as-follows:
  //
  //    * 0: params in the params argument will override any params in the
  //         current state.
  //    * 1: any params in the current state will override params in the params
  //         argument.
  //    * 2: params argument will completely replace current state.
  //
  // Returns:
  //
  //  Nothing.
  //
  // Additional Notes:
  //
  //  * Setting an empty state may cause the browser to scroll.
  //  * Unlike the fragment and querystring methods, if a hash string beginning
  //    with # is specified as the params agrument, merge_mode defaults to 2.

  jq_bbq.pushState = jq_bbq_pushState = function( params, merge_mode ) {
    if ( is_string( params ) && /^#/.test( params ) && merge_mode === undefined ) {
      // Params string begins with # and merge_mode not specified, so completely
      // overwrite window.location.hash.
      merge_mode = 2;
    }

    var has_args = params !== undefined,
      // Merge params into window.location using $.param.fragment.
      url = jq_param_fragment( window[ str_location ][ str_href ],
        has_args ? params : {}, has_args ? merge_mode : 2 );

    // Set new window.location.href. If hash is empty, use just # to prevent
    // browser from reloading the page. Note that Safari 3 & Chrome barf on
    // location.hash = '#'.
    window[ str_location ][ str_href ] = url + ( /#/.test( url ) ? '' : '#' );
  };

  // Method: jQuery.bbq.getState
  //
  // Retrieves the current 'state' from the browser history, parsing
  // location.hash for a specific key or returning an object containing the
  // entire state, optionally coercing numbers, booleans, null and undefined
  // values.
  //
  // Usage:
  //
  // > jQuery.bbq.getState( [ key ] [, coerce ] );
  //
  // Arguments:
  //
  //  key - (String) An optional state key for which to return a value.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false.
  //
  // Returns:
  //
  //  (Anything) If key is passed, returns the value corresponding with that key
  //    in the location.hash 'state', or undefined. If not, an object
  //    representing the entire 'state' is returned.

  jq_bbq.getState = jq_bbq_getState = function( key, coerce ) {
    return key === undefined || typeof key === 'boolean'
      ? jq_deparam_fragment( key ) // 'key' really means 'coerce' here
      : jq_deparam_fragment( coerce )[ key ];
  };

  // Method: jQuery.bbq.removeState
  //
  // Remove one or more keys from the current browser history 'state', creating
  // a new state, setting location.hash and triggering any bound
  // <hashchange event> callbacks (provided the new state is different than
  // the previous state).
  //
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  //
  // Usage:
  //
  // > jQuery.bbq.removeState( [ key [, key ... ] ] );
  //
  // Arguments:
  //
  //  key - (String) One or more key values to remove from the current state,
  //    passed as individual arguments.
  //  key - (Array) A single array argument that contains a list of key values
  //    to remove from the current state.
  //
  // Returns:
  //
  //  Nothing.
  //
  // Additional Notes:
  //
  //  * Setting an empty state may cause the browser to scroll.

  jq_bbq.removeState = function( arr ) {
    var state = {};

    // If one or more arguments is passed..
    if ( arr !== undefined ) {

      // Get the current state.
      state = jq_bbq_getState();

      // For each passed key, delete the corresponding property from the current
      // state.
      $.each( $.isArray( arr ) ? arr : arguments, function(i,v){
        delete state[ v ];
      });
    }

    // Set the state, completely overriding any existing state.
    jq_bbq_pushState( state, 2 );
  };

  // Event: hashchange event (BBQ)
  //
  // Usage in jQuery 1.4 and newer:
  //
  // In jQuery 1.4 and newer, the event object passed into any hashchange event
  // callback is augmented with a copy of the location.hash fragment at the time
  // the event was triggered as its event.fragment property. In addition, the
  // event.getState method operates on this property (instead of location.hash)
  // which allows this fragment-as-a-state to be referenced later, even after
  // window.location may have changed.
  //
  // Note that event.fragment and event.getState are not defined according to
  // W3C (or any other) specification, but will still be available whether or
  // not the hashchange event exists natively in the browser, because of the
  // utility they provide.
  //
  // The event.fragment property contains the output of <jQuery.param.fragment>
  // and the event.getState method is equivalent to the <jQuery.bbq.getState>
  // method.
  //
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = event.fragment,
  // >     param_obj = event.getState(),
  // >     param_val = event.getState( 'param_name' ),
  // >     param_val_coerced = event.getState( 'param_name', true );
  // >   ...
  // > });
  //
  // Usage in jQuery 1.3.2:
  //
  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,
  // so the fragment state isn't bound to the event object and must instead be
  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.
  //
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = $.param.fragment(),
  // >     param_obj = $.bbq.getState(),
  // >     param_val = $.bbq.getState( 'param_name' ),
  // >     param_val_coerced = $.bbq.getState( 'param_name', true );
  // >   ...
  // > });
  //
  // Additional Notes:
  //
  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is
  //   required to enable the augmented event object in jQuery 1.4.2 and newer.
  // * See <jQuery hashchange event> for more detailed information.

  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {

    // Augmenting the event object with the .fragment property and .getState
    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will
    // work, but the event won't be augmented)
    add: function( handleObj ) {
      var old_handler;

      function new_handler(e) {
        // e.fragment is set to the value of location.hash (with any leading #
        // removed) at the time the event is triggered.
        var hash = e[ str_fragment ] = jq_param_fragment();

        // e.getState() works just like $.bbq.getState(), but uses the
        // e.fragment property stored on the event object.
        e.getState = function( key, coerce ) {
          return key === undefined || typeof key === 'boolean'
            ? jq_deparam( hash, key ) // 'key' really means 'coerce' here
            : jq_deparam( hash, coerce )[ key ];
        };

        old_handler.apply( this, arguments );
      };

      // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+
      if ( $.isFunction( handleObj ) ) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }

  });

})(jQuery,this);

/*!
 * jQuery hashchange event - v1.2 - 2/11/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.2, Last updated: 2/11/2010*
//
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (1.1kb)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// This working example, complete with fully commented code, illustrate one way
// in which this plugin can be used.
//
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.7, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
//
// About: Known issues
//
// While this jQuery hashchange event implementation is quite stable and robust,
// there are a few unfortunate browser bugs surrounding expected hashchange
// event-based behaviors, independent of any JavaScript window.onhashchange
// abstraction. See the following examples for more information:
//
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
//
// About: Release History
//
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.

  // Method / object references.
  var fake_onhashchange,
    jq_event_special = $.event.special,

    // Reused strings.
    str_location = 'location',
    str_hashchange = 'hashchange',
    str_href = 'href',

    // IE6/7 specifically need some special love when it comes to back-button
    // support, so let's do a little browser sniffing..
    browser = $.browser,
    mode = document.documentMode,
    is_old_ie = browser.msie && ( mode === undefined || mode < 8 ),

    // Does the browser support window.onhashchange? Test for IE version, since
    // IE8 incorrectly reports this when in "IE7" or "IE8 Compatibility View"!
    supports_onhashchange = 'on' + str_hashchange in window && !is_old_ie;

  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || window[ str_location ][ str_href ];
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };

  // Property: jQuery.hashchangeDelay
  //
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 100.

  $[ str_hashchange + 'Delay' ] = 100;

  // Event: hashchange event
  //
  // Fired when location.hash changes. In browsers that support it, the native
  // window.onhashchange event is used (IE8, FF3.6), otherwise a polling loop is
  // initialized, running every <jQuery.hashchangeDelay> milliseconds to see if
  // the hash has changed. In IE 6 and 7, a hidden Iframe is created to allow
  // the back button and hash-based history to work.
  //
  // Usage:
  //
  // > $(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  //
  // Additional Notes:
  //
  // * The polling loop and Iframe are not created until at least one callback
  //   is actually bound to 'hashchange'.
  // * If you need the bound callback(s) to execute immediately, in cases where
  //   the page 'state' exists on page load (via bookmark or page refresh, for
  //   example) use $(window).trigger( 'hashchange' );
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a $(document).ready() callback.

  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {

    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }

      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },

    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }

      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }

  });

  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      iframe,
      set_history,
      get_history;

    // Initialize. In IE 6/7, creates a hidden Iframe for history handling.
    function init(){
      // Most browsers don't need special methods here..
      set_history = get_history = function(val){ return val; };

      // But IE6/7 do!
      if ( is_old_ie ) {

        // Create hidden Iframe after the end of the body to prevent initial
        // page load from scrolling unnecessarily.
        iframe = $('<iframe src="javascript:0"/>').hide().insertAfter( 'body' )[0].contentWindow;

        // Get history by looking at the hidden Iframe's location.hash.
        get_history = function() {
          return get_fragment( iframe.document[ str_location ][ str_href ] );
        };

        // Set a new history item by opening and then closing the Iframe
        // document, *then* setting its location.hash.
        set_history = function( hash, history_hash ) {
          if ( hash !== history_hash ) {
            var doc = iframe.document;
            doc.open().close();
            doc[ str_location ].hash = '#' + hash;
          }
        };

        // Set initial history.
        set_history( get_fragment() );
      }
    };

    // Start the polling loop.
    self.start = function() {
      // Polling loop is already running!
      if ( timeout_id ) { return; }

      // Remember the initial hash so it doesn't get triggered immediately.
      var last_hash = get_fragment();

      // Initialize if not yet initialized.
      set_history || init();

      // This polling loop checks every $.hashchangeDelay milliseconds to see if
      // location.hash has changed, and triggers the 'hashchange' event on
      // window when necessary.
      (function loopy(){
        var hash = get_fragment(),
          history_hash = get_history( last_hash );

        if ( hash !== last_hash ) {
          set_history( last_hash = hash, history_hash );

          $(window).trigger( str_hashchange );

        } else if ( history_hash !== last_hash ) {
          window[ str_location ][ str_href ] = window[ str_location ][ str_href ].replace( /#.*/, '' ) + '#' + history_hash;
        }

        timeout_id = setTimeout( loopy, $[ str_hashchange + 'Delay' ] );
      })();
    };

    // Stop the polling loop, but only if an IE6/7 Iframe wasn't created. In
    // that case, even if there are no longer any bound event handlers, the
    // polling loop is still necessary for back/next to work at all!
    self.stop = function() {
      if ( !iframe ) {
        timeout_id && clearTimeout( timeout_id );
        timeout_id = 0;
      }
    };

    return self;
  })();

})(jQuery,this);


// assets/js/bundle/third_party/jquery/fancybox.js
goog.provide("optly.jquery.fancybox");

/*!
 * fancyBox - jQuery Plugin
 * version: 2.0.6 (16/04/2012)
 * @requires jQuery v1.6 or later
 *
 * Examples at http://fancyapps.com/fancybox/
 * License: www.fancyapps.com/fancybox/#license
 *
 * Copyright 2012 Janis Skarnelis - janis@fancyapps.com
 *
 */

(function (window, document, $, undefined) {
  "use strict";

  var W = $(window),
    D = $(document),
    F = $.fancybox = function () {
      F.open.apply( this, arguments );
    },
    didResize = false,
    resizeTimer = null,
    isTouch   = document.createTouch !== undefined,
    isString  = function(str) {
      return $.type(str) === "string";
    },
    isPercentage = function(str) {
      return isString(str) && str.indexOf('%') > 0;
    },
    getValue = function(value, dim) {
      if (dim && isPercentage(value)) {
        value = F.getViewport()[ dim ] / 100 * parseInt(value, 10);
      }

      return Math.round(value) + 'px';
    };

  $.extend(F, {
    // The current version of fancyBox
    version: '2.0.5',

    defaults: {
      padding: 15,
      margin: 20,

      width: 800,
      height: 600,
      minWidth: 100,
      minHeight: 100,
      maxWidth: 9999,
      maxHeight: 9999,

      autoSize: true,
      autoResize: !isTouch,
      autoCenter : !isTouch,
      fitToView: true,
      aspectRatio: false,
      topRatio: 0.5,

      fixed: false,
      scrolling: 'auto', // 'auto', 'yes' or 'no'
      wrapCSS: '',

      arrows: true,
      closeBtn: true,
      closeClick: false,
      nextClick : false,
      mouseWheel: true,
      autoPlay: false,
      playSpeed: 3000,
      preload : 3,

      modal: false,
      loop: true,
      ajax: { dataType: 'html', headers: { 'X-fancyBox': true } },
      keys: {
        next: [13, 32, 34, 39, 40], // enter, space, page down, right arrow, down arrow
        prev: [8, 33, 37, 38], // backspace, page up, left arrow, up arrow
        close: [27] // escape key
      },

      // Override some properties
      index: 0,
      type: null,
      href: null,
      content: null,
      title: null,

      // HTML templates
      tpl: {
        wrap: '<div class="fancybox-wrap"><div class="fancybox-skin"><div class="fancybox-outer"><div class="fancybox-inner"></div></div></div></div>',
        image: '<img class="fancybox-image" src="{href}" alt="" />',
        iframe: '<iframe class="fancybox-iframe" name="fancybox-frame{rnd}" frameborder="0" hspace="0"' + ($.browser.msie ? ' allowtransparency="true"' : '') + '></iframe>',
        swf: '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="100%" height="100%"><param name="wmode" value="transparent" /><param name="allowfullscreen" value="true" /><param name="allowscriptaccess" value="always" /><param name="movie" value="{href}" /><embed src="{href}" type="application/x-shockwave-flash" allowfullscreen="true" allowscriptaccess="always" width="100%" height="100%" wmode="transparent"></embed></object>',
        error: '<p class="fancybox-error">The requested content cannot be loaded.<br/>Please try again later.</p>',
        closeBtn: '<div title="Close" class="fancybox-item fancybox-close"></div>',
        next: '<a title="Next" class="fancybox-nav fancybox-next"><span></span></a>',
        prev: '<a title="Previous" class="fancybox-nav fancybox-prev"><span></span></a>'
      },

      // Properties for each animation type
      // Opening fancyBox
      openEffect: 'fade', // 'elastic', 'fade' or 'none'
      openSpeed: 300,
      openEasing: 'swing',
      openOpacity: true,
      openMethod: 'zoomIn',

      // Closing fancyBox
      closeEffect: 'fade', // 'elastic', 'fade' or 'none'
      closeSpeed: 300,
      closeEasing: 'swing',
      closeOpacity: true,
      closeMethod: 'zoomOut',

      // Changing next gallery item
      nextEffect: 'elastic', // 'elastic', 'fade' or 'none'
      nextSpeed: 300,
      nextEasing: 'swing',
      nextMethod: 'changeIn',

      // Changing previous gallery item
      prevEffect: 'elastic', // 'elastic', 'fade' or 'none'
      prevSpeed: 300,
      prevEasing: 'swing',
      prevMethod: 'changeOut',

      // Enabled helpers
      helpers: {
        overlay: {
          speedIn: 0,
          speedOut: 300,
          opacity: 0.8,
          css: {
            cursor: 'pointer'
          },
          closeClick: true
        },
        title: {
          type: 'float' // 'float', 'inside', 'outside' or 'over'
        }
      },

      // Callbacks
      onCancel: $.noop, // If canceling
      beforeLoad: $.noop, // Before loading
      afterLoad: $.noop, // After loading
      beforeShow: $.noop, // Before changing in current item
      afterShow: $.noop, // After opening
      beforeClose: $.noop, // Before closing
      afterClose: $.noop // After closing
    },

    //Current state
    group: {}, // Selected group
    opts: {}, // Group options
    coming: null, // Element being loaded
    current: null, // Currently loaded element
    isOpen: false, // Is currently open
    isOpened: false, // Have been fully opened at least once
    wrap: null,
    skin: null,
    outer: null,
    inner: null,

    player: {
      timer: null,
      isActive: false
    },

    // Loaders
    ajaxLoad: null,
    imgPreload: null,

    // Some collections
    transitions: {},
    helpers: {},

    /*
     *  Static methods
     */

    open: function (group, opts) {
      //Kill existing instances
      F.close(true);

      //Normalize group
      if (group && !$.isArray(group)) {
        group = group instanceof $ ? $(group).get() : [group];
      }

      F.isActive = true;

      //Extend the defaults
      F.opts = $.extend(true, {}, F.defaults, opts);

      //All options are merged recursive except keys
      if ($.isPlainObject(opts) && opts.keys !== undefined) {
        F.opts.keys = opts.keys ? $.extend({}, F.defaults.keys, opts.keys) : false;
      }

      F.group = group;

      F._start(F.opts.index || 0);
    },

    cancel: function () {
      if (F.coming && false === F.trigger('onCancel')) {
        return;
      }

      F.coming = null;

      F.hideLoading();

      if (F.ajaxLoad) {
        F.ajaxLoad.abort();
      }

      F.ajaxLoad = null;

      if (F.imgPreload) {
        F.imgPreload.onload = F.imgPreload.onabort = F.imgPreload.onerror = null;
      }
    },

    close: function (a) {
      F.cancel();

      if (!F.current || false === F.trigger('beforeClose')) {
        return;
      }

      F.unbindEvents();

      //If forced or is still opening then remove immediately
      if (!F.isOpen || (a && a[0] === true)) {
        $('.fancybox-wrap').stop().trigger('onReset').remove();

        F._afterZoomOut();

      } else {
        F.isOpen = F.isOpened = false;

        $('.fancybox-item, .fancybox-nav').remove();

        F.wrap.stop(true).removeClass('fancybox-opened');
        F.inner.css('overflow', 'hidden');

        F.transitions[F.current.closeMethod]();
      }
    },

    // Start/stop slideshow
    play: function (a) {
      var clear = function () {
          clearTimeout(F.player.timer);
        },
        set = function () {
          clear();

          if (F.current && F.player.isActive) {
            F.player.timer = setTimeout(F.next, F.current.playSpeed);
          }
        },
        stop = function () {
          clear();

          $('body').unbind('.player');

          F.player.isActive = false;

          F.trigger('onPlayEnd');
        },
        start = function () {
          if (F.current && (F.current.loop || F.current.index < F.group.length - 1)) {
            F.player.isActive = true;

            $('body').bind({
              'afterShow.player onUpdate.player': set,
              'onCancel.player beforeClose.player': stop,
              'beforeLoad.player': clear
            });

            set();

            F.trigger('onPlayStart');
          }
        };

      if (F.player.isActive || (a && a[0] === false)) {
        stop();
      } else {
        start();
      }
    },

    next: function () {
      if (F.current) {
        F.jumpto(F.current.index + 1);
      }
    },

    prev: function () {
      if (F.current) {
        F.jumpto(F.current.index - 1);
      }
    },

    jumpto: function (index) {
      if (!F.current) {
        return;
      }

      index = parseInt(index, 10);

      if (F.group.length > 1 && F.current.loop) {
        if (index >= F.group.length) {
          index = 0;

        } else if (index < 0) {
          index = F.group.length - 1;
        }
      }

      if (F.group[index] !== undefined) {
        F.cancel();

        F._start(index);
      }
    },

    reposition: function (e, onlyAbsolute) {
      var pos;

      if (F.isOpen) {
        pos = F._getPosition(onlyAbsolute);

        if (e && e.type === 'scroll') {
          delete pos.position;

          F.wrap.stop(true, true).animate(pos, 200);

        } else {
          F.wrap.css(pos);
        }
      }
    },

    update: function (e) {
      if (!F.isOpen) {
        return;
      }

      // Run this code after a delay for better performance
      if (!didResize) {
        resizeTimer = setTimeout(function () {
          var current = F.current, anyway = !e || (e && e.type === 'orientationchange');

          if (didResize) {
            didResize = false;

            if (!current) {
              return;
            }

            if ((!e || e.type !== 'scroll') || anyway) {
              if (current.autoSize && current.type !== 'iframe') {
                F.inner.height('auto');
                current.height = F.inner.height();
              }

              if (current.autoResize || anyway) {
                F._setDimension();
              }

              if (current.canGrow && current.type !== 'iframe') {
                F.inner.height('auto');
              }
            }

            if (current.autoCenter || anyway) {
              F.reposition(e);
            }

            F.trigger('onUpdate');
          }
        }, 200);
      }

      didResize = true;
    },

    toggle: function () {
      if (F.isOpen) {
        F.current.fitToView = !F.current.fitToView;

        F.update();
      }
    },

    hideLoading: function () {
      D.unbind('keypress.fb');

      $('#fancybox-loading').remove();
    },

    showLoading: function () {
      F.hideLoading();

      //If user will press the escape-button, the request will be canceled
      D.bind('keypress.fb', function(e) {
        if (e.keyCode === 27) {
          e.preventDefault();
          F.cancel();
        }
      });

      $('<div id="fancybox-loading"><div></div></div>').click(F.cancel).appendTo('body');
    },

    getViewport: function () {
      // See http://bugs.jquery.com/ticket/6724
      return {
        x: W.scrollLeft(),
        y: W.scrollTop(),
        w: isTouch && window.innerWidth ? window.innerWidth : W.width(),
        h: isTouch && window.innerHeight ? window.innerHeight : W.height()
      };
    },

    // Unbind the keyboard / clicking actions
    unbindEvents: function () {
      if (F.wrap) {
        F.wrap.unbind('.fb');
      }

      D.unbind('.fb');
      W.unbind('.fb');
    },

    bindEvents: function () {
      var current = F.current,
        keys = current.keys;

      if (!current) {
        return;
      }

      W.bind('resize.fb orientationchange.fb' + (current.autoCenter && !current.fixed ? ' scroll.fb' : ''), F.update);

      if (keys) {
        D.bind('keydown.fb', function (e) {
          var code, target = e.target || e.srcElement;

          // Ignore key combinations and key events within form elements
          if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey && !(target && (target.type || $(target).is('[contenteditable]')))) {
            code = e.keyCode;

            if ($.inArray(code, keys.close) > -1) {
              F.close();
              e.preventDefault();

            } else if ($.inArray(code, keys.next) > -1) {
              F.next();
              e.preventDefault();

            } else if ($.inArray(code, keys.prev) > -1) {
              F.prev();
              e.preventDefault();
            }
          }
        });
      }

      if ($.fn.mousewheel && current.mouseWheel && F.group.length > 1) {
        F.wrap.bind('mousewheel.fb', function (e, delta) {
          var target = e.target || null;

          if (delta !== 0 && (!target || target.clientHeight === 0 || (target.scrollHeight === target.clientHeight && target.scrollWidth === target.clientWidth))) {
            e.preventDefault();

            F[delta > 0 ? 'prev' : 'next']();
          }
        });
      }
    },

    trigger: function (event, o) {
      var ret, obj = o || F[ $.inArray(event, ['onCancel', 'beforeLoad', 'afterLoad']) > -1 ? 'coming' : 'current' ];

      if (!obj) {
        return;
      }

      if ($.isFunction( obj[event] )) {
        ret = obj[event].apply(obj, Array.prototype.slice.call(arguments, 1));
      }

      if (ret === false) {
        return false;
      }

      if (obj.helpers) {
        $.each(obj.helpers, function (helper, opts) {
          if (opts && $.isPlainObject(F.helpers[helper]) && $.isFunction(F.helpers[helper][event])) {
            F.helpers[helper][event](opts, obj);
          }
        });
      }

      $.event.trigger(event + '.fb');
    },

    isImage: function (str) {
      return isString(str) && str.match(/\.(jpe?g|gif|png|bmp)((\?|#).*)?$/i);
    },

    isSWF: function (str) {
      return isString(str) && str.match(/\.(swf)((\?|#).*)?$/i);
    },

    _start: function (index) {
      var coming = {},
        element = F.group[index] || null,
        isDom,
        href,
        type,
        rez,
        hrefParts;

      if (element && (element.nodeType || element instanceof $)) {
        isDom = true;

        if ($.metadata) {
          coming = $(element).metadata();
        }
      }

      coming = $.extend(true, {}, F.opts, {index : index, element : element}, ($.isPlainObject(element) ? element : coming));

      // Re-check overridable options
      $.each(['href', 'title', 'content', 'type'], function(i,v) {
        coming[v] = F.opts[ v ] || (isDom && $(element).attr( v )) || coming[ v ] || null;
      });

      // Convert margin property to array - top, right, bottom, left
      if (typeof coming.margin === 'number') {
        coming.margin = [coming.margin, coming.margin, coming.margin, coming.margin];
      }

      // 'modal' propery is just a shortcut
      if (coming.modal) {
        $.extend(true, coming, {
          closeBtn : false,
          closeClick: false,
          nextClick : false,
          arrows : false,
          mouseWheel : false,
          keys : null,
          helpers: {
            overlay : {
              css: {
                cursor : 'auto'
              },
              closeClick : false
            }
          }
        });
      }

      //Give a chance for callback or helpers to update coming item (type, title, etc)
      F.coming = coming;

      if (false === F.trigger('beforeLoad')) {
        F.coming = null;
        return;
      }

      type = coming.type;
      href = coming.href || element;

      ///Check if content type is set, if not, try to get
      if (!type) {
        if (isDom) {
          type = $(element).data('fancybox-type');

          if (!type) {
            rez = element.className.match(/fancybox\.(\w+)/);
            type = rez ? rez[1] : null;
          }
        }

        if (!type && isString(href)) {
          if (F.isImage(href)) {
            type = 'image';

          } else if (F.isSWF(href)) {
            type = 'swf';

          } else if (href.match(/^#/)) {
            type = 'inline';
          }
        }

        // ...if not - display element itself
        if (!type) {
          type = isDom ? 'inline' : 'html';
        }

        coming.type = type;
      }

      // Check before try to load; 'inline' and 'html' types need content, others - href
      if (type === 'inline' || type === 'html') {
        if (!coming.content) {
          if (type === 'inline') {
            coming.content = $( isString(href) ? href.replace(/.*(?=#[^\s]+$)/, '') : href ); //strip for ie7

          } else {
            coming.content = element;
          }
        }

        if (!coming.content || !coming.content.length) {
          type = null;
        }

      } else if (!href) {
        type = null;
      }

      /*
       * Add reference to the group, so it`s possible to access from callbacks, example:
       * afterLoad : function() {
       *     this.title = 'Image ' + (this.index + 1) + ' of ' + this.group.length + (this.title ? ' - ' + this.title : '');
       * }
       */

      if (type === 'ajax' && isString(href)) {
        hrefParts = href.split(/\s+/, 2);

        href = hrefParts.shift();
        coming.selector = hrefParts.shift();
      }

      coming.href  = href;
      coming.group = F.group;
      coming.isDom = isDom;

      switch (type) {
        case 'image':
          F._loadImage();
          break;

        case 'ajax':
          F._loadAjax();
          break;

        case 'inline':
        case 'iframe':
        case 'swf':
        case 'html':
          F._afterLoad();
          break;

        default:
          F._error( 'type' );
      }
    },

    _error: function ( type ) {
      F.hideLoading();

      $.extend(F.coming, {
        type      : 'html',
        autoSize  : true,
        minWidth  : 0,
        minHeight : 0,
        padding   : 15,
        hasError  : type,
        content   : F.coming.tpl.error
      });

      F._afterLoad();
    },

    _loadImage: function () {
      // Reset preload image so it is later possible to check "complete" property
      var img = F.imgPreload = new Image();

      img.onload = function () {
        this.onload = this.onerror = null;

        F.coming.width  = this.width;
        F.coming.height = this.height;

        F._afterLoad();
      };

      img.onerror = function () {
        this.onload = this.onerror = null;

        F._error( 'image' );
      };

      img.src = F.coming.href;

      if (img.complete === undefined || !img.complete) {
        F.showLoading();
      }
    },

    _loadAjax: function () {
      F.showLoading();

      F.ajaxLoad = $.ajax($.extend({}, F.coming.ajax, {
        url: F.coming.href,
        error: function (jqXHR, textStatus) {
          if (F.coming && textStatus !== 'abort') {
            F._error( 'ajax', jqXHR );

          } else {
            F.hideLoading();
          }
        },
        success: function (data, textStatus) {
          if (textStatus === 'success') {
            F.coming.content = data;

            F._afterLoad();
          }
        }
      }));
    },

    _preloadImages: function() {
      var group = F.group,
        current = F.current,
        len = group.length,
        item,
        href,
        i,
        cnt = Math.min(current.preload, len - 1);

      if (!current.preload || group.length < 2) {
        return;
      }

      for (i = 1; i <= cnt; i += 1) {
        item = group[ (current.index + i ) % len ];
        href = item.href || $( item ).attr('href') || item;

        if (item.type === 'image' || F.isImage(href)) {
          new Image().src = href;
        }
      }
    },

    _afterLoad: function () {
      F.hideLoading();

      if (!F.coming || false === F.trigger('afterLoad', F.current)) {
        F.coming = false;

        return;
      }

      if (F.isOpened) {
        $('.fancybox-item, .fancybox-nav').remove();

        F.wrap.stop(true).removeClass('fancybox-opened');
        F.inner.css('overflow', 'hidden');

        F.transitions[F.current.prevMethod]();

      } else {
        $('.fancybox-wrap').stop().trigger('onReset').remove();

        F.trigger('afterClose');
      }

      F.unbindEvents();

      F.isOpen    = false;
      F.current   = F.coming;

      //Build the neccessary markup
      F.wrap  = $(F.current.tpl.wrap).addClass('fancybox-' + (isTouch ? 'mobile' : 'desktop') + ' fancybox-type-' + F.current.type + ' fancybox-tmp ' + F.current.wrapCSS).appendTo('body');
      F.skin  = $('.fancybox-skin', F.wrap).css('padding', getValue(F.current.padding));
      F.outer = $('.fancybox-outer', F.wrap);
      F.inner = $('.fancybox-inner', F.wrap);

      F._setContent();
    },

    _setContent: function () {
      var current = F.current,
        content = current.content,
        type    = current.type,
        minWidth    = current.minWidth,
        minHeight   = current.minHeight,
        maxWidth    = current.maxWidth,
        maxHeight   = current.maxHeight,
        loadingBay;

      switch (type) {
        case 'inline':
        case 'ajax':
        case 'html':
          if (current.selector) {
            content = $('<div>').html(content).find(current.selector);

          } else if (content instanceof $) {
            if (content.parent().hasClass('fancybox-inner')) {
              content.parents('.fancybox-wrap').unbind('onReset');
            }

            content = content.show().detach();

            $(F.wrap).bind('onReset', function () {
              content.appendTo('body').hide();
            });
          }

          if (current.autoSize) {
            loadingBay = $('<div class="fancybox-wrap ' + F.current.wrapCSS + ' fancybox-tmp"></div>')
              .appendTo('body')
              .css({
                minWidth    : getValue(minWidth, 'w'),
                minHeight   : getValue(minHeight, 'h'),
                maxWidth    : getValue(maxWidth, 'w'),
                maxHeight   : getValue(maxHeight, 'h')
              })
              .append(content);

            current.width = loadingBay.width();
            current.height = loadingBay.height();

            // Re-check to fix 1px bug in some browsers
            loadingBay.width( F.current.width );

            if (loadingBay.height() > current.height) {
              loadingBay.width(current.width + 1);

              current.width = loadingBay.width();
              current.height = loadingBay.height();
            }

            content = loadingBay.contents().detach();

            loadingBay.remove();
          }

          break;

        case 'image':
          content = current.tpl.image.replace('{href}', current.href);

          current.aspectRatio = true;
          break;

        case 'swf':
          content = current.tpl.swf.replace(/\{width\}/g, current.width).replace(/\{height\}/g, current.height).replace(/\{href\}/g, current.href);
          break;

        case 'iframe':
          content = $(current.tpl.iframe.replace('{rnd}', new Date().getTime()) )
            .attr('scrolling', current.scrolling)
            .attr('src', current.href);

          current.scrolling = isTouch ? 'scroll' : 'auto';

          break;
      }

      if (type === 'image' || type === 'swf') {
        current.autoSize = false;
        current.scrolling = 'visible';
      }

      if (type === 'iframe' && current.autoSize) {
        F.showLoading();

        F._setDimension();

        F.inner.css('overflow', current.scrolling);

        content.bind({
          onCancel : function() {
            $(this).unbind();

            F._afterZoomOut();
          },
          load : function() {
            F.hideLoading();

            try {
              if (this.contentWindow.document.location) {
                F.current.height = $(this).contents().find('body').height();
              }
            } catch (e) {
              F.current.autoSize = false;
            }

            F[ F.isOpen ? '_afterZoomIn' : '_beforeShow']();
          }
        }).appendTo(F.inner);

      } else {
        F.inner.append(content);

        F._beforeShow();
      }
    },

    _beforeShow : function() {
      F.coming = null;

      //Give a chance for helpers or callbacks to update elements
      F.trigger('beforeShow');

      //Set initial dimensions and hide
      F._setDimension();
      F.wrap.hide().removeClass('fancybox-tmp');

      F.bindEvents();

      F._preloadImages();

      F.transitions[ F.isOpened ? F.current.nextMethod : F.current.openMethod ]();
    },

    _setDimension: function () {
      var wrap      = F.wrap,
        inner     = F.inner,
        current   = F.current,
        viewport  = F.getViewport(),
        margin    = current.margin,
        padding2  = current.padding * 2,
        width     = current.width,
        height    = current.height,
        maxWidth  = current.maxWidth + padding2,
        maxHeight = current.maxHeight + padding2,
        minWidth  = current.minWidth + padding2,
        minHeight = current.minHeight + padding2,
        ratio,
        height_;

      viewport.w -= (margin[1] + margin[3]);
      viewport.h -= (margin[0] + margin[2]);

      if (isPercentage(width)) {
        width = (((viewport.w - padding2) * parseFloat(width)) / 100);
      }

      if (isPercentage(height)) {
        height = (((viewport.h - padding2) * parseFloat(height)) / 100);
      }

      ratio  = width / height;
      width  += padding2;
      height += padding2;

      if (current.fitToView) {
        maxWidth  = Math.min(viewport.w, maxWidth);
        maxHeight = Math.min(viewport.h, maxHeight);
      }

      if (current.aspectRatio) {
        if (width > maxWidth) {
          width = maxWidth;
          height = ((width - padding2) / ratio) + padding2;
        }

        if (height > maxHeight) {
          height = maxHeight;
          width = ((height - padding2) * ratio) + padding2;
        }

        if (width < minWidth) {
          width = minWidth;
          height = ((width - padding2) / ratio) + padding2;
        }

        if (height < minHeight) {
          height = minHeight;
          width = ((height - padding2) * ratio) + padding2;
        }

      } else {
        width = Math.max(minWidth, Math.min(width, maxWidth));
        height = Math.max(minHeight, Math.min(height, maxHeight));
      }

      width = Math.round(width);
      height = Math.round(height);

      //Reset dimensions
      $(wrap.add(inner)).width('auto').height('auto');

      inner.width(width - padding2).height(height - padding2);
      wrap.width(width);

      height_ = wrap.height(); // Real wrap height

      //Fit wrapper inside
      if (width > maxWidth || height_ > maxHeight) {
        while ((width > maxWidth || height_ > maxHeight) && width > minWidth && height_ > minHeight) {
          height = height - 10;

          if (current.aspectRatio) {
            width = Math.round(((height - padding2) * ratio) + padding2);

            if (width < minWidth) {
              width = minWidth;
              height = ((width - padding2) / ratio) + padding2;
            }

          } else {
            width = width - 10;
          }

          inner.width(width - padding2).height(height - padding2);
          wrap.width(width);

          height_ = wrap.height();
        }
      }

      current.dim = {
        width : getValue(width),
        height  : getValue(height_)
      };

      current.canGrow   = current.autoSize && height > minHeight && height < maxHeight;
      current.canShrink = false;
      current.canExpand = false;

      if ((width - padding2) < current.width || (height - padding2) < current.height) {
        current.canExpand = true;

      } else if ((width > viewport.w || height_ > viewport.h) && width > minWidth && height > minHeight) {
        current.canShrink = true;
      }

      F.innerSpace = height_ - padding2 - inner.height();
    },

    _getPosition: function (onlyAbsolute) {
      var current   = F.current,
        viewport    = F.getViewport(),
        margin      = current.margin,
        width       = F.wrap.width() + margin[1] + margin[3],
        height      = F.wrap.height() + margin[0] + margin[2],
        rez         = {
          position: 'absolute',
          top  : margin[0] + viewport.y,
          left : margin[3] + viewport.x
        };

      if (current.autoCenter && current.fixed && !onlyAbsolute && height <= viewport.h && width <= viewport.w) {
        rez = {
          position: 'fixed',
          top  : margin[0],
          left : margin[3]
        };
      }

      rez.top     = getValue(Math.max(rez.top, rez.top + ((viewport.h - height) * current.topRatio)));
      rez.left    = getValue(Math.max(rez.left, rez.left + ((viewport.w - width) * 0.5)));

      return rez;
    },

    _afterZoomIn: function () {
      var current = F.current, scrolling = current ? current.scrolling : 'no';

      if (!current) {
        return;
      }

      F.isOpen = F.isOpened = true;

      F.wrap.addClass('fancybox-opened');

      F.inner.css('overflow', scrolling === 'yes' ? 'scroll' : (scrolling === 'no' ? 'hidden' : scrolling));

      F.trigger('afterShow');

      F.update();

      //Assign a click event
      if (current.closeClick || current.nextClick) {
        F.inner.css('cursor', 'pointer').bind('click.fb', function(e) {
          if (!$(e.target).is('a') && !$(e.target).parent().is('a')) {
            F[ current.closeClick ? 'close' : 'next' ]();
          }
        });
      }

      //Create a close button
      if (current.closeBtn) {
        $(current.tpl.closeBtn).appendTo(F.skin).bind('click.fb', F.close);
      }

      //Create navigation arrows
      if (current.arrows && F.group.length > 1) {
        if (current.loop || current.index > 0) {
          $(current.tpl.prev).appendTo(F.outer).bind('click.fb', F.prev);
        }

        if (current.loop || current.index < F.group.length - 1) {
          $(current.tpl.next).appendTo(F.outer).bind('click.fb', F.next);
        }
      }

      if (F.opts.autoPlay && !F.player.isActive) {
        F.opts.autoPlay = false;

        F.play();
      }
    },

    _afterZoomOut: function () {
      var current = F.current;

      F.wrap.trigger('onReset').remove();

      $.extend(F, {
        group: {},
        opts: {},
        current: null,
        isActive: false,
        isOpened: false,
        isOpen: false,
        wrap: null,
        skin: null,
        outer: null,
        inner: null
      });

      F.trigger('afterClose', current);
    }
  });

  /*
   *  Default transitions
   */

  F.transitions = {
    getOrigPosition: function () {
      var current = F.current,
        element = current.element,
        padding = current.padding,
        orig    = $(current.orig),
        pos     = {},
        width   = 50,
        height  = 50,
        viewport;

      if (!orig.length && current.isDom && $(element).is(':visible')) {
        orig = $(element).find('img:first');

        if (!orig.length) {
          orig = $(element);
        }
      }

      if (orig.length) {
        pos = orig.offset();

        if (orig.is('img')) {
          width = orig.outerWidth();
          height = orig.outerHeight();
        }

      } else {
        viewport = F.getViewport();

        pos.top  = viewport.y + (viewport.h - height) * 0.5;
        pos.left = viewport.x + (viewport.w - width) * 0.5;
      }

      pos = {
        top     : getValue(pos.top - padding),
        left    : getValue(pos.left - padding),
        width   : getValue(width + padding * 2),
        height  : getValue(height + padding * 2)
      };

      return pos;
    },

    step: function (now, fx) {
      var prop = fx.prop, value, ratio;

      if (prop === 'width' || prop === 'height') {
        value = Math.ceil(now - (F.current.padding * 2));

        if (prop === 'height') {
          ratio = (now - fx.start) / (fx.end - fx.start);

          if (fx.start > fx.end) {
            ratio = 1 - ratio;
          }

          value -= F.innerSpace * ratio;
        }

        F.inner[prop](value);
      }
    },

    zoomIn: function () {
      var wrap     = F.wrap,
        current  = F.current,
        effect   = current.openEffect,
        elastic  = effect === 'elastic',
        dim      = current.dim,
        startPos = $.extend({}, dim, F._getPosition( elastic )),
        endPos   = $.extend({opacity : 1}, startPos);

      //Remove "position" property that breaks older IE
      delete endPos.position;

      if (elastic) {
        startPos = this.getOrigPosition();

        if (current.openOpacity) {
          startPos.opacity = 0;
        }

        F.outer.add(F.inner).width('auto').height('auto');

      } else if (effect === 'fade') {
        startPos.opacity = 0;
      }

      wrap.css(startPos)
        .show()
        .animate(endPos, {
          duration : effect === 'none' ? 0 : current.openSpeed,
          easing   : current.openEasing,
          step     : elastic ? this.step : null,
          complete : F._afterZoomIn
        });
    },

    zoomOut: function () {
      var wrap     = F.wrap,
        current  = F.current,
        effect   = current.openEffect,
        elastic  = effect === 'elastic',
        endPos   = {opacity : 0};

      if (elastic) {
        if (wrap.css('position') === 'fixed') {
          wrap.css(F._getPosition(true));
        }

        endPos = this.getOrigPosition();

        if (current.closeOpacity) {
          endPos.opacity = 0;
        }
      }

      wrap.animate(endPos, {
        duration : effect === 'none' ? 0 : current.closeSpeed,
        easing   : current.closeEasing,
        step     : elastic ? this.step : null,
        complete : F._afterZoomOut
      });
    },

    changeIn: function () {
      var wrap     = F.wrap,
        current  = F.current,
        effect   = current.nextEffect,
        elastic  = effect === 'elastic',
        startPos = F._getPosition( elastic ),
        endPos   = { opacity : 1 };

      startPos.opacity = 0;

      if (elastic) {
        startPos.top = getValue(parseInt(startPos.top, 10) - 200);
        endPos.top = '+=200px';
      }

      wrap.css(startPos)
        .show()
        .animate(endPos, {
          duration : effect === 'none' ? 0 : current.nextSpeed,
          easing   : current.nextEasing,
          complete : F._afterZoomIn
        });
    },

    changeOut: function () {
      var wrap     = F.wrap,
        current  = F.current,
        effect   = current.prevEffect,
        endPos   = { opacity : 0 },
        cleanUp  = function () {
          $(this).trigger('onReset').remove();
        };

      wrap.removeClass('fancybox-opened');

      if (effect === 'elastic') {
        endPos.top = '+=200px';
      }

      wrap.animate(endPos, {
        duration : effect === 'none' ? 0 : current.prevSpeed,
        easing   : current.prevEasing,
        complete : cleanUp
      });
    }
  };

  /*
   *  Overlay helper
   */

  F.helpers.overlay = {
    overlay: null,

    update: function () {
      var width, scrollWidth, offsetWidth;

      //Reset width/height so it will not mess
      this.overlay.width('100%').height('100%');

      if ($.browser.msie || isTouch) {
        scrollWidth = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);
        offsetWidth = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth);

        width = scrollWidth < offsetWidth ? W.width() : scrollWidth;

      } else {
        width = D.width();
      }

      this.overlay.width(width).height(D.height());
    },

    beforeShow: function (opts) {
      if (this.overlay) {
        return;
      }

      opts = $.extend(true, {}, F.defaults.helpers.overlay, opts);

      this.overlay = $('<div id="fancybox-overlay"></div>').css(opts.css).appendTo('body');

      if (opts.closeClick) {
        this.overlay.bind('click.fb', F.close);
      }

      if (F.current.fixed && !isTouch) {
        this.overlay.addClass('overlay-fixed');

      } else {
        this.update();

        this.onUpdate = function () {
          this.update();
        };
      }

      this.overlay.fadeTo(opts.speedIn, opts.opacity);
    },

    afterClose: function (opts) {
      if (this.overlay) {
        this.overlay.fadeOut(opts.speedOut || 0, function () {
          $(this).remove();
        });
      }

      this.overlay = null;
    }
  };

  /*
   *  Title helper
   */

  F.helpers.title = {
    beforeShow: function (opts) {
      var title, text = F.current.title;

      if (text) {
        title = $('<div class="fancybox-title fancybox-title-' + opts.type + '-wrap">' + text + '</div>').appendTo('body');

        if (opts.type === 'float') {
          //This helps for some browsers
          title.width(title.width());

          title.wrapInner('<span class="child"></span>');

          //Increase bottom margin so this title will also fit into viewport
          F.current.margin[2] += Math.abs(parseInt(title.css('margin-bottom'), 10));
        }

        title.appendTo(opts.type === 'over' ? F.inner : (opts.type === 'outside' ? F.wrap : F.skin));
      }
    }
  };

  // jQuery plugin initialization
  $.fn.fancybox = function (options) {
    var that     = $(this),
      selector = this.selector || '',
      index,
      run      = function(e) {
        var what = this, idx = index, relType, relVal;

        if (!(e.ctrlKey || e.altKey || e.shiftKey || e.metaKey) && !$(what).is('.fancybox-wrap')) {
          e.preventDefault();

          relType = options.groupAttr || 'data-fancybox-group';
          relVal  = $(what).attr(relType);

          if (!relVal) {
            relType = 'rel';
            relVal  = what[ relType ];
          }

          if (relVal && relVal !== '' && relVal !== 'nofollow') {
            what = selector.length ? $(selector) : that;
            what = what.filter('[' + relType + '="' + relVal + '"]');
            idx  = what.index(this);
          }

          options.index = idx;

          F.open(what, options);
        }
      };

    options = options || {};
    index   = options.index || 0;

    if (selector) {
      D.undelegate(selector, 'click.fb-start').delegate(selector, 'click.fb-start', run);

    } else {
      that.unbind('click.fb-start').bind('click.fb-start', run);
    }

    return this;
  };

  // Test for fixedPosition needs a body at doc ready
  $(document).ready(function() {
    F.defaults.fixed = $.support.fixedPosition || (!($.browser.msie && $.browser.version <= 6) && !isTouch);
  });

}(window, document, jQuery));


// assets/js/bundle/third_party/jquery/modal.js
goog.provide("optly.jquery.modal");

goog.require("optly.jquery");

/*
 * jqModal - Minimalist Modaling with jQuery
 *   (http://dev.iceburg.net/jquery/jqModal/)
 *
 * Copyright (c) 2007,2008 Brice Burgess <bhb@iceburg.net>
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * $Version: 03/01/2009 +r14
 */
(function ($) {
  $.fn.jqm = function (o) {
    var p = {
      overlayClass: 'jqmOverlay',
      overlayCloses: F,
      closeClass: 'jqmClose',
      trigger: '.jqModal',
      ajax: F,
      ajaxText: '',
      target: F,
      modal: F,
      toTop: F,
      onShow: F,
      onHide: F,
      onLoad: F
    };
    return this.each(function () {
      if (this._jqm) return H[this._jqm].c = $.extend({}, H[this._jqm].c, o);
      s++;
      this._jqm = s;
      H[s] = {
        c: $.extend(p, $.jqm.params, o),
        a: F,
        w: $(this).addClass('jqmID' + s),
        s: s
      };
      if (p.trigger) $(this).jqmAddTrigger(p.trigger);
    });
  };

  $.fn.jqmAdd = function (e) {
    return hs(this, e);
  };
  $.fn.jqmAddClose = function (e) {
    return hs(this, e, 'jqmHide');
  };
  $.fn.jqmAddTrigger = function (e) {
    return hs(this, e, 'jqmShow');
  };
  $.fn.jqmShow = function (t) {
    return this.each(function () {
      t = t || window.event;
      $.jqm.open(this._jqm, t);
    });
  };
  $.fn.jqmHide = function (t) {
    return this.each(function () {
      t = t || window.event;
      $.jqm.close(this._jqm, t)
    });
  };

  $.jqm = {
    hash: {},
    open: function (s, t) {
      var h = H[s],
        c = h.c,
        cc = '.' + c.closeClass,
        z = (parseInt(h.w.css('z-index'))),
        z = (z > 0) ? z : 3000,
        o = $('<div></div>').css({
          height: '100%',
          width: '100%',
          position: 'fixed',
          left: 0,
          top: 0,
          'z-index': z - 1
        });
      if (h.a) return F;
      h.t = t;
      h.a = true;
      h.w.css('z-index', z);
      if (c.modal) {
        if (!A[0]) L('bind');
        A.push(s);
      } else {
        if (c.overlayCloses) {
          h.w.jqmAddClose(o);
        } else {
          h.w.jqmAdd(o);
        }
      };

      if (ie8orLess) {
        // no fading, add opacity
        h.o = (o) ? o.addClass(c.overlayClass).prependTo('body').show().css("opacity", 0.5) : F;
      }
      else {
        h.o = (o) ? o.addClass(c.overlayClass).hide().prependTo('body').fadeIn(UI_EFFECT_DURATION, UI_EFFECT_EASING_OUT) : F;
      }


      if (ie6) {
        $('html,body').css({
          height: '100%',
          width: '100%'
        });
        if (o) {
          o = o.css({
            position: 'absolute'
          })[0];
          for (var y in {
            Top: 1,
            Left: 1
          }) o.style.setExpression(y.toLowerCase(), "(_=(document.documentElement.scroll" + y + " || document.body.scroll" + y + "))+'px'");
        }
      }

      if (c.ajax) {
        var r = c.target || h.w,
          u = c.ajax,
          r = (typeof r == 'string') ? $(r, h.w) : $(r),
          u = (u.substr(0, 1) == '@') ? $(t).attr(u.substring(1)) : u;
        r.html(c.ajaxText).load(u, function () {
          if (c.onLoad) c.onLoad.call(this, h);
          if (cc) h.w.jqmAddClose($(cc, h.w));
          e(h);
        });
      } else if (cc) h.w.jqmAddClose($(cc, h.w));

      if (c.toTop && h.o) h.w.before('<span id="jqmP' + h.w[0]._jqm + '"></span>').insertAfter(h.o);
      (c.onShow) ? c.onShow(h) : h.w.show();
      e(h);
      return F;
    },
    close: function (s) {
      var h = H[s];
      if (h.c.beforeHide && !h.c.beforeHide()) {
        return F;
      }
      if (!h.a) return F;
      h.a = F;
      if (A[0]) {
        A.pop();
        if (!A[0]) L('unbind');
      }
      if (h.c.toTop && h.o) $('#jqmP' + h.w[0]._jqm).after(h.w).remove();
      if (h.c.onHide) h.c.onHide(h);
      else {
        h.w.hide();
        $.jqm.hideOverlay(h);
      }
      if (h.c.afterHide) {
        h.c.afterHide();
      }
      return F;
    },
    hideOverlay: function (h) {
      if (h.o) {
        if (ie8orLess || h.c.overlayCloses) {
          h.o.remove();
        }
        else {
          h.o.fadeOut(UI_EFFECT_DURATION, UI_EFFECT_EASING_OUT, function () {
            $(this).remove();
          });
        }
      }
    },
    params: {}
  };
  var s = 0,
    H = $.jqm.hash,
    A = [],
    ie6 = $.browser.msie && ($.browser.version == "6.0"),
    ie8orLess = $.browser.msie && (parseInt($.browser.version, 10) < 9),
    F = false,
    i = $('<iframe src="javascript:false;document.write(\'\');" class="jqm"></iframe>').css({
      opacity: 0
    }),
    e = function (h) {
      if (ie6) if (h.o) h.o.html('<p style="width:100%;height:100%"/>').prepend(i);
      else if (!$('iframe.jqm', h.w)[0]) h.w.prepend(i);
      f(h);
    },
    f = function (h) {
      try {
        $(':input:visible', h.w)[0].focus();
      } catch (_) {}
    },
    L = function (t) {
      $()[t]("keypress", m)[t]("keydown", m)[t]("mousedown", m);
    },
    m = function (e) {
      var h = H[A[A.length - 1]],
        r = (!$(e.target).parents('.jqmID' + h.s)[0]);
      if (r) f(h);
      return !r;
    },
    hs = function (w, t, c) {
      return w.each(function () {
        var s = this._jqm;
        $(t).each(function () {
          if (c) {
            if (!this[c]) {
              this[c] = [];
              $(this).click(function () {
                for (var i in {
                  jqmShow: 1,
                  jqmHide: 1
                }) for (var s in this[i]) if (H[this[i][s]]) H[this[i][s]].w[i](this);
                return F;
              });
            }
            this[c].push(s);
          }
        });
      });
    };
})(jQuery);


// assets/js/bundle/third_party/jquery/easydate.js
goog.provide("optly.jquery.easydate");

goog.require("optly.jquery");

(function($)
{
    /*
     * jQuery EasyDate 0.2.4 ($Rev: 54 $)
     * Copyright (c) 2009 Parsha Pourkhomami (parshap@gmail.com)
     * Licensed under the MIT license.
     */

    $.easydate = { };
    $.easydate.locales = { };
    $.easydate.locales.enUS = {
        "future_format": "%s %t",
        "past_format": "%t %s",
        "second": "second",
        "seconds": "seconds",
        "minute": "minute",
        "minutes": "minutes",
        "hour": "hour",
        "hours": "hours",
        "day": "day",
        "days": "days",
        "week": "week",
        "weeks": "weeks",
        "month": "month",
        "months": "months",
        "year": "year",
        "years": "years",
        "yesterday": "yesterday",
        "tomorrow": "tomorrow",
        "now": "seconds ago",
        "ago": "ago",
        "in": "in"
    };

    var defaults = {
        live: true,
        set_title: true,
        format_future: true,
        format_past: true,
        units: [
            { name: "now", limit: 60 },
            { name: "second", limit: 60, in_seconds: 1 },
            { name: "minute", limit: 3600, in_seconds: 60 },
            { name: "hour", limit: 86400, in_seconds: 3600  },
            { name: "yesterday", limit: 172800, past_only: true },
            { name: "tomorrow", limit: 172800, future_only: true },
            { name: "day", limit: 604800, in_seconds: 86400 },
            { name: "week", limit: 2629743, in_seconds: 604800  },
            { name: "month", limit: 31556926, in_seconds: 2629743 },
            { name: "year", limit: Infinity, in_seconds: 31556926 }
        ],
        uneasy_format: function(date)
        {
            return date.toLocaleDateString();
        },
        locale: $.easydate.locales.enUS
    };

    // Difference (in milliseconds) between the local system time and the time
    // that should be used as "now". This is set by using set_now.
    var now_diff = 0;

    // A mapping of unique element IDs of elements that are waiting to be
    // updated to the ID of the timeout returned by setTimeOut.
    var updates = {};

    // A la updates, but contains element IDs for elements that are paused.
    var paused_updates = {};

    // A mapping of unique element IDs to the jQuery DOM elements it
    // represents.
    var elements = {};

    function __(str, value, settings)
    {
        if(!isNaN(value) && value != 1)
            str = str + "s";
        return settings.locale[str] || str;
    }

    // Pauses live updates of elements matching the given selector. If the
    // selector argument is omitted then all updating will be paused.
    var pause = $.easydate.pause = function(selector)
    {
        var p = function(element_id)
        {
            clearTimeout(updates[element_id]);
            delete updates[element_id];
            paused_updates[element_id] = true;
        };

        if(!selector)
        {
            for(var element_id in updates)
                p(element_id)
        }
        else
        {
            $(selector).each(function()
            {
                var element_id = jQuery.data(this);
                if(!isNaN(updates[element_id]))
                    p(element_id);
            });
        }
    };

    // Pauses updates on paused elements matching the given selector. If no
    // selector is provided, all updates will be resumed.
    var resume = $.easydate.resume = function(selector)
    {
        var r = function(element_id)
        {
            delete paused_updates[element_id];
            update_time(elements[element_id]);
        };

        if(!selector)
        {
            for(var element_id in paused_updates)
                r(element_id);
        }
        else
        {
            $(selector).each(function()
            {
                var element_id = jQuery.data(this);
                if(!isNaN(paused_updates[element_id]))
                    r(element_id);
            });
        }
    };

    // Makes all future time calculations relative to the given date argument
    // instead of the system clock. The date argument can be a JavaScript Date
    // object or a RFC 1123 valid timestamp string. This is useful for
    // synchronizing the user's clock with a server-side clock.
    var set_now = $.easydate.set_now = function(date)
    {
        var time;
        if(date instanceof Date)
            time = date.getTime();
        else
            time = Date.parse(date);

        if(isNaN(time))
            return;

        now_diff = time - (new Date()).getTime();

        // Re-adjust any previously formatted dates.
        for(var element_id in elements)
        {
            if(!isNaN[updates[element_id]])
                clearTimeout(updates[element_id]);
            update_time(elements[element_id]);
        }
    };

    var get_now = $.easydate.get_now = function()
    {
        var now = new Date();
        now.setTime(now.getTime() + now_diff);
        return now;
    };

    // Formats a Date object to a human-readable localized string.
    var format_date = $.easydate.format_date = function(date, options)
    {
        var settings = $.extend({}, defaults, options);

        var diff = ((get_now().getTime() - date.getTime()) / 1000);
        var diff_abs = Math.abs(diff);

        if(isNaN(diff))
            return;

        // Return if we shouldn't format this date because it is in the past
        // or future and our setting does not allow it.
        if((!settings.format_future && diff < 0) ||
            (!settings.format_past && diff > 0))
            return;

        for(var i in settings.units)
        {
            var unit = settings.units[i];

            // Skip this unit if it's for past dates only and this is a future
            // date, or if it's for future dates only and this is a past date.
            if((unit.past_only && diff < 0) || (unit.future_only && diff > 0))
                continue;

            if(diff_abs < unit.limit)
            {
                // Case for units that are not really measurement units - e.g.,
                // "yesterday" or "now".
                if(isNaN(unit.in_seconds))
                    return __(unit.name, NaN, settings);

                var val = diff_abs / unit.in_seconds;
                val = Math.round(val);
                var format_string;
                if(diff < 0)
                    format_string = __("future_format", NaN, settings)
                        .replace("%s", __("in", NaN, settings))
                else
                    format_string = __("past_format", NaN, settings)
                        .replace("%s", __("ago", NaN, settings))
                return format_string
                    .replace("%t", val + " " + __(unit.name, val, settings));
            }
        }

        // The date does not fall into any units' limits - use uneasy format.
        return settings.uneasy_format(date);
    }

    // Returns how long (in milliseconds) the timout until the next update for
    // the given date should be.
    function get_timeout_delay(date, settings)
    {
        var now = get_now();
        var diff = ((now.getTime() - date.getTime()) / 1000);
        var diff_abs = Math.abs(diff);

        if(isNaN(diff))
            return;

        var last_limit = 0;
        for(var i in settings.units)
        {
            var unit = settings.units[i];

            // Skip this unit if it's for past dates only and this is a future
            // date, or if it's for future dates only and this is a past date.
            if((unit.past_only && diff < 0) || (unit.future_only && diff > 0))
                continue;

            if(diff_abs < unit.limit)
            {
                // @todo: check edge cases (diff == 0)
                if(isNaN(unit.in_seconds))
                {
                    // This is not a real unit of time, so only update once we
                    // pass the limit of this unit.
                    if(diff < 0)
                        return (last_limit - diff_abs) * 1000 + 100;
                    else
                        return (unit.limit - diff_abs) * 1000 + 100;
                }
                else
                {
                    // Real unit of time - update every tick of this time unit.
                    if(diff < 0)
                        return (diff_abs % unit.in_seconds) * 1000 + 100
                    else
                        return (unit.in_seconds - (diff_abs % unit.in_seconds)) *
                            1000 + 100
                }
            }
            last_limit = unit.limit;
        }

        // Date is out of range of all units' limits. If this is a future date,
        // update once the date comes in range of a future unit.
        if(diff < 0)
        {
            for(var i = settings.units.length - 1; i >= 0; i--)
            {
                var unit = settings.units[i];

                if(unit.past_only)
                    continue;

                return (unit.limit - diff_abs) * 1000 + 100
            }
        }
    }

    // Returns a date object for the date represented by the given DOM element
    // from the following sources (in order):
    //     1) element.data("easydate.date") (in case we previously cached it)
    //     2) DOM element's title (if it is a valid RFC 1123 timestamp)
    //     3) DOM element's innerHTML (if it is a valid RFC 1123 timestamp)
    function get_date(element, settings)
    {
        var date = element.data("easydate.date");

        if(isNaN(date))
        {
            var timestamp;
            var time = Date.parse(timestamp = element.attr("title")) ||
                       Date.parse(timestamp = element.html());
            if(!isNaN(time))
            {
                date = new Date();
                date.setTime(time);
                element.data("easydate.date", date);
                if(settings.set_title && !element.attr("title"))
                    element.attr("title", timestamp);
            }
        }

        return date;
    }

    // Updates the given element's innerHTML based on the time it represents.
    function update_time(element)
    {
        var settings = element.data("easydate.settings");

        // Don't try to update the time if element was removed from page.
        if (!settings) {
          return;
        }

        var element_id = $.data(element[0]);
        elements[element_id] = element;
        delete updates[element_id];

        var date = get_date(element, settings);

        if(isNaN(date))
            return;

        element.html(format_date(date, settings));

        if(settings.live)
        {
            var timeout = get_timeout_delay(date, settings);
            if(!isNaN(timeout))
            {
                if(timeout > 2147483647)
                    timeout = 2147483647; // max Firefox timeout delay

                var id = setTimeout(
                    function() { update_time(element); },
                    Math.round(timeout)
                );
                updates[element_id] = id;
            }
        }
    }

    $.fn.easydate = function(options)
    {
        var settings = $.extend({}, defaults, options);
        this.data("easydate.settings", settings);

        // Clear any cached dates in case the timestamp has been updated since
        // the last easydate() call on any of these elements.
        this.removeData("easydate.date");

        this.each(function()
        {
            // Make sure that we aren't updating the element multiple times in
            // case easydate() was called on the same element more than once.
            var element_id = $.data(this);
            if(!isNaN(updates[element_id]))
            {
                clearTimeout(updates[element_id]);
                delete updates[element_id];
            }

            update_time($(this));
        });
    };

})(jQuery);


// assets/js/bundle/third_party/jquery/tmpl.js
goog.provide("optly.jquery.tmpl");

goog.require("optly.jquery");

/*!
 * jQuery Templates Plugin 1.0.0pre
 * http://github.com/jquery/jquery-tmpl
 * Requires jQuery 1.4.2
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
(function( jQuery, undefined ){
  var oldManip = jQuery.fn.domManip, tmplItmAtt = "_tmplitem", htmlExpr = /^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,
    newTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];

  function newTmplItem( options, parentItem, fn, data ) {
    // Returns a template item data structure for a new rendered instance of a template (a 'template item').
    // The content field is a hierarchical array of strings and nested items (to be
    // removed and replaced by nodes field of dom elements, once inserted in DOM).
    var newItem = {
      data: data || (data === 0 || data === false) ? data : (parentItem ? parentItem.data : {}),
      _wrap: parentItem ? parentItem._wrap : null,
      tmpl: null,
      parent: parentItem || null,
      nodes: [],
      calls: tiCalls,
      nest: tiNest,
      wrap: tiWrap,
      html: tiHtml,
      update: tiUpdate
    };
    if ( options ) {
      jQuery.extend( newItem, options, { nodes: [], parent: parentItem });
    }
    if ( fn ) {
      // Build the hierarchical content to be used during insertion into DOM
      newItem.tmpl = fn;
      newItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );
      newItem.key = ++itemKey;
      // Keep track of new template item, until it is stored as jQuery Data on DOM element
      (stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;
    }
    return newItem;
  }

  // Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function( name, original ) {
    jQuery.fn[ name ] = function( selector ) {
      var ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,
        parent = this.length === 1 && this[0].parentNode;

      appendToTmplItems = newTmplItems || {};
      if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
        insert[ original ]( this[0] );
        ret = this;
      } else {
        for ( i = 0, l = insert.length; i < l; i++ ) {
          cloneIndex = i;
          elems = (i > 0 ? this.clone(true) : this).get();
          jQuery( insert[i] )[ original ]( elems );
          ret = ret.concat( elems );
        }
        cloneIndex = 0;
        ret = this.pushStack( ret, name, insert.selector );
      }
      tmplItems = appendToTmplItems;
      appendToTmplItems = null;
      jQuery.tmpl.complete( tmplItems );
      return ret;
    };
  });

  jQuery.fn.extend({
    // Use first wrapped element as template markup.
    // Return wrapped set of template items, obtained by rendering template against data.
    tmpl: function( data, options, parentItem ) {
      return jQuery.tmpl( this[0], data, options, parentItem );
    },

    // Find which rendered template item the first wrapped DOM element belongs to
    tmplItem: function() {
      return jQuery.tmplItem( this[0] );
    },

    // Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.
    template: function( name ) {
      return jQuery.template( name, this[0] );
    },

    domManip: function( args, table, callback, options ) {
      if ( args[0] && jQuery.isArray( args[0] )) {
        var dmArgs = jQuery.makeArray( arguments ), elems = args[0], elemsLength = elems.length, i = 0, tmplItem;
        while ( i < elemsLength && !(tmplItem = jQuery.data( elems[i++], "tmplItem" ))) {}
        if ( tmplItem && cloneIndex ) {
          dmArgs[2] = function( fragClone ) {
            // Handler called by oldManip when rendered template has been inserted into DOM.
            jQuery.tmpl.afterManip( this, fragClone, callback );
          };
        }
        oldManip.apply( this, dmArgs );
      } else {
        oldManip.apply( this, arguments );
      }
      cloneIndex = 0;
      if ( !appendToTmplItems ) {
        jQuery.tmpl.complete( newTmplItems );
      }
      return this;
    }
  });

  jQuery.extend({
    // Return wrapped set of template items, obtained by rendering template against data.
    tmpl: function( tmpl, data, options, parentItem ) {
      var ret, topLevel = !parentItem;
      if ( topLevel ) {
        // This is a top-level tmpl call (not from a nested template using {{tmpl}})
        parentItem = topTmplItem;
        tmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );
        wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level
      } else if ( !tmpl ) {
        // The template item is already associated with DOM - this is a refresh.
        // Re-evaluate rendered template for the parentItem
        tmpl = parentItem.tmpl;
        newTmplItems[parentItem.key] = parentItem;
        parentItem.nodes = [];
        if ( parentItem.wrapped ) {
          updateWrapped( parentItem, parentItem.wrapped );
        }
        // Rebuild, without creating a new template item
        return jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));
      }
      if ( !tmpl ) {
        return []; // Could throw...
      }
      if ( typeof data === "function" ) {
        data = data.call( parentItem || {} );
      }
      if ( options && options.wrapped ) {
        updateWrapped( options, options.wrapped );
      }
      ret = jQuery.isArray( data ) ?
        jQuery.map( data, function( dataItem ) {
          return dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;
        }) :
        [ newTmplItem( options, parentItem, tmpl, data ) ];
      return topLevel ? jQuery( build( parentItem, null, ret ) ) : ret;
    },

    // Return rendered template item for an element.
    tmplItem: function( elem ) {
      var tmplItem;
      if ( elem instanceof jQuery ) {
        elem = elem[0];
      }
      while ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, "tmplItem" )) && (elem = elem.parentNode) ) {}
      return tmplItem || topTmplItem;
    },

    // Set:
    // Use $.template( name, tmpl ) to cache a named template,
    // where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.
    // Use $( "selector" ).template( name ) to provide access by name to a script block template declaration.

    // Get:
    // Use $.template( name ) to access a cached template.
    // Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )
    // will return the compiled template, without adding a name reference.
    // If templateString includes at least one HTML tag, $.template( templateString ) is equivalent
    // to $.template( null, templateString )
    template: function( name, tmpl ) {
      if (tmpl) {
        // Compile template and associate with name
        if ( typeof tmpl === "string" ) {
          // This is an HTML string being passed directly in.
          tmpl = buildTmplFn( tmpl );
        } else if ( tmpl instanceof jQuery ) {
          tmpl = tmpl[0] || {};
        }
        if ( tmpl.nodeType ) {
          // If this is a template block, use cached copy, or generate tmpl function and cache.
          tmpl = jQuery.data( tmpl, "tmpl" ) || jQuery.data( tmpl, "tmpl", buildTmplFn( tmpl.innerHTML ));
          // Issue: In IE, if the container element is not a script block, the innerHTML will remove quotes from attribute values whenever the value does not include white space.
          // This means that foo="${x}" will not work if the value of x includes white space: foo="${x}" -> foo=value of x.
          // To correct this, include space in tag: foo="${ x }" -> foo="value of x"
        }
        return typeof name === "string" ? (jQuery.template[name] = tmpl) : tmpl;
      }
      // Return named compiled template
      return name ? (typeof name !== "string" ? jQuery.template( null, name ):
        (jQuery.template[name] ||
          // If not in map, and not containing at least on HTML tag, treat as a selector.
          // (If integrated with core, use quickExpr.exec)
          jQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null;
    },

    encode: function( text ) {
      // Do HTML encoding replacing < > & and ' and " by corresponding entities.
      return ("" + text).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;");
    }
  });

  jQuery.extend( jQuery.tmpl, {
    tag: {
      "tmpl": {
        _default: { $2: "null" },
        open: "if($notnull_1){__=__.concat($item.nest($1,$2));}"
        // tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)
        // This means that {{tmpl foo}} treats foo as a template (which IS a function).
        // Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.
      },
      "wrap": {
        _default: { $2: "null" },
        open: "$item.calls(__,$1,$2);__=[];",
        close: "call=$item.calls();__=call._.concat($item.wrap(call,__));"
      },
      "each": {
        _default: { $2: "$index, $value" },
        open: "if($notnull_1){$.each($1a,function($2){with(this){",
        close: "}});}"
      },
      "if": {
        open: "if(($notnull_1) && $1a){",
        close: "}"
      },
      "else": {
        _default: { $1: "true" },
        open: "}else if(($notnull_1) && $1a){"
      },
      "html": {
        // Unecoded expression evaluation.
        open: "if($notnull_1){__.push($1a);}"
      },
      "=": {
        // Encoded expression evaluation. Abbreviated form is ${}.
        _default: { $1: "$data" },
        open: "if($notnull_1){__.push($.encode($1a));}"
      },
      "!": {
        // Comment tag. Skipped by parser
        open: ""
      }
    },

    // This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events
    complete: function( items ) {
      newTmplItems = {};
    },

    // Call this from code which overrides domManip, or equivalent
    // Manage cloning/storing template items etc.
    afterManip: function afterManip( elem, fragClone, callback ) {
      // Provides cloned fragment ready for fixup prior to and after insertion into DOM
      var content = fragClone.nodeType === 11 ?
        jQuery.makeArray(fragClone.childNodes) :
        fragClone.nodeType === 1 ? [fragClone] : [];

      // Return fragment to original caller (e.g. append) for DOM insertion
      callback.call( elem, fragClone );

      // Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.
      storeTmplItems( content );
      cloneIndex++;
    }
  });

  //========================== Private helper functions, used by code above ==========================

  function build( tmplItem, nested, content ) {
    // Convert hierarchical content into flat string array
    // and finally return array of fragments ready for DOM insertion
    var frag, ret = content ? jQuery.map( content, function( item ) {
      return (typeof item === "string") ?
        // Insert template item annotations, to be converted to jQuery.data( "tmplItem" ) when elems are inserted into DOM.
        (tmplItem.key ? item.replace( /(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g, "$1 " + tmplItmAtt + "=\"" + tmplItem.key + "\" $2" ) : item) :
        // This is a child template item. Build nested template.
        build( item, tmplItem, item._ctnt );
    }) :
    // If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.
    tmplItem;
    if ( nested ) {
      return ret;
    }

    // top-level template
    ret = ret.join("");

    // Support templates which have initial or final text nodes, or consist only of text
    // Also support HTML entities within the HTML markup.
    ret.replace( /^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/, function( all, before, middle, after) {
      frag = jQuery( middle ).get();

      storeTmplItems( frag );
      if ( before ) {
        frag = unencode( before ).concat(frag);
      }
      if ( after ) {
        frag = frag.concat(unencode( after ));
      }
    });
    return frag ? frag : unencode( ret );
  }

  function unencode( text ) {
    // Use createElement, since createTextNode will not render HTML entities correctly
    var el = document.createElement( "div" );
    el.innerHTML = text;
    return jQuery.makeArray(el.childNodes);
  }

  // Generate a reusable function that will serve to render a template against data
  function buildTmplFn( markup ) {
    return new Function("jQuery","$item",
      // Use the variable __ to hold a string array while building the compiled template. (See https://github.com/jquery/jquery-tmpl/issues#issue/10).
      "var $=jQuery,call,__=[],$data=$item.data;" +

      // Introduce the data as local variables using with(){}
      "with($data){__.push('" +

      // Convert the template into pure JavaScript
      jQuery.trim(markup)
        .replace( /([\\'])/g, "\\$1" )
        .replace( /[\r\t\n]/g, " " )
        .replace( /\$\{([^\}]*)\}/g, "{{= $1}}" )
        .replace( /\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,
        function( all, slash, type, fnargs, target, parens, args ) {
          var tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;
          if ( !tag ) {
            throw "Unknown template tag: " + type;
          }
          def = tag._default || [];
          if ( parens && !/\w$/.test(target)) {
            target += parens;
            parens = "";
          }
          if ( target ) {
            target = unescape( target );
            args = args ? ("," + unescape( args ) + ")") : (parens ? ")" : "");
            // Support for target being things like a.toLowerCase();
            // In that case don't call with template item as 'this' pointer. Just evaluate...
            expr = parens ? (target.indexOf(".") > -1 ? target + unescape( parens ) : ("(" + target + ").call($item" + args)) : target;
            exprAutoFnDetect = parens ? expr : "(typeof(" + target + ")==='function'?(" + target + ").call($item):(" + target + "))";
          } else {
            exprAutoFnDetect = expr = def.$1 || "null";
          }
          fnargs = unescape( fnargs );
          return "');" +
            tag[ slash ? "close" : "open" ]
              .split( "$notnull_1" ).join( target ? "typeof(" + target + ")!=='undefined' && (" + target + ")!=null" : "true" )
              .split( "$1a" ).join( exprAutoFnDetect )
              .split( "$1" ).join( expr )
              .split( "$2" ).join( fnargs || def.$2 || "" ) +
            "__.push('";
        }) +
      "');}return __;"
    );
  }
  function updateWrapped( options, wrapped ) {
    // Build the wrapped content.
    options._wrap = build( options, true,
      // Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.
      jQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]
    ).join("");
  }

  function unescape( args ) {
    return args ? args.replace( /\\'/g, "'").replace(/\\\\/g, "\\" ) : null;
  }
  function outerHtml( elem ) {
    var div = document.createElement("div");
    div.appendChild( elem.cloneNode(true) );
    return div.innerHTML;
  }

  // Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.
  function storeTmplItems( content ) {
    var keySuffix = "_" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;
    for ( i = 0, l = content.length; i < l; i++ ) {
      if ( (elem = content[i]).nodeType !== 1 ) {
        continue;
      }
      elems = elem.getElementsByTagName("*");
      for ( m = elems.length - 1; m >= 0; m-- ) {
        processItemKey( elems[m] );
      }
      processItemKey( elem );
    }
    function processItemKey( el ) {
      var pntKey, pntNode = el, pntItem, tmplItem, key;
      // Ensure that each rendered template inserted into the DOM has its own template item,
      if ( (key = el.getAttribute( tmplItmAtt ))) {
        while ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }
        if ( pntKey !== key ) {
          // The next ancestor with a _tmplitem expando is on a different key than this one.
          // So this is a top-level element within this template item
          // Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.
          pntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;
          if ( !(tmplItem = newTmplItems[key]) ) {
            // The item is for wrapped content, and was copied from the temporary parent wrappedItem.
            tmplItem = wrappedItems[key];
            tmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode] );
            tmplItem.key = ++itemKey;
            newTmplItems[itemKey] = tmplItem;
          }
          if ( cloneIndex ) {
            cloneTmplItem( key );
          }
        }
        el.removeAttribute( tmplItmAtt );
      } else if ( cloneIndex && (tmplItem = jQuery.data( el, "tmplItem" )) ) {
        // This was a rendered element, cloned during append or appendTo etc.
        // TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.
        cloneTmplItem( tmplItem.key );
        newTmplItems[tmplItem.key] = tmplItem;
        pntNode = jQuery.data( el.parentNode, "tmplItem" );
        pntNode = pntNode ? pntNode.key : 0;
      }
      if ( tmplItem ) {
        pntItem = tmplItem;
        // Find the template item of the parent element.
        // (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)
        while ( pntItem && pntItem.key != pntNode ) {
          // Add this element as a top-level node for this rendered template item, as well as for any
          // ancestor items between this item and the item of its parent element
          pntItem.nodes.push( el );
          pntItem = pntItem.parent;
        }
        // Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...
        delete tmplItem._ctnt;
        delete tmplItem._wrap;
        // Store template item as jQuery data on the element
        jQuery.data( el, "tmplItem", tmplItem );
      }
      function cloneTmplItem( key ) {
        key = key + keySuffix;
        tmplItem = newClonedItems[key] =
          (newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent ));
      }
    }
  }

  //---- Helper functions for template item ----

  function tiCalls( content, tmpl, data, options ) {
    if ( !content ) {
      return stack.pop();
    }
    stack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });
  }

  function tiNest( tmpl, data, options ) {
    // nested template, using {{tmpl}} tag
    return jQuery.tmpl( jQuery.template( tmpl ), data, options, this );
  }

  function tiWrap( call, wrapped ) {
    // nested template, using {{wrap}} tag
    var options = call.options || {};
    options.wrapped = wrapped;
    // Apply the template, which may incorporate wrapped content,
    return jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );
  }

  function tiHtml( filter, textOnly ) {
    var wrapped = this._wrap;
    return jQuery.map(
      jQuery( jQuery.isArray( wrapped ) ? wrapped.join("") : wrapped ).filter( filter || "*" ),
      function(e) {
        return textOnly ?
          e.innerText || e.textContent :
          e.outerHTML || outerHtml(e);
      });
  }

  function tiUpdate() {
    var coll = this.nodes;
    jQuery.tmpl( null, null, null, this).insertBefore( coll[0] );
    jQuery( coll ).remove();
  }
})( jQuery );


// assets/js/bundle/third_party/jquery/validate.js
goog.provide("optly.jquery.validate");

goog.require("optly.jquery");

/**
 * jQuery Validation Plugin 1.11.0pre
 *
 * http://bassistance.de/jquery-plugins/jquery-plugin-validation/
 * http://docs.jquery.com/Plugins/Validation
 *
 * Copyright (c) 2012 Jrn Zaefferer
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

(function($) {

$.extend($.fn, {
  // http://docs.jquery.com/Plugins/Validation/validate
  validate: function( options ) {

    // if nothing is selected, return nothing; can't chain anyway
    if (!this.length) {
      if (options && options.debug && window.console) {
        console.warn( "nothing selected, can't validate, returning nothing" );
      }
      return;
    }

    // check if a validator for this form was already created
    var validator = $.data(this[0], 'validator');
    if ( validator ) {
      return validator;
    }

    // Add novalidate tag if HTML5.
    this.attr('novalidate', 'novalidate');

    validator = new $.validator( options, this[0] );
    $.data(this[0], 'validator', validator);

    if ( validator.settings.onsubmit ) {

      this.validateDelegate( ":submit", "click", function(ev) {
        if ( validator.settings.submitHandler ) {
          validator.submitButton = ev.target;
        }
        // allow suppressing validation by adding a cancel class to the submit button
        if ( $(ev.target).hasClass('cancel') ) {
          validator.cancelSubmit = true;
        }
      });

      // validate the form on submit
      this.submit( function( event ) {
        if ( validator.settings.debug ) {
          // prevent form submit to be able to see console output
          event.preventDefault();
        }
        function handle() {
          var hidden;
          if ( validator.settings.submitHandler ) {
            if (validator.submitButton) {
              // insert a hidden input as a replacement for the missing submit button
              hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val(validator.submitButton.value).appendTo(validator.currentForm);
            }
            validator.settings.submitHandler.call( validator, validator.currentForm, event );
            if (validator.submitButton) {
              // and clean up afterwards; thanks to no-block-scope, hidden can be referenced
              hidden.remove();
            }
            return false;
          }
          return true;
        }

        // prevent submit for invalid forms or custom submit handlers
        if ( validator.cancelSubmit ) {
          validator.cancelSubmit = false;
          return handle();
        }
        if ( validator.form() ) {
          if ( validator.pendingRequest ) {
            validator.formSubmitted = true;
            return false;
          }
          return handle();
        } else {
          validator.focusInvalid();
          return false;
        }
      });
    }

    return validator;
  },
  // http://docs.jquery.com/Plugins/Validation/valid
  valid: function() {
    if ( $(this[0]).is('form')) {
      return this.validate().form();
    } else {
      var valid = true;
      var validator = $(this[0].form).validate();
      this.each(function() {
        valid &= validator.element(this);
      });
      return valid;
    }
  },
  // attributes: space seperated list of attributes to retrieve and remove
  removeAttrs: function(attributes) {
    var result = {},
      $element = this;
    $.each(attributes.split(/\s/), function(index, value) {
      result[value] = $element.attr(value);
      $element.removeAttr(value);
    });
    return result;
  },
  // http://docs.jquery.com/Plugins/Validation/rules
  rules: function(command, argument) {
    var element = this[0];

    if (command) {
      var settings = $.data(element.form, 'validator').settings;
      var staticRules = settings.rules;
      var existingRules = $.validator.staticRules(element);
      switch(command) {
      case "add":
        $.extend(existingRules, $.validator.normalizeRule(argument));
        staticRules[element.name] = existingRules;
        if (argument.messages) {
          settings.messages[element.name] = $.extend( settings.messages[element.name], argument.messages );
        }
        break;
      case "remove":
        if (!argument) {
          delete staticRules[element.name];
          return existingRules;
        }
        var filtered = {};
        $.each(argument.split(/\s/), function(index, method) {
          filtered[method] = existingRules[method];
          delete existingRules[method];
        });
        return filtered;
      }
    }

    var data = $.validator.normalizeRules(
    $.extend(
      {},
      $.validator.metadataRules(element),
      $.validator.classRules(element),
      $.validator.attributeRules(element),
      $.validator.staticRules(element)
    ), element);

    // make sure required is at front
    if (data.required) {
      var param = data.required;
      delete data.required;
      data = $.extend({required: param}, data);
    }

    return data;
  }
});

// Custom selectors
$.extend($.expr[":"], {
  // http://docs.jquery.com/Plugins/Validation/blank
  blank: function(a) {return !$.trim("" + a.value);},
  // http://docs.jquery.com/Plugins/Validation/filled
  filled: function(a) {return !!$.trim("" + a.value);},
  // http://docs.jquery.com/Plugins/Validation/unchecked
  unchecked: function(a) {return !a.checked;}
});

// constructor for validator
$.validator = function( options, form ) {
  this.settings = $.extend( true, {}, $.validator.defaults, options );
  this.currentForm = form;
  this.init();
};

$.validator.format = function(source, params) {
  if ( arguments.length === 1 ) {
    return function() {
      var args = $.makeArray(arguments);
      args.unshift(source);
      return $.validator.format.apply( this, args );
    };
  }
  if ( arguments.length > 2 && params.constructor !== Array  ) {
    params = $.makeArray(arguments).slice(1);
  }
  if ( params.constructor !== Array ) {
    params = [ params ];
  }
  $.each(params, function(i, n) {
    source = source.replace(new RegExp("\\{" + i + "\\}", "g"), n);
  });
  return source;
};

$.extend($.validator, {

  defaults: {
    messages: {},
    groups: {},
    rules: {},
    errorClass: "error",
    validClass: "valid",
    errorElement: "label",
    focusInvalid: true,
    errorContainer: $( [] ),
    errorLabelContainer: $( [] ),
    onsubmit: true,
    ignore: ":hidden",
    ignoreTitle: false,
    onfocusin: function(element, event) {
      this.lastActive = element;

      // hide error label and remove error class on focus if enabled
      if ( this.settings.focusCleanup && !this.blockFocusCleanup ) {
        if ( this.settings.unhighlight ) {
          this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
        }
        this.addWrapper(this.errorsFor(element)).hide();
      }
    },
    onfocusout: function(element, event) {
      if ( !this.checkable(element) && (element.name in this.submitted || !this.optional(element)) ) {
        this.element(element);
      }
    },
    onkeyup: function(element, event) {
      if ( event.which === 9 && this.elementValue(element) === '' ) {
        return;
      } else if ( element.name in this.submitted || element === this.lastElement ) {
        this.element(element);
      }
    },
    onclick: function(element, event) {
      // click on selects, radiobuttons and checkboxes
      if ( element.name in this.submitted ) {
        this.element(element);
      }
      // or option elements, check parent select in that case
      else if (element.parentNode.name in this.submitted) {
        this.element(element.parentNode);
      }
    },
    highlight: function(element, errorClass, validClass) {
      if (element.type === 'radio') {
        this.findByName(element.name).addClass(errorClass).removeClass(validClass);
      } else {
        $(element).addClass(errorClass).removeClass(validClass);
      }
    },
    unhighlight: function(element, errorClass, validClass) {
      if (element.type === 'radio') {
        this.findByName(element.name).removeClass(errorClass).addClass(validClass);
      } else {
        $(element).removeClass(errorClass).addClass(validClass);
      }
    }
  },

  // http://docs.jquery.com/Plugins/Validation/Validator/setDefaults
  setDefaults: function(settings) {
    $.extend( $.validator.defaults, settings );
  },

  messages: {
    required: tr("This field is required."),
    remote: tr("Please fix this field."),
    email: tr("Please enter a valid email address."),
    url: tr("Please enter a valid URL."),
    date: tr("Please enter a valid date."),
    dateISO: tr("Please enter a valid date (ISO)."),
    number: tr("Please enter a valid number."),
    digits: tr("Please enter only digits."),
    creditcard: tr("Please enter a valid credit card number."),
    equalTo: tr("Please enter the same value again."),
    maxlength: $.validator.format(tr("Please enter no more than {0} characters.")),
    minlength: $.validator.format(tr("Please enter at least {0} characters.")),
    rangelength: $.validator.format(tr("Please enter a value between {0} and {1} characters long.")),
    range: $.validator.format(tr("Please enter a value between {0} and {1}.")),
    max: $.validator.format(tr("Please enter a value less than or equal to {0}.")),
    min: $.validator.format(tr("Please enter a value greater than or equal to {0}."))
  },

  autoCreateRanges: false,

  prototype: {

    init: function() {
      this.labelContainer = $(this.settings.errorLabelContainer);
      this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
      this.containers = $(this.settings.errorContainer).add( this.settings.errorLabelContainer );
      this.submitted = {};
      this.valueCache = {};
      this.pendingRequest = 0;
      this.pending = {};
      this.invalid = {};
      this.reset();

      var groups = (this.groups = {});
      $.each(this.settings.groups, function(key, value) {
        $.each(value.split(/\s/), function(index, name) {
          groups[name] = key;
        });
      });
      var rules = this.settings.rules;
      $.each(rules, function(key, value) {
        rules[key] = $.validator.normalizeRule(value);
      });

      function delegate(event) {
        var validator = $.data(this[0].form, "validator"),
          eventType = "on" + event.type.replace(/^validate/, "");
        if (validator.settings[eventType]) {
          validator.settings[eventType].call(validator, this[0], event);
        }
      }
      $(this.currentForm)
        .validateDelegate(":text, [type='password'], [type='file'], select, textarea, " +
          "[type='number'], [type='search'] ,[type='tel'], [type='url'], " +
          "[type='email'], [type='datetime'], [type='date'], [type='month'], " +
          "[type='week'], [type='time'], [type='datetime-local'], " +
          "[type='range'], [type='color'] ",
          "focusin focusout keyup", delegate)
        .validateDelegate("[type='radio'], [type='checkbox'], select, option", "click", delegate);

      if (this.settings.invalidHandler) {
        $(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);
      }
    },

    // http://docs.jquery.com/Plugins/Validation/Validator/form
    form: function() {
      this.checkForm();
      $.extend(this.submitted, this.errorMap);
      this.invalid = $.extend({}, this.errorMap);
      if (!this.valid()) {
        $(this.currentForm).triggerHandler("invalid-form", [this]);
      }
      this.showErrors();
      return this.valid();
    },

    checkForm: function() {
      this.prepareForm();
      for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) {
        this.check( elements[i] );
      }
      return this.valid();
    },

    // http://docs.jquery.com/Plugins/Validation/Validator/element
    element: function( element ) {
      element = this.validationTargetFor( this.clean( element ) );
      this.lastElement = element;
      this.prepareElement( element );
      this.currentElements = $(element);
      var result = this.check( element ) !== false;
      if (result) {
        delete this.invalid[element.name];
      } else {
        this.invalid[element.name] = true;
      }
      if ( !this.numberOfInvalids() ) {
        // Hide error containers on last error
        this.toHide = this.toHide.add( this.containers );
      }
      this.showErrors();
      return result;
    },

    // http://docs.jquery.com/Plugins/Validation/Validator/showErrors
    showErrors: function(errors) {
      if(errors) {
        // add items to error list and map
        $.extend( this.errorMap, errors );
        this.errorList = [];
        for ( var name in errors ) {
          this.errorList.push({
            message: errors[name],
            element: this.findByName(name)[0]
          });
        }
        // remove items from success list
        this.successList = $.grep( this.successList, function(element) {
          return !(element.name in errors);
        });
      }
      if (this.settings.showErrors) {
        this.settings.showErrors.call( this, this.errorMap, this.errorList );
      } else {
        this.defaultShowErrors();
      }
    },

    // http://docs.jquery.com/Plugins/Validation/Validator/resetForm
    resetForm: function() {
      if ( $.fn.resetForm ) {
        $( this.currentForm ).resetForm();
      }
      this.submitted = {};
      this.lastElement = null;
      this.prepareForm();
      this.hideErrors();
      this.elements().removeClass( this.settings.errorClass ).removeData( "previousValue" );
    },

    numberOfInvalids: function() {
      return this.objectLength(this.invalid);
    },

    objectLength: function( obj ) {
      var count = 0;
      for ( var i in obj ) {
        count++;
      }
      return count;
    },

    hideErrors: function() {
      this.addWrapper( this.toHide ).hide();
    },

    valid: function() {
      return this.size() === 0;
    },

    size: function() {
      return this.errorList.length;
    },

    focusInvalid: function() {
      if( this.settings.focusInvalid ) {
        try {
          $(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])
          .filter(":visible")
          .focus()
          // manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
          .trigger("focusin");
        } catch(e) {
          // ignore IE throwing errors when focusing hidden elements
        }
      }
    },

    findLastActive: function() {
      var lastActive = this.lastActive;
      return lastActive && $.grep(this.errorList, function(n) {
        return n.element.name === lastActive.name;
      }).length === 1 && lastActive;
    },

    elements: function() {
      var validator = this,
        rulesCache = {};

      // select all valid inputs inside the form (no submit or reset buttons)
      return $(this.currentForm)
      .find("input, select, textarea")
      .not(":submit, :reset, :image, [disabled]")
      .not( this.settings.ignore )
      .filter(function() {
        if ( !this.name && validator.settings.debug && window.console ) {
          console.error( "%o has no name assigned", this);
        }

        // select only the first element for each name, and only those with rules specified
        if ( this.name in rulesCache || !validator.objectLength($(this).rules()) ) {
          return false;
        }

        rulesCache[this.name] = true;
        return true;
      });
    },

    clean: function( selector ) {
      return $( selector )[0];
    },

    errors: function() {
      var errorClass = this.settings.errorClass.replace(' ', '.');
      return $( this.settings.errorElement + "." + errorClass, this.errorContext );
    },

    reset: function() {
      this.successList = [];
      this.errorList = [];
      this.errorMap = {};
      this.toShow = $([]);
      this.toHide = $([]);
      this.currentElements = $([]);
    },

    prepareForm: function() {
      this.reset();
      this.toHide = this.errors().add( this.containers );
    },

    prepareElement: function( element ) {
      this.reset();
      this.toHide = this.errorsFor(element);
    },

    elementValue: function( element ) {
      var type = $(element).attr('type'),
        val = $(element).val();

      if ( type === 'radio' || type === 'checkbox' ) {
        return $('input[name="' + $(element).attr('name') + '"]:checked').val();
      }

      if ( typeof val === 'string' ) {
        return val.replace(/\r/g, "");
      }
      return val;
    },

    check: function( element ) {
      element = this.validationTargetFor( this.clean( element ) );

      var rules = $(element).rules();
      var dependencyMismatch = false;
      var val = this.elementValue(element);
      var result;

      for (var method in rules ) {
        var rule = { method: method, parameters: rules[method] };
        try {

          result = $.validator.methods[method].call( this, val, element, rule.parameters );

          // if a method indicates that the field is optional and therefore valid,
          // don't mark it as valid when there are no other rules
          if ( result === "dependency-mismatch" ) {
            dependencyMismatch = true;
            continue;
          }
          dependencyMismatch = false;

          if ( result === "pending" ) {
            this.toHide = this.toHide.not( this.errorsFor(element) );
            return;
          }

          if( !result ) {
            this.formatAndAdd( element, rule );
            return false;
          }
        } catch(e) {
          if ( this.settings.debug && window.console ) {
            console.log("exception occured when checking element " + element.id + ", check the '" + rule.method + "' method", e);
          }
          throw e;
        }
      }
      if (dependencyMismatch) {
        return;
      }
      if ( this.objectLength(rules) ) {
        this.successList.push(element);
      }
      return true;
    },

    // return the custom message for the given element and validation method
    // specified in the element's "messages" metadata
    customMetaMessage: function(element, method) {
      if (!$.metadata) {
        return;
      }
      var meta = this.settings.meta ? $(element).metadata()[this.settings.meta] : $(element).metadata();
      return meta && meta.messages && meta.messages[method];
    },

    // return the custom message for the given element and validation method
    // specified in the element's HTML5 data attribute
    customDataMessage: function(element, method) {
      return $(element).data('msg-' + method.toLowerCase()) || (element.attributes && $(element).attr('data-msg-' + method.toLowerCase()));
    },

    // return the custom message for the given element name and validation method
    customMessage: function( name, method ) {
      var m = this.settings.messages[name];
      return m && (m.constructor === String ? m : m[method]);
    },

    // return the first defined argument, allowing empty strings
    findDefined: function() {
      for(var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) {
          return arguments[i];
        }
      }
      return undefined;
    },

    defaultMessage: function( element, method) {
      return this.findDefined(
        this.customMessage( element.name, method ),
        this.customDataMessage( element, method ),
        this.customMetaMessage( element, method ),
        // title is never undefined, so handle empty string as undefined
        !this.settings.ignoreTitle && element.title || undefined,
        $.validator.messages[method],
        "<strong>Warning: No message defined for " + element.name + "</strong>"
      );
    },

    formatAndAdd: function( element, rule ) {
      var message = this.defaultMessage( element, rule.method ),
        theregex = /\$?\{(\d+)\}/g;
      if ( typeof message === "function" ) {
        message = message.call(this, rule.parameters, element);
      } else if (theregex.test(message)) {
        message = $.validator.format(message.replace(theregex, '{$1}'), rule.parameters);
      }
      this.errorList.push({
        message: message,
        element: element
      });

      this.errorMap[element.name] = message;
      this.submitted[element.name] = message;
    },

    addWrapper: function(toToggle) {
      if ( this.settings.wrapper ) {
        toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
      }
      return toToggle;
    },

    defaultShowErrors: function() {
      var i, elements;
      for ( i = 0; this.errorList[i]; i++ ) {
        var error = this.errorList[i];
        if ( this.settings.highlight ) {
          this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
        }
        this.showLabel( error.element, error.message );
      }
      if( this.errorList.length ) {
        this.toShow = this.toShow.add( this.containers );
      }
      if (this.settings.success) {
        for ( i = 0; this.successList[i]; i++ ) {
          this.showLabel( this.successList[i] );
        }
      }
      if (this.settings.unhighlight) {
        for ( i = 0, elements = this.validElements(); elements[i]; i++ ) {
          this.settings.unhighlight.call( this, elements[i], this.settings.errorClass, this.settings.validClass );
        }
      }
      this.toHide = this.toHide.not( this.toShow );
      this.hideErrors();
      this.addWrapper( this.toShow ).show();
    },

    validElements: function() {
      return this.currentElements.not(this.invalidElements());
    },

    invalidElements: function() {
      return $(this.errorList).map(function() {
        return this.element;
      });
    },

    showLabel: function(element, message) {
      var label = this.errorsFor( element );
      if ( label.length ) {
        // refresh error/success class
        label.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );

        // check if we have a generated label, replace the message then
        if ( label.attr("generated") ) {
          label.html(message);
        }
      } else {
        // create label
        label = $("<" + this.settings.errorElement + "/>")
          .attr({"for":  this.idOrName(element), generated: true})
          .addClass(this.settings.errorClass)
          .html(message || "");
        if ( this.settings.wrapper ) {
          // make sure the element is visible, even in IE
          // actually showing the wrapped element is handled elsewhere
          label = label.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
        }
        if ( !this.labelContainer.append(label).length ) {
          if ( this.settings.errorPlacement ) {
            this.settings.errorPlacement(label, $(element) );
          } else {
          label.insertAfter(element);
          }
        }
      }
      if ( !message && this.settings.success ) {
        label.text("");
        if ( typeof this.settings.success === "string" ) {
          label.addClass( this.settings.success );
        } else {
          this.settings.success( label, element );
        }
      }
      this.toShow = this.toShow.add(label);
    },

    errorsFor: function(element) {
      var name = this.idOrName(element);
      return this.errors().filter(function() {
        return $(this).attr('for') === name;
      });
    },

    idOrName: function(element) {
      return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
    },

    validationTargetFor: function(element) {
      // if radio/checkbox, validate first element in group instead
      if (this.checkable(element)) {
        element = this.findByName( element.name ).not(this.settings.ignore)[0];
      }
      return element;
    },

    checkable: function( element ) {
      return (/radio|checkbox/i).test(element.type);
    },

    findByName: function( name ) {
      return $(this.currentForm).find('[name="' + name + '"]');
    },

    getLength: function(value, element) {
      switch( element.nodeName.toLowerCase() ) {
      case 'select':
        return $("option:selected", element).length;
      case 'input':
        if( this.checkable( element) ) {
          return this.findByName(element.name).filter(':checked').length;
        }
      }
      return value.length;
    },

    depend: function(param, element) {
      return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;
    },

    dependTypes: {
      "boolean": function(param, element) {
        return param;
      },
      "string": function(param, element) {
        return !!$(param, element.form).length;
      },
      "function": function(param, element) {
        return param(element);
      }
    },

    optional: function(element) {
      var val = this.elementValue(element);
      return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
    },

    startRequest: function(element) {
      if (!this.pending[element.name]) {
        this.pendingRequest++;
        this.pending[element.name] = true;
      }
    },

    stopRequest: function(element, valid) {
      this.pendingRequest--;
      // sometimes synchronization fails, make sure pendingRequest is never < 0
      if (this.pendingRequest < 0) {
        this.pendingRequest = 0;
      }
      delete this.pending[element.name];
      if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {
        $(this.currentForm).submit();
        this.formSubmitted = false;
      } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {
        $(this.currentForm).triggerHandler("invalid-form", [this]);
        this.formSubmitted = false;
      }
    },

    previousValue: function(element) {
      return $.data(element, "previousValue") || $.data(element, "previousValue", {
        old: null,
        valid: true,
        message: this.defaultMessage( element, "remote" )
      });
    }

  },

  classRuleSettings: {
    required: {required: true},
    email: {email: true},
    url: {url: true},
    date: {date: true},
    dateISO: {dateISO: true},
    number: {number: true},
    digits: {digits: true},
    creditcard: {creditcard: true}
  },

  addClassRules: function(className, rules) {
    if ( className.constructor === String ) {
      this.classRuleSettings[className] = rules;
    } else {
      $.extend(this.classRuleSettings, className);
    }
  },

  classRules: function(element) {
    var rules = {};
    var classes = $(element).attr('class');
    if ( classes ) {
      $.each(classes.split(' '), function() {
        if (this in $.validator.classRuleSettings) {
          $.extend(rules, $.validator.classRuleSettings[this]);
        }
      });
    }
    return rules;
  },

  attributeRules: function(element) {
    var rules = {};
    var $element = $(element);

    for (var method in $.validator.methods) {
      var value;

      // support for <input required> in both html5 and older browsers
      if (method === 'required') {
        value = $element.get(0).getAttribute(method);
        // Some browsers return an empty string for the required attribute
        // and non-HTML5 browsers might have required="" markup
        if (value === "") {
          value = true;
        }
        // force non-HTML5 browsers to return bool
        value = !!value;
      } else {
        value = $element.attr(method);
      }

      if (value) {
        rules[method] = value;
      } else if ($element[0].getAttribute("type") === method) {
        rules[method] = true;
      }
    }

    // maxlength may be returned as -1, 2147483647 (IE) and 524288 (safari) for text inputs
    if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
      delete rules.maxlength;
    }

    return rules;
  },

  metadataRules: function(element) {
    if (!$.metadata) {
      return {};
    }

    var meta = $.data(element.form, 'validator').settings.meta;
    return meta ?
      $(element).metadata()[meta] :
      $(element).metadata();
  },

  staticRules: function(element) {
    var rules = {};
    var validator = $.data(element.form, 'validator');
    if (validator.settings.rules) {
      rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
    }
    return rules;
  },

  normalizeRules: function(rules, element) {
    // handle dependency check
    $.each(rules, function(prop, val) {
      // ignore rule when param is explicitly false, eg. required:false
      if (val === false) {
        delete rules[prop];
        return;
      }
      if (val.param || val.depends) {
        var keepRule = true;
        switch (typeof val.depends) {
          case "string":
            keepRule = !!$(val.depends, element.form).length;
            break;
          case "function":
            keepRule = val.depends.call(element, element);
            break;
        }
        if (keepRule) {
          rules[prop] = val.param !== undefined ? val.param : true;
        } else {
          delete rules[prop];
        }
      }
    });

    // evaluate parameters
    $.each(rules, function(rule, parameter) {
      rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;
    });

    // clean number parameters
    $.each(['minlength', 'maxlength', 'min', 'max'], function() {
      if (rules[this]) {
        rules[this] = Number(rules[this]);
      }
    });
    $.each(['rangelength', 'range'], function() {
      if (rules[this]) {
        rules[this] = [Number(rules[this][0]), Number(rules[this][1])];
      }
    });

    if ($.validator.autoCreateRanges) {
      // auto-create ranges
      if (rules.min && rules.max) {
        rules.range = [rules.min, rules.max];
        delete rules.min;
        delete rules.max;
      }
      if (rules.minlength && rules.maxlength) {
        rules.rangelength = [rules.minlength, rules.maxlength];
        delete rules.minlength;
        delete rules.maxlength;
      }
    }

    // To support custom messages in metadata ignore rule methods titled "messages"
    if (rules.messages) {
      delete rules.messages;
    }

    return rules;
  },

  // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
  normalizeRule: function(data) {
    if( typeof data === "string" ) {
      var transformed = {};
      $.each(data.split(/\s/), function() {
        transformed[this] = true;
      });
      data = transformed;
    }
    return data;
  },

  // http://docs.jquery.com/Plugins/Validation/Validator/addMethod
  addMethod: function(name, method, message) {
    $.validator.methods[name] = method;
    $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];
    if (method.length < 3) {
      $.validator.addClassRules(name, $.validator.normalizeRule(name));
    }
  },

  methods: {

    // http://docs.jquery.com/Plugins/Validation/Methods/required
    required: function(value, element, param) {
      // check if dependency is met
      if ( !this.depend(param, element) ) {
        return "dependency-mismatch";
      }
      if ( element.nodeName.toLowerCase() === "select" ) {
        // could be an array for select-multiple or a string, both are fine this way
        var val = $(element).val();
        return val && val.length > 0;
      }
      if ( this.checkable(element) ) {
        return this.getLength(value, element) > 0;
      }
      return $.trim(value).length > 0;
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/remote
    remote: function(value, element, param) {
      if ( this.optional(element) ) {
        return "dependency-mismatch";
      }

      var previous = this.previousValue(element);
      if (!this.settings.messages[element.name] ) {
        this.settings.messages[element.name] = {};
      }
      previous.originalMessage = this.settings.messages[element.name].remote;
      this.settings.messages[element.name].remote = previous.message;

      param = typeof param === "string" && {url:param} || param;

      if ( previous.old === value ) {
        return previous.valid;
      }

      previous.old = value;
      var validator = this;
      this.startRequest(element);
      var data = {};
      data[element.name] = value;
      $.ajax($.extend(true, {
        url: param,
        mode: "abort",
        port: "validate" + element.name,
        dataType: "json",
        data: data,
        success: function(response) {
          validator.settings.messages[element.name].remote = previous.originalMessage;
          var valid = response === true || response === "true";
          if ( valid ) {
            var submitted = validator.formSubmitted;
            validator.prepareElement(element);
            validator.formSubmitted = submitted;
            validator.successList.push(element);
            delete validator.invalid[element.name];
            validator.showErrors();
          } else {
            var errors = {};
            var message = response || validator.defaultMessage( element, "remote" );
            errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;
            validator.invalid[element.name] = true;
            validator.showErrors(errors);
          }
          previous.valid = valid;
          validator.stopRequest(element, valid);
        }
      }, param));
      return "pending";
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/minlength
    minlength: function(value, element, param) {
      var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);
      return this.optional(element) || length >= param;
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/maxlength
    maxlength: function(value, element, param) {
      var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);
      return this.optional(element) || length <= param;
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/rangelength
    rangelength: function(value, element, param) {
      var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);
      return this.optional(element) || ( length >= param[0] && length <= param[1] );
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/min
    min: function( value, element, param ) {
      return this.optional(element) || value >= param;
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/max
    max: function( value, element, param ) {
      return this.optional(element) || value <= param;
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/range
    range: function( value, element, param ) {
      return this.optional(element) || ( value >= param[0] && value <= param[1] );
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/email
    email: function(value, element) {
      // contributed by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/
      return this.optional(element) || /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(value);
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/url
    url: function(value, element) {
      // contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
      return this.optional(element) || /^((https?|ftp):\/\/)?(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/date
    date: function(value, element) {
      return this.optional(element) || !/Invalid|NaN/.test(new Date(value));
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/dateISO
    dateISO: function(value, element) {
      return this.optional(element) || /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/.test(value);
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/number
    number: function(value, element) {
      return this.optional(element) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/digits
    digits: function(value, element) {
      return this.optional(element) || /^\d+$/.test(value);
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/creditcard
    // based on http://en.wikipedia.org/wiki/Luhn
    creditcard: function(value, element) {
      if ( this.optional(element) ) {
        return "dependency-mismatch";
      }
      // accept only spaces, digits and dashes
      if (/[^0-9 \-]+/.test(value)) {
        return false;
      }
      var nCheck = 0,
        nDigit = 0,
        bEven = false;

      value = value.replace(/\D/g, "");

      for (var n = value.length - 1; n >= 0; n--) {
        var cDigit = value.charAt(n);
        nDigit = parseInt(cDigit, 10);
        if (bEven) {
          if ((nDigit *= 2) > 9) {
            nDigit -= 9;
          }
        }
        nCheck += nDigit;
        bEven = !bEven;
      }

      return (nCheck % 10) === 0;
    },

    // http://docs.jquery.com/Plugins/Validation/Methods/equalTo
    equalTo: function(value, element, param) {
      // bind to the blur event of the target in order to revalidate whenever the target field is updated
      // TODO find a way to bind the event just once, avoiding the unbind-rebind overhead
      var target = $(param);
      if (this.settings.onfocusout) {
        target.unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
          $(element).valid();
        });
      }
      return value === target.val();
    }

  }

});

// deprecated, use $.validator.format instead
$.format = $.validator.format;

}(jQuery));

// ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()
(function($) {
  var pendingRequests = {};
  // Use a prefilter if available (1.5+)
  if ( $.ajaxPrefilter ) {
    $.ajaxPrefilter(function(settings, _, xhr) {
      var port = settings.port;
      if (settings.mode === "abort") {
        if ( pendingRequests[port] ) {
          pendingRequests[port].abort();
        }
        pendingRequests[port] = xhr;
      }
    });
  } else {
    // Proxy ajax
    var ajax = $.ajax;
    $.ajax = function(settings) {
      var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
        port = ( "port" in settings ? settings : $.ajaxSettings ).port;
      if (mode === "abort") {
        if ( pendingRequests[port] ) {
          pendingRequests[port].abort();
        }
        return (pendingRequests[port] = ajax.apply(this, arguments));
      }
      return ajax.apply(this, arguments);
    };
  }
}(jQuery));

// provides cross-browser focusin and focusout events
// IE has native support, in other browsers, use event caputuring (neither bubbles)

// provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation
// handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target
(function($) {
  // only implement if not provided by jQuery core (since 1.4)
  // TODO verify if jQuery 1.4's implementation is compatible with older jQuery special-event APIs
  if (!jQuery.event.special.focusin && !jQuery.event.special.focusout && document.addEventListener) {
    $.each({
      focus: 'focusin',
      blur: 'focusout'
    }, function( original, fix ){
      $.event.special[fix] = {
        setup:function() {
          this.addEventListener( original, handler, true );
        },
        teardown:function() {
          this.removeEventListener( original, handler, true );
        },
        handler: function(e) {
          var args = arguments;
          args[0] = $.event.fix(e);
          args[0].type = fix;
          return $.event.handle.apply(this, args);
        }
      };
      function handler(e) {
        e = $.event.fix(e);
        e.type = fix;
        return $.event.handle.call(this, e);
      }
    });
  }
  $.extend($.fn, {
    validateDelegate: function(delegate, type, handler) {
      return this.bind(type, function(event) {
        var target = $(event.target);
        if (target.is(delegate)) {
          return handler.apply(target, arguments);
        }
      });
    }
  });
}(jQuery));


// assets/js/bundle/third_party/jquery/jcarousellite.js
goog.provide("optly.jquery.jcarousellite");

goog.require("optly.jquery");

// Extended version from: http://origin1tech.wordpress.com/2011/08/14/jcarousellite-extended-carousel-slider-with-paging-nfl-com-style/
// - Pause the slide when hovered.
// - Add paging that was simple and customizable via css.
// - At the end of the last slide go to the first slide.

/**
 * jCarouselLite - jQuery plugin to navigate images/any content in a carousel style widget.
 * @requires jQuery v1.2 or above
 *
 * http://gmarwaha.com/jquery/jcarousellite/
 *
 * Copyright (c) 2007 Ganeshji Marwaha (gmarwaha.com)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Version: 1.0.1
 * Note: Requires jquery 1.2 or above from version 1.0.1
 */

/**
 * Creates a carousel-style navigation widget for images/any-content from a simple HTML markup.
 *
 * The HTML markup that is used to build the carousel can be as simple as...
 *
 *  <div class="carousel">
 *      <ul>
 *          <li><img src="image/1.jpg" alt="1"></li>
 *          <li><img src="image/2.jpg" alt="2"></li>
 *          <li><img src="image/3.jpg" alt="3"></li>
 *      </ul>
 *  </div>
 *
 * As you can see, this snippet is nothing but a simple div containing an unordered list of images.
 * You don't need any special "class" attribute, or a special "css" file for this plugin.
 * I am using a class attribute just for the sake of explanation here.
 *
 * To navigate the elements of the carousel, you need some kind of navigation buttons.
 * For example, you will need a "previous" button to go backward, and a "next" button to go forward.
 * This need not be part of the carousel "div" itself. It can be any element in your page.
 * Lets assume that the following elements in your document can be used as next, and prev buttons...
 *
 * <button class="prev">&lt;&lt;</button>
 * <button class="next">&gt;&gt;</button>
 *
 * Now, all you need to do is call the carousel component on the div element that represents it, and pass in the
 * navigation buttons as options.
 *
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev"
 * });
 *
 * That's it, you would have now converted your raw div, into a magnificient carousel.
 *
 * There are quite a few other options that you can use to customize it though.
 * Each will be explained with an example below.
 *
 * @param an options object - You can specify all the options shown below as an options object param.
 *
 * @option btnPrev, btnNext : string - no defaults
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev"
 * });
 * @desc Creates a basic carousel. Clicking "btnPrev" navigates backwards and "btnNext" navigates forward.
 *
 * @option btnGo - array - no defaults
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      btnGo: [".0", ".1", ".2"]
 * });
 * @desc If you don't want next and previous buttons for navigation, instead you prefer custom navigation based on
 * the item number within the carousel, you can use this option. Just supply an array of selectors for each element
 * in the carousel. The index of the array represents the index of the element. What i mean is, if the
 * first element in the array is ".0", it means that when the element represented by ".0" is clicked, the carousel
 * will slide to the first element and so on and so forth. This feature is very powerful. For example, i made a tabbed
 * interface out of it by making my navigation elements styled like tabs in css. As the carousel is capable of holding
 * any content, not just images, you can have a very simple tabbed navigation in minutes without using any other plugin.
 * The best part is that, the tab will "slide" based on the provided effect. :-)
 *
 * @option mouseWheel : boolean - default is false
 * @example
 * $(".carousel").jCarouselLite({
 *      mouseWheel: true
 * });
 * @desc The carousel can also be navigated using the mouse wheel interface of a scroll mouse instead of using buttons.
 * To get this feature working, you have to do 2 things. First, you have to include the mouse-wheel plugin from brandon.
 * Second, you will have to set the option "mouseWheel" to true. That's it, now you will be able to navigate your carousel
 * using the mouse wheel. Using buttons and mouseWheel or not mutually exclusive. You can still have buttons for navigation
 * as well. They complement each other. To use both together, just supply the options required for both as shown below.
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      mouseWheel: true
 * });
 *
 * @option auto : number - default is null, meaning autoscroll is disabled by default
 * @example
 * $(".carousel").jCarouselLite({
 *      auto: 800,
 *      speed: 500
 * });
 * @desc You can make your carousel auto-navigate itself by specfying a millisecond value in this option.
 * The value you specify is the amount of time between 2 slides. The default is null, and that disables auto scrolling.
 * Specify this value and magically your carousel will start auto scrolling.
 *
 * @option speed : number - 200 is default
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      speed: 800
 * });
 * @desc Specifying a speed will slow-down or speed-up the sliding speed of your carousel. Try it out with
 * different speeds like 800, 600, 1500 etc. Providing 0, will remove the slide effect.
 *
 * @option easing : string - no easing effects by default.
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      easing: "bounceout"
 * });
 * @desc You can specify any easing effect. Note: You need easing plugin for that. Once specified,
 * the carousel will slide based on the provided easing effect.
 *
 * @option vertical : boolean - default is false
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      vertical: true
 * });
 * @desc Determines the direction of the carousel. true, means the carousel will display vertically. The next and
 * prev buttons will slide the items vertically as well. The default is false, which means that the carousel will
 * display horizontally. The next and prev items will slide the items from left-right in this case.
 *
 * @option circular : boolean - default is true
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      circular: false
 * });
 * @desc Setting it to true enables circular navigation. This means, if you click "next" after you reach the last
 * element, you will automatically slide to the first element and vice versa. If you set circular to false, then
 * if you click on the "next" button after you reach the last element, you will stay in the last element itself
 * and similarly for "previous" button and first element.
 *
 * @option visible : number - default is 3
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      visible: 4
 * });
 * @desc This specifies the number of items visible at all times within the carousel. The default is 3.
 * You are even free to experiment with real numbers. Eg: "3.5" will have 3 items fully visible and the
 * last item half visible. This gives you the effect of showing the user that there are more images to the right.
 *
 * @option start : number - default is 0
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      start: 2
 * });
 * @desc You can specify from which item the carousel should start. Remember, the first item in the carousel
 * has a start of 0, and so on.
 *
 * @option scrool : number - default is 1
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      scroll: 2
 * });
 * @desc The number of items that should scroll/slide when you click the next/prev navigation buttons. By
 * default, only one item is scrolled, but you may set it to any number. Eg: setting it to "2" will scroll
 * 2 items when you click the next or previous buttons.
 *
 * @option beforeStart, afterEnd : function - callbacks
 * @example
 * $(".carousel").jCarouselLite({
 *      btnNext: ".next",
 *      btnPrev: ".prev",
 *      beforeStart: function(a) {
 *          alert("Before animation starts:" + a);
 *      },
 *      afterEnd: function(a) {
 *          alert("After animation ends:" + a);
 *      }
 * });
 * @desc If you wanted to do some logic in your page before the slide starts and after the slide ends, you can
 * register these 2 callbacks. The functions will be passed an argument that represents an array of elements that
 * are visible at the time of callback.
 *
 *
 * @cat Plugins/Image Gallery
 * @author Ganeshji Marwaha/ganeshread@gmail.com
 */

(function ($) {                                          // Compliant with jquery.noConflict()
    $.fn.jCarouselLite = function (o) {
        o = $.extend({
            btnPrev: null,
            btnNext: null,
            btnGo: null,
            mouseWheel: false,
            auto: null,

            speed: 200,
            easing: null,

            vertical: false,
            circular: true,
            visible: 1,
            start: 0,
            scroll: 1,

            beforeStart: null,
            afterEnd: null,

            //Begin Custom Options
            onEndFirst: false, // circular must be set to false.
            pauseOnHover: false,
            showPager: false, // indicates whether to show the pager.
            pager: 'pager' // the class that will be used.

        }, o || {});

        return this.each(function () {  // Returns the element collection. Chainable.

            var running, animCss, sizeCss, div, ul, tLi, tl, v, li, liSize, ulSize, divSize, itemLength, curr,
            isPause, pagerDiv, pagerUl, pagerGo, pagerPages, pagerPage, pagerStart, pagerPageInt; // These are custom vars.

            //////////////// BEGIN CUSTOM CODE //////////////
            // We need to set the pager to the start page before the orig.
            // card mucks with it if a circular concept is used.
            // Note you could use some of the existing vars however
            // I chose to use new so as to better keep the existing
            // code unused or touched.
            pagerStart = o.start;
            pagerPageInt = pagerStart;

            // Simply warns you in the console if you've accidentially enabled
            // both circular and onEndFirst.
            if (o.onEndFirst && o.circular)
                console.log('Please diable either circular or onEndFirst. Both cannot be enabled.');
            /////////////// END CUSTOM CODE /////////////////

            running = false, animCss = o.vertical ? "top" : "left", sizeCss = o.vertical ? "height" : "width";
            div = $(this), ul = $("ul", div), tLi = $("li", ul), tl = tLi.size(), v = o.visible;

            if (o.circular) {
                ul.prepend(tLi.slice(tl - v - 1 + 1).clone())
                .append(tLi.slice(0, v).clone());
                o.start += v;
            }

            li = $("li", ul), itemLength = li.size(), curr = o.start;
            div.css("visibility", "visible");

            li.css({ overflow: "hidden", 'float': o.vertical ? "none" : "left" });
            ul.css({ margin: "0", padding: "0", position: "relative", "list-style-type": "none", "z-index": "1" });
            div.css({ overflow: "hidden", position: "relative", "z-index": "2", left: "0px" });

            liSize = o.vertical ? height(li) : width(li);   // Full li size(incl margin)-Used for animation
            ulSize = liSize * itemLength;                   // size of full ul(total length, not just for the visible items)
            divSize = liSize * v;                           // size of entire div(total length for just the visible items)

            li.css({ width: li.width(), height: li.height() });
            ul.css(sizeCss, ulSize + "px").css(animCss, -(curr * liSize));

            div.css(sizeCss, divSize + "px");                     // Width of the DIV. length of visible images

            ///////////////////////////////////////////////////////////////////
            /////////////////////// BEGIN CUSTOM CODE /////////////////////////
            ///////////////////////////////////////////////////////////////////

            isPause = false;
            pagerGo = null;
            pagerPage = '.' + (pagerStart += '');
            pagerPages = tl;

            if (o.pauseOnHover) {
                div.hover(
                function () {
                    isPause = true;
                },
                function () {
                    isPause = false;
                });
            }

            if (o.showPager) {
                // Add the Ul element.
                pagerUl = $('<ul></ul>');
                pagerGo = new Array();
                // For each carousel item add a pager
                // button.

                //for (i = 0; i < pagerPages; i++) { // This if uncommented will result in items floating in wrong order.
                  for( i = pagerPages - 1; i >=0; i--){ // We interate in rev. as we need to float in IE otherwise we won't line up right.
                    var pagerLi = $('<li></li>');
                    pagerGo[i] = ('.' + (i += '')); // Add selected for pager li navigation.
                    pagerLi.addClass(i += ''); // Convert index to string.
                    if (i == pagerStart)
                        pagerLi.addClass('selected');
                    pagerLi.appendTo(pagerUl);
                }

                // Create the page Div add style
                pagerDiv = $('<div></div>');
                pagerDiv.addClass(o.pager);
                pagerDiv.css({ 'z-index': '3' });

                // Add pagerUl to pagerDiv.
                pagerUl.appendTo(pagerDiv);

                // Add the pager to the carousel.
                pagerDiv.appendTo(div);

                // When the pager is hovered over make sure
                // isPause is false.
                pagerDiv.hover(
                    function () {
                        isPause = false;
                    },
                    function () {
                        isPause = false;
                    });
            }

            ///////////////////////////////////////////////////////////////////
            //////////////////////// END CUSTOM CODE //////////////////////////
            ///////////////////////////////////////////////////////////////////


            if (o.btnPrev)
                $(o.btnPrev).click(function () {
                    return go(curr - o.scroll);
                });

            if (o.btnNext)
                $(o.btnNext).click(function () {
                    return go(curr + o.scroll);
                });

            if (o.btnGo)
                $.each(o.btnGo, function (i, val) {
                    $(val).click(function () {
                        return go(o.circular ? o.visible + i : i);
                    });
                });

            if (o.showPager && pagerGo)
                $.each(pagerGo, function (i, val) {
                    $(val).click(function () {
                        return go(o.circular ? o.visible + i : i);
                    });
                });

            if (o.mouseWheel && div.mousewheel)
                div.mousewheel(function (e, d) {
                    return d > 0 ? go(curr - o.scroll) : go(curr + o.scroll);
                });

            if (o.auto)
                setInterval(function () {
                    go(curr + o.scroll);
                }, o.auto + o.speed);

            function vis() {
                return li.slice(curr).slice(0, v);
            };

            function go(to) {
                if (!running && !isPause) {
                    if (o.beforeStart)
                        o.beforeStart.call(this, vis());
                    ////////////// CUSTOM PAGER CODE ///////////////
                    function setPagerPage(currPage) {
                        if (o.showPager) {
                            pagerUl.children('li' + pagerPage).removeClass('selected'); // Clear all selected classes.
                            if (o.circular) {
                                currPage -= 1;
                                itemLength - 2 == currPage ? pagerPage = '.0' : pagerPage = '.' + currPage.toString();
                            } else if (o.onEndFirst)
                                currPage == 0 ? pagerPage = '.0' : pagerPage = '.' + currPage.toString();
                             else
                                return;  // nothing to do here just return, as the carousel is stopping.

                            // Set the selected page indicator.
                            pagerUl.children('li' + pagerPage).addClass('selected'); // Add the selected class.
                        }
                    }
                    ////////////// END PAGER CODE ///////////////
                    if (o.circular) {            // If circular we are in first or last, then goto the other end
                        if (to <= o.start - v - 1) {           // If first, then goto last
                            ul.css(animCss, -((itemLength - (v * 2)) * liSize) + "px");
                            // If "scroll" > 1, then the "to" might not be equal to the condition; it can be lesser depending on the number of elements.
                            curr = to == o.start - v - 1 ? itemLength - (v * 2) - 1 : itemLength - (v * 2) - o.scroll;
                            setPagerPage(curr); // Custom code.
                        } else if (to >= itemLength - v + 1) { // If last, then goto first
                            ul.css(animCss, -((v) * liSize) + "px");
                            // If "scroll" > 1, then the "to" might not be equal to the condition; it can be greater depending on the number of elements.
                            curr = to == itemLength - v + 1 ? v + 1 : v + o.scroll;
                            setPagerPage(curr); // Custom code.
                        } else {
                            curr = to;
                            setPagerPage(curr); // Custom code.
                        }

                    } else { // If non-circular and to points to first or last, we just return.
                        if (o.onEndFirst && to > itemLength - v) {
                            curr = 0;
                            setPagerPage(curr); // Custom code.
                        }
                        else {
                            if (to < 0 || to > itemLength - v) return; //original code start here.
                            curr = to;        // If neither overrides it, the curr will still be "to" and we can proceed. End original code
                            setPagerPage(curr); // Custom Code.
                        }
                    }

                    running = true;

                    ul.animate(
                    animCss == "left" ? { left: -(curr * liSize)} : { top: -(curr * liSize) }, o.speed, o.easing,
                    function () {
                        if (o.afterEnd)
                            o.afterEnd.call(this, vis());
                        running = false;
                    }
                );
                    // Disable buttons when the carousel reaches the last/first, and enable when not
                    if (!o.circular) {
                        $(o.btnPrev + "," + o.btnNext).removeClass("disabled");
                        $((curr - o.scroll < 0 && o.btnPrev)
                        ||
                       (curr + o.scroll > itemLength - v && o.btnNext)
                        ||
                       []
                     ).addClass("disabled");
                    }
                }
                return false;
            };
        });
    };

    function css(el, prop) {
        return parseInt($.css(el[0], prop)) || 0;
    };
    function width(el) {
        return el[0].offsetWidth + css(el, 'marginLeft') + css(el, 'marginRight');
    };
    function height(el) {
        return el[0].offsetHeight + css(el, 'marginTop') + css(el, 'marginBottom');
    };

})(jQuery);


// assets/js/bundle/form.js
goog.provide("optly.Form");

/**
 * @constructor
 */
optly.Form = function(options) {
  var defaultOptions = {
    ajaxMethod: 'GET', // Optional
    context: undefined, // Required
    errorClass: undefined, // Optional
    errorElement: undefined, // Optional
    errorPlacement: undefined, // Optional
    onComplete: goog.nullFunction, // Optional
    onError: goog.nullFunction, // Optional
    onSubmit: goog.nullFunction, // Optional
    onSuccess: goog.nullFunction, // Optional
    rules: {} // Optional
  };

  this.options = $.extend({}, defaultOptions, options);

  this.buttons = $(".button, .primary-button, .secondary-button", this.options.context);
  this.closers = $(".jqmClose", this.options.context);
  this.form = $("form", this.options.context);
  this.inputs = $("input, select", this.options.context);
  this.isSubmitting = false;
  this.submittingMessage = "";
  this.status = $("#status", this.options.context);

  this.formValidator = this.form.validate({
    errorClass: this.options.errorClass,
    errorElement: this.options.errorElement,
    errorPlacement: this.options.errorPlacement,
    rules: this.options.rules,
    ignore: ".ignore :input"
  });

  this.form.ajaxForm({
    beforeSubmit: goog.bind(this.handleBeforeSubmit, this),
    complete: goog.bind(this.handleComplete, this),
    dataType: "json",
    error: goog.bind(this.handleError, this),
    success: goog.bind(this.handleSuccess, this)
  });

  this.closers.click(goog.bind(this.handleClose, this));
};

optly.Form.prototype.reset = function() {
  this.formValidator.resetForm();
};

optly.Form.prototype.valid = function() {
  return this.form.valid();
};

/**
 * @param {Object} formData
 * @private
 */
optly.Form.prototype.handleBeforeSubmit = function(formData) {
  if (this.form.hasClass(DISABLED_CLASS)) {
    return false;
  }

  var valid = !this.isSubmitting
              && this.options.onSubmit(formData) !== false
              && this.form.valid();

  if (valid) {
    this.buttons.addClass("disabled_button") // legacy
      .addClass(DISABLED_CLASS);
    this.toggleInputs(false);
    this.status.html(this.submittingMessage);
    this.isSubmitting = true;
  }

  return valid;
};

/**
 * @param {Object} event
 * @private
 */
optly.Form.prototype.handleClose = function(event) {
  if (this.isSubmitting) {
    event.stopImmediatePropagation();
  }
};

/**
 * @private
 */
optly.Form.prototype.handleComplete = function() {
  this.buttons.removeClass("disabled_button")  // legacy
    .removeClass(DISABLED_CLASS);

  if (!this.form.hasClass(DISABLED_CLASS)) {
    this.toggleInputs(true);
  }

  this.status.html("");
  this.options.onComplete();
};

/**
 * @private
 */
optly.Form.prototype.handleError = function(jqXHR) {
  this.isSubmitting = false;

  var data = null;
  try {
    data = $.parseJSON(jqXHR.responseText);
  } catch(e) {
    data = {error:data}
  }

  this.options.onError(data);
};

/**
 * @param {Object} data
 * @private
 */
optly.Form.prototype.handleSuccess = function(data) {
  this.isSubmitting = false;

  if (data.succeeded === false) {
    this.options.onError(data);
  } else {
    this.options.onSuccess(data);
  }
};

/**
 * @private
 * @return {string}
 */
optly.Form.prototype.getActionUrl = function() {
  // from optly.jquery.form
  var action = this.form.attr('action');
  var url = (typeof action === 'string') ? $.trim(action) : '';

  if (url) {
    // clean url (don't include hash vaue)
    url = (url.match(/^([^#]+)/)||[])[1];
  }

  return url;
};

/**
 *
 * @param {*} formData
 * @param {Object=} options
 */
optly.Form.prototype.submitFormData = function(formData, options) {
  var url;
  if (options.url) {
    url = options.url;
  } else {
    url = this.getActionUrl();
  }

  var defaultOptions = {
    complete: goog.bind(this.handleComplete, this),
    data: formData,
    dataType: "json",
    error: goog.bind(this.handleError, this),
    success: goog.bind(this.handleSuccess, this),
    type: this.options.ajaxMethod,
    url: url
  };

  var ajaxOptions = $.extend({}, defaultOptions, options);

  $.ajax(ajaxOptions);
};

/**
 * Enable or disable the form.
 *
 * @param {boolean} toggle
 */
optly.Form.prototype.toggleForm = function(toggle) {
  this.form.toggleClass(DISABLED_CLASS, !toggle);
  this.toggleInputs(toggle);
};

/**
 * @param {boolean} toggle
 */
optly.Form.prototype.toggleInputs = function(toggle) {
  if (toggle) {
    this.inputs.removeClass(DISABLED_CLASS)
      .removeAttr("disabled");
  }
  else {
    this.inputs.addClass(DISABLED_CLASS)
      .attr("disabled", "disabled");
  }
};


// assets/js/bundle/dialog.js
goog.provide("optly.Dialog");

goog.require("optly.Form");

/**
 * @constructor
 */
optly.Dialog = function(options) {
  var defaultOptions = {
    afterHide: undefined, // Optional
    ajaxMethod: 'GET', // Optional
    context: undefined, // Required
    errorClass: "optimizely_form_error", // Optional
    errorElement: undefined, // Optional
    errorMessage: tr("An error occurred."), // Optional
    hasForm: true, // Optional
    resetForm: true, // Optional: form will be reset when dialog is shown
    onComplete: goog.nullFunction, // Optional
    onSubmit: goog.nullFunction, // Optional
    onSuccess: goog.nullFunction, // Optional
    rules: undefined, // Optional
    width: undefined // Optional
  };

  this.options = $.extend({}, defaultOptions, options);

  this.message = $(".optimizely_error, .message", this.options.context);
  this.window = $(".dialog", this.options.context);

  // Some dialogs have a container class that allows scrolling of dialog.
  var container = this.window.closest(".dialog-container");
  if (container.length > 0) {
    this.window = container;

    // Hide the modal when its container is clicked. The overlay click event
    // doesn't close it because the container is on top of it.
    $(container).click(function(e) {
      if ($(e.target).hasClass("dialog-container")) {
        container.jqmHide();
      }
    });
  }

  if (this.options.hasForm) {
    this.form = new optly.Form({
      ajaxMethod: this.options.ajaxMethod,
      context: this.options.context,
      errorClass: this.options.errorClass,
      errorElement: this.options.errorElement,
      errorPlacement: function(error, element) {
        error.insertBefore(element);
      },
      onComplete: this.options.onComplete,
      onError: goog.bind(this.handleError, this),
      onSubmit: goog.bind(this.handleSubmit, this),
      onSuccess: goog.bind(this.handleSuccess, this),
      rules: this.options.rules
    });
  }

  this.window.jqm({
    afterHide: goog.bind(this.handleAfterHide, this),
    beforeHide: goog.bind(this.handleBeforeHide, this),
    overlayCloses: true
  });

  if (this.options.width) {
    this.window.css({
      'margin-left': this.options.width / -2 + "px",
      width: this.options.width + "px"
    });
  }
};

optly.Dialog.prototype.dismiss = function() {
  this.window.jqmHide();
};

/**
 * @param {Object} data
 */
optly.Dialog.prototype.handleError = function(data) {
  var errorMessage = this.options.errorMessage;

  if (data && data['error']) {
    errorMessage = data['error'];
  }

  this.message.addClass(this.options.errorClass)
    .html(errorMessage)
    .show();
};

/**
 * If a dialog was shown inside .dialog-container, then need to show
 * page's scroll bars after hiding the dialog.
 *
 * @private
 */
optly.Dialog.prototype.handleAfterHide = function() {
  $("html").removeClass(DIALOG_SHOWN_CLASS);

  if (this.options.afterHide) {
    this.options.afterHide();
  }
};

/**
 * @param {Object} hash
 */
optly.Dialog.prototype.handleBeforeHide = function(hash) {
  return !this.options.hasForm || !this.form.isSubmitting;
};

/**
 * @param {Object} formData
 */
optly.Dialog.prototype.handleSubmit = function(formData) {
  this.message.hide();
  return this.options.onSubmit(formData);
};

/**
 * @param {Object} data
 */
optly.Dialog.prototype.handleSuccess = function(data) {
  this.dismiss();
  this.options.onSuccess(data);
};

/**
 * @param {...*} var_args
 */
optly.Dialog.prototype.prompt = function(var_args) {
  $(".dialog:visible, .dialog-container:visible").jqm().jqmHide();
  this.message.hide();

  if (this.options.hasForm) {
    if (this.options.resetForm) {
      this.form.reset();
    }
    this.toggleForm(true);
  }

  this.window.jqmShow();
  $("html, body").scrollTop(0);

  // Need to remove page's scroll bars because dialog is tall and scrollable.
  if (this.window.hasClass("dialog-container")) {
    $("html").addClass(DIALOG_SHOWN_CLASS);
  }
};

/**
 * @param {boolean} toggle
 */
optly.Dialog.prototype.toggleForm = function(toggle) {
  if (this.options.hasForm) {
    this.form.toggleForm(toggle);
  }
};


// assets/js/bundle/dialogs/create_account.js
goog.provide("optly.dialogs.CreateAccount");

goog.require("optly.Dialog");

/**
 * @constructor
 * @extends optly.Dialog
 * @param {Object=} options
 */
optly.dialogs.CreateAccount = function(options) {
  var context = $("#create-account-dialog-container");
  var passwordReq = context.find('.password-req');
  $.validator.addMethod("complexPassword", function(password){
    var result = checkComplexPassword(password);
    if (!result.passed){
      $.validator.messages.complexPassword = result.message;
    }
    passwordReq.toggle(result.passed)
    return result.passed;
  });



  goog.base(this, $.extend({}, options, {
    afterHide: goog.bind(this.handleHide, this),
    ajaxMethod: 'POST',
    context: context,
    errorClass: ERROR_CLASS + ' left',
    errorElement: "span",
    rules: {
      email: {
        email: true,
        required: true
      },
      password1: {
        complexPassword: true,
        minlength: 8,
        required: true
      },
      password2: {
        equalTo: "#create-account-dialog .password1",
        required: true
      },
      'terms-of-service': {
        required: true
      }
    }
  }));

  var pathname = window.location.pathname;

  if (pathname === "/signin") {
    // Sign in page doesn't need "Sign in here" link.
    context.find(".options").hide();
  }

  // Parse the query string
  var urlParams = $.deparam.querystring();
  // If 'signup_platform' is in the query parameters, it suggests the user is signing up from a non-web account.
  // They got to this page from some source from /mobile, or maybe an ad, which put that parameter into the query.
  // In this case, append it to the form so that when we create their account their first project is for the
  // platform they're signing up for.
  if (urlParams.signup_platform) {
    var platformInput = $('<input type="hidden" name="platform"></input>');
    platformInput.attr('value', urlParams.signup_platform);
    context.find('form').append(platformInput);
  }

  // if flow = nux then they are in the new user experience flow and will enter project name later
  if (urlParams.flow) {
    var flowInput = $('<input type="hidden" name="flow"></input>');
    flowInput.attr('value', urlParams.flow);
    context.find('form').append(flowInput);
  }

  this.anonymousHeader = context.find(".anonymous-header");
  this.cancelButton = context.find(".cancel-button");
  this.laterButton = context.find(".later-button");
  this.normalHeader = context.find(".normal-header");
  this.onAnonymousWallDone = new optly.Event(true);
  this.showAnonymousWall = false;

  context.find("#hidden").val("touched");
};

goog.inherits(optly.dialogs.CreateAccount, optly.Dialog);

/**
 * @override
 * @param {Object} data
 */
optly.dialogs.CreateAccount.prototype.handleSubmit = function(data) {
  if (this.showAnonymousWall) {
    this.showAnonymousWall = false;
    trackEvent("dialog/hide/anonymous_wall");
  }
  goog.base(this, "handleSubmit", data);
};


/**
 * @private
 */
optly.dialogs.CreateAccount.prototype.logSignupType = function() {
  // Log event in Marketo if this signup occurred as part of the signin flow for the Optimizely community
  var queryParameters = $.deparam.querystring();
  if (!("continue_to" in queryParameters)) {
    return;
  }

  // Track signups coming through the mobile landing page.
  if (queryParameters.continue_to.indexOf('/mobile/first-project') > -1) {
    trackEvent('/mobile/signup/success');
    return;
  }

  var continue_to_parts = decodeURIComponent(queryParameters['continue_to']).split("?");
  if (continue_to_parts.length != 2) {
    return;
  }

  var POSSIBLE_COMMUNITY_SSO_REFERER_PREFIXES =
      ["referer=http://community.optimizely.com", "referer=https://community.optimizely.com"];
  var continue_to_url_param_parts = continue_to_parts[1].split("&");
  for (var i=0; i<continue_to_url_param_parts.length; i++) {
    for (var j=0; j<POSSIBLE_COMMUNITY_SSO_REFERER_PREFIXES.length; j++) {
      if (continue_to_url_param_parts[i].indexOf(POSSIBLE_COMMUNITY_SSO_REFERER_PREFIXES[j]) == 0) {
        trackEvent("/account/create/for_community_signin");
        break;
      }
    }
  }
};

/**
 * @override
 * @param {Object} data
 */
optly.dialogs.CreateAccount.prototype.handleSuccess = function(data) {
  this.logSignupType();

  if (window.location.pathname === "/signin") {
    optly.common.signin.handleContinueToUrl();
    return;
  }

  if ($('#csrf-token').length == 0) {
      $('body').prepend($('<input id="csrf-token" type="hidden" value="' + data['csrf_token'] + '">'));
  }
  goog.base(this, "handleSuccess", data);
};

/**
 * @override
 */
optly.dialogs.CreateAccount.prototype.prompt = function() {
  this.anonymousHeader.hide();
  this.cancelButton.show();
  this.laterButton.hide();
  this.normalHeader.show();
  this.showAnonymousWall = false;

  trackEvent("/account/create/show");
  goog.base(this, "prompt");
};

/**
 * Show anonymous wall.
 */
optly.dialogs.CreateAccount.prototype.promptAnonymousWall = function() {
  this.anonymousHeader.show();
  this.cancelButton.hide();
  this.laterButton.show();
  this.normalHeader.hide();
  this.showAnonymousWall = true;

  trackEvent("dialog/show/anonymous_wall");
  optly.Dialog.prototype.prompt.call(this);
};

/**
 * @private
 */
optly.dialogs.CreateAccount.prototype.handleHide = function() {
  if (this.showAnonymousWall) {
    this.onAnonymousWallDone.fire();
  }

  trackEvent("/account/create/hide");
};


// assets/js/bundle/dialogs/sign_in.js
goog.provide("optly.dialogs.SignIn");

goog.require("optly.Dialog");

/**
 * @constructor
 * @extends optly.Dialog
 * @param {Object=} options
 */
optly.dialogs.SignIn = function(options) {
  goog.base(this, $.extend({}, options, {
    ajaxMethod: 'POST',
    context: $("#sign-in-dialog"),
    errorClass: ERROR_CLASS,
    errorElement: "span",
    rules: {
      email: "required",
      password: "required"
    }
  }));
};

goog.inherits(optly.dialogs.SignIn, optly.Dialog);

/**
 * @override
 * @param {Object} data
 */
optly.dialogs.SignIn.prototype.handleSuccess = function(data) {
  var path = window.location.pathname;

  if (path !== "/edit" && path !== "/pricing") {
    // Redirect to dashboard page
    this.toggleForm(false);
    window.location = "/dashboard";
  }
  else {
    if ($('#csrf-token').length == 0) {
      $('body').prepend($('<input id="csrf-token" type="hidden" value="' + data['csrf_token'] + '">'));
    }

    goog.base(this, "handleSuccess", data);
  }
};


// assets/js/bundle/dialogs/compatibility.js
goog.provide("optly.dialogs.Compatibility");

/**
 * @constructor
 */
optly.dialogs.Compatibility = function() {
  this.dialog = $("#compatibility-dialog");
};

optly.dialogs.Compatibility.prototype.show = function() {
  this.dialog.jqmShow();
};


// assets/js/bundle/dialogs/forgot_password.js
goog.provide("optly.dialogs.ForgotPassword");

goog.require("optly.Dialog");

/**
 * @constructor
 * @extends optly.Dialog
 * @param {Object=} options
 */
optly.dialogs.ForgotPassword = function(options) {
  var context = $("#forgot-password-dialog");

  goog.base(this, $.extend({}, options, {
    context: context,
    errorClass: ERROR_CLASS,
    errorElement: "span",
    successClass: "success",
    rules: {
      email: {
        required: true
      }
    }
  }));

  this.closeButton = $(".close-button", context);
  this.preSubmitButtons = $(".cancel-button, .submit", context);

  this.closeButton.click(goog.bind(this.handleClose, this));
};

goog.inherits(optly.dialogs.ForgotPassword, optly.Dialog);

/**
 * @override
 * @param {Object} data
 */
optly.dialogs.ForgotPassword.prototype.handleError = function(data) {
  this.message.addClass(ERROR_CLASS)
    .removeClass(SUCCESS_CLASS)
    .text(data['error'])
    .show();
};

/**
 * @override
 * @param {Object} data
 */
optly.dialogs.ForgotPassword.prototype.handleSuccess = function(data) {
  this.closeButton.show();
  this.preSubmitButtons.hide();
  this.toggleForm(false);

  this.message.addClass(SUCCESS_CLASS)
    .removeClass(ERROR_CLASS)
    .text(data['message'])
    .show();
};

/**
 * @override
 */
optly.dialogs.ForgotPassword.prototype.prompt = function() {
  this.closeButton.hide();
  this.preSubmitButtons.show();
  this.toggleForm(true);
  goog.base(this, "prompt");
};

/**
 * @private
 */
optly.dialogs.ForgotPassword.prototype.handleClose = function() {
  var path = window.location.pathname;

  if (path !== "/") {
    window.location = "/";
  }
  else {
    this.window.jqmHide();
  }
};


// assets/js/bundle/pricing/plan.js
goog.provide("optly.pricing.Plan");

/**
 * @enum {number}
 */
optly.pricing.Plan = {
  FREE: -1,
  BRONZE: 0,
  SILVER: 1,
  GOLD: 2,
  PLATINUM: 3
};


// assets/js/bundle/error.js
goog.provide("optly.Error");

goog.require("optly.common.main");
goog.require("optly.common.format");

/**
 * @constructor
 */
optly.Error = function() {
  var queryParameters = $.deparam.querystring();
  if ("error" in queryParameters) {
    this.showError(queryParameters.error, queryParameters.error_id);
  }
};

/**
 * @param {string} errorMessage
 * @param {string=} errorId
 * @return {Object} A json object containing the errorMessage, timestamp, and guid displayed on the error dialog
 */
optly.Error.prototype.showError = function(errorMessage, errorId) {
  var guid = require('utils/guid');

  var info = {
    errorMessage: errorMessage || optly.Error.DEFAULT_ERROR_MESSAGE,
    guid: errorId || guid(),
    timestamp: formatDateJson(new Date())
  };
  $(".optimizely_error").hide();
  $("#optimizely_error_dialog #optimizely_error_type").text(info.errorMessage);
  $("#optimizely_error_dialog").jqm().jqmShow();
  $("#optimizely_error_dialog #optimizely_error_info").text(info.guid + " | " + info.timestamp);
  return info;
};

optly.Error.DEFAULT_ERROR_MESSAGE = tr("Don't worry, most issues are minor - please refresh your browser and try again.");


// assets/js/bundle/event.js
goog.provide("optly.Event");

/**
 * If opt_oneTime is true, after the first fire(), any subsequent add()s will
 * invoke the passed callback immediately.
 *
 * @param {boolean=} opt_oneTime
 * @constructor
 */
optly.Event = function(opt_oneTime) {
  this.arguments = [];
  this.oneTime = opt_oneTime;
  this.subscribers = [];
  this.wasFired = false;
};

/**
 * @param {Function} callback
 */
optly.Event.prototype.add = function(callback) {
  if (this.wasFired)
    callback.apply(this, this.arguments);
  else
    this.subscribers.push(callback);
};

/**
 * Performs goog.bind internally to reduce verbosity in code.
 *
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which |this| should
 *     point to when the function is run. If the value is null or undefined, it
 *     will default to the global object.
 * @param {...*} var_args Additional arguments that are partially
 *     applied to the function.
 */
optly.Event.prototype.bind = function(fn, selfObj, var_args) {
  this.add(goog.bind.apply(this, arguments));
};

/**
 * Clear all subscribers.
 */
optly.Event.prototype.clear = function() {
  this.subscribers = [];
};

/**
 * @param {...*} var_args
 */
optly.Event.prototype.fire = function(var_args) {
  this.arguments = arguments;

  if (this.oneTime) {
    this.wasFired = true;
  }

  $.each(this.subscribers, goog.bind(function(index, subscriber) {
    subscriber.apply(this, this.arguments);
  }, this));
};

/**
 * Reset wasFired so callbacks aren't fired immediately.
 */
optly.Event.prototype.reset = function() {
  this.wasFired = false;
};


// assets/js/bundle/account.js
goog.provide("optly.Account");

goog.require("optly.dialogs.Compatibility");
goog.require("optly.dialogs.CreateAccount");
goog.require("optly.dialogs.ForgotPassword");
goog.require("optly.dialogs.SignIn");
goog.require("optly.pricing.Plan");
goog.require("optly.Event");
goog.require("optly.Error");

/**
 * @constructor
 * @param {Object} accountInfo
 */
optly.Account = function(accountInfo) {
  optly.Account.instance = this;

  this.accountId = null;
  this.email = null;
  this.isSignedIn = null;
  this.account_emails = null;

  // The following are Marketo-related variables.
  this.experiments_total = 0;
  this.firstName = null;
  this.lastName = null;
  this.company = null;
  this.phoneNumber = null;
  this.userAccounts = null;

  this.compatibilityDialog = new optly.dialogs.Compatibility();
  this.error = new optly.Error();
  this.createAccountDialog = new optly.dialogs.CreateAccount({
    onSuccess: goog.bind(this.handleCreateAccountResponse, this)
  });
  this.forgotPasswordDialog = new optly.dialogs.ForgotPassword();
  this.onSignInChanged = new optly.Event();
  this.onAccountInfoLoaded = new optly.Event();
  this.signInDialog = new optly.dialogs.SignIn({
    onSuccess: goog.bind(this.handleLoadResponse, this)
  });

  this.onSignInChanged.bind(this.trackSignIn, this);
  this.onSignInChanged.bind(this.updateMarketo, this);
  this.onSignInChanged.bind(this.updateBodyClass, this);

  // Check for presence of cookie being set for account creation.
  // Account creation in background only happens for users coming in from free trial page.
  if (this.shouldFinishFreeTrialCreate()) {
    this.createFreeTrialAccount();
  }
  else {
    // immediately populate the object with the accountInfo
    this.handleLoadResponse(accountInfo);
  }
};

optly.Account.getInstance = function() {
  return optly.Account.instance;
};

//TODO I do not think this will ever return you anything
//we are not passing back plan information in the account info response
optly.Account.prototype.getSubscriptionPlan = function() {
  if (this.subscribed === true && this.plan_display_name !== null) {
    return optly.pricing.Plan[this.plan_display_name];
  }
  else {
    return null;
  }
};

/**
 * Retrieve the preview JS file name for the specified project
 *
 * @param {number} projectId
 * @return {string}
 */
optly.Account.prototype.getPreviewJsFilename = function(projectId) {
  if (!this.projects[projectId] || !this.projects[projectId]['preview_js_file_name']) {
    throw new Error(sprintf('account.getPreviewJsFilename: invalid projectId: %s', projectId));
  }
  return this.projects[projectId]['preview_js_file_name'];
};

optly.Account.prototype.isShopifyCustomer = function() {
  return this.source === "shopify";
};

/** @return {boolean} */
optly.Account.prototype.isTrustedTester = function() {
  return this.trusted_tester || false;
};

/**
 * When a user comes from the /free-trial the cookie `encodedAcctData` is created
 * and after the user arrives at the edit page they need to finish the account creation process
 *
 * @private
 * @return {boolean}
 */
optly.Account.prototype.shouldFinishFreeTrialCreate = function() {
  return $.cookie('encodedAcctData') && window.location.pathname === '/edit';
};

/**
 * Create a users free trial account with the `encodedAcctData` cookie
 *
 * @private
 */
optly.Account.prototype.createFreeTrialAccount = function() {
  if (!this.shouldFinishFreeTrialCreate()) {
    throw new Error("Cannot create free trial account without `encodedAcctData` cookie and being on the edit page");
  }

  // create the account only if cookie is set with account data and user is on edit page.
  $.ajax({
    url: '/account/free_trial_create',
    type: 'POST',
    data: window.JSON.parse($.cookie("encodedAcctData"))
  }).done(goog.bind(this.handleCreateAccountResponse, this))
  .always(function() {
    $.cookie("encodedAcctData", null);
  });
};

optly.Account.prototype.showAnonymousWall = function() {
  if (!this.isSignedIn) {
    if(window.KRUSH && typeof window.KRUSH.anonymousWallExperimentId === 'number'){
      window.optimizely = window.optimizely || [];
      window.optimizely.push(["activate", window.KRUSH.anonymousWallExperimentId]);
    }
    this.createAccountDialog.promptAnonymousWall();
  }
  else {
    this.createAccountDialog.onAnonymousWallDone.fire();
  }
};

optly.Account.prototype.showCreateAccountDialog = function() {
  if(window.KRUSH && typeof window.KRUSH.createAccountExperimentId === 'number'){
    window.optimizely = window.optimizely || [];
    window.optimizely.push(["activate", window.KRUSH.createAccountExperimentId]);
  }
  this.createAccountDialog.prompt();
};

optly.Account.prototype.showForgotPasswordDialog = function() {
  this.forgotPasswordDialog.prompt();
};

optly.Account.prototype.showSignInDialog = function() {
  // check browser compatibility
  if (isBrowserCompatible() === true) {
    this.signInDialog.prompt();
  }
  else {
    this.compatibilityDialog.show();
    trackEvent("/account/compatibility/show");
  }
};

optly.Account.prototype.trackSignIn = function(signedIn) {
  if (signedIn) {
    trackIdentity(this.email);
    trackVisitorAttribute("plan", this.plan_id, {'gaqSlot': 1});

    // Track that a user has freshly arrived on the site already signed in
    if (!document.referrer.match("optimizely.com")) {
      trackEvent("/account/signedin");
    }
    else {
      trackEvent("/account/signin");
    }

    // Track paying customers with a custom event so Steve can remarket to non-payers
    if (this.plan_id && this.plan_id.indexOf("free") !== -1) {
      trackEvent("/customer/signedin");
      // Track plan type of customer
      trackEvent("/plan/" + this.plan_id);
    }

  }
};

optly.Account.prototype.updateBodyClass = function(signedIn) {
  if(signedIn){
      $('body').addClass(SIGNED_IN_BODY_CLASS);
  }
}

/**
 * @param {boolean} signedIn
 */
optly.Account.prototype.updateOlarkStatus = function(signedIn) {
  if (typeof window['olark'] === "function") {
    var snippet = tr("Not signed in");

    if (signedIn) {
      snippet = sprintf("%s | %d | %s",
                        this.email || "",
                        this.accountId || "",
                        this.plan_id || "");
    }

    window['olark']('api.chat.updateVisitorNickname', {snippet: snippet});
  }
};

/**
 * @param {Object} response
 * @private
 */
optly.Account.prototype.handleCreateAccountResponse = function(response) {
  if (typeof(response.succeeded) !== "undefined" && response.succeeded) {
    // AdWords "Created Account" conversion
    trackAdwordsConversion("0jdrCIzG4QEQ1MCR4gM");
    trackEvent("/account/create/success");
  }

  if (isBrowserCompatible() === true) {
    this.handleLoadResponse(response);
  }
  else {
    this.compatibilityDialog.show();
  }
};

/**
 * @param {Object} response
 * @private
 */
optly.Account.prototype.handleLoadResponse = function(response) {
  if (response['account_id'] === null) {
    this.isSignedIn = false;
  }
  else {
    this.accountId = response['account_id'];
    this.beta_customer = response.beta_customer;
    this.company = response.company_name;
    this.email = response['email'];
    this.enable_force_variation = response.enable_force_variation;
    this.exclude_disabled_experiments = response.exclude_disabled_experiments;
    this.experiments_total = response['experiments_total'] || 0;
    this.firstName = response.first_name;
    this.lastName = response.last_name;
    //this.include_geotargeting = response.include_geotargeting;
    this.include_whitelist_feature = response.include_whitelist_feature || ""; // deprecated
    this.is_very_big = response.is_very_big || false;
    this.isAdmin = response['is_admin'];
    this.isMasterAccount = response.is_master_account;
    this.has_installed_snippet = response.has_installed_snippet;
    this.has_seen_first_notice = response.has_seen_first_notice;
    this.has_seen_editor_guiders = response.has_seen_editor_guiders;
    this.has_seen_results2_guiders = response.has_seen_results2_guiders;
    this.has_seen_audience_guiders = response.has_seen_audience_guiders;
    this.max_projects = response.max_projects || -1;
    this.munchkin_token = response.munchkin_token;
    this.must_change_password = response.must_change_password;
    this.permissions = response.permissions;
    this.phoneNumber = response.phone_number || null;
    this.plan_display_name = response.plan_display_name;
    this.plan_id = response.plan_id;
    this.project_ids = response.project_ids;
    this.projectCount = response['project_count'];
    this.projects = response['projects'];
    this.subscribed = response.subscribed;
    this.source = response['source'];
    this.trusted_tester = response.trusted_tester;
    this.useProjectGoals = response.use_project_goals;
    this.userAccounts = response.user_accounts;
    // inject csrf token while signing up from free trial page
    if (response['csrf_token'] && $('#csrf-token').length == 0) {
      $('body').prepend($('<input id="csrf-token" type="hidden" value="' + response['csrf_token'] + '">'));
    }

    this.isSignedIn = true;

    window.optimizely = window.optimizely || [];
    window.accountInfoLoaded = true;
    window.accountId = this.accountId;
    window.optimizely.push('activate');

    if (window.usabilla_live) {
      window.usabilla_live("data", {
        "custom": {
          "email": this.email,
          "plan_id": this.plan_id
        }
      });
    }
  }

  // The event listeners for these events are bound AFTER the initial account load, meaning that
  // unless we defer firing them, the listeners will never register the state change. This hacks
  // around the issue, though ideally this will be addressed soon (TODO!!)
  setTimeout(goog.bind(function () {
    this.onSignInChanged.fire(this.isSignedIn);
    this.onAccountInfoLoaded.fire(response);
  }, this), 0);
};

/**
 * @param {boolean} signedIn
 * @private
 */
optly.Account.prototype.updateMarketo = function(signedIn) {
  if (!signedIn) {
    return;
  }

  var leadInfo = {
    'Email': this.email
  }

  if (this.firstName) {
    leadInfo['FirstName'] = this.firstName;
  }
  if (this.lastName) {
    leadInfo['LastName'] = this.lastName;
  }
  if (this.company) {
    leadInfo['Company'] = this.company;
  }
  if (this.phoneNumber) {
    leadInfo['Phone'] = this.phoneNumber;
  }

  if (this.isMasterAccount === false) {
    // This property tells Marketo / SFDC that the account was created by a
    // project invite.
    leadInfo['Account_Created_for_Project_Invite__c'] = true;
  }

  trackMarketo(leadInfo, this.munchkin_token);
};

/**
 * @param {boolean} signedIn
 */
optly.Account.prototype.updatePlanRestrictedContent = function(signedIn) {
  var newCSS = "";

  var myPlan = null;
  if (signedIn) {
    myPlan = this.getSubscriptionPlan();
  }

  var hideThese = [];
  var allPossibleHides = [
    ".restricted_platinum_plus",
    ".restricted_gold_plus",
    ".restricted_silver_plus"
  ];
  var showThese = [];
  var allPossibleShows = [
    ".restricted_show_platinum_plus",
    ".restricted_show_gold_plus",
    ".restricted_show_silver_plus"
  ];

  switch (myPlan) {
    case optly.pricing.Plan.FREE:
      hideThese = allPossibleHides;
      showThese = allPossibleShows;
      break;
    case optly.pricing.Plan.PLATINUM:
      hideThese = allPossibleHides;
      showThese = allPossibleShows;
      break;
    case optly.pricing.Plan.GOLD:
      hideThese.push(".restricted_silver_plus");
      hideThese.push(".restricted_gold_plus");
      showThese.push(".restricted_show_silver_plus");
      showThese.push(".restricted_show_gold_plus");
      break;
    case optly.pricing.Plan.SILVER:
      hideThese.push(".restricted_silver_plus");
      showThese.push(".restricted_show_silver_plus");
      break;
  }

  for (var i = 0; i < allPossibleHides.length; i++) {
    var myClass = allPossibleHides[i];
    if ($.inArray(myClass, hideThese) !== -1) {
      newCSS += myClass + " { display: none; } ";
    }
  }

  for (var j = 0; j < allPossibleShows.length; j++) {
    var myShowClass = allPossibleShows[j];
    if ($.inArray(myShowClass, showThese) === -1) {
      newCSS += myShowClass + " { display: none; } ";
    }
  }

  newCSS = "<style>" + newCSS + "</style";
  $("body").append(newCSS);
};

/**
 *
 * @param canUse
 */
optly.Account.prototype.updateSegmentationRestrictedContent = function(canUse) {
  $(".restricted-only-for-segments").toggleClass("locked", !canUse);
};

/**
 * Checks if the user can use segments.
 */
optly.Account.prototype.canUseSegments = function() {
  return this.useSegments === true;
};


// assets/js/bundle/guardian/guard_link_type.js
goog.provide("optly.guardian.GuardLinkType");

/**
 * @enum {number}
 */
optly.guardian.GuardLinkType = {
  LIVE: 0,
  HOSTED: 1,
  HOSTED_WITH_LIVE_REDIRECT: 2
};


// assets/js/bundle/verify/level.js
goog.provide("optly.verify.Level");

/**
 * @enum {string}
 */
optly.verify.Level = {
  AMAZON: "amazon",
  CDN: "cdn",
  DONE: "done"
};


// assets/js/bundle/verify/verifier.js
goog.provide('optly.verify.Verifier');

goog.require('optly.verify.Level');
goog.require('optly.Event');


/**
 *
 * @constructor
 * @param {{ '{{' }}interval: (number|undefined),
 *          maxAttempts: (number|undefined),
 *          requestTimeout: (number|undefined)}=} options
 */
optly.verify.Verifier = function(options) {
  this.options = $.extend({
    interval: 3000,
    maxAttempts: 100,
    requestTimeout: 6000
  }, options || {});
  this.onLevelChanged = new optly.Event();
  this.onLevelChanged.bind(this.updateLevel, this);
  /**
   * @private
   * @type {Object.<number, boolean>}
   */
  this.toDrop = {};
  /**
   * Mapping of projectId to last verified level
   * @private
   * @type {Object.<number, ?optly.verify.Level>}
   */
  this.verifications = {};
};

/**
 * Start verifying projectId
 * @param {number} projectId
 * @param {number} revision
 */
optly.verify.Verifier.prototype.verify = function(projectId, revision) {
  this.verifications[projectId] = null;
  this.verifyRevision(projectId, revision, optly.verify.Level.AMAZON);
};

/**
 * Drop result and stop verifying this projectId
 * @param {number} projectId
 */
optly.verify.Verifier.prototype.drop = function(projectId) {
  this.toDrop[projectId] = true;
};


/**
 * Has this project been verified at least once?
 * @param {number} projectId
 * @returns {boolean}
 */
optly.verify.Verifier.prototype.isVerified = function(projectId) {
  return this.verifications[projectId] === optly.verify.Level.DONE;
};


/**
 * @private
 * @param {number} projectId
 * @param {number} expectedRevision
 * @param {optly.verify.Level} level
 * @param {number=} attempt
 */
optly.verify.Verifier.prototype.verifyRevision = function(projectId, expectedRevision, level, attempt) {
  if (this.toDrop[projectId]) {
    delete this.toDrop[projectId];
    this.onLevelChanged.fire(projectId, null);
    return;
  }
  attempt = goog.isDef(attempt) ? attempt : 1;
  log("[verify] Loading project: %s at level: %s",
      projectId,
      level);
  $.ajax({
    url: sprintf('/api/client/%d/revision.json', projectId),
    data: {level: level},
    timeout: this.options.requestTimeout,
    // prevent default error dialog
    error: goog.nullFunction
  }).then(function(data) {
    var revision = data.revision;
    if (!revision || revision < expectedRevision) {
      log("[verify] Revision %s < %d (attempt %d)",
           revision || '[unknown]',
           expectedRevision,
           attempt);
      if (attempt >= this.options.maxAttempts) {
        this.drop(projectId);
      }
      setTimeout(this.verifyRevision.bind(this, projectId, expectedRevision, level, attempt+1),
                 this.options.interval);
    } else {
      var nextLevel = this.getNextLevel(level);
      this.onLevelChanged.fire(projectId, nextLevel);
      if (nextLevel && nextLevel !== optly.verify.Level.DONE) {
        this.verifyRevision(projectId, expectedRevision, nextLevel);
      }
    }
  }.bind(this)).fail(function(jqXHR, error, textStatus) {
    if (error === 'timeout') {
      // try again
      log('[verify] Timed out on project: %s, retrying (attempt %d)', projectId, attempt);
      setTimeout(this.verifyRevision.bind(this, projectId, expectedRevision, level, attempt+1),
                 this.options.interval);
    } else {
      log('[verify] Error on project: %s, %s', projectId, textStatus);
    }
  }.bind(this));
};


/**
 * @private
 * @param {number} projectId
 * @param {?optly.verify.Level} level
 */
optly.verify.Verifier.prototype.updateLevel = function(projectId, level) {
  this.verifications[projectId] = level;
  if (!level) {
    log("[verify] Dropped project: %s", projectId);
  } else {
    log("[verify] Project: %d level changed: %s", projectId, level);
  }
};


/**
 *
 * @param level
 * @returns {optly.verify.Level|null}
 */
optly.verify.Verifier.prototype.getNextLevel = function(level) {
  if (level === optly.verify.Level.AMAZON) {
    return optly.verify.Level.CDN;
  }
  if (level === optly.verify.Level.CDN) {
    return optly.verify.Level.DONE;
  }
  return null;
};



// assets/js/bundle/guardian/guard_type.js
goog.provide("optly.guardian.GuardType");

/**
 * @enum {number}
 */
optly.guardian.GuardType = {
  CROSS_BROWSER: 0,
  PREVIEW: 1
};


// assets/js/shared/shortlink.js
goog.provide('optly.Shortlink');

/*
 * This widget uses raw XHR because it is intended to be used on the preview page
 * as well as elsewhere on the site. On the preview page, we load a stripped down version
 * of jQuery that doesn't include $.ajax, and serving a version of jQuery that does include
 * it is more trouble than it's worth, given that the preview page is largely getting rewritten.
 * Part of the difficulty is that the preview overlay is injected onto anyone's page, and they may
 * or may not include full jQuery, so we can't rely on it being there.
 * The only browsers we support all include raw XHR requests natively, so this is safe.
 */

/**
 * Reusable UI Element for getting a shortlink
 * UI is [input][button] abutting each other
 * and the input field is .select()ed once
 * we receive a shortlink from the shortlink.Model
 *
 * @param {jQueryObject} container
 * @constructor
 */
optly.Shortlink = function(container) {

  // This is public so that the caller can
  // directly set a query string if they really want to
  this.shortlinkParameters = '';

  /** @private */
  this.container = container;
  /** @private */
  this.shortlinkInput = this.createShortlinkInput();
  /** @private */
  this.shortlinkButton = this.createShortlinkButton();

  /** @private */
  this.shortlink = '';
  /** @private */
  this.url = '';
  /** @private */
  this.hashFragment = '';
  /** @private */
  this.linkType = '';

  // Enable the button
  this.shortlinkButton.click(goog.bind(this.generateShortlink, this));

  // Disable by default so that the user is forced to
  // explicitly provide a URL before it's usable
  this.disable();
};

/**
 * Enables the shortlink input and button
 * Accepts a url parameter for the url that
 * will be shortened upon button click
 * and a linkType parameter. Options are
 * 'PREVIEW' and 'RESULTS'
 *
 * @param {string} url
 * @param {string} linkType
 * @param {boolean=} shouldPopulate (optional)
 */
optly.Shortlink.prototype.enable = function(url, linkType, shouldPopulate) {

  // If this is a new URL, delete the stored shortlink
  // This is unexpected for the current use cases of the preview and results pages
  if (url !== this.url) {
    this.shortlink = '';
    this.resetUIState();
  }

  this.url = url;
  this.linkType = linkType;

  // We should clear any token parameter from the URL that's going to be shortened
  // The main reason for this is to prevent someone who broke into our database from having
  // a token that would allow them to spoof any user who has created a shortlink
  if (this.url) {
    this.processUrl();
  }

  this.container.children().removeAttr('disabled');
  if (url && shouldPopulate) {
    this.generateShortlink();
  }
};

/**
 * Processes url to remove token and extract hash fragment.
 * @private
 */
optly.Shortlink.prototype.processUrl = function() {
  this.url = this.stripOutFirefoxWorkaround(this.url);
  this.url = this.removeToken(this.url);
  // Remove the hash fragment after token is removed to handle case when token is present after hash.
  var match = this.url.match(/^[^#]*(#.*)$/);
  if (match) {
    this.hashFragment = match[1];
    this.url = this.url.replace(this.hashFragment, '');
  }
}

/**
 * Strips any token parameters out of a url
 *
 * @param {string} url
 * @returns {string}
 * @private
 */
optly.Shortlink.prototype.removeToken = function(url) {
  // Remove any token parameters from the URL
  var tokenRegex = /([&?#])(token=[^&#]*&?)/;
  // Decode the URI so that the regex will work
  url = decodeURIComponent(url);
  // If the token parameter is the end of the url, replace the whole match with the empty string
  // If it's not, we need to leave the leading '?' or '&'
  // The last regex replace cleans the url of unusual cases such as &# and ?#. While the url is still valid with
  // these included, it's best to retain a standard format so that downstream consumers don't break.
  return url.replace(tokenRegex, function(match, p1, p2, offset, str) {
    return (offset + match.length == str.length ? '' : p1);
  }).replace(/([&?]#)/, '#');
};
/**
 *
 * @param {string} url
 * @returns {string}
 */
optly.Shortlink.prototype.stripOutFirefoxWorkaround = function(url) {
  var returnUrl = url;
  var splitResult = url.split('/edit_url/');
  if (splitResult.length > 1) {
    returnUrl = splitResult[1];
  }
  return decodeURIComponent(returnUrl);
};

/**
 * Disables the shortlink input and button
 * If requested, resets the UI to the initial state
 *
 * @param {boolean=} shouldResetUI (optional)
 */
optly.Shortlink.prototype.disable = function(shouldResetUI) {
  if (shouldResetUI) {
    this.resetUIState();
  }
  this.container.children().attr('disabled', true);
};

/**
 * Accepts and encodes a set of parameters that will be appended
 * to the returned shortlink
 *
 * @param {Object.<string, string>} parameters
 */
optly.Shortlink.prototype.setShortlinkParameters = function(parameters) {
  var paramsArray = [];
  for (var param in parameters) {
    if (parameters.hasOwnProperty(param)) {
      paramsArray.push(param + '=' + parameters[param]);
    }
  }
  this.shortlinkParameters = paramsArray.join('&');
};

/* Private functions */

/**
 * If necessary, makes a request to the shortlink API
 * otherwise it just calls the function to show the shortlink that was already received
 *
 * @private
 */
optly.Shortlink.prototype.generateShortlink = function() {
  // If we already have a shortlink, don't make another request
  if (this.shortlink) {
    this.showShortlink();
    return;
  }

  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = goog.bind(this.handleReadyStateChange, this, xhr);
  xhr.open('GET', this.getURLString(), true); // third param is a bool for whether the request should be async
  xhr.send();
};

/**
 * Handles the response from the XMLHTTP request
 * Stores the shortlink if the request was successful
 *
 * @param {Object} xhr
 * @private
 */
optly.Shortlink.prototype.handleReadyStateChange = function(xhr) {
  if (xhr.readyState == 4) {
    if (xhr.status == 200) {
      var data = $.parseJSON(xhr.responseText);
      if (data.succeeded) {
        this.shortlink = data.shortlink;
      }
    }
    // If the request failed, we'll just show the original url (logic in showShortlink)
    this.showShortlink();
  }
};

/**
 * Fills in the value of the shortlink if necessary and selects the input field so
 * that the user can easily copy the URL
 *
 * @private
 */
optly.Shortlink.prototype.showShortlink = function() {

  var valToShow = this.shortlink || this.url;
  // There's still a risk of parameters appearing twice. I'm not sure of a good fix for this without
  // a component parsing library. At the moment, this risk is irrelevant because the only
  // shortlink parameter ever appended is the token on the results page, which is never in valToShow.
  if (this.shortlinkParameters || this.hashFragment) {
    valToShow = this.constructUrlToShow(valToShow, this.shortlinkParameters, this.hashFragment);
  }
  this.shortlinkInput.val(valToShow);
  this.shortlinkInput.select();
  this.shortlinkButton.text('Select Shareable Link');
};

/**
 * Function that takes the shortlink and its extra parameters and returns the url to show
 *
 * @param {string} urlToShow
 * @param {string} params
 * @param {string} hashFragment
 * @returns {string}
 * @private
 */
optly.Shortlink.prototype.constructUrlToShow = function(urlToShow, params, hashFragment) {
  if (params) {
    if (urlToShow.indexOf('?') > -1) {
      // Check for trailing ampersands so we don't double them up.
      if (urlToShow[urlToShow.length - 1] !== '&') {
        urlToShow += '&';
      }
    }
    else {
      urlToShow += '?';
    }
    urlToShow += params;
  }
  if (hashFragment) {
    urlToShow += hashFragment;
  }

  return urlToShow;
};

/**
 * Escapes the url to be shortened and creates the url for the api request that will shorten it
 *
 * @private
 */
optly.Shortlink.prototype.getURLString = function() {
  // encode the URI that will be a parameter because otherwise the API route thinks it is getting
  // more parameters than it is, causing an error to be returned
  var escaped_url = encodeURIComponent(this.url);

  var url_string = [
    '//' + optly.env.HOST + '/api/shortlink.json?link_type=',
    this.linkType,
    '&url=',
    escaped_url
  ].join('');

  return url_string;
};

/**
 *
 * @private
 */
optly.Shortlink.prototype.resetUIState = function() {
  this.shortlinkInput.val('');
  this.shortlinkButton.text('Get Shareable Link');
};

/* UI Element initializers */

/**
 * Initializes the input element where the shortlink will go and adds it to the DOM
 * If the container already has a input, don't make a new input.
 *
 * @returns {jQueryObject}
 * @private
 */
optly.Shortlink.prototype.createShortlinkInput = function() {
  var input;
  var existingInput = this.container.children('input');
  if (existingInput.length) {
    input = existingInput;
  }
  else {
    input = $('<input type="text" placeholder="Shareable Link" readonly/>');
    this.container.append(input);
  }
  return input;
};
/**
 * Initializes the button for getting/selecting the shortlink and adds it to the DOM
 * If the container already has a button, don't make a new button.
 *
 * @returns {jQueryObject}
 * @private
 */
optly.Shortlink.prototype.createShortlinkButton = function() {
  var button;
  var existingButton = this.container.children('button');
  if (existingButton.length) {
    button = existingButton;
  }
  else {
    button = $('<button>Get Shareable Link</button>');
    this.container.append(button);
  }
  return button;
};


// assets/js/bundle/edit/option/user_agents.js
goog.provide("optly.edit.option.UserAgents");

/**
 * @const
 * @type {Object}
 */
optly.edit.option.UserAgents = {
  "androidPhone": {
    "deviceName": "Generic",
    "name": "Android Phone",
    "userAgentString": "Mozilla/5.0 (Linux; U; Android 4.0.1; en-us; sdk Build/ICS_MR0) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30"
  },
  "androidTablet": {
    "deviceName": "Motorola Xoom",
    "name": "Android Tablet",
    "userAgentString": "Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13"
  },
  "ipad": {
    "deviceName": "iPad2",
    "name": "iPad",
    "userAgentString": "Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5"
  },
  "iphone": {
    "deviceName": "iPhone4S",
    "name": "iPhone",
    "userAgentString": "Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5"
  }
};


// assets/js/bundle/guardian/guardian.js
goog.provide("optly.guardian.Guardian");

goog.require("optly.edit.option.UserAgents");
goog.require("optly.guardian.GuardType");
goog.require("optly.guardian.GuardLinkType");
goog.require("optly.verify.Verifier");
goog.require("optly.verify.Level");
goog.require('optly.Shortlink');
goog.require("optly.util.main");
goog.require("optly.Account");
goog.require("optly.env");

/**
 * Build URL for Previews and verify S3 is updated before loading
 *
 * @constructor
 */
optly.guardian.Guardian = function() {

  this.guardLinkType = optly.guardian.GuardLinkType.LIVE;
  this.projectId = null;
  this.revision = null;
  this.verifyAmazonDeferred = null;
  this.verifier = new optly.verify.Verifier();
  this.verifier.onLevelChanged.add(goog.bind(this.handleLevelChanged, this));

};

optly.guardian.WAITING_FOR_UPDATE_URL = sprintf('%s/waiting-for-changes-to-upload', optly.env.HOST_URL);
optly.guardian.PREVIEW_WINDOW_NAME = 'preview';

/**
 * Reset the verification level for this account (eg. indicate we need to reverify S3/CDN
 *
 * @param {number} accountId
 */
optly.guardian.Guardian.prototype.drop = function(accountId) {
  this.handleLevelChanged(accountId, optly.verify.Level.AMAZON);
};

/**
 * @param {optly.guardian.GuardType} type
 * @param {string} url
 * @param {string} userAgent
 * @param {number} accountId
 * @param {number|string} experimentId
 * @param {Array.<number>} sectionIds
 * @param {Array.<number>} variationIndices
 */
optly.guardian.Guardian.prototype.open = function(type, url, userAgent, accountId,
                                                  experimentId, sectionIds,
                                                  variationIndices) {

  //If the user has already clicked preview once and we are pinging cdn, prevent
  //overriding deferred object and stacking redirects
  if (this.verifyAmazonDeferred && this.verifyAmazonDeferred.state() === 'pending') {
    return;
  }

  //If user is going through a proxy or has opted to preview the page with an explicitly
  //specified user agent
  var showHostedPreview = this.guardLinkType !== optly.guardian.GuardLinkType.LIVE || Boolean(userAgent);

  if (this.guardLinkType === optly.guardian.GuardLinkType.HOSTED_WITH_LIVE_REDIRECT) {
    url = $.param.querystring(url, {'optimizely_check_for_snippet': accountId});
  }

  var previewURL = this.generateUrl(
      type,
      url,
      userAgent,
      accountId,
      experimentId,
      sectionIds,
      variationIndices,
      showHostedPreview
  );

  var previewWindow;

  //If snippet is already uploaded to S3, go to new window immediately. Otherwise wait.
  if (this.isReady()) {
    previewWindow = window.open(previewURL, optly.guardian.PREVIEW_WINDOW_NAME);
  }
  else {

    //we have to open the window in response to the user click as most browsers will
    //block window.open calls not triggered by user interaction (eg. asynch calls)
    previewWindow = window.open(optly.guardian.WAITING_FOR_UPDATE_URL, optly.guardian.PREVIEW_WINDOW_NAME);
    this.verifyAmazonDeferred = new $.Deferred();

    //This will redirect the "preview" window to the previewURL once we have verified S3 status
    this.verifyAmazonDeferred.done(function () {
      if (previewWindow && previewWindow.location) {
        previewWindow.location = previewURL;
      }
    });
  }
  previewWindow && previewWindow.focus();
};

/**
 *
 * @param {optly.guardian.GuardLinkType} guardLinkType
 */
optly.guardian.Guardian.prototype.toggle = function(guardLinkType) {
  this.guardLinkType = guardLinkType;
};

/**
 * @param {number} projectId
 * @param {number} revision
 */
optly.guardian.Guardian.prototype.verify = function(projectId, revision) {
  this.projectId = projectId;
  this.revision = revision;
  this.verifier.verify(projectId, revision);
};

/**
 * @param {optly.guardian.GuardType} type
 * @param {string} baseUrl
 * @param {string} userAgent
 * @param {number} accountId
 * @param {number|string} experimentId
 * @param {Array.<number>} sectionIds
 * @param {Array.<number>} variationIndices
 * @param {boolean} hosted
 * @private
 */
optly.guardian.Guardian.prototype.generateUrl = function(type, baseUrl, userAgent,
                                                         accountId, experimentId,
                                                         sectionIds, variationIndices,
                                                         hosted) {


  var experiment = experimentId;

  if (sectionIds.length > 0) {
    experiment = sectionIds.join(",");
  }

  var parameters = {};

  // Include the snippet url parameter if this is a hosted link so that the proxy knows
  // which client js snippet to insert into the source of the page
  if (hosted) {
    var local = window.location.hostname.indexOf("local") !== -1;
    var snippetHost = local ? "local" : "s3";
    parameters['optimizely_snippet'] = sprintf("%s-%d", snippetHost, accountId);
  }

  if (type === optly.guardian.GuardType.PREVIEW) {
    parameters['optimizely_show_preview'] = 'true';
  }

  var account = optly.Account.getInstance();
  parameters["optimizely_token"] = account.getPreviewJsFilename(this.projectId);
  parameters["optimizely_x" + experimentId] = variationIndices.join("_");

  var prefix = optly.env.PREVIEW_URL + '/';

  if (!hosted) {
    prefix = "";
  }

  if (userAgent) {
    parameters['optimizely_user_agent'] = optly.edit.option.UserAgents[userAgent].userAgentString;
  }

  var url = generateEditUrl(baseUrl, parameters, prefix);

  if (type === optly.guardian.GuardType.CROSS_BROWSER) {
    url = "/tool/experiment/cross_browser?url=" + encodeURIComponent(url);
  }

  return url;
};


/**
 * @param {number} accountId
 * @param {optly.verify.Level} level
 * @private
 */
optly.guardian.Guardian.prototype.handleLevelChanged = function(accountId, level) {

  this.level = level;

  if (this.verifyAmazonDeferred && this.isReady()) {
    this.verifyAmazonDeferred.resolve();
  }
};

/**
 * Determines whether we are ready to direct the user to the preview page. This means verifying that the most
 * recent version of the snippet has been uploaded to S3. You might think we would check to see that the most
 * recent version was uploaded to the CDN, however client.js bootstraps preview from S3 rather than the CDN.
 *
 * @private
 *
 * @return {boolean}
 */
optly.guardian.Guardian.prototype.isReady = function() {
  return this.level === optly.verify.Level.CDN || this.level === optly.verify.Level.DONE;
};


// assets/js/bundle/third_party/jquery/ui.js
goog.provide("optly.jquery.ui");

goog.require("optly.jquery");

/*!
 * jQuery UI 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function( $, undefined ) {

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
  return;
}

$.extend( $.ui, {
  version: "1.8.20",

  keyCode: {
    ALT: 18,
    BACKSPACE: 8,
    CAPS_LOCK: 20,
    COMMA: 188,
    COMMAND: 91,
    COMMAND_LEFT: 91, // COMMAND
    COMMAND_RIGHT: 93,
    CONTROL: 17,
    DELETE: 46,
    DOWN: 40,
    END: 35,
    ENTER: 13,
    ESCAPE: 27,
    HOME: 36,
    INSERT: 45,
    LEFT: 37,
    MENU: 93, // COMMAND_RIGHT
    NUMPAD_ADD: 107,
    NUMPAD_DECIMAL: 110,
    NUMPAD_DIVIDE: 111,
    NUMPAD_ENTER: 108,
    NUMPAD_MULTIPLY: 106,
    NUMPAD_SUBTRACT: 109,
    PAGE_DOWN: 34,
    PAGE_UP: 33,
    PERIOD: 190,
    RIGHT: 39,
    SHIFT: 16,
    SPACE: 32,
    TAB: 9,
    UP: 38,
    WINDOWS: 91 // COMMAND
  }
});

// plugins
$.fn.extend({
  propAttr: $.fn.prop || $.fn.attr,

  _focus: $.fn.focus,
  focus: function( delay, fn ) {
    return typeof delay === "number" ?
      this.each(function() {
        var elem = this;
        setTimeout(function() {
          $( elem ).focus();
          if ( fn ) {
            fn.call( elem );
          }
        }, delay );
      }) :
      this._focus.apply( this, arguments );
  },

  scrollParent: function() {
    var scrollParent;
    if (($.browser.msie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
      scrollParent = this.parents().filter(function() {
        return (/(relative|absolute|fixed)/).test($.curCSS(this,'position',1)) && (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
      }).eq(0);
    } else {
      scrollParent = this.parents().filter(function() {
        return (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
      }).eq(0);
    }

    return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
  },

  zIndex: function( zIndex ) {
    if ( zIndex !== undefined ) {
      return this.css( "zIndex", zIndex );
    }

    if ( this.length ) {
      var elem = $( this[ 0 ] ), position, value;
      while ( elem.length && elem[ 0 ] !== document ) {
        // Ignore z-index if position is set to a value where z-index is ignored by the browser
        // This makes behavior of this function consistent across browsers
        // WebKit always returns auto if the element is positioned
        position = elem.css( "position" );
        if ( position === "absolute" || position === "relative" || position === "fixed" ) {
          // IE returns 0 when zIndex is not specified
          // other browsers return a string
          // we ignore the case of nested elements with an explicit value of 0
          // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
          value = parseInt( elem.css( "zIndex" ), 10 );
          if ( !isNaN( value ) && value !== 0 ) {
            return value;
          }
        }
        elem = elem.parent();
      }
    }

    return 0;
  },

  disableSelection: function() {
    return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
      ".ui-disableSelection", function( event ) {
        event.preventDefault();
      });
  },

  enableSelection: function() {
    return this.unbind( ".ui-disableSelection" );
  }
});

$.each( [ "Width", "Height" ], function( i, name ) {
  var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
    type = name.toLowerCase(),
    orig = {
      innerWidth: $.fn.innerWidth,
      innerHeight: $.fn.innerHeight,
      outerWidth: $.fn.outerWidth,
      outerHeight: $.fn.outerHeight
    };

  function reduce( elem, size, border, margin ) {
    $.each( side, function() {
      size -= parseFloat( $.curCSS( elem, "padding" + this, true) ) || 0;
      if ( border ) {
        size -= parseFloat( $.curCSS( elem, "border" + this + "Width", true) ) || 0;
      }
      if ( margin ) {
        size -= parseFloat( $.curCSS( elem, "margin" + this, true) ) || 0;
      }
    });
    return size;
  }

  $.fn[ "inner" + name ] = function( size ) {
    if ( size === undefined ) {
      return orig[ "inner" + name ].call( this );
    }

    return this.each(function() {
      $( this ).css( type, reduce( this, size ) + "px" );
    });
  };

  $.fn[ "outer" + name] = function( size, margin ) {
    if ( typeof size !== "number" ) {
      return orig[ "outer" + name ].call( this, size );
    }

    return this.each(function() {
      $( this).css( type, reduce( this, size, true, margin ) + "px" );
    });
  };
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
  var nodeName = element.nodeName.toLowerCase();
  if ( "area" === nodeName ) {
    var map = element.parentNode,
      mapName = map.name,
      img;
    if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
      return false;
    }
    img = $( "img[usemap=#" + mapName + "]" )[0];
    return !!img && visible( img );
  }
  return ( /input|select|textarea|button|object/.test( nodeName )
    ? !element.disabled
    : "a" == nodeName
      ? element.href || isTabIndexNotNaN
      : isTabIndexNotNaN)
    // the element and all of its ancestors must be visible
    && visible( element );
}

function visible( element ) {
  return !$( element ).parents().andSelf().filter(function() {
    return $.curCSS( this, "visibility" ) === "hidden" ||
      $.expr.filters.hidden( this );
  }).length;
}

$.extend( $.expr[ ":" ], {
  data: function( elem, i, match ) {
    return !!$.data( elem, match[ 3 ] );
  },

  focusable: function( element ) {
    return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
  },

  tabbable: function( element ) {
    var tabIndex = $.attr( element, "tabindex" ),
      isTabIndexNaN = isNaN( tabIndex );
    return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
  }
});

// support
$(function() {
  var body = document.body,
    div = body.appendChild( div = document.createElement( "div" ) );

  // access offsetHeight before setting the style to prevent a layout bug
  // in IE 9 which causes the elemnt to continue to take up space even
  // after it is removed from the DOM (#8026)
  div.offsetHeight;

  $.extend( div.style, {
    minHeight: "100px",
    height: "auto",
    padding: 0,
    borderWidth: 0
  });

  $.support.minHeight = div.offsetHeight === 100;
  $.support.selectstart = "onselectstart" in div;

  // set display to none to avoid a layout bug in IE
  // http://dev.jquery.com/ticket/4014
  body.removeChild( div ).style.display = "none";
});





// deprecated
$.extend( $.ui, {
  // $.ui.plugin is deprecated.  Use the proxy pattern instead.
  plugin: {
    add: function( module, option, set ) {
      var proto = $.ui[ module ].prototype;
      for ( var i in set ) {
        proto.plugins[ i ] = proto.plugins[ i ] || [];
        proto.plugins[ i ].push( [ option, set[ i ] ] );
      }
    },
    call: function( instance, name, args ) {
      var set = instance.plugins[ name ];
      if ( !set || !instance.element[ 0 ].parentNode ) {
        return;
      }

      for ( var i = 0; i < set.length; i++ ) {
        if ( instance.options[ set[ i ][ 0 ] ] ) {
          set[ i ][ 1 ].apply( instance.element, args );
        }
      }
    }
  },

  // will be deprecated when we switch to jQuery 1.4 - use jQuery.contains()
  contains: function( a, b ) {
    return document.compareDocumentPosition ?
      a.compareDocumentPosition( b ) & 16 :
      a !== b && a.contains( b );
  },

  // only used by resizable
  hasScroll: function( el, a ) {

    //If overflow is hidden, the element might have extra content, but the user wants to hide it
    if ( $( el ).css( "overflow" ) === "hidden") {
      return false;
    }

    var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
      has = false;

    if ( el[ scroll ] > 0 ) {
      return true;
    }

    // TODO: determine which cases actually cause this to happen
    // if the element doesn't have the scroll set, see if it's possible to
    // set the scroll
    el[ scroll ] = 1;
    has = ( el[ scroll ] > 0 );
    el[ scroll ] = 0;
    return has;
  },

  // these are odd functions, fix the API or move into individual plugins
  isOverAxis: function( x, reference, size ) {
    //Determines when x coordinate is over "b" element axis
    return ( x > reference ) && ( x < ( reference + size ) );
  },
  isOver: function( y, x, top, left, height, width ) {
    //Determines when x, y coordinates is over "b" element
    return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
  }
});

})( jQuery );
/*!
 * jQuery UI Widget 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function( $, undefined ) {

// jQuery 1.4+
if ( $.cleanData ) {
  var _cleanData = $.cleanData;
  $.cleanData = function( elems ) {
    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
      try {
        $( elem ).triggerHandler( "remove" );
      // http://bugs.jquery.com/ticket/8235
      } catch( e ) {}
    }
    _cleanData( elems );
  };
} else {
  var _remove = $.fn.remove;
  $.fn.remove = function( selector, keepData ) {
    return this.each(function() {
      if ( !keepData ) {
        if ( !selector || $.filter( selector, [ this ] ).length ) {
          $( "*", this ).add( [ this ] ).each(function() {
            try {
              $( this ).triggerHandler( "remove" );
            // http://bugs.jquery.com/ticket/8235
            } catch( e ) {}
          });
        }
      }
      return _remove.call( $(this), selector, keepData );
    });
  };
}

$.widget = function( name, base, prototype ) {
  var namespace = name.split( "." )[ 0 ],
    fullName;
  name = name.split( "." )[ 1 ];
  fullName = namespace + "-" + name;

  if ( !prototype ) {
    prototype = base;
    base = $.Widget;
  }

  // create selector for plugin
  $.expr[ ":" ][ fullName ] = function( elem ) {
    return !!$.data( elem, name );
  };

  $[ namespace ] = $[ namespace ] || {};
  $[ namespace ][ name ] = function( options, element ) {
    // allow instantiation without initializing for simple inheritance
    if ( arguments.length ) {
      this._createWidget( options, element );
    }
  };

  var basePrototype = new base();
  // we need to make the options hash a property directly on the new instance
  // otherwise we'll modify the options hash on the prototype that we're
  // inheriting from
//  $.each( basePrototype, function( key, val ) {
//    if ( $.isPlainObject(val) ) {
//      basePrototype[ key ] = $.extend( {}, val );
//    }
//  });
  basePrototype.options = $.extend( true, {}, basePrototype.options );
  $[ namespace ][ name ].prototype = $.extend( true, basePrototype, {
    namespace: namespace,
    widgetName: name,
    widgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,
    widgetBaseClass: fullName
  }, prototype );

  $.widget.bridge( name, $[ namespace ][ name ] );
};

$.widget.bridge = function( name, object ) {
  $.fn[ name ] = function( options ) {
    var isMethodCall = typeof options === "string",
      args = Array.prototype.slice.call( arguments, 1 ),
      returnValue = this;

    // allow multiple hashes to be passed on init
    options = !isMethodCall && args.length ?
      $.extend.apply( null, [ true, options ].concat(args) ) :
      options;

    // prevent calls to internal methods
    if ( isMethodCall && options.charAt( 0 ) === "_" ) {
      return returnValue;
    }

    if ( isMethodCall ) {
      this.each(function() {
        var instance = $.data( this, name ),
          methodValue = instance && $.isFunction( instance[options] ) ?
            instance[ options ].apply( instance, args ) :
            instance;
        // TODO: add this back in 1.9 and use $.error() (see #5972)
//        if ( !instance ) {
//          throw "cannot call methods on " + name + " prior to initialization; " +
//            "attempted to call method '" + options + "'";
//        }
//        if ( !$.isFunction( instance[options] ) ) {
//          throw "no such method '" + options + "' for " + name + " widget instance";
//        }
//        var methodValue = instance[ options ].apply( instance, args );
        if ( methodValue !== instance && methodValue !== undefined ) {
          returnValue = methodValue;
          return false;
        }
      });
    } else {
      this.each(function() {
        var instance = $.data( this, name );
        if ( instance ) {
          instance.option( options || {} )._init();
        } else {
          $.data( this, name, new object( options, this ) );
        }
      });
    }

    return returnValue;
  };
};

$.Widget = function( options, element ) {
  // allow instantiation without initializing for simple inheritance
  if ( arguments.length ) {
    this._createWidget( options, element );
  }
};

$.Widget.prototype = {
  widgetName: "widget",
  widgetEventPrefix: "",
  options: {
    disabled: false
  },
  _createWidget: function( options, element ) {
    // $.widget.bridge stores the plugin instance, but we do it anyway
    // so that it's stored even before the _create function runs
    $.data( element, this.widgetName, this );
    this.element = $( element );
    this.options = $.extend( true, {},
      this.options,
      this._getCreateOptions(),
      options );

    var self = this;
    this.element.bind( "remove." + this.widgetName, function() {
      self.destroy();
    });

    this._create();
    this._trigger( "create" );
    this._init();
  },
  _getCreateOptions: function() {
    return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
  },
  _create: function() {},
  _init: function() {},

  destroy: function() {
    this.element
      .unbind( "." + this.widgetName )
      .removeData( this.widgetName );
    this.widget()
      .unbind( "." + this.widgetName )
      .removeAttr( "aria-disabled" )
      .removeClass(
        this.widgetBaseClass + "-disabled " +
        "ui-state-disabled" );
  },

  widget: function() {
    return this.element;
  },

  option: function( key, value ) {
    var options = key;

    if ( arguments.length === 0 ) {
      // don't return a reference to the internal hash
      return $.extend( {}, this.options );
    }

    if  (typeof key === "string" ) {
      if ( value === undefined ) {
        return this.options[ key ];
      }
      options = {};
      options[ key ] = value;
    }

    this._setOptions( options );

    return this;
  },
  _setOptions: function( options ) {
    var self = this;
    $.each( options, function( key, value ) {
      self._setOption( key, value );
    });

    return this;
  },
  _setOption: function( key, value ) {
    this.options[ key ] = value;

    if ( key === "disabled" ) {
      this.widget()
        [ value ? "addClass" : "removeClass"](
          this.widgetBaseClass + "-disabled" + " " +
          "ui-state-disabled" )
        .attr( "aria-disabled", value );
    }

    return this;
  },

  enable: function() {
    return this._setOption( "disabled", false );
  },
  disable: function() {
    return this._setOption( "disabled", true );
  },

  _trigger: function( type, event, data ) {
    var prop, orig,
      callback = this.options[ type ];

    data = data || {};
    event = $.Event( event );
    event.type = ( type === this.widgetEventPrefix ?
      type :
      this.widgetEventPrefix + type ).toLowerCase();
    // the original event may come from any element
    // so we need to reset the target on the new event
    event.target = this.element[ 0 ];

    // copy original event properties over to the new event
    orig = event.originalEvent;
    if ( orig ) {
      for ( prop in orig ) {
        if ( !( prop in event ) ) {
          event[ prop ] = orig[ prop ];
        }
      }
    }

    this.element.trigger( event, data );

    return !( $.isFunction(callback) &&
      callback.call( this.element[0], event, data ) === false ||
      event.isDefaultPrevented() );
  }
};

})( jQuery );
/*!
 * jQuery UI Mouse 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *  jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
  mouseHandled = false;
});

$.widget("ui.mouse", {
  options: {
    cancel: ':input,option',
    distance: 1,
    delay: 0
  },
  _mouseInit: function() {
    var self = this;

    this.element
      .bind('mousedown.'+this.widgetName, function(event) {
        return self._mouseDown(event);
      })
      .bind('click.'+this.widgetName, function(event) {
        if (true === $.data(event.target, self.widgetName + '.preventClickEvent')) {
            $.removeData(event.target, self.widgetName + '.preventClickEvent');
          event.stopImmediatePropagation();
          return false;
        }
      });

    this.started = false;
  },

  // TODO: make sure destroying one instance of mouse doesn't mess with
  // other instances of mouse
  _mouseDestroy: function() {
    this.element.unbind('.'+this.widgetName);
    $(document)
      .unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
      .unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);
  },

  _mouseDown: function(event) {
    // don't let more than one widget handle mouseStart
    if( mouseHandled ) { return };

    // we may have missed mouseup (out of window)
    (this._mouseStarted && this._mouseUp(event));

    this._mouseDownEvent = event;

    var self = this,
      btnIsLeft = (event.which == 1),
      // event.target.nodeName works around a bug in IE 8 with
      // disabled inputs (#7620)
      elIsCancel = (typeof this.options.cancel == "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
    if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
      return true;
    }

    this.mouseDelayMet = !this.options.delay;
    if (!this.mouseDelayMet) {
      this._mouseDelayTimer = setTimeout(function() {
        self.mouseDelayMet = true;
      }, this.options.delay);
    }

    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
      this._mouseStarted = (this._mouseStart(event) !== false);
      if (!this._mouseStarted) {
        event.preventDefault();
        return true;
      }
    }

    // Click event may never have fired (Gecko & Opera)
    if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
      $.removeData(event.target, this.widgetName + '.preventClickEvent');
    }

    // these delegates are required to keep context
    this._mouseMoveDelegate = function(event) {
      return self._mouseMove(event);
    };
    this._mouseUpDelegate = function(event) {
      return self._mouseUp(event);
    };
    $(document)
      .bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
      .bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

    event.preventDefault();

    mouseHandled = true;
    return true;
  },

  _mouseMove: function(event) {
    // IE mouseup check - mouseup happened when mouse was out of window
    if ($.browser.msie && !(document.documentMode >= 9) && !event.button) {
      return this._mouseUp(event);
    }

    if (this._mouseStarted) {
      this._mouseDrag(event);
      return event.preventDefault();
    }

    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
      this._mouseStarted =
        (this._mouseStart(this._mouseDownEvent, event) !== false);
      (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
    }

    return !this._mouseStarted;
  },

  _mouseUp: function(event) {
    $(document)
      .unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
      .unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

    if (this._mouseStarted) {
      this._mouseStarted = false;

      if (event.target == this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + '.preventClickEvent', true);
      }

      this._mouseStop(event);
    }

    return false;
  },

  _mouseDistanceMet: function(event) {
    return (Math.max(
        Math.abs(this._mouseDownEvent.pageX - event.pageX),
        Math.abs(this._mouseDownEvent.pageY - event.pageY)
      ) >= this.options.distance
    );
  },

  _mouseDelayMet: function(event) {
    return this.mouseDelayMet;
  },

  // These are placeholder methods, to be overriden by extending plugin
  _mouseStart: function(event) {},
  _mouseDrag: function(event) {},
  _mouseStop: function(event) {},
  _mouseCapture: function(event) { return true; }
});

})(jQuery);
/*!
 * jQuery UI Position 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
  verticalPositions = /top|center|bottom/,
  center = "center",
  support = {},
  _position = $.fn.position,
  _offset = $.fn.offset;

$.fn.position = function( options ) {
  if ( !options || !options.of ) {
    return _position.apply( this, arguments );
  }

  // make a copy, we don't want to modify arguments
  options = $.extend( {}, options );

  var target = $( options.of ),
    targetElem = target[0],
    collision = ( options.collision || "flip" ).split( " " ),
    offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
    targetWidth,
    targetHeight,
    basePosition;

  if ( targetElem.nodeType === 9 ) {
    targetWidth = target.width();
    targetHeight = target.height();
    basePosition = { top: 0, left: 0 };
  // TODO: use $.isWindow() in 1.9
  } else if ( targetElem.setTimeout ) {
    targetWidth = target.width();
    targetHeight = target.height();
    basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
  } else if ( targetElem.preventDefault ) {
    // force left top to allow flipping
    options.at = "left top";
    targetWidth = targetHeight = 0;
    basePosition = { top: options.of.pageY, left: options.of.pageX };
  } else {
    targetWidth = target.outerWidth();
    targetHeight = target.outerHeight();
    basePosition = target.offset();
  }

  // force my and at to have valid horizontal and veritcal positions
  // if a value is missing or invalid, it will be converted to center
  $.each( [ "my", "at" ], function() {
    var pos = ( options[this] || "" ).split( " " );
    if ( pos.length === 1) {
      pos = horizontalPositions.test( pos[0] ) ?
        pos.concat( [center] ) :
        verticalPositions.test( pos[0] ) ?
          [ center ].concat( pos ) :
          [ center, center ];
    }
    pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
    pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
    options[ this ] = pos;
  });

  // normalize collision option
  if ( collision.length === 1 ) {
    collision[ 1 ] = collision[ 0 ];
  }

  // normalize offset option
  offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
  if ( offset.length === 1 ) {
    offset[ 1 ] = offset[ 0 ];
  }
  offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

  if ( options.at[0] === "right" ) {
    basePosition.left += targetWidth;
  } else if ( options.at[0] === center ) {
    basePosition.left += targetWidth / 2;
  }

  if ( options.at[1] === "bottom" ) {
    basePosition.top += targetHeight;
  } else if ( options.at[1] === center ) {
    basePosition.top += targetHeight / 2;
  }

  basePosition.left += offset[ 0 ];
  basePosition.top += offset[ 1 ];

  return this.each(function() {
    var elem = $( this ),
      elemWidth = elem.outerWidth(),
      elemHeight = elem.outerHeight(),
      marginLeft = parseInt( $.curCSS( this, "marginLeft", true ) ) || 0,
      marginTop = parseInt( $.curCSS( this, "marginTop", true ) ) || 0,
      collisionWidth = elemWidth + marginLeft +
        ( parseInt( $.curCSS( this, "marginRight", true ) ) || 0 ),
      collisionHeight = elemHeight + marginTop +
        ( parseInt( $.curCSS( this, "marginBottom", true ) ) || 0 ),
      position = $.extend( {}, basePosition ),
      collisionPosition;

    if ( options.my[0] === "right" ) {
      position.left -= elemWidth;
    } else if ( options.my[0] === center ) {
      position.left -= elemWidth / 2;
    }

    if ( options.my[1] === "bottom" ) {
      position.top -= elemHeight;
    } else if ( options.my[1] === center ) {
      position.top -= elemHeight / 2;
    }

    // prevent fractions if jQuery version doesn't support them (see #5280)
    if ( !support.fractions ) {
      position.left = Math.round( position.left );
      position.top = Math.round( position.top );
    }

    collisionPosition = {
      left: position.left - marginLeft,
      top: position.top - marginTop
    };

    $.each( [ "left", "top" ], function( i, dir ) {
      if ( $.ui.position[ collision[i] ] ) {
        $.ui.position[ collision[i] ][ dir ]( position, {
          targetWidth: targetWidth,
          targetHeight: targetHeight,
          elemWidth: elemWidth,
          elemHeight: elemHeight,
          collisionPosition: collisionPosition,
          collisionWidth: collisionWidth,
          collisionHeight: collisionHeight,
          offset: offset,
          my: options.my,
          at: options.at
        });
      }
    });

    if ( $.fn.bgiframe ) {
      elem.bgiframe();
    }
    elem.offset( $.extend( position, { using: options.using } ) );
  });
};

$.ui.position = {
  fit: {
    left: function( position, data ) {
      var win = $( window ),
        over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
      position.left = over > 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
    },
    top: function( position, data ) {
      var win = $( window ),
        over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
      position.top = over > 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
    }
  },

  flip: {
    left: function( position, data ) {
      if ( data.at[0] === center ) {
        return;
      }
      var win = $( window ),
        over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
        myOffset = data.my[ 0 ] === "left" ?
          -data.elemWidth :
          data.my[ 0 ] === "right" ?
            data.elemWidth :
            0,
        atOffset = data.at[ 0 ] === "left" ?
          data.targetWidth :
          -data.targetWidth,
        offset = -2 * data.offset[ 0 ];
      position.left += data.collisionPosition.left < 0 ?
        myOffset + atOffset + offset :
        over > 0 ?
          myOffset + atOffset + offset :
          0;
    },
    top: function( position, data ) {
      if ( data.at[1] === center ) {
        return;
      }
      var win = $( window ),
        over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
        myOffset = data.my[ 1 ] === "top" ?
          -data.elemHeight :
          data.my[ 1 ] === "bottom" ?
            data.elemHeight :
            0,
        atOffset = data.at[ 1 ] === "top" ?
          data.targetHeight :
          -data.targetHeight,
        offset = -2 * data.offset[ 1 ];
      position.top += data.collisionPosition.top < 0 ?
        myOffset + atOffset + offset :
        over > 0 ?
          myOffset + atOffset + offset :
          0;
    }
  }
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
  $.offset.setOffset = function( elem, options ) {
    // set position first, in-case top/left are set even on static elem
    if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
      elem.style.position = "relative";
    }
    var curElem   = $( elem ),
      curOffset = curElem.offset(),
      curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
      curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
      props     = {
        top:  (options.top  - curOffset.top)  + curTop,
        left: (options.left - curOffset.left) + curLeft
      };

    if ( 'using' in options ) {
      options.using.call( elem, props );
    } else {
      curElem.css( props );
    }
  };

  $.fn.offset = function( options ) {
    var elem = this[ 0 ];
    if ( !elem || !elem.ownerDocument ) { return null; }
    if ( options ) {
      return this.each(function() {
        $.offset.setOffset( this, options );
      });
    }
    return _offset.call( this );
  };
}

// fraction support test (older versions of jQuery don't support fractions)
(function () {
  var body = document.getElementsByTagName( "body" )[ 0 ],
    div = document.createElement( "div" ),
    testElement, testElementParent, testElementStyle, offset, offsetTotal;

  //Create a "fake body" for testing based on method used in jQuery.support
  testElement = document.createElement( body ? "div" : "body" );
  testElementStyle = {
    visibility: "hidden",
    width: 0,
    height: 0,
    border: 0,
    margin: 0,
    background: "none"
  };
  if ( body ) {
    $.extend( testElementStyle, {
      position: "absolute",
      left: "-1000px",
      top: "-1000px"
    });
  }
  for ( var i in testElementStyle ) {
    testElement.style[ i ] = testElementStyle[ i ];
  }
  testElement.appendChild( div );
  testElementParent = body || document.documentElement;
  testElementParent.insertBefore( testElement, testElementParent.firstChild );

  div.style.cssText = "position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;";

  offset = $( div ).offset( function( _, offset ) {
    return offset;
  }).offset();

  testElement.innerHTML = "";
  testElementParent.removeChild( testElement );

  offsetTotal = offset.top + offset.left + ( body ? 2000 : 0 );
  support.fractions = offsetTotal > 21 && offsetTotal < 22;
})();

}( jQuery ));
/*!
 * jQuery UI Draggable 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.mouse.js
 *  jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
  widgetEventPrefix: "drag",
  options: {
    addClasses: true,
    appendTo: "parent",
    axis: false,
    connectToSortable: false,
    containment: false,
    cursor: "auto",
    cursorAt: false,
    grid: false,
    handle: false,
    helper: "original",
    iframeFix: false,
    opacity: false,
    refreshPositions: false,
    revert: false,
    revertDuration: 500,
    scope: "default",
    scroll: true,
    scrollSensitivity: 20,
    scrollSpeed: 20,
    snap: false,
    snapMode: "both",
    snapTolerance: 20,
    stack: false,
    zIndex: false
  },
  _create: function() {

    if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
      this.element[0].style.position = 'relative';

    (this.options.addClasses && this.element.addClass("ui-draggable"));
    (this.options.disabled && this.element.addClass("ui-draggable-disabled"));

    this._mouseInit();

  },

  destroy: function() {
    if(!this.element.data('draggable')) return;
    this.element
      .removeData("draggable")
      .unbind(".draggable")
      .removeClass("ui-draggable"
        + " ui-draggable-dragging"
        + " ui-draggable-disabled");
    this._mouseDestroy();

    return this;
  },

  _mouseCapture: function(event) {

    var o = this.options;

    // among others, prevent a drag on a resizable-handle
    if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
      return false;

    //Quit if we're not on a valid handle
    this.handle = this._getHandle(event);
    if (!this.handle)
      return false;

    if ( o.iframeFix ) {
      $(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
        $('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
        .css({
          width: this.offsetWidth+"px", height: this.offsetHeight+"px",
          position: "absolute", opacity: "0.001", zIndex: 1000
        })
        .css($(this).offset())
        .appendTo("body");
      });
    }

    return true;

  },

  _mouseStart: function(event) {

    var o = this.options;

    //Create and append the visible helper
    this.helper = this._createHelper(event);

    //Cache the helper size
    this._cacheHelperProportions();

    //If ddmanager is used for droppables, set the global draggable
    if($.ui.ddmanager)
      $.ui.ddmanager.current = this;

    /*
     * - Position generation -
     * This block generates everything position related - it's the core of draggables.
     */

    //Cache the margins of the original element
    this._cacheMargins();

    //Store the helper's css position
    this.cssPosition = this.helper.css("position");
    this.scrollParent = this.helper.scrollParent();

    //The element's absolute position on the page minus margins
    this.offset = this.positionAbs = this.element.offset();
    this.offset = {
      top: this.offset.top - this.margins.top,
      left: this.offset.left - this.margins.left
    };

    $.extend(this.offset, {
      click: { //Where the click happened, relative to the element
        left: event.pageX - this.offset.left,
        top: event.pageY - this.offset.top
      },
      parent: this._getParentOffset(),
      relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
    });

    //Generate the original position
    this.originalPosition = this.position = this._generatePosition(event);
    this.originalPageX = event.pageX;
    this.originalPageY = event.pageY;

    //Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

    //Set a containment if given in the options
    if(o.containment)
      this._setContainment();

    //Trigger event + callbacks
    if(this._trigger("start", event) === false) {
      this._clear();
      return false;
    }

    //Recache the helper size
    this._cacheHelperProportions();

    //Prepare the droppable offsets
    if ($.ui.ddmanager && !o.dropBehaviour)
      $.ui.ddmanager.prepareOffsets(this, event);

    this.helper.addClass("ui-draggable-dragging");
    this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

    //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
    if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);

    return true;
  },

  _mouseDrag: function(event, noPropagation) {

    //Compute the helpers position
    this.position = this._generatePosition(event);
    this.positionAbs = this._convertPositionTo("absolute");

    //Call plugins and callbacks and use the resulting position if something is returned
    if (!noPropagation) {
      var ui = this._uiHash();
      if(this._trigger('drag', event, ui) === false) {
        this._mouseUp({});
        return false;
      }
      this.position = ui.position;
    }

    if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
    if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
    if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

    return false;
  },

  _mouseStop: function(event) {

    //If we are using droppables, inform the manager about the drop
    var dropped = false;
    if ($.ui.ddmanager && !this.options.dropBehaviour)
      dropped = $.ui.ddmanager.drop(this, event);

    //if a drop comes from outside (a sortable)
    if(this.dropped) {
      dropped = this.dropped;
      this.dropped = false;
    }

    //if the original element is no longer in the DOM don't bother to continue (see #8269)
    var element = this.element[0], elementInDom = false;
    while ( element && (element = element.parentNode) ) {
      if (element == document ) {
        elementInDom = true;
      }
    }
    if ( !elementInDom && this.options.helper === "original" )
      return false;

    if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
      var self = this;
      $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
        if(self._trigger("stop", event) !== false) {
          self._clear();
        }
      });
    } else {
      if(this._trigger("stop", event) !== false) {
        this._clear();
      }
    }

    return false;
  },

  _mouseUp: function(event) {
    if (this.options.iframeFix === true) {
      $("div.ui-draggable-iframeFix").each(function() {
        this.parentNode.removeChild(this);
      }); //Remove frame helpers
    }

    //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
    if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);

    return $.ui.mouse.prototype._mouseUp.call(this, event);
  },

  cancel: function() {

    if(this.helper.is(".ui-draggable-dragging")) {
      this._mouseUp({});
    } else {
      this._clear();
    }

    return this;

  },

  _getHandle: function(event) {

    var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
    $(this.options.handle, this.element)
      .find("*")
      .andSelf()
      .each(function() {
        if(this == event.target) handle = true;
      });

    return handle;

  },

  _createHelper: function(event) {

    var o = this.options;
    var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);

    if(!helper.parents('body').length)
      helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

    if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
      helper.css("position", "absolute");

    return helper;

  },

  _adjustOffsetFromHelper: function(obj) {
    if (typeof obj == 'string') {
      obj = obj.split(' ');
    }
    if ($.isArray(obj)) {
      obj = {left: +obj[0], top: +obj[1] || 0};
    }
    if ('left' in obj) {
      this.offset.click.left = obj.left + this.margins.left;
    }
    if ('right' in obj) {
      this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
    }
    if ('top' in obj) {
      this.offset.click.top = obj.top + this.margins.top;
    }
    if ('bottom' in obj) {
      this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
    }
  },

  _getParentOffset: function() {

    //Get the offsetParent and cache its position
    this.offsetParent = this.helper.offsetParent();
    var po = this.offsetParent.offset();

    // This is a special case where we need to modify a offset calculated on start, since the following happened:
    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
    if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
      po.left += this.scrollParent.scrollLeft();
      po.top += this.scrollParent.scrollTop();
    }

    if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
    || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
      po = { top: 0, left: 0 };

    return {
      top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
      left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
    };

  },

  _getRelativeOffset: function() {

    if(this.cssPosition == "relative") {
      var p = this.element.position();
      return {
        top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
        left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
      };
    } else {
      return { top: 0, left: 0 };
    }

  },

  _cacheMargins: function() {
    this.margins = {
      left: (parseInt(this.element.css("marginLeft"),10) || 0),
      top: (parseInt(this.element.css("marginTop"),10) || 0),
      right: (parseInt(this.element.css("marginRight"),10) || 0),
      bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
    };
  },

  _cacheHelperProportions: function() {
    this.helperProportions = {
      width: this.helper.outerWidth(),
      height: this.helper.outerHeight()
    };
  },

  _setContainment: function() {

    var o = this.options;
    if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
    if(o.containment == 'document' || o.containment == 'window') this.containment = [
      o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
      o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
      (o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
      (o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
    ];

    if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
            var c = $(o.containment);
      var ce = c[0]; if(!ce) return;
      var co = c.offset();
      var over = ($(ce).css("overflow") != 'hidden');

      this.containment = [
        (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
        (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
        (over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
        (over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
      ];
      this.relative_container = c;

    } else if(o.containment.constructor == Array) {
      this.containment = o.containment;
    }

  },

  _convertPositionTo: function(d, pos) {

    if(!pos) pos = this.position;
    var mod = d == "absolute" ? 1 : -1;
    var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

    return {
      top: (
        pos.top                                 // The absolute mouse position
        + this.offset.relative.top * mod                    // Only for relative positioned nodes: Relative offset from element to offset parent
        + this.offset.parent.top * mod                      // The offsetParent's offset without borders (offset + border)
        - ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
      ),
      left: (
        pos.left                                // The absolute mouse position
        + this.offset.relative.left * mod                   // Only for relative positioned nodes: Relative offset from element to offset parent
        + this.offset.parent.left * mod                     // The offsetParent's offset without borders (offset + border)
        - ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
      )
    };

  },

  _generatePosition: function(event) {

    var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
    var pageX = event.pageX;
    var pageY = event.pageY;

    /*
     * - Position constraining -
     * Constrain the position to a mix of grid, containment.
     */

    if(this.originalPosition) { //If we are not dragging yet, we won't check for options
             var containment;
             if(this.containment) {
         if (this.relative_container){
             var co = this.relative_container.offset();
             containment = [ this.containment[0] + co.left,
                 this.containment[1] + co.top,
                 this.containment[2] + co.left,
                 this.containment[3] + co.top ];
         }
         else {
             containment = this.containment;
         }

        if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
        if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
        if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
        if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;
      }

      if(o.grid) {
        //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
        var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
        pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

        var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
        pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
      }

    }

    return {
      top: (
        pageY                               // The absolute mouse position
        - this.offset.click.top                         // Click offset (relative to the element)
        - this.offset.relative.top                        // Only for relative positioned nodes: Relative offset from element to offset parent
        - this.offset.parent.top                        // The offsetParent's offset without borders (offset + border)
        + ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
      ),
      left: (
        pageX                               // The absolute mouse position
        - this.offset.click.left                        // Click offset (relative to the element)
        - this.offset.relative.left                       // Only for relative positioned nodes: Relative offset from element to offset parent
        - this.offset.parent.left                       // The offsetParent's offset without borders (offset + border)
        + ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
      )
    };

  },

  _clear: function() {
    this.helper.removeClass("ui-draggable-dragging");
    if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
    //if($.ui.ddmanager) $.ui.ddmanager.current = null;
    this.helper = null;
    this.cancelHelperRemoval = false;
  },

  // From now on bulk stuff - mainly helpers

  _trigger: function(type, event, ui) {
    ui = ui || this._uiHash();
    $.ui.plugin.call(this, type, [event, ui]);
    if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
    return $.Widget.prototype._trigger.call(this, type, event, ui);
  },

  plugins: {},

  _uiHash: function(event) {
    return {
      helper: this.helper,
      position: this.position,
      originalPosition: this.originalPosition,
      offset: this.positionAbs
    };
  }

});

$.extend($.ui.draggable, {
  version: "1.8.20"
});

$.ui.plugin.add("draggable", "connectToSortable", {
  start: function(event, ui) {

    var inst = $(this).data("draggable"), o = inst.options,
      uiSortable = $.extend({}, ui, { item: inst.element });
    inst.sortables = [];
    $(o.connectToSortable).each(function() {
      var sortable = $.data(this, 'sortable');
      if (sortable && !sortable.options.disabled) {
        inst.sortables.push({
          instance: sortable,
          shouldRevert: sortable.options.revert
        });
        sortable.refreshPositions();  // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
        sortable._trigger("activate", event, uiSortable);
      }
    });

  },
  stop: function(event, ui) {

    //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
    var inst = $(this).data("draggable"),
      uiSortable = $.extend({}, ui, { item: inst.element });

    $.each(inst.sortables, function() {
      if(this.instance.isOver) {

        this.instance.isOver = 0;

        inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
        this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

        //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
        if(this.shouldRevert) this.instance.options.revert = true;

        //Trigger the stop of the sortable
        this.instance._mouseStop(event);

        this.instance.options.helper = this.instance.options._helper;

        //If the helper has been the original item, restore properties in the sortable
        if(inst.options.helper == 'original')
          this.instance.currentItem.css({ top: 'auto', left: 'auto' });

      } else {
        this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
        this.instance._trigger("deactivate", event, uiSortable);
      }

    });

  },
  drag: function(event, ui) {

    var inst = $(this).data("draggable"), self = this;

    var checkPos = function(o) {
      var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
      var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
      var itemHeight = o.height, itemWidth = o.width;
      var itemTop = o.top, itemLeft = o.left;

      return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
    };

    $.each(inst.sortables, function(i) {

      //Copy over some variables to allow calling the sortable's native _intersectsWith
      this.instance.positionAbs = inst.positionAbs;
      this.instance.helperProportions = inst.helperProportions;
      this.instance.offset.click = inst.offset.click;

      if(this.instance._intersectsWith(this.instance.containerCache)) {

        //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
        if(!this.instance.isOver) {

          this.instance.isOver = 1;
          //Now we fake the start of dragging for the sortable instance,
          //by cloning the list group item, appending it to the sortable and using it as inst.currentItem
          //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
          this.instance.currentItem = $(self).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true);
          this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
          this.instance.options.helper = function() { return ui.helper[0]; };

          event.target = this.instance.currentItem[0];
          this.instance._mouseCapture(event, true);
          this.instance._mouseStart(event, true, true);

          //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
          this.instance.offset.click.top = inst.offset.click.top;
          this.instance.offset.click.left = inst.offset.click.left;
          this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
          this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

          inst._trigger("toSortable", event);
          inst.dropped = this.instance.element; //draggable revert needs that
          //hack so receive/update callbacks work (mostly)
          inst.currentItem = inst.element;
          this.instance.fromOutside = inst;

        }

        //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
        if(this.instance.currentItem) this.instance._mouseDrag(event);

      } else {

        //If it doesn't intersect with the sortable, and it intersected before,
        //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
        if(this.instance.isOver) {

          this.instance.isOver = 0;
          this.instance.cancelHelperRemoval = true;

          //Prevent reverting on this forced stop
          this.instance.options.revert = false;

          // The out event needs to be triggered independently
          this.instance._trigger('out', event, this.instance._uiHash(this.instance));

          this.instance._mouseStop(event, true);
          this.instance.options.helper = this.instance.options._helper;

          //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
          this.instance.currentItem.remove();
          if(this.instance.placeholder) this.instance.placeholder.remove();

          inst._trigger("fromSortable", event);
          inst.dropped = false; //draggable revert needs that
        }

      };

    });

  }
});

$.ui.plugin.add("draggable", "cursor", {
  start: function(event, ui) {
    var t = $('body'), o = $(this).data('draggable').options;
    if (t.css("cursor")) o._cursor = t.css("cursor");
    t.css("cursor", o.cursor);
  },
  stop: function(event, ui) {
    var o = $(this).data('draggable').options;
    if (o._cursor) $('body').css("cursor", o._cursor);
  }
});

$.ui.plugin.add("draggable", "opacity", {
  start: function(event, ui) {
    var t = $(ui.helper), o = $(this).data('draggable').options;
    if(t.css("opacity")) o._opacity = t.css("opacity");
    t.css('opacity', o.opacity);
  },
  stop: function(event, ui) {
    var o = $(this).data('draggable').options;
    if(o._opacity) $(ui.helper).css('opacity', o._opacity);
  }
});

$.ui.plugin.add("draggable", "scroll", {
  start: function(event, ui) {
    var i = $(this).data("draggable");
    if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
  },
  drag: function(event, ui) {

    var i = $(this).data("draggable"), o = i.options, scrolled = false;

    if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

      if(!o.axis || o.axis != 'x') {
        if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
          i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
        else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
          i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
      }

      if(!o.axis || o.axis != 'y') {
        if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
          i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
        else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
          i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
      }

    } else {

      if(!o.axis || o.axis != 'x') {
        if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
          scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
        else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
          scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
      }

      if(!o.axis || o.axis != 'y') {
        if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
          scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
        else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
          scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
      }

    }

    if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
      $.ui.ddmanager.prepareOffsets(i, event);

  }
});

$.ui.plugin.add("draggable", "snap", {
  start: function(event, ui) {

    var i = $(this).data("draggable"), o = i.options;
    i.snapElements = [];

    $(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
      var $t = $(this); var $o = $t.offset();
      if(this != i.element[0]) i.snapElements.push({
        item: this,
        width: $t.outerWidth(), height: $t.outerHeight(),
        top: $o.top, left: $o.left
      });
    });

  },
  drag: function(event, ui) {

    var inst = $(this).data("draggable"), o = inst.options;
    var d = o.snapTolerance;

    var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
      y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

    for (var i = inst.snapElements.length - 1; i >= 0; i--){

      var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
        t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

      //Yes, I know, this is insane ;)
      if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
        if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
        inst.snapElements[i].snapping = false;
        continue;
      }

      if(o.snapMode != 'inner') {
        var ts = Math.abs(t - y2) <= d;
        var bs = Math.abs(b - y1) <= d;
        var ls = Math.abs(l - x2) <= d;
        var rs = Math.abs(r - x1) <= d;
        if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
        if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
        if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
        if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
      }

      var first = (ts || bs || ls || rs);

      if(o.snapMode != 'outer') {
        var ts = Math.abs(t - y1) <= d;
        var bs = Math.abs(b - y2) <= d;
        var ls = Math.abs(l - x1) <= d;
        var rs = Math.abs(r - x2) <= d;
        if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
        if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
        if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
        if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
      }

      if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
        (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
      inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

    };

  }
});

$.ui.plugin.add("draggable", "stack", {
  start: function(event, ui) {

    var o = $(this).data("draggable").options;

    var group = $.makeArray($(o.stack)).sort(function(a,b) {
      return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
    });
    if (!group.length) { return; }

    var min = parseInt(group[0].style.zIndex) || 0;
    $(group).each(function(i) {
      this.style.zIndex = min + i;
    });

    this[0].style.zIndex = min + group.length;

  }
});

$.ui.plugin.add("draggable", "zIndex", {
  start: function(event, ui) {
    var t = $(ui.helper), o = $(this).data("draggable").options;
    if(t.css("zIndex")) o._zIndex = t.css("zIndex");
    t.css('zIndex', o.zIndex);
  },
  stop: function(event, ui) {
    var o = $(this).data("draggable").options;
    if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
  }
});

})(jQuery);
/*!
 * jQuery UI Droppable 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 *  jquery.ui.draggable.js
 */
(function( $, undefined ) {

$.widget("ui.droppable", {
  widgetEventPrefix: "drop",
  options: {
    accept: '*',
    activeClass: false,
    addClasses: true,
    greedy: false,
    hoverClass: false,
    scope: 'default',
    tolerance: 'intersect'
  },
  _create: function() {

    var o = this.options, accept = o.accept;
    this.isover = 0; this.isout = 1;

    this.accept = $.isFunction(accept) ? accept : function(d) {
      return d.is(accept);
    };

    //Store the droppable's proportions
    this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

    // Add the reference and positions to the manager
    $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
    $.ui.ddmanager.droppables[o.scope].push(this);

    (o.addClasses && this.element.addClass("ui-droppable"));

  },

  destroy: function() {
    var drop = $.ui.ddmanager.droppables[this.options.scope];
    for ( var i = 0; i < drop.length; i++ )
      if ( drop[i] == this )
        drop.splice(i, 1);

    this.element
      .removeClass("ui-droppable ui-droppable-disabled")
      .removeData("droppable")
      .unbind(".droppable");

    return this;
  },

  _setOption: function(key, value) {

    if(key == 'accept') {
      this.accept = $.isFunction(value) ? value : function(d) {
        return d.is(value);
      };
    }
    $.Widget.prototype._setOption.apply(this, arguments);
  },

  _activate: function(event) {
    var draggable = $.ui.ddmanager.current;
    if(this.options.activeClass) this.element.addClass(this.options.activeClass);
    (draggable && this._trigger('activate', event, this.ui(draggable)));
  },

  _deactivate: function(event) {
    var draggable = $.ui.ddmanager.current;
    if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
    (draggable && this._trigger('deactivate', event, this.ui(draggable)));
  },

  _over: function(event) {

    var draggable = $.ui.ddmanager.current;
    if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

    if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
      if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
      this._trigger('over', event, this.ui(draggable));
    }

  },

  _out: function(event) {

    var draggable = $.ui.ddmanager.current;
    if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

    if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
      if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
      this._trigger('out', event, this.ui(draggable));
    }

  },

  _drop: function(event,custom) {

    var draggable = custom || $.ui.ddmanager.current;
    if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

    var childrenIntersection = false;
    this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
      var inst = $.data(this, 'droppable');
      if(
        inst.options.greedy
        && !inst.options.disabled
        && inst.options.scope == draggable.options.scope
        && inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
        && $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
      ) { childrenIntersection = true; return false; }
    });
    if(childrenIntersection) return false;

    if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
      if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
      if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
      this._trigger('drop', event, this.ui(draggable));
      return this.element;
    }

    return false;

  },

  ui: function(c) {
    return {
      draggable: (c.currentItem || c.element),
      helper: c.helper,
      position: c.position,
      offset: c.positionAbs
    };
  }

});

$.extend($.ui.droppable, {
  version: "1.8.20"
});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

  if (!droppable.offset) return false;

  var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
    y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
  var l = droppable.offset.left, r = l + droppable.proportions.width,
    t = droppable.offset.top, b = t + droppable.proportions.height;

  switch (toleranceMode) {
    case 'fit':
      return (l <= x1 && x2 <= r
        && t <= y1 && y2 <= b);
      break;
    case 'intersect':
      return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
        && x2 - (draggable.helperProportions.width / 2) < r // Left Half
        && t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
        && y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
      break;
    case 'pointer':
      var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
        draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
        isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
      return isOver;
      break;
    case 'touch':
      return (
          (y1 >= t && y1 <= b) || // Top edge touching
          (y2 >= t && y2 <= b) || // Bottom edge touching
          (y1 < t && y2 > b)    // Surrounded vertically
        ) && (
          (x1 >= l && x1 <= r) || // Left edge touching
          (x2 >= l && x2 <= r) || // Right edge touching
          (x1 < l && x2 > r)    // Surrounded horizontally
        );
      break;
    default:
      return false;
      break;
    }

};

/*
  This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
  current: null,
  droppables: { 'default': [] },
  prepareOffsets: function(t, event) {

    var m = $.ui.ddmanager.droppables[t.options.scope] || [];
    var type = event ? event.type : null; // workaround for #2317
    var list = (t.currentItem || t.element).find(":data(droppable)").andSelf();

    droppablesLoop: for (var i = 0; i < m.length; i++) {

      if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue; //No disabled and non-accepted
      for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
      m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue;                   //If the element is not visible, continue

      if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

      m[i].offset = m[i].element.offset();
      m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

    }

  },
  drop: function(draggable, event) {

    var dropped = false;
    $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

      if(!this.options) return;
      if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
        dropped = this._drop.call(this, event) || dropped;

      if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
        this.isout = 1; this.isover = 0;
        this._deactivate.call(this, event);
      }

    });
    return dropped;

  },
  dragStart: function( draggable, event ) {
    //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
    draggable.element.parents( ":not(body,html)" ).bind( "scroll.droppable", function() {
      if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
    });
  },
  drag: function(draggable, event) {

    //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
    if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

    //Run through all droppables and check their positions based on specific tolerance options
    $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

      if(this.options.disabled || this.greedyChild || !this.visible) return;
      var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

      var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
      if(!c) return;

      var parentInstance;
      if (this.options.greedy) {
        var parent = this.element.parents(':data(droppable):eq(0)');
        if (parent.length) {
          parentInstance = $.data(parent[0], 'droppable');
          parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
        }
      }

      // we just moved into a greedy child
      if (parentInstance && c == 'isover') {
        parentInstance['isover'] = 0;
        parentInstance['isout'] = 1;
        parentInstance._out.call(parentInstance, event);
      }

      this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
      this[c == "isover" ? "_over" : "_out"].call(this, event);

      // we just moved out of a greedy child
      if (parentInstance && c == 'isout') {
        parentInstance['isout'] = 0;
        parentInstance['isover'] = 1;
        parentInstance._over.call(parentInstance, event);
      }
    });

  },
  dragStop: function( draggable, event ) {
    draggable.element.parents( ":not(body,html)" ).unbind( "scroll.droppable" );
    //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
    if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
  }
};

})(jQuery);
/*!
 * jQuery UI Resizable 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.mouse.js
 *  jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.resizable", $.ui.mouse, {
  widgetEventPrefix: "resize",
  options: {
    alsoResize: false,
    animate: false,
    animateDuration: "slow",
    animateEasing: "swing",
    aspectRatio: false,
    autoHide: false,
    containment: false,
    ghost: false,
    grid: false,
    handles: "e,s,se",
    helper: false,
    maxHeight: null,
    maxWidth: null,
    minHeight: 10,
    minWidth: 10,
    zIndex: 1000
  },
  _create: function() {

    var self = this, o = this.options;
    this.element.addClass("ui-resizable");

    $.extend(this, {
      _aspectRatio: !!(o.aspectRatio),
      aspectRatio: o.aspectRatio,
      originalElement: this.element,
      _proportionallyResizeElements: [],
      _helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
    });

    //Wrap the element if it cannot hold child nodes
    if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

      //Create a wrapper element and set the wrapper to the new current internal element
      this.element.wrap(
        $('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
          position: this.element.css('position'),
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          top: this.element.css('top'),
          left: this.element.css('left')
        })
      );

      //Overwrite the original this.element
      this.element = this.element.parent().data(
        "resizable", this.element.data('resizable')
      );

      this.elementIsWrapper = true;

      //Move margins to the wrapper
      this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
      this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

      //Prevent Safari textarea resize
      this.originalResizeStyle = this.originalElement.css('resize');
      this.originalElement.css('resize', 'none');

      //Push the actual element to our proportionallyResize internal array
      this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

      // avoid IE jump (hard set the margin)
      this.originalElement.css({ margin: this.originalElement.css('margin') });

      // fix handlers offset
      this._proportionallyResize();

    }

    this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
    if(this.handles.constructor == String) {

      if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
      var n = this.handles.split(","); this.handles = {};

      for(var i = 0; i < n.length; i++) {

        var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
        var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

        // Apply zIndex to all handles - see #7960
        axis.css({ zIndex: o.zIndex });

        //TODO : What's going on here?
        if ('se' == handle) {
          axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
        };

        //Insert into internal handles object and append to element
        this.handles[handle] = '.ui-resizable-'+handle;
        this.element.append(axis);
      }

    }

    this._renderAxis = function(target) {

      target = target || this.element;

      for(var i in this.handles) {

        if(this.handles[i].constructor == String)
          this.handles[i] = $(this.handles[i], this.element).show();

        //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
        if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

          var axis = $(this.handles[i], this.element), padWrapper = 0;

          //Checking the correct pad and border
          padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

          //The padding type i have to apply...
          var padPos = [ 'padding',
            /ne|nw|n/.test(i) ? 'Top' :
            /se|sw|s/.test(i) ? 'Bottom' :
            /^e$/.test(i) ? 'Right' : 'Left' ].join("");

          target.css(padPos, padWrapper);

          this._proportionallyResize();

        }

        //TODO: What's that good for? There's not anything to be executed left
        if(!$(this.handles[i]).length)
          continue;

      }
    };

    //TODO: make renderAxis a prototype function
    this._renderAxis(this.element);

    this._handles = $('.ui-resizable-handle', this.element)
      .disableSelection();

    //Matching axis name
    this._handles.mouseover(function() {
      if (!self.resizing) {
        if (this.className)
          var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
        //Axis, default = se
        self.axis = axis && axis[1] ? axis[1] : 'se';
      }
    });

    //If we want to auto hide the elements
    if (o.autoHide) {
      this._handles.hide();
      $(this.element)
        .addClass("ui-resizable-autohide")
        .hover(function() {
          if (o.disabled) return;
          $(this).removeClass("ui-resizable-autohide");
          self._handles.show();
        },
        function(){
          if (o.disabled) return;
          if (!self.resizing) {
            $(this).addClass("ui-resizable-autohide");
            self._handles.hide();
          }
        });
    }

    //Initialize the mouse interaction
    this._mouseInit();

  },

  destroy: function() {

    this._mouseDestroy();

    var _destroy = function(exp) {
      $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
        .removeData("resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
    };

    //TODO: Unwrap at same DOM position
    if (this.elementIsWrapper) {
      _destroy(this.element);
      var wrapper = this.element;
      wrapper.after(
        this.originalElement.css({
          position: wrapper.css('position'),
          width: wrapper.outerWidth(),
          height: wrapper.outerHeight(),
          top: wrapper.css('top'),
          left: wrapper.css('left')
        })
      ).remove();
    }

    this.originalElement.css('resize', this.originalResizeStyle);
    _destroy(this.originalElement);

    return this;
  },

  _mouseCapture: function(event) {
    var handle = false;
    for (var i in this.handles) {
      if ($(this.handles[i])[0] == event.target) {
        handle = true;
      }
    }

    return !this.options.disabled && handle;
  },

  _mouseStart: function(event) {

    var o = this.options, iniPos = this.element.position(), el = this.element;

    this.resizing = true;
    this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

    // bugfix for http://dev.jquery.com/ticket/1749
    if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
      el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
    }

    this._renderProxy();

    var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

    if (o.containment) {
      curleft += $(o.containment).scrollLeft() || 0;
      curtop += $(o.containment).scrollTop() || 0;
    }

    //Store needed variables
    this.offset = this.helper.offset();
    this.position = { left: curleft, top: curtop };
    this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
    this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
    this.originalPosition = { left: curleft, top: curtop };
    this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
    this.originalMousePosition = { left: event.pageX, top: event.pageY };

    //Aspect Ratio
    this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

      var cursor = $('.ui-resizable-' + this.axis).css('cursor');
      $('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

    el.addClass("ui-resizable-resizing");
    this._propagate("start", event);
    return true;
  },

  _mouseDrag: function(event) {

    //Increase performance, avoid regex
    var el = this.helper, o = this.options, props = {},
      self = this, smp = this.originalMousePosition, a = this.axis;

    var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
    var trigger = this._change[a];
    if (!trigger) return false;

    // Calculate the attrs that will be change
    var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie && $.browser.version < 7, csdif = this.sizeDiff;

    // Put this in the mouseDrag handler since the user can start pressing shift while resizing
    this._updateVirtualBoundaries(event.shiftKey);
    if (this._aspectRatio || event.shiftKey)
      data = this._updateRatio(data, event);

    data = this._respectSize(data, event);

    // plugins callbacks need to be called first
    this._propagate("resize", event);

    el.css({
      top: this.position.top + "px", left: this.position.left + "px",
      width: this.size.width + "px", height: this.size.height + "px"
    });

    if (!this._helper && this._proportionallyResizeElements.length)
      this._proportionallyResize();

    this._updateCache(data);

    // calling the user callback at the end
    this._trigger('resize', event, this.ui());

    return false;
  },

  _mouseStop: function(event) {

    this.resizing = false;
    var o = this.options, self = this;

    if(this._helper) {
      var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
        soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
        soffsetw = ista ? 0 : self.sizeDiff.width;

      var s = { width: (self.helper.width()  - soffsetw), height: (self.helper.height() - soffseth) },
        left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
        top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

      if (!o.animate)
        this.element.css($.extend(s, { top: top, left: left }));

      self.helper.height(self.size.height);
      self.helper.width(self.size.width);

      if (this._helper && !o.animate) this._proportionallyResize();
    }

    $('body').css('cursor', 'auto');

    this.element.removeClass("ui-resizable-resizing");

    this._propagate("stop", event);

    if (this._helper) this.helper.remove();
    return false;

  },

    _updateVirtualBoundaries: function(forceAspectRatio) {
        var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

        b = {
            minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
            maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
            minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
            maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
        };

        if(this._aspectRatio || forceAspectRatio) {
            // We want to create an enclosing box whose aspect ration is the requested one
            // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
            pMinWidth = b.minHeight * this.aspectRatio;
            pMinHeight = b.minWidth / this.aspectRatio;
            pMaxWidth = b.maxHeight * this.aspectRatio;
            pMaxHeight = b.maxWidth / this.aspectRatio;

            if(pMinWidth > b.minWidth) b.minWidth = pMinWidth;
            if(pMinHeight > b.minHeight) b.minHeight = pMinHeight;
            if(pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
            if(pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;
        }
        this._vBoundaries = b;
    },

  _updateCache: function(data) {
    var o = this.options;
    this.offset = this.helper.offset();
    if (isNumber(data.left)) this.position.left = data.left;
    if (isNumber(data.top)) this.position.top = data.top;
    if (isNumber(data.height)) this.size.height = data.height;
    if (isNumber(data.width)) this.size.width = data.width;
  },

  _updateRatio: function(data, event) {

    var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

    if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
    else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

    if (a == 'sw') {
      data.left = cpos.left + (csize.width - data.width);
      data.top = null;
    }
    if (a == 'nw') {
      data.top = cpos.top + (csize.height - data.height);
      data.left = cpos.left + (csize.width - data.width);
    }

    return data;
  },

  _respectSize: function(data, event) {

    var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
        ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
          isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

    if (isminw) data.width = o.minWidth;
    if (isminh) data.height = o.minHeight;
    if (ismaxw) data.width = o.maxWidth;
    if (ismaxh) data.height = o.maxHeight;

    var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
    var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

    if (isminw && cw) data.left = dw - o.minWidth;
    if (ismaxw && cw) data.left = dw - o.maxWidth;
    if (isminh && ch) data.top = dh - o.minHeight;
    if (ismaxh && ch) data.top = dh - o.maxHeight;

    // fixing jump error on top/left - bug #2330
    var isNotwh = !data.width && !data.height;
    if (isNotwh && !data.left && data.top) data.top = null;
    else if (isNotwh && !data.top && data.left) data.left = null;

    return data;
  },

  _proportionallyResize: function() {

    var o = this.options;
    if (!this._proportionallyResizeElements.length) return;
    var element = this.helper || this.element;

    for (var i=0; i < this._proportionallyResizeElements.length; i++) {

      var prel = this._proportionallyResizeElements[i];

      if (!this.borderDif) {
        var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
          p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

        this.borderDif = $.map(b, function(v, i) {
          var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
          return border + padding;
        });
      }

      if ($.browser.msie && !(!($(element).is(':hidden') || $(element).parents(':hidden').length)))
        continue;

      prel.css({
        height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
        width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
      });

    };

  },

  _renderProxy: function() {

    var el = this.element, o = this.options;
    this.elementOffset = el.offset();

    if(this._helper) {

      this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

      // fix ie6 offset TODO: This seems broken
      var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0),
      pxyoffset = ( ie6 ? 2 : -1 );

      this.helper.addClass(this._helper).css({
        width: this.element.outerWidth() + pxyoffset,
        height: this.element.outerHeight() + pxyoffset,
        position: 'absolute',
        left: this.elementOffset.left - ie6offset +'px',
        top: this.elementOffset.top - ie6offset +'px',
        zIndex: ++o.zIndex //TODO: Don't modify option
      });

      this.helper
        .appendTo("body")
        .disableSelection();

    } else {
      this.helper = this.element;
    }

  },

  _change: {
    e: function(event, dx, dy) {
      return { width: this.originalSize.width + dx };
    },
    w: function(event, dx, dy) {
      var o = this.options, cs = this.originalSize, sp = this.originalPosition;
      return { left: sp.left + dx, width: cs.width - dx };
    },
    n: function(event, dx, dy) {
      var o = this.options, cs = this.originalSize, sp = this.originalPosition;
      return { top: sp.top + dy, height: cs.height - dy };
    },
    s: function(event, dx, dy) {
      return { height: this.originalSize.height + dy };
    },
    se: function(event, dx, dy) {
      return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
    },
    sw: function(event, dx, dy) {
      return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
    },
    ne: function(event, dx, dy) {
      return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
    },
    nw: function(event, dx, dy) {
      return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
    }
  },

  _propagate: function(n, event) {
    $.ui.plugin.call(this, n, [event, this.ui()]);
    (n != "resize" && this._trigger(n, event, this.ui()));
  },

  plugins: {},

  ui: function() {
    return {
      originalElement: this.originalElement,
      element: this.element,
      helper: this.helper,
      position: this.position,
      size: this.size,
      originalSize: this.originalSize,
      originalPosition: this.originalPosition
    };
  }

});

$.extend($.ui.resizable, {
  version: "1.8.20"
});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

  start: function (event, ui) {
    var self = $(this).data("resizable"), o = self.options;

    var _store = function (exp) {
      $(exp).each(function() {
        var el = $(this);
        el.data("resizable-alsoresize", {
          width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
          left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10)
        });
      });
    };

    if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
      if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
      else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
    }else{
      _store(o.alsoResize);
    }
  },

  resize: function (event, ui) {
    var self = $(this).data("resizable"), o = self.options, os = self.originalSize, op = self.originalPosition;

    var delta = {
      height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,
      top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0
    },

    _alsoResize = function (exp, c) {
      $(exp).each(function() {
        var el = $(this), start = $(this).data("resizable-alsoresize"), style = {},
          css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

        $.each(css, function (i, prop) {
          var sum = (start[prop]||0) + (delta[prop]||0);
          if (sum && sum >= 0)
            style[prop] = sum || null;
        });

        el.css(style);
      });
    };

    if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
      $.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
    }else{
      _alsoResize(o.alsoResize);
    }
  },

  stop: function (event, ui) {
    $(this).removeData("resizable-alsoresize");
  }
});

$.ui.plugin.add("resizable", "animate", {

  stop: function(event, ui) {
    var self = $(this).data("resizable"), o = self.options;

    var pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
          soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
            soffsetw = ista ? 0 : self.sizeDiff.width;

    var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
          left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
            top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

    self.element.animate(
      $.extend(style, top && left ? { top: top, left: left } : {}), {
        duration: o.animateDuration,
        easing: o.animateEasing,
        step: function() {

          var data = {
            width: parseInt(self.element.css('width'), 10),
            height: parseInt(self.element.css('height'), 10),
            top: parseInt(self.element.css('top'), 10),
            left: parseInt(self.element.css('left'), 10)
          };

          if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

          // propagating resize, and updating values for each animation step
          self._updateCache(data);
          self._propagate("resize", event);

        }
      }
    );
  }

});

$.ui.plugin.add("resizable", "containment", {

  start: function(event, ui) {
    var self = $(this).data("resizable"), o = self.options, el = self.element;
    var oc = o.containment, ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
    if (!ce) return;

    self.containerElement = $(ce);

    if (/document/.test(oc) || oc == document) {
      self.containerOffset = { left: 0, top: 0 };
      self.containerPosition = { left: 0, top: 0 };

      self.parentData = {
        element: $(document), left: 0, top: 0,
        width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
      };
    }

    // i'm a node, so compute top, left, right, bottom
    else {
      var element = $(ce), p = [];
      $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

      self.containerOffset = element.offset();
      self.containerPosition = element.position();
      self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

      var co = self.containerOffset, ch = self.containerSize.height,  cw = self.containerSize.width,
            width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

      self.parentData = {
        element: ce, left: co.left, top: co.top, width: width, height: height
      };
    }
  },

  resize: function(event, ui) {
    var self = $(this).data("resizable"), o = self.options,
        ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,
        pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;

    if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

    if (cp.left < (self._helper ? co.left : 0)) {
      self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));
      if (pRatio) self.size.height = self.size.width / self.aspectRatio;
      self.position.left = o.helper ? co.left : 0;
    }

    if (cp.top < (self._helper ? co.top : 0)) {
      self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);
      if (pRatio) self.size.width = self.size.height * self.aspectRatio;
      self.position.top = self._helper ? co.top : 0;
    }

    self.offset.left = self.parentData.left+self.position.left;
    self.offset.top = self.parentData.top+self.position.top;

    var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),
          hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );

    var isParent = self.containerElement.get(0) == self.element.parent().get(0),
        isOffsetRelative = /relative|absolute/.test(self.containerElement.css('position'));

    if(isParent && isOffsetRelative) woset -= self.parentData.left;

    if (woset + self.size.width >= self.parentData.width) {
      self.size.width = self.parentData.width - woset;
      if (pRatio) self.size.height = self.size.width / self.aspectRatio;
    }

    if (hoset + self.size.height >= self.parentData.height) {
      self.size.height = self.parentData.height - hoset;
      if (pRatio) self.size.width = self.size.height * self.aspectRatio;
    }
  },

  stop: function(event, ui){
    var self = $(this).data("resizable"), o = self.options, cp = self.position,
        co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;

    var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;

    if (self._helper && !o.animate && (/relative/).test(ce.css('position')))
      $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

    if (self._helper && !o.animate && (/static/).test(ce.css('position')))
      $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

  }
});

$.ui.plugin.add("resizable", "ghost", {

  start: function(event, ui) {

    var self = $(this).data("resizable"), o = self.options, cs = self.size;

    self.ghost = self.originalElement.clone();
    self.ghost
      .css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
      .addClass('ui-resizable-ghost')
      .addClass(typeof o.ghost == 'string' ? o.ghost : '');

    self.ghost.appendTo(self.helper);

  },

  resize: function(event, ui){
    var self = $(this).data("resizable"), o = self.options;
    if (self.ghost) self.ghost.css({ position: 'relative', height: self.size.height, width: self.size.width });
  },

  stop: function(event, ui){
    var self = $(this).data("resizable"), o = self.options;
    if (self.ghost && self.helper) self.helper.get(0).removeChild(self.ghost.get(0));
  }

});

$.ui.plugin.add("resizable", "grid", {

  resize: function(event, ui) {
    var self = $(this).data("resizable"), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;
    o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
    var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

    if (/^(se|s|e)$/.test(a)) {
      self.size.width = os.width + ox;
      self.size.height = os.height + oy;
    }
    else if (/^(ne)$/.test(a)) {
      self.size.width = os.width + ox;
      self.size.height = os.height + oy;
      self.position.top = op.top - oy;
    }
    else if (/^(sw)$/.test(a)) {
      self.size.width = os.width + ox;
      self.size.height = os.height + oy;
      self.position.left = op.left - ox;
    }
    else {
      self.size.width = os.width + ox;
      self.size.height = os.height + oy;
      self.position.top = op.top - oy;
      self.position.left = op.left - ox;
    }
  }

});

var num = function(v) {
  return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
  return !isNaN(parseInt(value, 10));
};

})(jQuery);
/*!
 * jQuery UI Selectable 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Selectables
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.mouse.js
 *  jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.selectable", $.ui.mouse, {
  options: {
    appendTo: 'body',
    autoRefresh: true,
    distance: 0,
    filter: '*',
    tolerance: 'touch'
  },
  _create: function() {
    var self = this;

    this.element.addClass("ui-selectable");

    this.dragged = false;

    // cache selectee children based on filter
    var selectees;
    this.refresh = function() {
      selectees = $(self.options.filter, self.element[0]);
      selectees.addClass("ui-selectee");
      selectees.each(function() {
        var $this = $(this);
        var pos = $this.offset();
        $.data(this, "selectable-item", {
          element: this,
          $element: $this,
          left: pos.left,
          top: pos.top,
          right: pos.left + $this.outerWidth(),
          bottom: pos.top + $this.outerHeight(),
          startselected: false,
          selected: $this.hasClass('ui-selected'),
          selecting: $this.hasClass('ui-selecting'),
          unselecting: $this.hasClass('ui-unselecting')
        });
      });
    };
    this.refresh();

    this.selectees = selectees.addClass("ui-selectee");

    this._mouseInit();

    this.helper = $("<div class='ui-selectable-helper'></div>");
  },

  destroy: function() {
    this.selectees
      .removeClass("ui-selectee")
      .removeData("selectable-item");
    this.element
      .removeClass("ui-selectable ui-selectable-disabled")
      .removeData("selectable")
      .unbind(".selectable");
    this._mouseDestroy();

    return this;
  },

  _mouseStart: function(event) {
    var self = this;

    this.opos = [event.pageX, event.pageY];

    if (this.options.disabled)
      return;

    var options = this.options;

    this.selectees = $(options.filter, this.element[0]);

    this._trigger("start", event);

    $(options.appendTo).append(this.helper);
    // position helper (lasso)
    this.helper.css({
      "left": event.clientX,
      "top": event.clientY,
      "width": 0,
      "height": 0
    });

    if (options.autoRefresh) {
      this.refresh();
    }

    this.selectees.filter('.ui-selected').each(function() {
      var selectee = $.data(this, "selectable-item");
      selectee.startselected = true;
      if (!event.metaKey && !event.ctrlKey) {
        selectee.$element.removeClass('ui-selected');
        selectee.selected = false;
        selectee.$element.addClass('ui-unselecting');
        selectee.unselecting = true;
        // selectable UNSELECTING callback
        self._trigger("unselecting", event, {
          unselecting: selectee.element
        });
      }
    });

    $(event.target).parents().andSelf().each(function() {
      var selectee = $.data(this, "selectable-item");
      if (selectee) {
        var doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass('ui-selected');
        selectee.$element
          .removeClass(doSelect ? "ui-unselecting" : "ui-selected")
          .addClass(doSelect ? "ui-selecting" : "ui-unselecting");
        selectee.unselecting = !doSelect;
        selectee.selecting = doSelect;
        selectee.selected = doSelect;
        // selectable (UN)SELECTING callback
        if (doSelect) {
          self._trigger("selecting", event, {
            selecting: selectee.element
          });
        } else {
          self._trigger("unselecting", event, {
            unselecting: selectee.element
          });
        }
        return false;
      }
    });

  },

  _mouseDrag: function(event) {
    var self = this;
    this.dragged = true;

    if (this.options.disabled)
      return;

    var options = this.options;

    var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
    if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
    if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
    this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

    this.selectees.each(function() {
      var selectee = $.data(this, "selectable-item");
      //prevent helper from being selected if appendTo: selectable
      if (!selectee || selectee.element == self.element[0])
        return;
      var hit = false;
      if (options.tolerance == 'touch') {
        hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
      } else if (options.tolerance == 'fit') {
        hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
      }

      if (hit) {
        // SELECT
        if (selectee.selected) {
          selectee.$element.removeClass('ui-selected');
          selectee.selected = false;
        }
        if (selectee.unselecting) {
          selectee.$element.removeClass('ui-unselecting');
          selectee.unselecting = false;
        }
        if (!selectee.selecting) {
          selectee.$element.addClass('ui-selecting');
          selectee.selecting = true;
          // selectable SELECTING callback
          self._trigger("selecting", event, {
            selecting: selectee.element
          });
        }
      } else {
        // UNSELECT
        if (selectee.selecting) {
          if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
            selectee.$element.removeClass('ui-selecting');
            selectee.selecting = false;
            selectee.$element.addClass('ui-selected');
            selectee.selected = true;
          } else {
            selectee.$element.removeClass('ui-selecting');
            selectee.selecting = false;
            if (selectee.startselected) {
              selectee.$element.addClass('ui-unselecting');
              selectee.unselecting = true;
            }
            // selectable UNSELECTING callback
            self._trigger("unselecting", event, {
              unselecting: selectee.element
            });
          }
        }
        if (selectee.selected) {
          if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
            selectee.$element.removeClass('ui-selected');
            selectee.selected = false;

            selectee.$element.addClass('ui-unselecting');
            selectee.unselecting = true;
            // selectable UNSELECTING callback
            self._trigger("unselecting", event, {
              unselecting: selectee.element
            });
          }
        }
      }
    });

    return false;
  },

  _mouseStop: function(event) {
    var self = this;

    this.dragged = false;

    var options = this.options;

    $('.ui-unselecting', this.element[0]).each(function() {
      var selectee = $.data(this, "selectable-item");
      selectee.$element.removeClass('ui-unselecting');
      selectee.unselecting = false;
      selectee.startselected = false;
      self._trigger("unselected", event, {
        unselected: selectee.element
      });
    });
    $('.ui-selecting', this.element[0]).each(function() {
      var selectee = $.data(this, "selectable-item");
      selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
      selectee.selecting = false;
      selectee.selected = true;
      selectee.startselected = true;
      self._trigger("selected", event, {
        selected: selectee.element
      });
    });
    this._trigger("stop", event);

    this.helper.remove();

    return false;
  }

});

$.extend($.ui.selectable, {
  version: "1.8.20"
});

})(jQuery);
/*!
 * jQuery UI Sortable 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.mouse.js
 *  jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.sortable", $.ui.mouse, {
  widgetEventPrefix: "sort",
  ready: false,
  options: {
    appendTo: "parent",
    axis: false,
    connectWith: false,
    containment: false,
    cursor: 'auto',
    cursorAt: false,
    dropOnEmpty: true,
    forcePlaceholderSize: false,
    forceHelperSize: false,
    grid: false,
    handle: false,
    helper: "original",
    items: '> *',
    opacity: false,
    placeholder: false,
    revert: false,
    scroll: true,
    scrollSensitivity: 20,
    scrollSpeed: 20,
    scope: "default",
    tolerance: "intersect",
    zIndex: 1000
  },
  _create: function() {

    var o = this.options;
    this.containerCache = {};
    this.element.addClass("ui-sortable");

    //Get the items
    this.refresh();

    //Let's determine if the items are being displayed horizontally
    this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;

    //Let's determine the parent's offset
    this.offset = this.element.offset();

    //Initialize mouse events for interaction
    this._mouseInit();

    //We're ready to go
    this.ready = true

  },

  destroy: function() {
    $.Widget.prototype.destroy.call( this );
    this.element
      .removeClass("ui-sortable ui-sortable-disabled");
    this._mouseDestroy();

    for ( var i = this.items.length - 1; i >= 0; i-- )
      this.items[i].item.removeData(this.widgetName + "-item");

    return this;
  },

  _setOption: function(key, value){
    if ( key === "disabled" ) {
      this.options[ key ] = value;

      this.widget()
        [ value ? "addClass" : "removeClass"]( "ui-sortable-disabled" );
    } else {
      // Don't call widget base _setOption for disable as it adds ui-state-disabled class
      $.Widget.prototype._setOption.apply(this, arguments);
    }
  },

  _mouseCapture: function(event, overrideHandle) {
    var that = this;

    if (this.reverting) {
      return false;
    }

    if(this.options.disabled || this.options.type == 'static') return false;

    //We have to refresh the items data once first
    this._refreshItems(event);

    //Find out if the clicked node (or one of its parents) is a actual item in this.items
    var currentItem = null, self = this, nodes = $(event.target).parents().each(function() {
      if($.data(this, that.widgetName + '-item') == self) {
        currentItem = $(this);
        return false;
      }
    });
    if($.data(event.target, that.widgetName + '-item') == self) currentItem = $(event.target);

    if(!currentItem) return false;
    if(this.options.handle && !overrideHandle) {
      var validHandle = false;

      $(this.options.handle, currentItem).find("*").andSelf().each(function() { if(this == event.target) validHandle = true; });
      if(!validHandle) return false;
    }

    this.currentItem = currentItem;
    this._removeCurrentsFromItems();
    return true;

  },

  _mouseStart: function(event, overrideHandle, noActivation) {

    var o = this.options, self = this;
    this.currentContainer = this;

    //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
    this.refreshPositions();

    //Create and append the visible helper
    this.helper = this._createHelper(event);

    //Cache the helper size
    this._cacheHelperProportions();

    /*
     * - Position generation -
     * This block generates everything position related - it's the core of draggables.
     */

    //Cache the margins of the original element
    this._cacheMargins();

    //Get the next scrolling parent
    this.scrollParent = this.helper.scrollParent();

    //The element's absolute position on the page minus margins
    this.offset = this.currentItem.offset();
    this.offset = {
      top: this.offset.top - this.margins.top,
      left: this.offset.left - this.margins.left
    };

    // Only after we got the offset, we can change the helper's position to absolute
    // TODO: Still need to figure out a way to make relative sorting possible
    this.helper.css("position", "absolute");
    this.cssPosition = this.helper.css("position");

    $.extend(this.offset, {
      click: { //Where the click happened, relative to the element
        left: event.pageX - this.offset.left,
        top: event.pageY - this.offset.top
      },
      parent: this._getParentOffset(),
      relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
    });

    //Generate the original position
    this.originalPosition = this._generatePosition(event);
    this.originalPageX = event.pageX;
    this.originalPageY = event.pageY;

    //Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

    //Cache the former DOM position
    this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

    //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
    if(this.helper[0] != this.currentItem[0]) {
      this.currentItem.hide();
    }

    //Create the placeholder
    this._createPlaceholder();

    //Set a containment if given in the options
    if(o.containment)
      this._setContainment();

    if(o.cursor) { // cursor option
      if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
      $('body').css("cursor", o.cursor);
    }

    if(o.opacity) { // opacity option
      if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
      this.helper.css("opacity", o.opacity);
    }

    if(o.zIndex) { // zIndex option
      if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
      this.helper.css("zIndex", o.zIndex);
    }

    //Prepare scrolling
    if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
      this.overflowOffset = this.scrollParent.offset();

    //Call callbacks
    this._trigger("start", event, this._uiHash());

    //Recache the helper size
    if(!this._preserveHelperProportions)
      this._cacheHelperProportions();


    //Post 'activate' events to possible containers
    if(!noActivation) {
       for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, self._uiHash(this)); }
    }

    //Prepare possible droppables
    if($.ui.ddmanager)
      $.ui.ddmanager.current = this;

    if ($.ui.ddmanager && !o.dropBehaviour)
      $.ui.ddmanager.prepareOffsets(this, event);

    this.dragging = true;

    this.helper.addClass("ui-sortable-helper");
    this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
    return true;

  },

  _mouseDrag: function(event) {

    //Compute the helpers position
    this.position = this._generatePosition(event);
    this.positionAbs = this._convertPositionTo("absolute");

    if (!this.lastPositionAbs) {
      this.lastPositionAbs = this.positionAbs;
    }

    //Do scrolling
    if(this.options.scroll) {
      var o = this.options, scrolled = false;
      if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

        if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
          this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
        else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)
          this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

        if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
          this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
        else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)
          this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

      } else {

        if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
          scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
        else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
          scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

        if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
          scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
        else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
          scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

      }

      if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
        $.ui.ddmanager.prepareOffsets(this, event);
    }

    //Regenerate the absolute position used for position checks
    this.positionAbs = this._convertPositionTo("absolute");

    //Set the helper position
    if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
    if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';

    //Rearrange
    for (var i = this.items.length - 1; i >= 0; i--) {

      //Cache variables and intersection, continue if no intersection
      var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
      if (!intersection) continue;

      if(itemElement != this.currentItem[0] //cannot intersect with itself
        &&  this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
        &&  !$.ui.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
        && (this.options.type == 'semi-dynamic' ? !$.ui.contains(this.element[0], itemElement) : true)
        //&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
      ) {

        this.direction = intersection == 1 ? "down" : "up";

        if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
          this._rearrange(event, item);
        } else {
          break;
        }

        this._trigger("change", event, this._uiHash());
        break;
      }
    }

    //Post events to containers
    this._contactContainers(event);

    //Interconnect with droppables
    if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

    //Call callbacks
    this._trigger('sort', event, this._uiHash());

    this.lastPositionAbs = this.positionAbs;
    return false;

  },

  _mouseStop: function(event, noPropagation) {

    if(!event) return;

    //If we are using droppables, inform the manager about the drop
    if ($.ui.ddmanager && !this.options.dropBehaviour)
      $.ui.ddmanager.drop(this, event);

    if(this.options.revert) {
      var self = this;
      var cur = self.placeholder.offset();

      self.reverting = true;

      $(this.helper).animate({
        left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
        top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
      }, parseInt(this.options.revert, 10) || 500, function() {
        self._clear(event);
      });
    } else {
      this._clear(event, noPropagation);
    }

    return false;

  },

  cancel: function() {

    var self = this;

    if(this.dragging) {

      this._mouseUp({ target: null });

      if(this.options.helper == "original")
        this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
      else
        this.currentItem.show();

      //Post deactivating events to containers
      for (var i = this.containers.length - 1; i >= 0; i--){
        this.containers[i]._trigger("deactivate", null, self._uiHash(this));
        if(this.containers[i].containerCache.over) {
          this.containers[i]._trigger("out", null, self._uiHash(this));
          this.containers[i].containerCache.over = 0;
        }
      }

    }

    if (this.placeholder) {
      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
      if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
      if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

      $.extend(this, {
        helper: null,
        dragging: false,
        reverting: false,
        _noFinalSort: null
      });

      if(this.domPosition.prev) {
        $(this.domPosition.prev).after(this.currentItem);
      } else {
        $(this.domPosition.parent).prepend(this.currentItem);
      }
    }

    return this;

  },

  serialize: function(o) {

    var items = this._getItemsAsjQuery(o && o.connected);
    var str = []; o = o || {};

    $(items).each(function() {
      var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
      if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));
    });

    if(!str.length && o.key) {
      str.push(o.key + '=');
    }

    return str.join('&');

  },

  toArray: function(o) {

    var items = this._getItemsAsjQuery(o && o.connected);
    var ret = []; o = o || {};

    items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });
    return ret;

  },

  /* Be careful with the following core functions */
  _intersectsWith: function(item) {

    var x1 = this.positionAbs.left,
      x2 = x1 + this.helperProportions.width,
      y1 = this.positionAbs.top,
      y2 = y1 + this.helperProportions.height;

    var l = item.left,
      r = l + item.width,
      t = item.top,
      b = t + item.height;

    var dyClick = this.offset.click.top,
      dxClick = this.offset.click.left;

    var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

    if(    this.options.tolerance == "pointer"
      || this.options.forcePointerForContainers
      || (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
    ) {
      return isOverElement;
    } else {

      return (l < x1 + (this.helperProportions.width / 2) // Right Half
        && x2 - (this.helperProportions.width / 2) < r // Left Half
        && t < y1 + (this.helperProportions.height / 2) // Bottom Half
        && y2 - (this.helperProportions.height / 2) < b ); // Top Half

    }
  },

  _intersectsWithPointer: function(item) {

    var isOverElementHeight = (this.options.axis === 'x') || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
      isOverElementWidth = (this.options.axis === 'y') || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
      isOverElement = isOverElementHeight && isOverElementWidth,
      verticalDirection = this._getDragVerticalDirection(),
      horizontalDirection = this._getDragHorizontalDirection();

    if (!isOverElement)
      return false;

    return this.floating ?
      ( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
      : ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

  },

  _intersectsWithSides: function(item) {

    var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
      isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
      verticalDirection = this._getDragVerticalDirection(),
      horizontalDirection = this._getDragHorizontalDirection();

    if (this.floating && horizontalDirection) {
      return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
    } else {
      return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
    }

  },

  _getDragVerticalDirection: function() {
    var delta = this.positionAbs.top - this.lastPositionAbs.top;
    return delta != 0 && (delta > 0 ? "down" : "up");
  },

  _getDragHorizontalDirection: function() {
    var delta = this.positionAbs.left - this.lastPositionAbs.left;
    return delta != 0 && (delta > 0 ? "right" : "left");
  },

  refresh: function(event) {
    this._refreshItems(event);
    this.refreshPositions();
    return this;
  },

  _connectWith: function() {
    var options = this.options;
    return options.connectWith.constructor == String
      ? [options.connectWith]
      : options.connectWith;
  },

  _getItemsAsjQuery: function(connected) {

    var self = this;
    var items = [];
    var queries = [];
    var connectWith = this._connectWith();

    if(connectWith && connected) {
      for (var i = connectWith.length - 1; i >= 0; i--){
        var cur = $(connectWith[i]);
        for (var j = cur.length - 1; j >= 0; j--){
          var inst = $.data(cur[j], this.widgetName);
          if(inst && inst != this && !inst.options.disabled) {
            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
          }
        };
      };
    }

    queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

    for (var i = queries.length - 1; i >= 0; i--){
      queries[i][0].each(function() {
        items.push(this);
      });
    };

    return $(items);

  },

  _removeCurrentsFromItems: function() {

    var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

    for (var i=0; i < this.items.length; i++) {

      for (var j=0; j < list.length; j++) {
        if(list[j] == this.items[i].item[0])
          this.items.splice(i,1);
      };

    };

  },

  _refreshItems: function(event) {

    this.items = [];
    this.containers = [this];
    var items = this.items;
    var self = this;
    var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
    var connectWith = this._connectWith();

    if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
      for (var i = connectWith.length - 1; i >= 0; i--){
        var cur = $(connectWith[i]);
        for (var j = cur.length - 1; j >= 0; j--){
          var inst = $.data(cur[j], this.widgetName);
          if(inst && inst != this && !inst.options.disabled) {
            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
            this.containers.push(inst);
          }
        };
      };
    }

    for (var i = queries.length - 1; i >= 0; i--) {
      var targetData = queries[i][1];
      var _queries = queries[i][0];

      for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {
        var item = $(_queries[j]);

        item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)

        items.push({
          item: item,
          instance: targetData,
          width: 0, height: 0,
          left: 0, top: 0
        });
      };
    };

  },

  refreshPositions: function(fast) {

    //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
    if(this.offsetParent && this.helper) {
      this.offset.parent = this._getParentOffset();
    }

    for (var i = this.items.length - 1; i >= 0; i--){
      var item = this.items[i];

      //We ignore calculating positions of all connected containers when we're not over them
      if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])
        continue;

      var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

      if (!fast) {
        item.width = t.outerWidth();
        item.height = t.outerHeight();
      }

      var p = t.offset();
      item.left = p.left;
      item.top = p.top;
    };

    if(this.options.custom && this.options.custom.refreshContainers) {
      this.options.custom.refreshContainers.call(this);
    } else {
      for (var i = this.containers.length - 1; i >= 0; i--){
        var p = this.containers[i].element.offset();
        this.containers[i].containerCache.left = p.left;
        this.containers[i].containerCache.top = p.top;
        this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
        this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
      };
    }

    return this;
  },

  _createPlaceholder: function(that) {

    var self = that || this, o = self.options;

    if(!o.placeholder || o.placeholder.constructor == String) {
      var className = o.placeholder;
      o.placeholder = {
        element: function() {

          var el = $(document.createElement(self.currentItem[0].nodeName))
            .addClass(className || self.currentItem[0].className+" ui-sortable-placeholder")
            .removeClass("ui-sortable-helper")[0];

          if(!className)
            el.style.visibility = "hidden";

          return el;
        },
        update: function(container, p) {

          // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
          // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
          if(className && !o.forcePlaceholderSize) return;

          //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
          if(!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css('paddingTop')||0, 10) - parseInt(self.currentItem.css('paddingBottom')||0, 10)); };
          if(!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css('paddingLeft')||0, 10) - parseInt(self.currentItem.css('paddingRight')||0, 10)); };
        }
      };
    }

    //Create the placeholder
    self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem));

    //Append it after the actual current item
    self.currentItem.after(self.placeholder);

    //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
    o.placeholder.update(self, self.placeholder);

  },

  _contactContainers: function(event) {

    // get innermost container that intersects with item
    var innermostContainer = null, innermostIndex = null;


    for (var i = this.containers.length - 1; i >= 0; i--){

      // never consider a container that's located within the item itself
      if($.ui.contains(this.currentItem[0], this.containers[i].element[0]))
        continue;

      if(this._intersectsWith(this.containers[i].containerCache)) {

        // if we've already found a container and it's more "inner" than this, then continue
        if(innermostContainer && $.ui.contains(this.containers[i].element[0], innermostContainer.element[0]))
          continue;

        innermostContainer = this.containers[i];
        innermostIndex = i;

      } else {
        // container doesn't intersect. trigger "out" event if necessary
        if(this.containers[i].containerCache.over) {
          this.containers[i]._trigger("out", event, this._uiHash(this));
          this.containers[i].containerCache.over = 0;
        }
      }

    }

    // if no intersecting containers found, return
    if(!innermostContainer) return;

    // move the item into the container if it's not there already
    if(this.containers.length === 1) {
      this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
      this.containers[innermostIndex].containerCache.over = 1;
    } else if(this.currentContainer != this.containers[innermostIndex]) {

      //When entering a new container, we will find the item with the least distance and append our item near it
      var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? 'left' : 'top'];
      for (var j = this.items.length - 1; j >= 0; j--) {
        if(!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
        var cur = this.items[j][this.containers[innermostIndex].floating ? 'left' : 'top'];
        if(Math.abs(cur - base) < dist) {
          dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
        }
      }

      if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled
        return;

      this.currentContainer = this.containers[innermostIndex];
      itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
      this._trigger("change", event, this._uiHash());
      this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

      //Update the placeholder
      this.options.placeholder.update(this.currentContainer, this.placeholder);

      this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
      this.containers[innermostIndex].containerCache.over = 1;
    }


  },

  _createHelper: function(event) {

    var o = this.options;
    var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

    if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
      $(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

    if(helper[0] == this.currentItem[0])
      this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

    if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
    if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

    return helper;

  },

  _adjustOffsetFromHelper: function(obj) {
    if (typeof obj == 'string') {
      obj = obj.split(' ');
    }
    if ($.isArray(obj)) {
      obj = {left: +obj[0], top: +obj[1] || 0};
    }
    if ('left' in obj) {
      this.offset.click.left = obj.left + this.margins.left;
    }
    if ('right' in obj) {
      this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
    }
    if ('top' in obj) {
      this.offset.click.top = obj.top + this.margins.top;
    }
    if ('bottom' in obj) {
      this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
    }
  },

  _getParentOffset: function() {


    //Get the offsetParent and cache its position
    this.offsetParent = this.helper.offsetParent();
    var po = this.offsetParent.offset();

    // This is a special case where we need to modify a offset calculated on start, since the following happened:
    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
    if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
      po.left += this.scrollParent.scrollLeft();
      po.top += this.scrollParent.scrollTop();
    }

    if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
    || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
      po = { top: 0, left: 0 };

    return {
      top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
      left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
    };

  },

  _getRelativeOffset: function() {

    if(this.cssPosition == "relative") {
      var p = this.currentItem.position();
      return {
        top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
        left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
      };
    } else {
      return { top: 0, left: 0 };
    }

  },

  _cacheMargins: function() {
    this.margins = {
      left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
      top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
    };
  },

  _cacheHelperProportions: function() {
    this.helperProportions = {
      width: this.helper.outerWidth(),
      height: this.helper.outerHeight()
    };
  },

  _setContainment: function() {

    var o = this.options;
    if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
    if(o.containment == 'document' || o.containment == 'window') this.containment = [
      0 - this.offset.relative.left - this.offset.parent.left,
      0 - this.offset.relative.top - this.offset.parent.top,
      $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
      ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
    ];

    if(!(/^(document|window|parent)$/).test(o.containment)) {
      var ce = $(o.containment)[0];
      var co = $(o.containment).offset();
      var over = ($(ce).css("overflow") != 'hidden');

      this.containment = [
        co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
        co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
        co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
        co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
      ];
    }

  },

  _convertPositionTo: function(d, pos) {

    if(!pos) pos = this.position;
    var mod = d == "absolute" ? 1 : -1;
    var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

    return {
      top: (
        pos.top                                 // The absolute mouse position
        + this.offset.relative.top * mod                    // Only for relative positioned nodes: Relative offset from element to offset parent
        + this.offset.parent.top * mod                      // The offsetParent's offset without borders (offset + border)
        - ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
      ),
      left: (
        pos.left                                // The absolute mouse position
        + this.offset.relative.left * mod                   // Only for relative positioned nodes: Relative offset from element to offset parent
        + this.offset.parent.left * mod                     // The offsetParent's offset without borders (offset + border)
        - ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
      )
    };

  },

  _generatePosition: function(event) {

    var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

    // This is another very weird special case that only happens for relative elements:
    // 1. If the css position is relative
    // 2. and the scroll parent is the document or similar to the offset parent
    // we have to refresh the relative offset during the scroll so there are no jumps
    if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
      this.offset.relative = this._getRelativeOffset();
    }

    var pageX = event.pageX;
    var pageY = event.pageY;

    /*
     * - Position constraining -
     * Constrain the position to a mix of grid, containment.
     */

    if(this.originalPosition) { //If we are not dragging yet, we won't check for options

      if(this.containment) {
        if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
        if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
        if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
        if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
      }

      if(o.grid) {
        var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
        pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

        var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
        pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
      }

    }

    return {
      top: (
        pageY                               // The absolute mouse position
        - this.offset.click.top                         // Click offset (relative to the element)
        - this.offset.relative.top                        // Only for relative positioned nodes: Relative offset from element to offset parent
        - this.offset.parent.top                        // The offsetParent's offset without borders (offset + border)
        + ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
      ),
      left: (
        pageX                               // The absolute mouse position
        - this.offset.click.left                        // Click offset (relative to the element)
        - this.offset.relative.left                       // Only for relative positioned nodes: Relative offset from element to offset parent
        - this.offset.parent.left                       // The offsetParent's offset without borders (offset + border)
        + ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
      )
    };

  },

  _rearrange: function(event, i, a, hardRefresh) {

    a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

    //Various things done here to improve the performance:
    // 1. we create a setTimeout, that calls refreshPositions
    // 2. on the instance, we have a counter variable, that get's higher after every append
    // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
    // 4. this lets only the last addition to the timeout stack through
    this.counter = this.counter ? ++this.counter : 1;
    var self = this, counter = this.counter;

    window.setTimeout(function() {
      if(counter == self.counter) self.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
    },0);

  },

  _clear: function(event, noPropagation) {

    this.reverting = false;
    // We delay all events that have to be triggered to after the point where the placeholder has been removed and
    // everything else normalized again
    var delayedTriggers = [], self = this;

    // We first have to update the dom position of the actual currentItem
    // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
    if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
    this._noFinalSort = null;

    if(this.helper[0] == this.currentItem[0]) {
      for(var i in this._storedCSS) {
        if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
      }
      this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
    } else {
      this.currentItem.show();
    }

    if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
    if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
    if(!$.ui.contains(this.element[0], this.currentItem[0])) { //Node was moved out of the current element
      if(!noPropagation) delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
      for (var i = this.containers.length - 1; i >= 0; i--){
        if($.ui.contains(this.containers[i].element[0], this.currentItem[0]) && !noPropagation) {
          delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
          delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.containers[i]));
        }
      };
    };

    //Post events to containers
    for (var i = this.containers.length - 1; i >= 0; i--){
      if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
      if(this.containers[i].containerCache.over) {
        delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
        this.containers[i].containerCache.over = 0;
      }
    }

    //Do what was originally in plugins
    if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
    if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
    if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

    this.dragging = false;
    if(this.cancelHelperRemoval) {
      if(!noPropagation) {
        this._trigger("beforeStop", event, this._uiHash());
        for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
        this._trigger("stop", event, this._uiHash());
      }
      return false;
    }

    if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());

    //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

    if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

    if(!noPropagation) {
      for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
      this._trigger("stop", event, this._uiHash());
    }

    this.fromOutside = false;
    return true;

  },

  _trigger: function() {
    if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
      this.cancel();
    }
  },

  _uiHash: function(inst) {
    var self = inst || this;
    return {
      helper: self.helper,
      placeholder: self.placeholder || $([]),
      position: self.position,
      originalPosition: self.originalPosition,
      offset: self.positionAbs,
      item: self.currentItem,
      sender: inst ? inst.element : null
    };
  }

});

$.extend($.ui.sortable, {
  version: "1.8.20"
});

})(jQuery);
/*!
 * jQuery UI Accordion 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Accordion
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( "ui.accordion", {
  options: {
    active: 0,
    animated: "slide",
    autoHeight: true,
    clearStyle: false,
    collapsible: false,
    event: "click",
    fillSpace: false,
    header: "> li > :first-child,> :not(li):even",
    icons: {
      header: "ui-icon-triangle-1-e",
      headerSelected: "ui-icon-triangle-1-s"
    },
    navigation: false,
    navigationFilter: function() {
      return this.href.toLowerCase() === location.href.toLowerCase();
    }
  },

  _create: function() {
    var self = this,
      options = self.options;

    self.running = 0;

    self.element
      .addClass( "ui-accordion ui-widget ui-helper-reset" )
      // in lack of child-selectors in CSS
      // we need to mark top-LIs in a UL-accordion for some IE-fix
      .children( "li" )
        .addClass( "ui-accordion-li-fix" );

    self.headers = self.element.find( options.header )
      .addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" )
      .bind( "mouseenter.accordion", function() {
        if ( options.disabled ) {
          return;
        }
        $( this ).addClass( "ui-state-hover" );
      })
      .bind( "mouseleave.accordion", function() {
        if ( options.disabled ) {
          return;
        }
        $( this ).removeClass( "ui-state-hover" );
      })
      .bind( "focus.accordion", function() {
        if ( options.disabled ) {
          return;
        }
        $( this ).addClass( "ui-state-focus" );
      })
      .bind( "blur.accordion", function() {
        if ( options.disabled ) {
          return;
        }
        $( this ).removeClass( "ui-state-focus" );
      });

    self.headers.next()
      .addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" );

    if ( options.navigation ) {
      var current = self.element.find( "a" ).filter( options.navigationFilter ).eq( 0 );
      if ( current.length ) {
        var header = current.closest( ".ui-accordion-header" );
        if ( header.length ) {
          // anchor within header
          self.active = header;
        } else {
          // anchor within content
          self.active = current.closest( ".ui-accordion-content" ).prev();
        }
      }
    }

    self.active = self._findActive( self.active || options.active )
      .addClass( "ui-state-default ui-state-active" )
      .toggleClass( "ui-corner-all" )
      .toggleClass( "ui-corner-top" );
    self.active.next().addClass( "ui-accordion-content-active" );

    self._createIcons();
    self.resize();

    // ARIA
    self.element.attr( "role", "tablist" );

    self.headers
      .attr( "role", "tab" )
      .bind( "keydown.accordion", function( event ) {
        return self._keydown( event );
      })
      .next()
        .attr( "role", "tabpanel" );

    self.headers
      .not( self.active || "" )
      .attr({
        "aria-expanded": "false",
        "aria-selected": "false",
        tabIndex: -1
      })
      .next()
        .hide();

    // make sure at least one header is in the tab order
    if ( !self.active.length ) {
      self.headers.eq( 0 ).attr( "tabIndex", 0 );
    } else {
      self.active
        .attr({
          "aria-expanded": "true",
          "aria-selected": "true",
          tabIndex: 0
        });
    }

    // only need links in tab order for Safari
    if ( !$.browser.safari ) {
      self.headers.find( "a" ).attr( "tabIndex", -1 );
    }

    if ( options.event ) {
      self.headers.bind( options.event.split(" ").join(".accordion ") + ".accordion", function(event) {
        self._clickHandler.call( self, event, this );
        event.preventDefault();
      });
    }
  },

  _createIcons: function() {
    var options = this.options;
    if ( options.icons ) {
      $( "<span></span>" )
        .addClass( "ui-icon " + options.icons.header )
        .prependTo( this.headers );
      this.active.children( ".ui-icon" )
        .toggleClass(options.icons.header)
        .toggleClass(options.icons.headerSelected);
      this.element.addClass( "ui-accordion-icons" );
    }
  },

  _destroyIcons: function() {
    this.headers.children( ".ui-icon" ).remove();
    this.element.removeClass( "ui-accordion-icons" );
  },

  destroy: function() {
    var options = this.options;

    this.element
      .removeClass( "ui-accordion ui-widget ui-helper-reset" )
      .removeAttr( "role" );

    this.headers
      .unbind( ".accordion" )
      .removeClass( "ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
      .removeAttr( "role" )
      .removeAttr( "aria-expanded" )
      .removeAttr( "aria-selected" )
      .removeAttr( "tabIndex" );

    this.headers.find( "a" ).removeAttr( "tabIndex" );
    this._destroyIcons();
    var contents = this.headers.next()
      .css( "display", "" )
      .removeAttr( "role" )
      .removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled" );
    if ( options.autoHeight || options.fillHeight ) {
      contents.css( "height", "" );
    }

    return $.Widget.prototype.destroy.call( this );
  },

  _setOption: function( key, value ) {
    $.Widget.prototype._setOption.apply( this, arguments );

    if ( key == "active" ) {
      this.activate( value );
    }
    if ( key == "icons" ) {
      this._destroyIcons();
      if ( value ) {
        this._createIcons();
      }
    }
    // #5332 - opacity doesn't cascade to positioned elements in IE
    // so we need to add the disabled class to the headers and panels
    if ( key == "disabled" ) {
      this.headers.add(this.headers.next())
        [ value ? "addClass" : "removeClass" ](
          "ui-accordion-disabled ui-state-disabled" );
    }
  },

  _keydown: function( event ) {
    if ( this.options.disabled || event.altKey || event.ctrlKey ) {
      return;
    }

    var keyCode = $.ui.keyCode,
      length = this.headers.length,
      currentIndex = this.headers.index( event.target ),
      toFocus = false;

    switch ( event.keyCode ) {
      case keyCode.RIGHT:
      case keyCode.DOWN:
        toFocus = this.headers[ ( currentIndex + 1 ) % length ];
        break;
      case keyCode.LEFT:
      case keyCode.UP:
        toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
        break;
      case keyCode.SPACE:
      case keyCode.ENTER:
        this._clickHandler( { target: event.target }, event.target );
        event.preventDefault();
    }

    if ( toFocus ) {
      $( event.target ).attr( "tabIndex", -1 );
      $( toFocus ).attr( "tabIndex", 0 );
      toFocus.focus();
      return false;
    }

    return true;
  },

  resize: function() {
    var options = this.options,
      maxHeight;

    if ( options.fillSpace ) {
      if ( $.browser.msie ) {
        var defOverflow = this.element.parent().css( "overflow" );
        this.element.parent().css( "overflow", "hidden");
      }
      maxHeight = this.element.parent().height();
      if ($.browser.msie) {
        this.element.parent().css( "overflow", defOverflow );
      }

      this.headers.each(function() {
        maxHeight -= $( this ).outerHeight( true );
      });

      this.headers.next()
        .each(function() {
          $( this ).height( Math.max( 0, maxHeight -
            $( this ).innerHeight() + $( this ).height() ) );
        })
        .css( "overflow", "auto" );
    } else if ( options.autoHeight ) {
      maxHeight = 0;
      this.headers.next()
        .each(function() {
          maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
        })
        .height( maxHeight );
    }

    return this;
  },

  activate: function( index ) {
    // TODO this gets called on init, changing the option without an explicit call for that
    this.options.active = index;
    // call clickHandler with custom event
    var active = this._findActive( index )[ 0 ];
    this._clickHandler( { target: active }, active );

    return this;
  },

  _findActive: function( selector ) {
    return selector
      ? typeof selector === "number"
        ? this.headers.filter( ":eq(" + selector + ")" )
        : this.headers.not( this.headers.not( selector ) )
      : selector === false
        ? $( [] )
        : this.headers.filter( ":eq(0)" );
  },

  // TODO isn't event.target enough? why the separate target argument?
  _clickHandler: function( event, target ) {
    var options = this.options;
    if ( options.disabled ) {
      return;
    }

    // called only when using activate(false) to close all parts programmatically
    if ( !event.target ) {
      if ( !options.collapsible ) {
        return;
      }
      this.active
        .removeClass( "ui-state-active ui-corner-top" )
        .addClass( "ui-state-default ui-corner-all" )
        .children( ".ui-icon" )
          .removeClass( options.icons.headerSelected )
          .addClass( options.icons.header );
      this.active.next().addClass( "ui-accordion-content-active" );
      var toHide = this.active.next(),
        data = {
          options: options,
          newHeader: $( [] ),
          oldHeader: options.active,
          newContent: $( [] ),
          oldContent: toHide
        },
        toShow = ( this.active = $( [] ) );
      this._toggle( toShow, toHide, data );
      return;
    }

    // get the click target
    var clicked = $( event.currentTarget || target ),
      clickedIsActive = clicked[0] === this.active[0];

    // TODO the option is changed, is that correct?
    // TODO if it is correct, shouldn't that happen after determining that the click is valid?
    options.active = options.collapsible && clickedIsActive ?
      false :
      this.headers.index( clicked );

    // if animations are still active, or the active header is the target, ignore click
    if ( this.running || ( !options.collapsible && clickedIsActive ) ) {
      return;
    }

    // find elements to show and hide
    var active = this.active,
      toShow = clicked.next(),
      toHide = this.active.next(),
      data = {
        options: options,
        newHeader: clickedIsActive && options.collapsible ? $([]) : clicked,
        oldHeader: this.active,
        newContent: clickedIsActive && options.collapsible ? $([]) : toShow,
        oldContent: toHide
      },
      down = this.headers.index( this.active[0] ) > this.headers.index( clicked[0] );

    // when the call to ._toggle() comes after the class changes
    // it causes a very odd bug in IE 8 (see #6720)
    this.active = clickedIsActive ? $([]) : clicked;
    this._toggle( toShow, toHide, data, clickedIsActive, down );

    // switch classes
    active
      .removeClass( "ui-state-active ui-corner-top" )
      .addClass( "ui-state-default ui-corner-all" )
      .children( ".ui-icon" )
        .removeClass( options.icons.headerSelected )
        .addClass( options.icons.header );
    if ( !clickedIsActive ) {
      clicked
        .removeClass( "ui-state-default ui-corner-all" )
        .addClass( "ui-state-active ui-corner-top" )
        .children( ".ui-icon" )
          .removeClass( options.icons.header )
          .addClass( options.icons.headerSelected );
      clicked
        .next()
        .addClass( "ui-accordion-content-active" );
    }

    return;
  },

  _toggle: function( toShow, toHide, data, clickedIsActive, down ) {
    var self = this,
      options = self.options;

    self.toShow = toShow;
    self.toHide = toHide;
    self.data = data;

    var complete = function() {
      if ( !self ) {
        return;
      }
      return self._completed.apply( self, arguments );
    };

    // trigger changestart event
    self._trigger( "changestart", null, self.data );

    // count elements to animate
    self.running = toHide.size() === 0 ? toShow.size() : toHide.size();

    if ( options.animated ) {
      var animOptions = {};

      if ( options.collapsible && clickedIsActive ) {
        animOptions = {
          toShow: $( [] ),
          toHide: toHide,
          complete: complete,
          down: down,
          autoHeight: options.autoHeight || options.fillSpace
        };
      } else {
        animOptions = {
          toShow: toShow,
          toHide: toHide,
          complete: complete,
          down: down,
          autoHeight: options.autoHeight || options.fillSpace
        };
      }

      if ( !options.proxied ) {
        options.proxied = options.animated;
      }

      if ( !options.proxiedDuration ) {
        options.proxiedDuration = options.duration;
      }

      options.animated = $.isFunction( options.proxied ) ?
        options.proxied( animOptions ) :
        options.proxied;

      options.duration = $.isFunction( options.proxiedDuration ) ?
        options.proxiedDuration( animOptions ) :
        options.proxiedDuration;

      var animations = $.ui.accordion.animations,
        duration = options.duration,
        easing = options.animated;

      if ( easing && !animations[ easing ] && !$.easing[ easing ] ) {
        easing = "slide";
      }
      if ( !animations[ easing ] ) {
        animations[ easing ] = function( options ) {
          this.slide( options, {
            easing: easing,
            duration: duration || 700
          });
        };
      }

      animations[ easing ]( animOptions );
    } else {
      if ( options.collapsible && clickedIsActive ) {
        toShow.toggle();
      } else {
        toHide.hide();
        toShow.show();
      }

      complete( true );
    }

    // TODO assert that the blur and focus triggers are really necessary, remove otherwise
    toHide.prev()
      .attr({
        "aria-expanded": "false",
        "aria-selected": "false",
        tabIndex: -1
      })
      .blur();
    toShow.prev()
      .attr({
        "aria-expanded": "true",
        "aria-selected": "true",
        tabIndex: 0
      })
      .focus();
  },

  _completed: function( cancel ) {
    this.running = cancel ? 0 : --this.running;
    if ( this.running ) {
      return;
    }

    if ( this.options.clearStyle ) {
      this.toShow.add( this.toHide ).css({
        height: "",
        overflow: ""
      });
    }

    // other classes are removed before the animation; this one needs to stay until completed
    this.toHide.removeClass( "ui-accordion-content-active" );
    // Work around for rendering bug in IE (#5421)
    if ( this.toHide.length ) {
      this.toHide.parent()[0].className = this.toHide.parent()[0].className;
    }

    this._trigger( "change", null, this.data );
  }
});

$.extend( $.ui.accordion, {
  version: "1.8.20",
  animations: {
    slide: function( options, additions ) {
      options = $.extend({
        easing: "swing",
        duration: 300
      }, options, additions );
      if ( !options.toHide.size() ) {
        options.toShow.animate({
          height: "show",
          paddingTop: "show",
          paddingBottom: "show"
        }, options );
        return;
      }
      if ( !options.toShow.size() ) {
        options.toHide.animate({
          height: "hide",
          paddingTop: "hide",
          paddingBottom: "hide"
        }, options );
        return;
      }
      var overflow = options.toShow.css( "overflow" ),
        percentDone = 0,
        showProps = {},
        hideProps = {},
        fxAttrs = [ "height", "paddingTop", "paddingBottom" ],
        originalWidth;
      // fix width before calculating height of hidden element
      var s = options.toShow;
      originalWidth = s[0].style.width;
      s.width( s.parent().width()
        - parseFloat( s.css( "paddingLeft" ) )
        - parseFloat( s.css( "paddingRight" ) )
        - ( parseFloat( s.css( "borderLeftWidth" ) ) || 0 )
        - ( parseFloat( s.css( "borderRightWidth" ) ) || 0 ) );

      $.each( fxAttrs, function( i, prop ) {
        hideProps[ prop ] = "hide";

        var parts = ( "" + $.css( options.toShow[0], prop ) ).match( /^([\d+-.]+)(.*)$/ );
        showProps[ prop ] = {
          value: parts[ 1 ],
          unit: parts[ 2 ] || "px"
        };
      });
      options.toShow.css({ height: 0, overflow: "hidden" }).show();
      options.toHide
        .filter( ":hidden" )
          .each( options.complete )
        .end()
        .filter( ":visible" )
        .animate( hideProps, {
        step: function( now, settings ) {
          // only calculate the percent when animating height
          // IE gets very inconsistent results when animating elements
          // with small values, which is common for padding
          if ( settings.prop == "height" ) {
            percentDone = ( settings.end - settings.start === 0 ) ? 0 :
              ( settings.now - settings.start ) / ( settings.end - settings.start );
          }

          options.toShow[ 0 ].style[ settings.prop ] =
            ( percentDone * showProps[ settings.prop ].value )
            + showProps[ settings.prop ].unit;
        },
        duration: options.duration,
        easing: options.easing,
        complete: function() {
          if ( !options.autoHeight ) {
            options.toShow.css( "height", "" );
          }
          options.toShow.css({
            width: originalWidth,
            overflow: overflow
          });
          options.complete();
        }
      });
    },
    bounceslide: function( options ) {
      this.slide( options, {
        easing: options.down ? "easeOutBounce" : "swing",
        duration: options.down ? 1000 : 200
      });
    }
  }
});

})( jQuery );
/*!
 * jQuery UI Autocomplete 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.position.js
 */
(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( "ui.autocomplete", {
  options: {
    appendTo: "body",
    autoFocus: false,
    delay: 300,
    minLength: 1,
    position: {
      my: "left top",
      at: "left bottom",
      collision: "none"
    },
    source: null
  },

  pending: 0,

  _create: function() {
    var self = this,
      doc = this.element[ 0 ].ownerDocument,
      suppressKeyPress;
    this.isMultiLine = this.element.is( "textarea" );

    this.element
      .addClass( "ui-autocomplete-input" )
      .attr( "autocomplete", "off" )
      // TODO verify these actually work as intended
      .attr({
        role: "textbox",
        "aria-autocomplete": "list",
        "aria-haspopup": "true"
      })
      .bind( "keydown.autocomplete", function( event ) {
        if ( self.options.disabled || self.element.propAttr( "readOnly" ) ) {
          return;
        }

        suppressKeyPress = false;
        var keyCode = $.ui.keyCode;
        switch( event.keyCode ) {
        case keyCode.PAGE_UP:
          self._move( "previousPage", event );
          break;
        case keyCode.PAGE_DOWN:
          self._move( "nextPage", event );
          break;
        case keyCode.UP:
          self._keyEvent( "previous", event );
          break;
        case keyCode.DOWN:
          self._keyEvent( "next", event );
          break;
        case keyCode.ENTER:
        case keyCode.NUMPAD_ENTER:
          // when menu is open and has focus
          if ( self.menu.active ) {
            // #6055 - Opera still allows the keypress to occur
            // which causes forms to submit
            suppressKeyPress = true;
            event.preventDefault();
          }
          //passthrough - ENTER and TAB both select the current element
        case keyCode.TAB:
          if ( !self.menu.active ) {
            return;
          }
          self.menu.select( event );
          break;
        case keyCode.ESCAPE:
          self.element.val( self.term );
          self.close( event );
          break;
        default:
          // keypress is triggered before the input value is changed
          clearTimeout( self.searching );
          self.searching = setTimeout(function() {
            // only search if the value has changed
            if ( self.term != self.element.val() ) {
              self.selectedItem = null;
              self.search( null, event );
            }
          }, self.options.delay );
          break;
        }
      })
      .bind( "keypress.autocomplete", function( event ) {
        if ( suppressKeyPress ) {
          suppressKeyPress = false;
          event.preventDefault();
        }
      })
      .bind( "focus.autocomplete", function() {
        if ( self.options.disabled ) {
          return;
        }

        self.selectedItem = null;
        self.previous = self.element.val();
      })
      .bind( "blur.autocomplete", function( event ) {
        if ( self.options.disabled ) {
          return;
        }

        clearTimeout( self.searching );
        // clicks on the menu (or a button to trigger a search) will cause a blur event
        self.closing = setTimeout(function() {
          self.close( event );
          self._change( event );
        }, 150 );
      });
    this._initSource();
    this.menu = $( "<ul></ul>" )
      .addClass( "ui-autocomplete" )
      .appendTo( $( this.options.appendTo || "body", doc )[0] )
      // prevent the close-on-blur in case of a "slow" click on the menu (long mousedown)
      .mousedown(function( event ) {
        // clicking on the scrollbar causes focus to shift to the body
        // but we can't detect a mouseup or a click immediately afterward
        // so we have to track the next mousedown and close the menu if
        // the user clicks somewhere outside of the autocomplete
        var menuElement = self.menu.element[ 0 ];
        if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
          setTimeout(function() {
            $( document ).one( 'mousedown', function( event ) {
              if ( event.target !== self.element[ 0 ] &&
                event.target !== menuElement &&
                !$.ui.contains( menuElement, event.target ) ) {
                self.close();
              }
            });
          }, 1 );
        }

        // use another timeout to make sure the blur-event-handler on the input was already triggered
        setTimeout(function() {
          clearTimeout( self.closing );
        }, 13);
      })
      .menu({
        focus: function( event, ui ) {
          var item = ui.item.data( "item.autocomplete" );
          if ( false !== self._trigger( "focus", event, { item: item } ) ) {
            // use value to match what will end up in the input, if it was a key event
            if ( /^key/.test(event.originalEvent.type) ) {
              self.element.val( item.value );
            }
          }
        },
        selected: function( event, ui ) {
          var item = ui.item.data( "item.autocomplete" ),
            previous = self.previous;

          // only trigger when focus was lost (click on menu)
          if ( self.element[0] !== doc.activeElement ) {
            self.element.focus();
            self.previous = previous;
            // #6109 - IE triggers two focus events and the second
            // is asynchronous, so we need to reset the previous
            // term synchronously and asynchronously :-(
            setTimeout(function() {
              self.previous = previous;
              self.selectedItem = item;
            }, 1);
          }

          if ( false !== self._trigger( "select", event, { item: item } ) ) {
            self.element.val( item.value );
          }
          // reset the term after the select event
          // this allows custom select handling to work properly
          self.term = self.element.val();

          self.close( event );
          self.selectedItem = item;
        },
        blur: function( event, ui ) {
          // don't set the value of the text field if it's already correct
          // this prevents moving the cursor unnecessarily
          if ( self.menu.element.is(":visible") &&
            ( self.element.val() !== self.term ) ) {
            self.element.val( self.term );
          }
        }
      })
      .zIndex( this.element.zIndex() + 1 )
      // workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
      .css({ top: 0, left: 0 })
      .hide()
      .data( "menu" );
    if ( $.fn.bgiframe ) {
       this.menu.element.bgiframe();
    }
    // turning off autocomplete prevents the browser from remembering the
    // value when navigating through history, so we re-enable autocomplete
    // if the page is unloaded before the widget is destroyed. #7790
    self.beforeunloadHandler = function() {
      self.element.removeAttr( "autocomplete" );
    };
    $( window ).bind( "beforeunload", self.beforeunloadHandler );
  },

  destroy: function() {
    this.element
      .removeClass( "ui-autocomplete-input" )
      .removeAttr( "autocomplete" )
      .removeAttr( "role" )
      .removeAttr( "aria-autocomplete" )
      .removeAttr( "aria-haspopup" );
    this.menu.element.remove();
    $( window ).unbind( "beforeunload", this.beforeunloadHandler );
    $.Widget.prototype.destroy.call( this );
  },

  _setOption: function( key, value ) {
    $.Widget.prototype._setOption.apply( this, arguments );
    if ( key === "source" ) {
      this._initSource();
    }
    if ( key === "appendTo" ) {
      this.menu.element.appendTo( $( value || "body", this.element[0].ownerDocument )[0] )
    }
    if ( key === "disabled" && value && this.xhr ) {
      this.xhr.abort();
    }
  },

  _initSource: function() {
    var self = this,
      array,
      url;
    if ( $.isArray(this.options.source) ) {
      array = this.options.source;
      this.source = function( request, response ) {
        response( $.ui.autocomplete.filter(array, request.term) );
      };
    } else if ( typeof this.options.source === "string" ) {
      url = this.options.source;
      this.source = function( request, response ) {
        if ( self.xhr ) {
          self.xhr.abort();
        }
        self.xhr = $.ajax({
          url: url,
          data: request,
          dataType: "json",
          success: function( data, status ) {
            response( data );
          },
          error: function() {
            response( [] );
          }
        });
      };
    } else {
      this.source = this.options.source;
    }
  },

  search: function( value, event ) {
    value = value != null ? value : this.element.val();

    // always save the actual value, not the one passed as an argument
    this.term = this.element.val();

    if ( value.length < this.options.minLength ) {
      return this.close( event );
    }

    clearTimeout( this.closing );
    if ( this._trigger( "search", event ) === false ) {
      return;
    }

    return this._search( value );
  },

  _search: function( value ) {
    this.pending++;
    this.element.addClass( "ui-autocomplete-loading" );

    this.source( { term: value }, this._response() );
  },

  _response: function() {
    var that = this,
      index = ++requestIndex;

    return function( content ) {
      if ( index === requestIndex ) {
        that.__response( content );
      }

      that.pending--;
      if ( !that.pending ) {
        that.element.removeClass( "ui-autocomplete-loading" );
      }
    };
  },

  __response: function( content ) {
    if ( !this.options.disabled && content && content.length ) {
      content = this._normalize( content );
      this._suggest( content );
      this._trigger( "open" );
    } else {
      this.close();
    }
  },

  close: function( event ) {
    clearTimeout( this.closing );
    if ( this.menu.element.is(":visible") ) {
      this.menu.element.hide();
      this.menu.deactivate();
      this._trigger( "close", event );
    }
  },

  _change: function( event ) {
    if ( this.previous !== this.element.val() ) {
      this._trigger( "change", event, { item: this.selectedItem } );
    }
  },

  _normalize: function( items ) {
    // assume all items have the right format when the first item is complete
    if ( items.length && items[0].label && items[0].value ) {
      return items;
    }
    return $.map( items, function(item) {
      if ( typeof item === "string" ) {
        return {
          label: item,
          value: item
        };
      }
      return $.extend({
        label: item.label || item.value,
        value: item.value || item.label
      }, item );
    });
  },

  _suggest: function( items ) {
    var ul = this.menu.element
      .empty()
      .zIndex( this.element.zIndex() + 1 );
    this._renderMenu( ul, items );
    // TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
    this.menu.deactivate();
    this.menu.refresh();

    // size and position menu
    ul.show();
    this._resizeMenu();
    ul.position( $.extend({
      of: this.element
    }, this.options.position ));

    if ( this.options.autoFocus ) {
      this.menu.next( new $.Event("mouseover") );
    }
  },

  _resizeMenu: function() {
    var ul = this.menu.element;
    ul.outerWidth( Math.max(
      // Firefox wraps long text (possibly a rounding bug)
      // so we add 1px to avoid the wrapping (#7513)
      ul.width( "" ).outerWidth() + 1,
      this.element.outerWidth()
    ) );
  },

  _renderMenu: function( ul, items ) {
    var self = this;
    $.each( items, function( index, item ) {
      self._renderItem( ul, item );
    });
  },

  _renderItem: function( ul, item) {
    return $( "<li></li>" )
      .data( "item.autocomplete", item )
      .append( $( "<a></a>" ).text( item.label ) )
      .appendTo( ul );
  },

  _move: function( direction, event ) {
    if ( !this.menu.element.is(":visible") ) {
      this.search( null, event );
      return;
    }
    if ( this.menu.first() && /^previous/.test(direction) ||
        this.menu.last() && /^next/.test(direction) ) {
      this.element.val( this.term );
      this.menu.deactivate();
      return;
    }
    this.menu[ direction ]( event );
  },

  widget: function() {
    return this.menu.element;
  },
  _keyEvent: function( keyEvent, event ) {
    if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
      this._move( keyEvent, event );

      // prevents moving cursor to beginning/end of the text field in some browsers
      event.preventDefault();
    }
  }
});

$.extend( $.ui.autocomplete, {
  escapeRegex: function( value ) {
    return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  },
  filter: function(array, term) {
    var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
    return $.grep( array, function(value) {
      return matcher.test( value.label || value.value || value );
    });
  }
});

}( jQuery ));

/*
 * jQuery UI Menu (not officially released)
 *
 * This widget isn't yet finished and the API is subject to change. We plan to finish
 * it for the next release. You're welcome to give it a try anyway and give us feedback,
 * as long as you're okay with migrating your code later on. We can help with that, too.
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Menu
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function($) {

$.widget("ui.menu", {
  _create: function() {
    var self = this;
    this.element
      .addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
      .attr({
        role: "listbox",
        "aria-activedescendant": "ui-active-menuitem"
      })
      .click(function( event ) {
        if ( !$( event.target ).closest( ".ui-menu-item a" ).length ) {
          return;
        }
        // temporary
        event.preventDefault();
        self.select( event );
      });
    this.refresh();
  },

  refresh: function() {
    var self = this;

    // don't refresh list items that are already adapted
    var items = this.element.children("li:not(.ui-menu-item):has(a)")
      .addClass("ui-menu-item")
      .attr("role", "menuitem");

    items.children("a")
      .addClass("ui-corner-all")
      .attr("tabindex", -1)
      // mouseenter doesn't work with event delegation
      .mouseenter(function( event ) {
        self.activate( event, $(this).parent() );
      })
      .mouseleave(function() {
        self.deactivate();
      });
  },

  activate: function( event, item ) {
    this.deactivate();
    if (this.hasScroll()) {
      var offset = item.offset().top - this.element.offset().top,
        scroll = this.element.scrollTop(),
        elementHeight = this.element.height();
      if (offset < 0) {
        this.element.scrollTop( scroll + offset);
      } else if (offset >= elementHeight) {
        this.element.scrollTop( scroll + offset - elementHeight + item.height());
      }
    }
    this.active = item.eq(0)
      .children("a")
        .addClass("ui-state-hover")
        .attr("id", "ui-active-menuitem")
      .end();
    this._trigger("focus", event, { item: item });
  },

  deactivate: function() {
    if (!this.active) { return; }

    this.active.children("a")
      .removeClass("ui-state-hover")
      .removeAttr("id");
    this._trigger("blur");
    this.active = null;
  },

  next: function(event) {
    this.move("next", ".ui-menu-item:first", event);
  },

  previous: function(event) {
    this.move("prev", ".ui-menu-item:last", event);
  },

  first: function() {
    return this.active && !this.active.prevAll(".ui-menu-item").length;
  },

  last: function() {
    return this.active && !this.active.nextAll(".ui-menu-item").length;
  },

  move: function(direction, edge, event) {
    if (!this.active) {
      this.activate(event, this.element.children(edge));
      return;
    }
    var next = this.active[direction + "All"](".ui-menu-item").eq(0);
    if (next.length) {
      this.activate(event, next);
    } else {
      this.activate(event, this.element.children(edge));
    }
  },

  // TODO merge with previousPage
  nextPage: function(event) {
    if (this.hasScroll()) {
      // TODO merge with no-scroll-else
      if (!this.active || this.last()) {
        this.activate(event, this.element.children(".ui-menu-item:first"));
        return;
      }
      var base = this.active.offset().top,
        height = this.element.height(),
        result = this.element.children(".ui-menu-item").filter(function() {
          var close = $(this).offset().top - base - height + $(this).height();
          // TODO improve approximation
          return close < 10 && close > -10;
        });

      // TODO try to catch this earlier when scrollTop indicates the last page anyway
      if (!result.length) {
        result = this.element.children(".ui-menu-item:last");
      }
      this.activate(event, result);
    } else {
      this.activate(event, this.element.children(".ui-menu-item")
        .filter(!this.active || this.last() ? ":first" : ":last"));
    }
  },

  // TODO merge with nextPage
  previousPage: function(event) {
    if (this.hasScroll()) {
      // TODO merge with no-scroll-else
      if (!this.active || this.first()) {
        this.activate(event, this.element.children(".ui-menu-item:last"));
        return;
      }

      var base = this.active.offset().top,
        height = this.element.height(),
        result = this.element.children(".ui-menu-item").filter(function() {
          var close = $(this).offset().top - base + height - $(this).height();
          // TODO improve approximation
          return close < 10 && close > -10;
        });

      // TODO try to catch this earlier when scrollTop indicates the last page anyway
      if (!result.length) {
        result = this.element.children(".ui-menu-item:first");
      }
      this.activate(event, result);
    } else {
      this.activate(event, this.element.children(".ui-menu-item")
        .filter(!this.active || this.first() ? ":last" : ":first"));
    }
  },

  hasScroll: function() {
    return this.element.height() < this.element[ $.fn.prop ? "prop" : "attr" ]("scrollHeight");
  },

  select: function( event ) {
    this._trigger("selected", event, { item: this.active });
  }
});

}(jQuery));
/*!
 * jQuery UI Button 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
  baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
  stateClasses = "ui-state-hover ui-state-active ",
  typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
  formResetHandler = function() {
    var buttons = $( this ).find( ":ui-button" );
    setTimeout(function() {
      buttons.button( "refresh" );
    }, 1 );
  },
  radioGroup = function( radio ) {
    var name = radio.name,
      form = radio.form,
      radios = $( [] );
    if ( name ) {
      if ( form ) {
        radios = $( form ).find( "[name='" + name + "']" );
      } else {
        radios = $( "[name='" + name + "']", radio.ownerDocument )
          .filter(function() {
            return !this.form;
          });
      }
    }
    return radios;
  };

$.widget( "ui.button", {
  options: {
    disabled: null,
    text: true,
    label: null,
    icons: {
      primary: null,
      secondary: null
    }
  },
  _create: function() {
    this.element.closest( "form" )
      .unbind( "reset.button" )
      .bind( "reset.button", formResetHandler );

    if ( typeof this.options.disabled !== "boolean" ) {
      this.options.disabled = !!this.element.propAttr( "disabled" );
    } else {
      this.element.propAttr( "disabled", this.options.disabled );
    }

    this._determineButtonType();
    this.hasTitle = !!this.buttonElement.attr( "title" );

    var self = this,
      options = this.options,
      toggleButton = this.type === "checkbox" || this.type === "radio",
      hoverClass = "ui-state-hover" + ( !toggleButton ? " ui-state-active" : "" ),
      focusClass = "ui-state-focus";

    if ( options.label === null ) {
      options.label = this.buttonElement.html();
    }

    this.buttonElement
      .addClass( baseClasses )
      .attr( "role", "button" )
      .bind( "mouseenter.button", function() {
        if ( options.disabled ) {
          return;
        }
        $( this ).addClass( "ui-state-hover" );
        if ( this === lastActive ) {
          $( this ).addClass( "ui-state-active" );
        }
      })
      .bind( "mouseleave.button", function() {
        if ( options.disabled ) {
          return;
        }
        $( this ).removeClass( hoverClass );
      })
      .bind( "click.button", function( event ) {
        if ( options.disabled ) {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      });

    this.element
      .bind( "focus.button", function() {
        // no need to check disabled, focus won't be triggered anyway
        self.buttonElement.addClass( focusClass );
      })
      .bind( "blur.button", function() {
        self.buttonElement.removeClass( focusClass );
      });

    if ( toggleButton ) {
      this.element.bind( "change.button", function() {
        if ( clickDragged ) {
          return;
        }
        self.refresh();
      });
      // if mouse moves between mousedown and mouseup (drag) set clickDragged flag
      // prevents issue where button state changes but checkbox/radio checked state
      // does not in Firefox (see ticket #6970)
      this.buttonElement
        .bind( "mousedown.button", function( event ) {
          if ( options.disabled ) {
            return;
          }
          clickDragged = false;
          startXPos = event.pageX;
          startYPos = event.pageY;
        })
        .bind( "mouseup.button", function( event ) {
          if ( options.disabled ) {
            return;
          }
          if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
            clickDragged = true;
          }
      });
    }

    if ( this.type === "checkbox" ) {
      this.buttonElement.bind( "click.button", function() {
        if ( options.disabled || clickDragged ) {
          return false;
        }
        $( this ).toggleClass( "ui-state-active" );
        self.buttonElement.attr( "aria-pressed", self.element[0].checked );
      });
    } else if ( this.type === "radio" ) {
      this.buttonElement.bind( "click.button", function() {
        if ( options.disabled || clickDragged ) {
          return false;
        }
        $( this ).addClass( "ui-state-active" );
        self.buttonElement.attr( "aria-pressed", "true" );

        var radio = self.element[ 0 ];
        radioGroup( radio )
          .not( radio )
          .map(function() {
            return $( this ).button( "widget" )[ 0 ];
          })
          .removeClass( "ui-state-active" )
          .attr( "aria-pressed", "false" );
      });
    } else {
      this.buttonElement
        .bind( "mousedown.button", function() {
          if ( options.disabled ) {
            return false;
          }
          $( this ).addClass( "ui-state-active" );
          lastActive = this;
          $( document ).one( "mouseup", function() {
            lastActive = null;
          });
        })
        .bind( "mouseup.button", function() {
          if ( options.disabled ) {
            return false;
          }
          $( this ).removeClass( "ui-state-active" );
        })
        .bind( "keydown.button", function(event) {
          if ( options.disabled ) {
            return false;
          }
          if ( event.keyCode == $.ui.keyCode.SPACE || event.keyCode == $.ui.keyCode.ENTER ) {
            $( this ).addClass( "ui-state-active" );
          }
        })
        .bind( "keyup.button", function() {
          $( this ).removeClass( "ui-state-active" );
        });

      if ( this.buttonElement.is("a") ) {
        this.buttonElement.keyup(function(event) {
          if ( event.keyCode === $.ui.keyCode.SPACE ) {
            // TODO pass through original event correctly (just as 2nd argument doesn't work)
            $( this ).click();
          }
        });
      }
    }

    // TODO: pull out $.Widget's handling for the disabled option into
    // $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
    // be overridden by individual plugins
    this._setOption( "disabled", options.disabled );
    this._resetButton();
  },

  _determineButtonType: function() {

    if ( this.element.is(":checkbox") ) {
      this.type = "checkbox";
    } else if ( this.element.is(":radio") ) {
      this.type = "radio";
    } else if ( this.element.is("input") ) {
      this.type = "input";
    } else {
      this.type = "button";
    }

    if ( this.type === "checkbox" || this.type === "radio" ) {
      // we don't search against the document in case the element
      // is disconnected from the DOM
      var ancestor = this.element.parents().filter(":last"),
        labelSelector = "label[for='" + this.element.attr("id") + "']";
      this.buttonElement = ancestor.find( labelSelector );
      if ( !this.buttonElement.length ) {
        ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
        this.buttonElement = ancestor.filter( labelSelector );
        if ( !this.buttonElement.length ) {
          this.buttonElement = ancestor.find( labelSelector );
        }
      }
      this.element.addClass( "ui-helper-hidden-accessible" );

      var checked = this.element.is( ":checked" );
      if ( checked ) {
        this.buttonElement.addClass( "ui-state-active" );
      }
      this.buttonElement.attr( "aria-pressed", checked );
    } else {
      this.buttonElement = this.element;
    }
  },

  widget: function() {
    return this.buttonElement;
  },

  destroy: function() {
    this.element
      .removeClass( "ui-helper-hidden-accessible" );
    this.buttonElement
      .removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
      .removeAttr( "role" )
      .removeAttr( "aria-pressed" )
      .html( this.buttonElement.find(".ui-button-text").html() );

    if ( !this.hasTitle ) {
      this.buttonElement.removeAttr( "title" );
    }

    $.Widget.prototype.destroy.call( this );
  },

  _setOption: function( key, value ) {
    $.Widget.prototype._setOption.apply( this, arguments );
    if ( key === "disabled" ) {
      if ( value ) {
        this.element.propAttr( "disabled", true );
      } else {
        this.element.propAttr( "disabled", false );
      }
      return;
    }
    this._resetButton();
  },

  refresh: function() {
    var isDisabled = this.element.is( ":disabled" );
    if ( isDisabled !== this.options.disabled ) {
      this._setOption( "disabled", isDisabled );
    }
    if ( this.type === "radio" ) {
      radioGroup( this.element[0] ).each(function() {
        if ( $( this ).is( ":checked" ) ) {
          $( this ).button( "widget" )
            .addClass( "ui-state-active" )
            .attr( "aria-pressed", "true" );
        } else {
          $( this ).button( "widget" )
            .removeClass( "ui-state-active" )
            .attr( "aria-pressed", "false" );
        }
      });
    } else if ( this.type === "checkbox" ) {
      if ( this.element.is( ":checked" ) ) {
        this.buttonElement
          .addClass( "ui-state-active" )
          .attr( "aria-pressed", "true" );
      } else {
        this.buttonElement
          .removeClass( "ui-state-active" )
          .attr( "aria-pressed", "false" );
      }
    }
  },

  _resetButton: function() {
    if ( this.type === "input" ) {
      if ( this.options.label ) {
        this.element.val( this.options.label );
      }
      return;
    }
    var buttonElement = this.buttonElement.removeClass( typeClasses ),
      buttonText = $( "<span></span>", this.element[0].ownerDocument )
        .addClass( "ui-button-text" )
        .html( this.options.label )
        .appendTo( buttonElement.empty() )
        .text(),
      icons = this.options.icons,
      multipleIcons = icons.primary && icons.secondary,
      buttonClasses = [];

    if ( icons.primary || icons.secondary ) {
      if ( this.options.text ) {
        buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
      }

      if ( icons.primary ) {
        buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
      }

      if ( icons.secondary ) {
        buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
      }

      if ( !this.options.text ) {
        buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

        if ( !this.hasTitle ) {
          buttonElement.attr( "title", buttonText );
        }
      }
    } else {
      buttonClasses.push( "ui-button-text-only" );
    }
    buttonElement.addClass( buttonClasses.join( " " ) );
  }
});

$.widget( "ui.buttonset", {
  options: {
    items: ":button, :submit, :reset, :checkbox, :radio, a, :data(button)"
  },

  _create: function() {
    this.element.addClass( "ui-buttonset" );
  },

  _init: function() {
    this.refresh();
  },

  _setOption: function( key, value ) {
    if ( key === "disabled" ) {
      this.buttons.button( "option", key, value );
    }

    $.Widget.prototype._setOption.apply( this, arguments );
  },

  refresh: function() {
    var rtl = this.element.css( "direction" ) === "rtl";

    this.buttons = this.element.find( this.options.items )
      .filter( ":ui-button" )
        .button( "refresh" )
      .end()
      .not( ":ui-button" )
        .button()
      .end()
      .map(function() {
        return $( this ).button( "widget" )[ 0 ];
      })
        .removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
        .filter( ":first" )
          .addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
        .end()
        .filter( ":last" )
          .addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
        .end()
      .end();
  },

  destroy: function() {
    this.element.removeClass( "ui-buttonset" );
    this.buttons
      .map(function() {
        return $( this ).button( "widget" )[ 0 ];
      })
        .removeClass( "ui-corner-left ui-corner-right" )
      .end()
      .button( "destroy" );

    $.Widget.prototype.destroy.call( this );
  }
});

}( jQuery ) );
/*!
 * jQuery UI Dialog 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.button.js
 *  jquery.ui.draggable.js
 *  jquery.ui.mouse.js
 *  jquery.ui.position.js
 *  jquery.ui.resizable.js
 */
(function( $, undefined ) {

var uiDialogClasses =
    'ui-dialog ' +
    'ui-widget ' +
    'ui-widget-content ' +
    'ui-corner-all ',
  sizeRelatedOptions = {
    buttons: true,
    height: true,
    maxHeight: true,
    maxWidth: true,
    minHeight: true,
    minWidth: true,
    width: true
  },
  resizableRelatedOptions = {
    maxHeight: true,
    maxWidth: true,
    minHeight: true,
    minWidth: true
  },
  // support for jQuery 1.3.2 - handle common attrFn methods for dialog
  attrFn = $.attrFn || {
    val: true,
    css: true,
    html: true,
    text: true,
    data: true,
    width: true,
    height: true,
    offset: true,
    click: true
  };

$.widget("ui.dialog", {
  options: {
    autoOpen: true,
    buttons: {},
    closeOnEscape: true,
    closeText: 'close',
    dialogClass: '',
    draggable: true,
    hide: null,
    height: 'auto',
    maxHeight: false,
    maxWidth: false,
    minHeight: 150,
    minWidth: 150,
    modal: false,
    position: {
      my: 'center',
      at: 'center',
      collision: 'fit',
      // ensure that the titlebar is never outside the document
      using: function(pos) {
        var topOffset = $(this).css(pos).offset().top;
        if (topOffset < 0) {
          $(this).css('top', pos.top - topOffset);
        }
      }
    },
    resizable: true,
    show: null,
    stack: true,
    title: '',
    width: 300,
    zIndex: 1000
  },

  _create: function() {
    this.originalTitle = this.element.attr('title');
    // #5742 - .attr() might return a DOMElement
    if ( typeof this.originalTitle !== "string" ) {
      this.originalTitle = "";
    }

    this.options.title = this.options.title || this.originalTitle;
    var self = this,
      options = self.options,

      title = options.title || '&#160;',
      titleId = $.ui.dialog.getTitleId(self.element),

      uiDialog = (self.uiDialog = $('<div></div>'))
        .appendTo(document.body)
        .hide()
        .addClass(uiDialogClasses + options.dialogClass)
        .css({
          zIndex: options.zIndex
        })
        // setting tabIndex makes the div focusable
        // setting outline to 0 prevents a border on focus in Mozilla
        .attr('tabIndex', -1).css('outline', 0).keydown(function(event) {
          if (options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
            event.keyCode === $.ui.keyCode.ESCAPE) {

            self.close(event);
            event.preventDefault();
          }
        })
        .attr({
          role: 'dialog',
          'aria-labelledby': titleId
        })
        .mousedown(function(event) {
          self.moveToTop(false, event);
        }),

      uiDialogContent = self.element
        .show()
        .removeAttr('title')
        .addClass(
          'ui-dialog-content ' +
          'ui-widget-content')
        .appendTo(uiDialog),

      uiDialogTitlebar = (self.uiDialogTitlebar = $('<div></div>'))
        .addClass(
          'ui-dialog-titlebar ' +
          'ui-widget-header ' +
          'ui-corner-all ' +
          'ui-helper-clearfix'
        )
        .prependTo(uiDialog),

      uiDialogTitlebarClose = $('<a href="#"></a>')
        .addClass(
          'ui-dialog-titlebar-close ' +
          'ui-corner-all'
        )
        .attr('role', 'button')
        .hover(
          function() {
            uiDialogTitlebarClose.addClass('ui-state-hover');
          },
          function() {
            uiDialogTitlebarClose.removeClass('ui-state-hover');
          }
        )
        .focus(function() {
          uiDialogTitlebarClose.addClass('ui-state-focus');
        })
        .blur(function() {
          uiDialogTitlebarClose.removeClass('ui-state-focus');
        })
        .click(function(event) {
          self.close(event);
          return false;
        })
        .appendTo(uiDialogTitlebar),

      uiDialogTitlebarCloseText = (self.uiDialogTitlebarCloseText = $('<span></span>'))
        .addClass(
          'ui-icon ' +
          'ui-icon-closethick'
        )
        .text(options.closeText)
        .appendTo(uiDialogTitlebarClose),

      uiDialogTitle = $('<span></span>')
        .addClass('ui-dialog-title')
        .attr('id', titleId)
        .html(title)
        .prependTo(uiDialogTitlebar);

    //handling of deprecated beforeclose (vs beforeClose) option
    //Ticket #4669 http://dev.jqueryui.com/ticket/4669
    //TODO: remove in 1.9pre
    if ($.isFunction(options.beforeclose) && !$.isFunction(options.beforeClose)) {
      options.beforeClose = options.beforeclose;
    }

    uiDialogTitlebar.find("*").add(uiDialogTitlebar).disableSelection();

    if (options.draggable && $.fn.draggable) {
      self._makeDraggable();
    }
    if (options.resizable && $.fn.resizable) {
      self._makeResizable();
    }

    self._createButtons(options.buttons);
    self._isOpen = false;

    if ($.fn.bgiframe) {
      uiDialog.bgiframe();
    }
  },

  _init: function() {
    if ( this.options.autoOpen ) {
      this.open();
    }
  },

  destroy: function() {
    var self = this;

    if (self.overlay) {
      self.overlay.destroy();
    }
    self.uiDialog.hide();
    self.element
      .unbind('.dialog')
      .removeData('dialog')
      .removeClass('ui-dialog-content ui-widget-content')
      .hide().appendTo('body');
    self.uiDialog.remove();

    if (self.originalTitle) {
      self.element.attr('title', self.originalTitle);
    }

    return self;
  },

  widget: function() {
    return this.uiDialog;
  },

  close: function(event) {
    var self = this,
      maxZ, thisZ;

    if (false === self._trigger('beforeClose', event)) {
      return;
    }

    if (self.overlay) {
      self.overlay.destroy();
    }
    self.uiDialog.unbind('keypress.ui-dialog');

    self._isOpen = false;

    if (self.options.hide) {
      self.uiDialog.hide(self.options.hide, function() {
        self._trigger('close', event);
      });
    } else {
      self.uiDialog.hide();
      self._trigger('close', event);
    }

    $.ui.dialog.overlay.resize();

    // adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
    if (self.options.modal) {
      maxZ = 0;
      $('.ui-dialog').each(function() {
        if (this !== self.uiDialog[0]) {
          thisZ = $(this).css('z-index');
          if(!isNaN(thisZ)) {
            maxZ = Math.max(maxZ, thisZ);
          }
        }
      });
      $.ui.dialog.maxZ = maxZ;
    }

    return self;
  },

  isOpen: function() {
    return this._isOpen;
  },

  // the force parameter allows us to move modal dialogs to their correct
  // position on open
  moveToTop: function(force, event) {
    var self = this,
      options = self.options,
      saveScroll;

    if ((options.modal && !force) ||
      (!options.stack && !options.modal)) {
      return self._trigger('focus', event);
    }

    if (options.zIndex > $.ui.dialog.maxZ) {
      $.ui.dialog.maxZ = options.zIndex;
    }
    if (self.overlay) {
      $.ui.dialog.maxZ += 1;
      self.overlay.$el.css('z-index', $.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ);
    }

    //Save and then restore scroll since Opera 9.5+ resets when parent z-Index is changed.
    //  http://ui.jquery.com/bugs/ticket/3193
    saveScroll = { scrollTop: self.element.scrollTop(), scrollLeft: self.element.scrollLeft() };
    $.ui.dialog.maxZ += 1;
    self.uiDialog.css('z-index', $.ui.dialog.maxZ);
    self.element.attr(saveScroll);
    self._trigger('focus', event);

    return self;
  },

  open: function() {
    if (this._isOpen) { return; }

    var self = this,
      options = self.options,
      uiDialog = self.uiDialog;

    self.overlay = options.modal ? new $.ui.dialog.overlay(self) : null;
    self._size();
    self._position(options.position);
    uiDialog.show(options.show);
    self.moveToTop(true);

    // prevent tabbing out of modal dialogs
    if ( options.modal ) {
      uiDialog.bind( "keydown.ui-dialog", function( event ) {
        if ( event.keyCode !== $.ui.keyCode.TAB ) {
          return;
        }

        var tabbables = $(':tabbable', this),
          first = tabbables.filter(':first'),
          last  = tabbables.filter(':last');

        if (event.target === last[0] && !event.shiftKey) {
          first.focus(1);
          return false;
        } else if (event.target === first[0] && event.shiftKey) {
          last.focus(1);
          return false;
        }
      });
    }

    // set focus to the first tabbable element in the content area or the first button
    // if there are no tabbable elements, set focus on the dialog itself
    $(self.element.find(':tabbable').get().concat(
      uiDialog.find('.ui-dialog-buttonpane :tabbable').get().concat(
        uiDialog.get()))).eq(0).focus();

    self._isOpen = true;
    self._trigger('open');

    return self;
  },

  _createButtons: function(buttons) {
    var self = this,
      hasButtons = false,
      uiDialogButtonPane = $('<div></div>')
        .addClass(
          'ui-dialog-buttonpane ' +
          'ui-widget-content ' +
          'ui-helper-clearfix'
        ),
      uiButtonSet = $( "<div></div>" )
        .addClass( "ui-dialog-buttonset" )
        .appendTo( uiDialogButtonPane );

    // if we already have a button pane, remove it
    self.uiDialog.find('.ui-dialog-buttonpane').remove();

    if (typeof buttons === 'object' && buttons !== null) {
      $.each(buttons, function() {
        return !(hasButtons = true);
      });
    }
    if (hasButtons) {
      $.each(buttons, function(name, props) {
        props = $.isFunction( props ) ?
          { click: props, text: name } :
          props;
        var button = $('<button type="button"></button>')
          .click(function() {
            props.click.apply(self.element[0], arguments);
          })
          .appendTo(uiButtonSet);
        // can't use .attr( props, true ) with jQuery 1.3.2.
        $.each( props, function( key, value ) {
          if ( key === "click" ) {
            return;
          }
          if ( key in attrFn ) {
            button[ key ]( value );
          } else {
            button.attr( key, value );
          }
        });
        if ($.fn.button) {
          button.button();
        }
      });
      uiDialogButtonPane.appendTo(self.uiDialog);
    }
  },

  _makeDraggable: function() {
    var self = this,
      options = self.options,
      doc = $(document),
      heightBeforeDrag;

    function filteredUi(ui) {
      return {
        position: ui.position,
        offset: ui.offset
      };
    }

    self.uiDialog.draggable({
      cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
      handle: '.ui-dialog-titlebar',
      containment: 'document',
      start: function(event, ui) {
        heightBeforeDrag = options.height === "auto" ? "auto" : $(this).height();
        $(this).height($(this).height()).addClass("ui-dialog-dragging");
        self._trigger('dragStart', event, filteredUi(ui));
      },
      drag: function(event, ui) {
        self._trigger('drag', event, filteredUi(ui));
      },
      stop: function(event, ui) {
        options.position = [ui.position.left - doc.scrollLeft(),
          ui.position.top - doc.scrollTop()];
        $(this).removeClass("ui-dialog-dragging").height(heightBeforeDrag);
        self._trigger('dragStop', event, filteredUi(ui));
        $.ui.dialog.overlay.resize();
      }
    });
  },

  _makeResizable: function(handles) {
    handles = (handles === undefined ? this.options.resizable : handles);
    var self = this,
      options = self.options,
      // .ui-resizable has position: relative defined in the stylesheet
      // but dialogs have to use absolute or fixed positioning
      position = self.uiDialog.css('position'),
      resizeHandles = (typeof handles === 'string' ?
        handles :
        'n,e,s,w,se,sw,ne,nw'
      );

    function filteredUi(ui) {
      return {
        originalPosition: ui.originalPosition,
        originalSize: ui.originalSize,
        position: ui.position,
        size: ui.size
      };
    }

    self.uiDialog.resizable({
      cancel: '.ui-dialog-content',
      containment: 'document',
      alsoResize: self.element,
      maxWidth: options.maxWidth,
      maxHeight: options.maxHeight,
      minWidth: options.minWidth,
      minHeight: self._minHeight(),
      handles: resizeHandles,
      start: function(event, ui) {
        $(this).addClass("ui-dialog-resizing");
        self._trigger('resizeStart', event, filteredUi(ui));
      },
      resize: function(event, ui) {
        self._trigger('resize', event, filteredUi(ui));
      },
      stop: function(event, ui) {
        $(this).removeClass("ui-dialog-resizing");
        options.height = $(this).height();
        options.width = $(this).width();
        self._trigger('resizeStop', event, filteredUi(ui));
        $.ui.dialog.overlay.resize();
      }
    })
    .css('position', position)
    .find('.ui-resizable-se').addClass('ui-icon ui-icon-grip-diagonal-se');
  },

  _minHeight: function() {
    var options = this.options;

    if (options.height === 'auto') {
      return options.minHeight;
    } else {
      return Math.min(options.minHeight, options.height);
    }
  },

  _position: function(position) {
    var myAt = [],
      offset = [0, 0],
      isVisible;

    if (position) {
      // deep extending converts arrays to objects in jQuery <= 1.3.2 :-(
  //    if (typeof position == 'string' || $.isArray(position)) {
  //      myAt = $.isArray(position) ? position : position.split(' ');

      if (typeof position === 'string' || (typeof position === 'object' && '0' in position)) {
        myAt = position.split ? position.split(' ') : [position[0], position[1]];
        if (myAt.length === 1) {
          myAt[1] = myAt[0];
        }

        $.each(['left', 'top'], function(i, offsetPosition) {
          if (+myAt[i] === myAt[i]) {
            offset[i] = myAt[i];
            myAt[i] = offsetPosition;
          }
        });

        position = {
          my: myAt.join(" "),
          at: myAt.join(" "),
          offset: offset.join(" ")
        };
      }

      position = $.extend({}, $.ui.dialog.prototype.options.position, position);
    } else {
      position = $.ui.dialog.prototype.options.position;
    }

    // need to show the dialog to get the actual offset in the position plugin
    isVisible = this.uiDialog.is(':visible');
    if (!isVisible) {
      this.uiDialog.show();
    }
    this.uiDialog
      // workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
      .css({ top: 0, left: 0 })
      .position($.extend({ of: window }, position));
    if (!isVisible) {
      this.uiDialog.hide();
    }
  },

  _setOptions: function( options ) {
    var self = this,
      resizableOptions = {},
      resize = false;

    $.each( options, function( key, value ) {
      self._setOption( key, value );

      if ( key in sizeRelatedOptions ) {
        resize = true;
      }
      if ( key in resizableRelatedOptions ) {
        resizableOptions[ key ] = value;
      }
    });

    if ( resize ) {
      this._size();
    }
    if ( this.uiDialog.is( ":data(resizable)" ) ) {
      this.uiDialog.resizable( "option", resizableOptions );
    }
  },

  _setOption: function(key, value){
    var self = this,
      uiDialog = self.uiDialog;

    switch (key) {
      //handling of deprecated beforeclose (vs beforeClose) option
      //Ticket #4669 http://dev.jqueryui.com/ticket/4669
      //TODO: remove in 1.9pre
      case "beforeclose":
        key = "beforeClose";
        break;
      case "buttons":
        self._createButtons(value);
        break;
      case "closeText":
        // ensure that we always pass a string
        self.uiDialogTitlebarCloseText.text("" + value);
        break;
      case "dialogClass":
        uiDialog
          .removeClass(self.options.dialogClass)
          .addClass(uiDialogClasses + value);
        break;
      case "disabled":
        if (value) {
          uiDialog.addClass('ui-dialog-disabled');
        } else {
          uiDialog.removeClass('ui-dialog-disabled');
        }
        break;
      case "draggable":
        var isDraggable = uiDialog.is( ":data(draggable)" );
        if ( isDraggable && !value ) {
          uiDialog.draggable( "destroy" );
        }

        if ( !isDraggable && value ) {
          self._makeDraggable();
        }
        break;
      case "position":
        self._position(value);
        break;
      case "resizable":
        // currently resizable, becoming non-resizable
        var isResizable = uiDialog.is( ":data(resizable)" );
        if (isResizable && !value) {
          uiDialog.resizable('destroy');
        }

        // currently resizable, changing handles
        if (isResizable && typeof value === 'string') {
          uiDialog.resizable('option', 'handles', value);
        }

        // currently non-resizable, becoming resizable
        if (!isResizable && value !== false) {
          self._makeResizable(value);
        }
        break;
      case "title":
        // convert whatever was passed in o a string, for html() to not throw up
        $(".ui-dialog-title", self.uiDialogTitlebar).html("" + (value || '&#160;'));
        break;
    }

    $.Widget.prototype._setOption.apply(self, arguments);
  },

  _size: function() {
    /* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
     * divs will both have width and height set, so we need to reset them
     */
    var options = this.options,
      nonContentHeight,
      minContentHeight,
      isVisible = this.uiDialog.is( ":visible" );

    // reset content sizing
    this.element.show().css({
      width: 'auto',
      minHeight: 0,
      height: 0
    });

    if (options.minWidth > options.width) {
      options.width = options.minWidth;
    }

    // reset wrapper sizing
    // determine the height of all the non-content elements
    nonContentHeight = this.uiDialog.css({
        height: 'auto',
        width: options.width
      })
      .height();
    minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );

    if ( options.height === "auto" ) {
      // only needed for IE6 support
      if ( $.support.minHeight ) {
        this.element.css({
          minHeight: minContentHeight,
          height: "auto"
        });
      } else {
        this.uiDialog.show();
        var autoHeight = this.element.css( "height", "auto" ).height();
        if ( !isVisible ) {
          this.uiDialog.hide();
        }
        this.element.height( Math.max( autoHeight, minContentHeight ) );
      }
    } else {
      this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
    }

    if (this.uiDialog.is(':data(resizable)')) {
      this.uiDialog.resizable('option', 'minHeight', this._minHeight());
    }
  }
});

$.extend($.ui.dialog, {
  version: "1.8.20",

  uuid: 0,
  maxZ: 0,

  getTitleId: function($el) {
    var id = $el.attr('id');
    if (!id) {
      this.uuid += 1;
      id = this.uuid;
    }
    return 'ui-dialog-title-' + id;
  },

  overlay: function(dialog) {
    this.$el = $.ui.dialog.overlay.create(dialog);
  }
});

$.extend($.ui.dialog.overlay, {
  instances: [],
  // reuse old instances due to IE memory leak with alpha transparency (see #5185)
  oldInstances: [],
  maxZ: 0,
  events: $.map('focus,mousedown,mouseup,keydown,keypress,click'.split(','),
    function(event) { return event + '.dialog-overlay'; }).join(' '),
  create: function(dialog) {
    if (this.instances.length === 0) {
      // prevent use of anchors and inputs
      // we use a setTimeout in case the overlay is created from an
      // event that we're going to be cancelling (see #2804)
      setTimeout(function() {
        // handle $(el).dialog().dialog('close') (see #4065)
        if ($.ui.dialog.overlay.instances.length) {
          $(document).bind($.ui.dialog.overlay.events, function(event) {
            // stop events if the z-index of the target is < the z-index of the overlay
            // we cannot return true when we don't want to cancel the event (#3523)
            if ($(event.target).zIndex() < $.ui.dialog.overlay.maxZ) {
              return false;
            }
          });
        }
      }, 1);

      // allow closing by pressing the escape key
      $(document).bind('keydown.dialog-overlay', function(event) {
        if (dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
          event.keyCode === $.ui.keyCode.ESCAPE) {

          dialog.close(event);
          event.preventDefault();
        }
      });

      // handle window resize
      $(window).bind('resize.dialog-overlay', $.ui.dialog.overlay.resize);
    }

    var $el = (this.oldInstances.pop() || $('<div></div>').addClass('ui-widget-overlay'))
      .appendTo(document.body)
      .css({
        width: this.width(),
        height: this.height()
      });

    if ($.fn.bgiframe) {
      $el.bgiframe();
    }

    this.instances.push($el);
    return $el;
  },

  destroy: function($el) {
    var indexOf = $.inArray($el, this.instances);
    if (indexOf != -1){
      this.oldInstances.push(this.instances.splice(indexOf, 1)[0]);
    }

    if (this.instances.length === 0) {
      $([document, window]).unbind('.dialog-overlay');
    }

    $el.remove();

    // adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
    var maxZ = 0;
    $.each(this.instances, function() {
      maxZ = Math.max(maxZ, this.css('z-index'));
    });
    this.maxZ = maxZ;
  },

  height: function() {
    var scrollHeight,
      offsetHeight;
    // handle IE 6
    if ($.browser.msie && $.browser.version < 7) {
      scrollHeight = Math.max(
        document.documentElement.scrollHeight,
        document.body.scrollHeight
      );
      offsetHeight = Math.max(
        document.documentElement.offsetHeight,
        document.body.offsetHeight
      );

      if (scrollHeight < offsetHeight) {
        return $(window).height() + 'px';
      } else {
        return scrollHeight + 'px';
      }
    // handle "good" browsers
    } else {
      return $(document).height() + 'px';
    }
  },

  width: function() {
    var scrollWidth,
      offsetWidth;
    // handle IE
    if ( $.browser.msie ) {
      scrollWidth = Math.max(
        document.documentElement.scrollWidth,
        document.body.scrollWidth
      );
      offsetWidth = Math.max(
        document.documentElement.offsetWidth,
        document.body.offsetWidth
      );

      if (scrollWidth < offsetWidth) {
        return $(window).width() + 'px';
      } else {
        return scrollWidth + 'px';
      }
    // handle "good" browsers
    } else {
      return $(document).width() + 'px';
    }
  },

  resize: function() {
    /* If the dialog is draggable and the user drags it past the
     * right edge of the window, the document becomes wider so we
     * need to stretch the overlay. If the user then drags the
     * dialog back to the left, the document will become narrower,
     * so we need to shrink the overlay to the appropriate size.
     * This is handled by shrinking the overlay before setting it
     * to the full document size.
     */
    var $overlays = $([]);
    $.each($.ui.dialog.overlay.instances, function() {
      $overlays = $overlays.add(this);
    });

    $overlays.css({
      width: 0,
      height: 0
    }).css({
      width: $.ui.dialog.overlay.width(),
      height: $.ui.dialog.overlay.height()
    });
  }
});

$.extend($.ui.dialog.overlay.prototype, {
  destroy: function() {
    $.ui.dialog.overlay.destroy(this.$el);
  }
});

}(jQuery));
/*!
 * jQuery UI Slider 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.mouse.js
 *  jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {

  widgetEventPrefix: "slide",

  options: {
    animate: false,
    distance: 0,
    max: 100,
    min: 0,
    orientation: "horizontal",
    range: false,
    step: 1,
    value: 0,
    values: null
  },

  _create: function() {
    var self = this,
      o = this.options,
      existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
      handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
      handleCount = ( o.values && o.values.length ) || 1,
      handles = [];

    this._keySliding = false;
    this._mouseSliding = false;
    this._animateOff = true;
    this._handleIndex = null;
    this._detectOrientation();
    this._mouseInit();

    this.element
      .addClass( "ui-slider" +
        " ui-slider-" + this.orientation +
        " ui-widget" +
        " ui-widget-content" +
        " ui-corner-all" +
        ( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

    this.range = $([]);

    if ( o.range ) {
      if ( o.range === true ) {
        if ( !o.values ) {
          o.values = [ this._valueMin(), this._valueMin() ];
        }
        if ( o.values.length && o.values.length !== 2 ) {
          o.values = [ o.values[0], o.values[0] ];
        }
      }

      this.range = $( "<div></div>" )
        .appendTo( this.element )
        .addClass( "ui-slider-range" +
        // note: this isn't the most fittingly semantic framework class for this element,
        // but worked best visually with a variety of themes
        " ui-widget-header" +
        ( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
    }

    for ( var i = existingHandles.length; i < handleCount; i += 1 ) {
      handles.push( handle );
    }

    this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( self.element ) );

    this.handle = this.handles.eq( 0 );

    this.handles.add( this.range ).filter( "a" )
      .click(function( event ) {
        event.preventDefault();
      })
      .hover(function() {
        if ( !o.disabled ) {
          $( this ).addClass( "ui-state-hover" );
        }
      }, function() {
        $( this ).removeClass( "ui-state-hover" );
      })
      .focus(function() {
        if ( !o.disabled ) {
          $( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
          $( this ).addClass( "ui-state-focus" );
        } else {
          $( this ).blur();
        }
      })
      .blur(function() {
        $( this ).removeClass( "ui-state-focus" );
      });

    this.handles.each(function( i ) {
      $( this ).data( "index.ui-slider-handle", i );
    });

    this.handles
      .keydown(function( event ) {
        var index = $( this ).data( "index.ui-slider-handle" ),
          allowed,
          curVal,
          newVal,
          step;

        if ( self.options.disabled ) {
          return;
        }

        switch ( event.keyCode ) {
          case $.ui.keyCode.HOME:
          case $.ui.keyCode.END:
          case $.ui.keyCode.PAGE_UP:
          case $.ui.keyCode.PAGE_DOWN:
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            event.preventDefault();
            if ( !self._keySliding ) {
              self._keySliding = true;
              $( this ).addClass( "ui-state-active" );
              allowed = self._start( event, index );
              if ( allowed === false ) {
                return;
              }
            }
            break;
        }

        step = self.options.step;
        if ( self.options.values && self.options.values.length ) {
          curVal = newVal = self.values( index );
        } else {
          curVal = newVal = self.value();
        }

        switch ( event.keyCode ) {
          case $.ui.keyCode.HOME:
            newVal = self._valueMin();
            break;
          case $.ui.keyCode.END:
            newVal = self._valueMax();
            break;
          case $.ui.keyCode.PAGE_UP:
            newVal = self._trimAlignValue( curVal + ( (self._valueMax() - self._valueMin()) / numPages ) );
            break;
          case $.ui.keyCode.PAGE_DOWN:
            newVal = self._trimAlignValue( curVal - ( (self._valueMax() - self._valueMin()) / numPages ) );
            break;
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
            if ( curVal === self._valueMax() ) {
              return;
            }
            newVal = self._trimAlignValue( curVal + step );
            break;
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            if ( curVal === self._valueMin() ) {
              return;
            }
            newVal = self._trimAlignValue( curVal - step );
            break;
        }

        self._slide( event, index, newVal );
      })
      .keyup(function( event ) {
        var index = $( this ).data( "index.ui-slider-handle" );

        if ( self._keySliding ) {
          self._keySliding = false;
          self._stop( event, index );
          self._change( event, index );
          $( this ).removeClass( "ui-state-active" );
        }

      });

    this._refreshValue();

    this._animateOff = false;
  },

  destroy: function() {
    this.handles.remove();
    this.range.remove();

    this.element
      .removeClass( "ui-slider" +
        " ui-slider-horizontal" +
        " ui-slider-vertical" +
        " ui-slider-disabled" +
        " ui-widget" +
        " ui-widget-content" +
        " ui-corner-all" )
      .removeData( "slider" )
      .unbind( ".slider" );

    this._mouseDestroy();

    return this;
  },

  _mouseCapture: function( event ) {
    var o = this.options,
      position,
      normValue,
      distance,
      closestHandle,
      self,
      index,
      allowed,
      offset,
      mouseOverHandle;

    if ( o.disabled ) {
      return false;
    }

    this.elementSize = {
      width: this.element.outerWidth(),
      height: this.element.outerHeight()
    };
    this.elementOffset = this.element.offset();

    position = { x: event.pageX, y: event.pageY };
    normValue = this._normValueFromMouse( position );
    distance = this._valueMax() - this._valueMin() + 1;
    self = this;
    this.handles.each(function( i ) {
      var thisDistance = Math.abs( normValue - self.values(i) );
      if ( distance > thisDistance ) {
        distance = thisDistance;
        closestHandle = $( this );
        index = i;
      }
    });

    // workaround for bug #3736 (if both handles of a range are at 0,
    // the first is always used as the one with least distance,
    // and moving it is obviously prevented by preventing negative ranges)
    if( o.range === true && this.values(1) === o.min ) {
      index += 1;
      closestHandle = $( this.handles[index] );
    }

    allowed = this._start( event, index );
    if ( allowed === false ) {
      return false;
    }
    this._mouseSliding = true;

    self._handleIndex = index;

    closestHandle
      .addClass( "ui-state-active" )
      .focus();

    offset = closestHandle.offset();
    mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
    this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
      left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
      top: event.pageY - offset.top -
        ( closestHandle.height() / 2 ) -
        ( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
        ( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
        ( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
    };

    if ( !this.handles.hasClass( "ui-state-hover" ) ) {
      this._slide( event, index, normValue );
    }
    this._animateOff = true;
    return true;
  },

  _mouseStart: function( event ) {
    return true;
  },

  _mouseDrag: function( event ) {
    var position = { x: event.pageX, y: event.pageY },
      normValue = this._normValueFromMouse( position );

    this._slide( event, this._handleIndex, normValue );

    return false;
  },

  _mouseStop: function( event ) {
    this.handles.removeClass( "ui-state-active" );
    this._mouseSliding = false;

    this._stop( event, this._handleIndex );
    this._change( event, this._handleIndex );

    this._handleIndex = null;
    this._clickOffset = null;
    this._animateOff = false;

    return false;
  },

  _detectOrientation: function() {
    this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
  },

  _normValueFromMouse: function( position ) {
    var pixelTotal,
      pixelMouse,
      percentMouse,
      valueTotal,
      valueMouse;

    if ( this.orientation === "horizontal" ) {
      pixelTotal = this.elementSize.width;
      pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
    } else {
      pixelTotal = this.elementSize.height;
      pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
    }

    percentMouse = ( pixelMouse / pixelTotal );
    if ( percentMouse > 1 ) {
      percentMouse = 1;
    }
    if ( percentMouse < 0 ) {
      percentMouse = 0;
    }
    if ( this.orientation === "vertical" ) {
      percentMouse = 1 - percentMouse;
    }

    valueTotal = this._valueMax() - this._valueMin();
    valueMouse = this._valueMin() + percentMouse * valueTotal;

    return this._trimAlignValue( valueMouse );
  },

  _start: function( event, index ) {
    var uiHash = {
      handle: this.handles[ index ],
      value: this.value()
    };
    if ( this.options.values && this.options.values.length ) {
      uiHash.value = this.values( index );
      uiHash.values = this.values();
    }
    return this._trigger( "start", event, uiHash );
  },

  _slide: function( event, index, newVal ) {
    var otherVal,
      newValues,
      allowed;

    if ( this.options.values && this.options.values.length ) {
      otherVal = this.values( index ? 0 : 1 );

      if ( ( this.options.values.length === 2 && this.options.range === true ) &&
          ( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
        ) {
        newVal = otherVal;
      }

      if ( newVal !== this.values( index ) ) {
        newValues = this.values();
        newValues[ index ] = newVal;
        // A slide can be canceled by returning false from the slide callback
        allowed = this._trigger( "slide", event, {
          handle: this.handles[ index ],
          value: newVal,
          values: newValues
        } );
        otherVal = this.values( index ? 0 : 1 );
        if ( allowed !== false ) {
          this.values( index, newVal, true );
        }
      }
    } else {
      if ( newVal !== this.value() ) {
        // A slide can be canceled by returning false from the slide callback
        allowed = this._trigger( "slide", event, {
          handle: this.handles[ index ],
          value: newVal
        } );
        if ( allowed !== false ) {
          this.value( newVal );
        }
      }
    }
  },

  _stop: function( event, index ) {
    var uiHash = {
      handle: this.handles[ index ],
      value: this.value()
    };
    if ( this.options.values && this.options.values.length ) {
      uiHash.value = this.values( index );
      uiHash.values = this.values();
    }

    this._trigger( "stop", event, uiHash );
  },

  _change: function( event, index ) {
    if ( !this._keySliding && !this._mouseSliding ) {
      var uiHash = {
        handle: this.handles[ index ],
        value: this.value()
      };
      if ( this.options.values && this.options.values.length ) {
        uiHash.value = this.values( index );
        uiHash.values = this.values();
      }

      this._trigger( "change", event, uiHash );
    }
  },

  value: function( newValue ) {
    if ( arguments.length ) {
      this.options.value = this._trimAlignValue( newValue );
      this._refreshValue();
      this._change( null, 0 );
      return;
    }

    return this._value();
  },

  values: function( index, newValue ) {
    var vals,
      newValues,
      i;

    if ( arguments.length > 1 ) {
      this.options.values[ index ] = this._trimAlignValue( newValue );
      this._refreshValue();
      this._change( null, index );
      return;
    }

    if ( arguments.length ) {
      if ( $.isArray( arguments[ 0 ] ) ) {
        vals = this.options.values;
        newValues = arguments[ 0 ];
        for ( i = 0; i < vals.length; i += 1 ) {
          vals[ i ] = this._trimAlignValue( newValues[ i ] );
          this._change( null, i );
        }
        this._refreshValue();
      } else {
        if ( this.options.values && this.options.values.length ) {
          return this._values( index );
        } else {
          return this.value();
        }
      }
    } else {
      return this._values();
    }
  },

  _setOption: function( key, value ) {
    var i,
      valsLength = 0;

    if ( $.isArray( this.options.values ) ) {
      valsLength = this.options.values.length;
    }

    $.Widget.prototype._setOption.apply( this, arguments );

    switch ( key ) {
      case "disabled":
        if ( value ) {
          this.handles.filter( ".ui-state-focus" ).blur();
          this.handles.removeClass( "ui-state-hover" );
          this.handles.propAttr( "disabled", true );
          this.element.addClass( "ui-disabled" );
        } else {
          this.handles.propAttr( "disabled", false );
          this.element.removeClass( "ui-disabled" );
        }
        break;
      case "orientation":
        this._detectOrientation();
        this.element
          .removeClass( "ui-slider-horizontal ui-slider-vertical" )
          .addClass( "ui-slider-" + this.orientation );
        this._refreshValue();
        break;
      case "value":
        this._animateOff = true;
        this._refreshValue();
        this._change( null, 0 );
        this._animateOff = false;
        break;
      case "values":
        this._animateOff = true;
        this._refreshValue();
        for ( i = 0; i < valsLength; i += 1 ) {
          this._change( null, i );
        }
        this._animateOff = false;
        break;
    }
  },

  //internal value getter
  // _value() returns value trimmed by min and max, aligned by step
  _value: function() {
    var val = this.options.value;
    val = this._trimAlignValue( val );

    return val;
  },

  //internal values getter
  // _values() returns array of values trimmed by min and max, aligned by step
  // _values( index ) returns single value trimmed by min and max, aligned by step
  _values: function( index ) {
    var val,
      vals,
      i;

    if ( arguments.length ) {
      val = this.options.values[ index ];
      val = this._trimAlignValue( val );

      return val;
    } else {
      // .slice() creates a copy of the array
      // this copy gets trimmed by min and max and then returned
      vals = this.options.values.slice();
      for ( i = 0; i < vals.length; i+= 1) {
        vals[ i ] = this._trimAlignValue( vals[ i ] );
      }

      return vals;
    }
  },

  // returns the step-aligned value that val is closest to, between (inclusive) min and max
  _trimAlignValue: function( val ) {
    if ( val <= this._valueMin() ) {
      return this._valueMin();
    }
    if ( val >= this._valueMax() ) {
      return this._valueMax();
    }
    var step = ( this.options.step > 0 ) ? this.options.step : 1,
      valModStep = (val - this._valueMin()) % step,
      alignValue = val - valModStep;

    if ( Math.abs(valModStep) * 2 >= step ) {
      alignValue += ( valModStep > 0 ) ? step : ( -step );
    }

    // Since JavaScript has problems with large floats, round
    // the final value to 5 digits after the decimal point (see #4124)
    return parseFloat( alignValue.toFixed(5) );
  },

  _valueMin: function() {
    return this.options.min;
  },

  _valueMax: function() {
    return this.options.max;
  },

  _refreshValue: function() {
    var oRange = this.options.range,
      o = this.options,
      self = this,
      animate = ( !this._animateOff ) ? o.animate : false,
      valPercent,
      _set = {},
      lastValPercent,
      value,
      valueMin,
      valueMax;

    if ( this.options.values && this.options.values.length ) {
      this.handles.each(function( i, j ) {
        valPercent = ( self.values(i) - self._valueMin() ) / ( self._valueMax() - self._valueMin() ) * 100;
        _set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
        $( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
        if ( self.options.range === true ) {
          if ( self.orientation === "horizontal" ) {
            if ( i === 0 ) {
              self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
            }
            if ( i === 1 ) {
              self.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
            }
          } else {
            if ( i === 0 ) {
              self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
            }
            if ( i === 1 ) {
              self.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
            }
          }
        }
        lastValPercent = valPercent;
      });
    } else {
      value = this.value();
      valueMin = this._valueMin();
      valueMax = this._valueMax();
      valPercent = ( valueMax !== valueMin ) ?
          ( value - valueMin ) / ( valueMax - valueMin ) * 100 :
          0;
      _set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
      this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

      if ( oRange === "min" && this.orientation === "horizontal" ) {
        this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
      }
      if ( oRange === "max" && this.orientation === "horizontal" ) {
        this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
      }
      if ( oRange === "min" && this.orientation === "vertical" ) {
        this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
      }
      if ( oRange === "max" && this.orientation === "vertical" ) {
        this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
      }
    }
  }

});

$.extend( $.ui.slider, {
  version: "1.8.20"
});

}(jQuery));
/*!
 * jQuery UI Tabs 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function( $, undefined ) {

var tabId = 0,
  listId = 0;

function getNextTabId() {
  return ++tabId;
}

function getNextListId() {
  return ++listId;
}

$.widget( "ui.tabs", {
  options: {
    add: null,
    ajaxOptions: null,
    cache: false,
    cookie: null, // e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
    collapsible: false,
    disable: null,
    disabled: [],
    enable: null,
    event: "click",
    fx: null, // e.g. { height: 'toggle', opacity: 'toggle', duration: 200 }
    idPrefix: "ui-tabs-",
    load: null,
    panelTemplate: "<div></div>",
    remove: null,
    select: null,
    show: null,
    spinner: "<em>Loading&#8230;</em>",
    tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
  },

  _create: function() {
    this._tabify( true );
  },

  _setOption: function( key, value ) {
    if ( key == "selected" ) {
      if (this.options.collapsible && value == this.options.selected ) {
        return;
      }
      this.select( value );
    } else {
      this.options[ key ] = value;
      this._tabify();
    }
  },

  _tabId: function( a ) {
    return a.title && a.title.replace( /\s/g, "_" ).replace( /[^\w\u00c0-\uFFFF-]/g, "" ) ||
      this.options.idPrefix + getNextTabId();
  },

  _sanitizeSelector: function( hash ) {
    // we need this because an id may contain a ":"
    return hash.replace( /:/g, "\\:" );
  },

  _cookie: function() {
    var cookie = this.cookie ||
      ( this.cookie = this.options.cookie.name || "ui-tabs-" + getNextListId() );
    return $.cookie.apply( null, [ cookie ].concat( $.makeArray( arguments ) ) );
  },

  _ui: function( tab, panel ) {
    return {
      tab: tab,
      panel: panel,
      index: this.anchors.index( tab )
    };
  },

  _cleanup: function() {
    // restore all former loading tabs labels
    this.lis.filter( ".ui-state-processing" )
      .removeClass( "ui-state-processing" )
      .find( "span:data(label.tabs)" )
        .each(function() {
          var el = $( this );
          el.html( el.data( "label.tabs" ) ).removeData( "label.tabs" );
        });
  },

  _tabify: function( init ) {
    var self = this,
      o = this.options,
      fragmentId = /^#.+/; // Safari 2 reports '#' for an empty hash

    this.list = this.element.find( "ol,ul" ).eq( 0 );
    this.lis = $( " > li:has(a[href])", this.list );
    this.anchors = this.lis.map(function() {
      return $( "a", this )[ 0 ];
    });
    this.panels = $( [] );

    this.anchors.each(function( i, a ) {
      var href = $( a ).attr( "href" );
      // For dynamically created HTML that contains a hash as href IE < 8 expands
      // such href to the full page url with hash and then misinterprets tab as ajax.
      // Same consideration applies for an added tab with a fragment identifier
      // since a[href=#fragment-identifier] does unexpectedly not match.
      // Thus normalize href attribute...
      var hrefBase = href.split( "#" )[ 0 ],
        baseEl;
      if ( hrefBase && ( hrefBase === location.toString().split( "#" )[ 0 ] ||
          ( baseEl = $( "base" )[ 0 ]) && hrefBase === baseEl.href ) ) {
        href = a.hash;
        a.href = href;
      }

      // inline tab
      if ( fragmentId.test( href ) ) {
        self.panels = self.panels.add( self.element.find( self._sanitizeSelector( href ) ) );
      // remote tab
      // prevent loading the page itself if href is just "#"
      } else if ( href && href !== "#" ) {
        // required for restore on destroy
        $.data( a, "href.tabs", href );

        // TODO until #3808 is fixed strip fragment identifier from url
        // (IE fails to load from such url)
        $.data( a, "load.tabs", href.replace( /#.*$/, "" ) );

        var id = self._tabId( a );
        a.href = "#" + id;
        var $panel = self.element.find( "#" + id );
        if ( !$panel.length ) {
          $panel = $( o.panelTemplate )
            .attr( "id", id )
            .addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
            .insertAfter( self.panels[ i - 1 ] || self.list );
          $panel.data( "destroy.tabs", true );
        }
        self.panels = self.panels.add( $panel );
      // invalid tab href
      } else {
        o.disabled.push( i );
      }
    });

    // initialization from scratch
    if ( init ) {
      // attach necessary classes for styling
      this.element.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" );
      this.list.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );
      this.lis.addClass( "ui-state-default ui-corner-top" );
      this.panels.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" );

      // Selected tab
      // use "selected" option or try to retrieve:
      // 1. from fragment identifier in url
      // 2. from cookie
      // 3. from selected class attribute on <li>
      if ( o.selected === undefined ) {
        if ( location.hash ) {
          this.anchors.each(function( i, a ) {
            if ( a.hash == location.hash ) {
              o.selected = i;
              return false;
            }
          });
        }
        if ( typeof o.selected !== "number" && o.cookie ) {
          o.selected = parseInt( self._cookie(), 10 );
        }
        if ( typeof o.selected !== "number" && this.lis.filter( ".ui-tabs-selected" ).length ) {
          o.selected = this.lis.index( this.lis.filter( ".ui-tabs-selected" ) );
        }
        o.selected = o.selected || ( this.lis.length ? 0 : -1 );
      } else if ( o.selected === null ) { // usage of null is deprecated, TODO remove in next release
        o.selected = -1;
      }

      // sanity check - default to first tab...
      o.selected = ( ( o.selected >= 0 && this.anchors[ o.selected ] ) || o.selected < 0 )
        ? o.selected
        : 0;

      // Take disabling tabs via class attribute from HTML
      // into account and update option properly.
      // A selected tab cannot become disabled.
      o.disabled = $.unique( o.disabled.concat(
        $.map( this.lis.filter( ".ui-state-disabled" ), function( n, i ) {
          return self.lis.index( n );
        })
      ) ).sort();

      if ( $.inArray( o.selected, o.disabled ) != -1 ) {
        o.disabled.splice( $.inArray( o.selected, o.disabled ), 1 );
      }

      // highlight selected tab
      this.panels.addClass( "ui-tabs-hide" );
      this.lis.removeClass( "ui-tabs-selected ui-state-active" );
      // check for length avoids error when initializing empty list
      if ( o.selected >= 0 && this.anchors.length ) {
        self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) ).removeClass( "ui-tabs-hide" );
        this.lis.eq( o.selected ).addClass( "ui-tabs-selected ui-state-active" );

        // seems to be expected behavior that the show callback is fired
        self.element.queue( "tabs", function() {
          self._trigger( "show", null,
            self._ui( self.anchors[ o.selected ], self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) )[ 0 ] ) );
        });

        this.load( o.selected );
      }

      // clean up to avoid memory leaks in certain versions of IE 6
      // TODO: namespace this event
      $( window ).bind( "unload", function() {
        self.lis.add( self.anchors ).unbind( ".tabs" );
        self.lis = self.anchors = self.panels = null;
      });
    // update selected after add/remove
    } else {
      o.selected = this.lis.index( this.lis.filter( ".ui-tabs-selected" ) );
    }

    // update collapsible
    // TODO: use .toggleClass()
    this.element[ o.collapsible ? "addClass" : "removeClass" ]( "ui-tabs-collapsible" );

    // set or update cookie after init and add/remove respectively
    if ( o.cookie ) {
      this._cookie( o.selected, o.cookie );
    }

    // disable tabs
    for ( var i = 0, li; ( li = this.lis[ i ] ); i++ ) {
      $( li )[ $.inArray( i, o.disabled ) != -1 &&
        // TODO: use .toggleClass()
        !$( li ).hasClass( "ui-tabs-selected" ) ? "addClass" : "removeClass" ]( "ui-state-disabled" );
    }

    // reset cache if switching from cached to not cached
    if ( o.cache === false ) {
      this.anchors.removeData( "cache.tabs" );
    }

    // remove all handlers before, tabify may run on existing tabs after add or option change
    this.lis.add( this.anchors ).unbind( ".tabs" );

    if ( o.event !== "mouseover" ) {
      var addState = function( state, el ) {
        if ( el.is( ":not(.ui-state-disabled)" ) ) {
          el.addClass( "ui-state-" + state );
        }
      };
      var removeState = function( state, el ) {
        el.removeClass( "ui-state-" + state );
      };
      this.lis.bind( "mouseover.tabs" , function() {
        addState( "hover", $( this ) );
      });
      this.lis.bind( "mouseout.tabs", function() {
        removeState( "hover", $( this ) );
      });
      this.anchors.bind( "focus.tabs", function() {
        addState( "focus", $( this ).closest( "li" ) );
      });
      this.anchors.bind( "blur.tabs", function() {
        removeState( "focus", $( this ).closest( "li" ) );
      });
    }

    // set up animations
    var hideFx, showFx;
    if ( o.fx ) {
      if ( $.isArray( o.fx ) ) {
        hideFx = o.fx[ 0 ];
        showFx = o.fx[ 1 ];
      } else {
        hideFx = showFx = o.fx;
      }
    }

    // Reset certain styles left over from animation
    // and prevent IE's ClearType bug...
    function resetStyle( $el, fx ) {
      $el.css( "display", "" );
      if ( !$.support.opacity && fx.opacity ) {
        $el[ 0 ].style.removeAttribute( "filter" );
      }
    }

    // Show a tab...
    var showTab = showFx
      ? function( clicked, $show ) {
        $( clicked ).closest( "li" ).addClass( "ui-tabs-selected ui-state-active" );
        $show.hide().removeClass( "ui-tabs-hide" ) // avoid flicker that way
          .animate( showFx, showFx.duration || "normal", function() {
            resetStyle( $show, showFx );
            self._trigger( "show", null, self._ui( clicked, $show[ 0 ] ) );
          });
      }
      : function( clicked, $show ) {
        $( clicked ).closest( "li" ).addClass( "ui-tabs-selected ui-state-active" );
        $show.removeClass( "ui-tabs-hide" );
        self._trigger( "show", null, self._ui( clicked, $show[ 0 ] ) );
      };

    // Hide a tab, $show is optional...
    var hideTab = hideFx
      ? function( clicked, $hide ) {
        $hide.animate( hideFx, hideFx.duration || "normal", function() {
          self.lis.removeClass( "ui-tabs-selected ui-state-active" );
          $hide.addClass( "ui-tabs-hide" );
          resetStyle( $hide, hideFx );
          self.element.dequeue( "tabs" );
        });
      }
      : function( clicked, $hide, $show ) {
        self.lis.removeClass( "ui-tabs-selected ui-state-active" );
        $hide.addClass( "ui-tabs-hide" );
        self.element.dequeue( "tabs" );
      };

    // attach tab event handler, unbind to avoid duplicates from former tabifying...
    this.anchors.bind( o.event + ".tabs", function() {
      var el = this,
        $li = $(el).closest( "li" ),
        $hide = self.panels.filter( ":not(.ui-tabs-hide)" ),
        $show = self.element.find( self._sanitizeSelector( el.hash ) );

      // If tab is already selected and not collapsible or tab disabled or
      // or is already loading or click callback returns false stop here.
      // Check if click handler returns false last so that it is not executed
      // for a disabled or loading tab!
      if ( ( $li.hasClass( "ui-tabs-selected" ) && !o.collapsible) ||
        $li.hasClass( "ui-state-disabled" ) ||
        $li.hasClass( "ui-state-processing" ) ||
        self.panels.filter( ":animated" ).length ||
        self._trigger( "select", null, self._ui( this, $show[ 0 ] ) ) === false ) {
        this.blur();
        return false;
      }

      o.selected = self.anchors.index( this );

      self.abort();

      // if tab may be closed
      if ( o.collapsible ) {
        if ( $li.hasClass( "ui-tabs-selected" ) ) {
          o.selected = -1;

          if ( o.cookie ) {
            self._cookie( o.selected, o.cookie );
          }

          self.element.queue( "tabs", function() {
            hideTab( el, $hide );
          }).dequeue( "tabs" );

          this.blur();
          return false;
        } else if ( !$hide.length ) {
          if ( o.cookie ) {
            self._cookie( o.selected, o.cookie );
          }

          self.element.queue( "tabs", function() {
            showTab( el, $show );
          });

          // TODO make passing in node possible, see also http://dev.jqueryui.com/ticket/3171
          self.load( self.anchors.index( this ) );

          this.blur();
          return false;
        }
      }

      if ( o.cookie ) {
        self._cookie( o.selected, o.cookie );
      }

      // show new tab
      if ( $show.length ) {
        if ( $hide.length ) {
          self.element.queue( "tabs", function() {
            hideTab( el, $hide );
          });
        }
        self.element.queue( "tabs", function() {
          showTab( el, $show );
        });

        self.load( self.anchors.index( this ) );
      } else {
        throw "jQuery UI Tabs: Mismatching fragment identifier.";
      }

      // Prevent IE from keeping other link focussed when using the back button
      // and remove dotted border from clicked link. This is controlled via CSS
      // in modern browsers; blur() removes focus from address bar in Firefox
      // which can become a usability and annoying problem with tabs('rotate').
      if ( $.browser.msie ) {
        this.blur();
      }
    });

    // disable click in any case
    this.anchors.bind( "click.tabs", function(){
      return false;
    });
  },

    _getIndex: function( index ) {
    // meta-function to give users option to provide a href string instead of a numerical index.
    // also sanitizes numerical indexes to valid values.
    if ( typeof index == "string" ) {
      index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
    }

    return index;
  },

  destroy: function() {
    var o = this.options;

    this.abort();

    this.element
      .unbind( ".tabs" )
      .removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" )
      .removeData( "tabs" );

    this.list.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );

    this.anchors.each(function() {
      var href = $.data( this, "href.tabs" );
      if ( href ) {
        this.href = href;
      }
      var $this = $( this ).unbind( ".tabs" );
      $.each( [ "href", "load", "cache" ], function( i, prefix ) {
        $this.removeData( prefix + ".tabs" );
      });
    });

    this.lis.unbind( ".tabs" ).add( this.panels ).each(function() {
      if ( $.data( this, "destroy.tabs" ) ) {
        $( this ).remove();
      } else {
        $( this ).removeClass([
          "ui-state-default",
          "ui-corner-top",
          "ui-tabs-selected",
          "ui-state-active",
          "ui-state-hover",
          "ui-state-focus",
          "ui-state-disabled",
          "ui-tabs-panel",
          "ui-widget-content",
          "ui-corner-bottom",
          "ui-tabs-hide"
        ].join( " " ) );
      }
    });

    if ( o.cookie ) {
      this._cookie( null, o.cookie );
    }

    return this;
  },

  add: function( url, label, index ) {
    if ( index === undefined ) {
      index = this.anchors.length;
    }

    var self = this,
      o = this.options,
      $li = $( o.tabTemplate.replace( /#\{href\}/g, url ).replace( /#\{label\}/g, label ) ),
      id = !url.indexOf( "#" ) ? url.replace( "#", "" ) : this._tabId( $( "a", $li )[ 0 ] );

    $li.addClass( "ui-state-default ui-corner-top" ).data( "destroy.tabs", true );

    // try to find an existing element before creating a new one
    var $panel = self.element.find( "#" + id );
    if ( !$panel.length ) {
      $panel = $( o.panelTemplate )
        .attr( "id", id )
        .data( "destroy.tabs", true );
    }
    $panel.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide" );

    if ( index >= this.lis.length ) {
      $li.appendTo( this.list );
      $panel.appendTo( this.list[ 0 ].parentNode );
    } else {
      $li.insertBefore( this.lis[ index ] );
      $panel.insertBefore( this.panels[ index ] );
    }

    o.disabled = $.map( o.disabled, function( n, i ) {
      return n >= index ? ++n : n;
    });

    this._tabify();

    if ( this.anchors.length == 1 ) {
      o.selected = 0;
      $li.addClass( "ui-tabs-selected ui-state-active" );
      $panel.removeClass( "ui-tabs-hide" );
      this.element.queue( "tabs", function() {
        self._trigger( "show", null, self._ui( self.anchors[ 0 ], self.panels[ 0 ] ) );
      });

      this.load( 0 );
    }

    this._trigger( "add", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
    return this;
  },

  remove: function( index ) {
    index = this._getIndex( index );
    var o = this.options,
      $li = this.lis.eq( index ).remove(),
      $panel = this.panels.eq( index ).remove();

    // If selected tab was removed focus tab to the right or
    // in case the last tab was removed the tab to the left.
    if ( $li.hasClass( "ui-tabs-selected" ) && this.anchors.length > 1) {
      this.select( index + ( index + 1 < this.anchors.length ? 1 : -1 ) );
    }

    o.disabled = $.map(
      $.grep( o.disabled, function(n, i) {
        return n != index;
      }),
      function( n, i ) {
        return n >= index ? --n : n;
      });

    this._tabify();

    this._trigger( "remove", null, this._ui( $li.find( "a" )[ 0 ], $panel[ 0 ] ) );
    return this;
  },

  enable: function( index ) {
    index = this._getIndex( index );
    var o = this.options;
    if ( $.inArray( index, o.disabled ) == -1 ) {
      return;
    }

    this.lis.eq( index ).removeClass( "ui-state-disabled" );
    o.disabled = $.grep( o.disabled, function( n, i ) {
      return n != index;
    });

    this._trigger( "enable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
    return this;
  },

  disable: function( index ) {
    index = this._getIndex( index );
    var self = this, o = this.options;
    // cannot disable already selected tab
    if ( index != o.selected ) {
      this.lis.eq( index ).addClass( "ui-state-disabled" );

      o.disabled.push( index );
      o.disabled.sort();

      this._trigger( "disable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
    }

    return this;
  },

  select: function( index ) {
    index = this._getIndex( index );
    if ( index == -1 ) {
      if ( this.options.collapsible && this.options.selected != -1 ) {
        index = this.options.selected;
      } else {
        return this;
      }
    }
    this.anchors.eq( index ).trigger( this.options.event + ".tabs" );
    return this;
  },

  load: function( index ) {
    index = this._getIndex( index );
    var self = this,
      o = this.options,
      a = this.anchors.eq( index )[ 0 ],
      url = $.data( a, "load.tabs" );

    this.abort();

    // not remote or from cache
    if ( !url || this.element.queue( "tabs" ).length !== 0 && $.data( a, "cache.tabs" ) ) {
      this.element.dequeue( "tabs" );
      return;
    }

    // load remote from here on
    this.lis.eq( index ).addClass( "ui-state-processing" );

    if ( o.spinner ) {
      var span = $( "span", a );
      span.data( "label.tabs", span.html() ).html( o.spinner );
    }

    this.xhr = $.ajax( $.extend( {}, o.ajaxOptions, {
      url: url,
      success: function( r, s ) {
        self.element.find( self._sanitizeSelector( a.hash ) ).html( r );

        // take care of tab labels
        self._cleanup();

        if ( o.cache ) {
          $.data( a, "cache.tabs", true );
        }

        self._trigger( "load", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
        try {
          o.ajaxOptions.success( r, s );
        }
        catch ( e ) {}
      },
      error: function( xhr, s, e ) {
        // take care of tab labels
        self._cleanup();

        self._trigger( "load", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
        try {
          // Passing index avoid a race condition when this method is
          // called after the user has selected another tab.
          // Pass the anchor that initiated this request allows
          // loadError to manipulate the tab content panel via $(a.hash)
          o.ajaxOptions.error( xhr, s, index, a );
        }
        catch ( e ) {}
      }
    } ) );

    // last, so that load event is fired before show...
    self.element.dequeue( "tabs" );

    return this;
  },

  abort: function() {
    // stop possibly running animations
    this.element.queue( [] );
    this.panels.stop( false, true );

    // "tabs" queue must not contain more than two elements,
    // which are the callbacks for the latest clicked tab...
    this.element.queue( "tabs", this.element.queue( "tabs" ).splice( -2, 2 ) );

    // terminate pending requests from other tabs
    if ( this.xhr ) {
      this.xhr.abort();
      delete this.xhr;
    }

    // take care of tab labels
    this._cleanup();
    return this;
  },

  url: function( index, url ) {
    this.anchors.eq( index ).removeData( "cache.tabs" ).data( "load.tabs", url );
    return this;
  },

  length: function() {
    return this.anchors.length;
  }
});

$.extend( $.ui.tabs, {
  version: "1.8.20"
});

/*
 * Tabs Extensions
 */

/*
 * Rotate
 */
$.extend( $.ui.tabs.prototype, {
  rotation: null,
  rotate: function( ms, continuing ) {
    var self = this,
      o = this.options;

    var rotate = self._rotate || ( self._rotate = function( e ) {
      clearTimeout( self.rotation );
      self.rotation = setTimeout(function() {
        var t = o.selected;
        self.select( ++t < self.anchors.length ? t : 0 );
      }, ms );

      if ( e ) {
        e.stopPropagation();
      }
    });

    var stop = self._unrotate || ( self._unrotate = !continuing
      ? function(e) {
        if (e.clientX) { // in case of a true click
          self.rotate(null);
        }
      }
      : function( e ) {
        rotate();
      });

    // start rotation
    if ( ms ) {
      this.element.bind( "tabsshow", rotate );
      this.anchors.bind( o.event + ".tabs", stop );
      rotate();
    // stop rotation
    } else {
      clearTimeout( self.rotation );
      this.element.unbind( "tabsshow", rotate );
      this.anchors.unbind( o.event + ".tabs", stop );
      delete this._rotate;
      delete this._unrotate;
    }

    return this;
  }
});

})( jQuery );
/*!
 * jQuery UI Datepicker 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *  jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.8.20" } });

var PROP_NAME = 'datepicker';
var dpuuid = new Date().getTime();
var instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
  this.debug = false; // Change this to true to start debugging
  this._curInst = null; // The current instance in use
  this._keyEvent = false; // If the last event was a key event
  this._disabledInputs = []; // List of date picker inputs that have been disabled
  this._datepickerShowing = false; // True if the popup picker is showing , false if not
  this._inDialog = false; // True if showing within a "dialog", false if not
  this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
  this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
  this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
  this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
  this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
  this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
  this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
  this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
  this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
  this.regional = []; // Available regional settings, indexed by language code
  this.regional[''] = { // Default regional settings
    closeText: 'Done', // Display text for close link
    prevText: 'Prev', // Display text for previous month link
    nextText: 'Next', // Display text for next month link
    currentText: 'Today', // Display text for current month link
    monthNames: ['January','February','March','April','May','June',
      'July','August','September','October','November','December'], // Names of months for drop-down and formatting
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
    dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
    weekHeader: 'Wk', // Column header for week of the year
    dateFormat: 'mm/dd/yy', // See format options on parseDate
    firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
    isRTL: false, // True if right-to-left language, false if left-to-right
    showMonthAfterYear: false, // True if the year select precedes month, false for month then year
    yearSuffix: '' // Additional text to append to the year in the month headers
  };
  this._defaults = { // Global defaults for all the date picker instances
    showOn: 'focus', // 'focus' for popup on focus,
      // 'button' for trigger button, or 'both' for either
    showAnim: 'fadeIn', // Name of jQuery animation for popup
    showOptions: {}, // Options for enhanced animations
    defaultDate: null, // Used when field is blank: actual date,
      // +/-number for offset from today, null for today
    appendText: '', // Display text following the input box, e.g. showing the format
    buttonText: '...', // Text for trigger button
    buttonImage: '', // URL for trigger button image
    buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
    hideIfNoPrevNext: false, // True to hide next/previous month links
      // if not applicable, false to just disable them
    navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
    gotoCurrent: false, // True if today link goes back to current selection instead
    changeMonth: false, // True if month can be selected directly, false if only prev/next
    changeYear: false, // True if year can be selected directly, false if only prev/next
    yearRange: 'c-10:c+10', // Range of years to display in drop-down,
      // either relative to today's year (-nn:+nn), relative to currently displayed year
      // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
    showOtherMonths: false, // True to show dates in other months, false to leave blank
    selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
    showWeek: false, // True to show week of the year, false to not show it
    calculateWeek: this.iso8601Week, // How to calculate the week of the year,
      // takes a Date and returns the number of the week for it
    shortYearCutoff: '+10', // Short year values < this are in the current century,
      // > this are in the previous century,
      // string value starting with '+' for current year + value
    minDate: null, // The earliest selectable date, or null for no limit
    maxDate: null, // The latest selectable date, or null for no limit
    duration: 'fast', // Duration of display/closure
    beforeShowDay: null, // Function that takes a date and returns an array with
      // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
      // [2] = cell title (optional), e.g. $.datepicker.noWeekends
    beforeShow: null, // Function that takes an input field and
      // returns a set of custom settings for the date picker
    onSelect: null, // Define a callback function when a date is selected
    onChangeMonthYear: null, // Define a callback function when the month or year is changed
    onClose: null, // Define a callback function when the datepicker is closed
    numberOfMonths: 1, // Number of months to show at a time
    showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
    stepMonths: 1, // Number of months to step back/forward
    stepBigMonths: 12, // Number of months to step back/forward for the big links
    altField: '', // Selector for an alternate field to store selected dates into
    altFormat: '', // The date format to use for the alternate field
    constrainInput: true, // The input is constrained by the current date format
    showButtonPanel: false, // True to show button panel, false to not show it
    autoSize: false, // True to size the input for the date format, false to leave as is
    disabled: false // The initial disabled state
  };
  $.extend(this._defaults, this.regional['']);
  this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'));
}

$.extend(Datepicker.prototype, {
  /* Class name added to elements to indicate already configured with a date picker. */
  markerClassName: 'hasDatepicker',

  //Keep track of the maximum number of rows displayed (see #7043)
  maxRows: 4,

  /* Debug logging (if enabled). */
  log: function () {
    if (this.debug)
      console.log.apply('', arguments);
  },

  // TODO rename to "widget" when switching to widget factory
  _widgetDatepicker: function() {
    return this.dpDiv;
  },

  /* Override the default settings for all instances of the date picker.
     @param  settings  object - the new settings to use as defaults (anonymous object)
     @return the manager object */
  setDefaults: function(settings) {
    extendRemove(this._defaults, settings || {});
    return this;
  },

  /* Attach the date picker to a jQuery selection.
     @param  target    element - the target input field or division or span
     @param  settings  object - the new settings to use for this date picker instance (anonymous) */
  _attachDatepicker: function(target, settings) {
    // check for settings on the control itself - in namespace 'date:'
    var inlineSettings = null;
    for (var attrName in this._defaults) {
      var attrValue = target.getAttribute('date:' + attrName);
      if (attrValue) {
        inlineSettings = inlineSettings || {};
        try {
          inlineSettings[attrName] = eval(attrValue);
        } catch (err) {
          inlineSettings[attrName] = attrValue;
        }
      }
    }
    var nodeName = target.nodeName.toLowerCase();
    var inline = (nodeName == 'div' || nodeName == 'span');
    if (!target.id) {
      this.uuid += 1;
      target.id = 'dp' + this.uuid;
    }
    var inst = this._newInst($(target), inline);
    inst.settings = $.extend({}, settings || {}, inlineSettings || {});
    if (nodeName == 'input') {
      this._connectDatepicker(target, inst);
    } else if (inline) {
      this._inlineDatepicker(target, inst);
    }
  },

  /* Create a new instance object. */
  _newInst: function(target, inline) {
    var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
    return {id: id, input: target, // associated target
      selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
      drawMonth: 0, drawYear: 0, // month being drawn
      inline: inline, // is datepicker inline or not
      dpDiv: (!inline ? this.dpDiv : // presentation div
      bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')))};
  },

  /* Attach the date picker to an input field. */
  _connectDatepicker: function(target, inst) {
    var input = $(target);
    inst.append = $([]);
    inst.trigger = $([]);
    if (input.hasClass(this.markerClassName))
      return;
    this._attachments(input, inst);
    input.addClass(this.markerClassName).keydown(this._doKeyDown).
      keypress(this._doKeyPress).keyup(this._doKeyUp).
      bind("setData.datepicker", function(event, key, value) {
        inst.settings[key] = value;
      }).bind("getData.datepicker", function(event, key) {
        return this._get(inst, key);
      });
    this._autoSize(inst);
    $.data(target, PROP_NAME, inst);
    //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
    if( inst.settings.disabled ) {
      this._disableDatepicker( target );
    }
  },

  /* Make attachments based on settings. */
  _attachments: function(input, inst) {
    var appendText = this._get(inst, 'appendText');
    var isRTL = this._get(inst, 'isRTL');
    if (inst.append)
      inst.append.remove();
    if (appendText) {
      inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
      input[isRTL ? 'before' : 'after'](inst.append);
    }
    input.unbind('focus', this._showDatepicker);
    if (inst.trigger)
      inst.trigger.remove();
    var showOn = this._get(inst, 'showOn');
    if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field
      input.focus(this._showDatepicker);
    if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked
      var buttonText = this._get(inst, 'buttonText');
      var buttonImage = this._get(inst, 'buttonImage');
      inst.trigger = $(this._get(inst, 'buttonImageOnly') ?
        $('<img/>').addClass(this._triggerClass).
          attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
        $('<button type="button"></button>').addClass(this._triggerClass).
          html(buttonImage == '' ? buttonText : $('<img/>').attr(
          { src:buttonImage, alt:buttonText, title:buttonText })));
      input[isRTL ? 'before' : 'after'](inst.trigger);
      inst.trigger.click(function() {
        if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])
          $.datepicker._hideDatepicker();
        else if ($.datepicker._datepickerShowing && $.datepicker._lastInput != input[0]) {
          $.datepicker._hideDatepicker();
          $.datepicker._showDatepicker(input[0]);
        } else
          $.datepicker._showDatepicker(input[0]);
        return false;
      });
    }
  },

  /* Apply the maximum length for the date format. */
  _autoSize: function(inst) {
    if (this._get(inst, 'autoSize') && !inst.inline) {
      var date = new Date(2009, 12 - 1, 20); // Ensure double digits
      var dateFormat = this._get(inst, 'dateFormat');
      if (dateFormat.match(/[DM]/)) {
        var findMax = function(names) {
          var max = 0;
          var maxI = 0;
          for (var i = 0; i < names.length; i++) {
            if (names[i].length > max) {
              max = names[i].length;
              maxI = i;
            }
          }
          return maxI;
        };
        date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
          'monthNames' : 'monthNamesShort'))));
        date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
          'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
      }
      inst.input.attr('size', this._formatDate(inst, date).length);
    }
  },

  /* Attach an inline date picker to a div. */
  _inlineDatepicker: function(target, inst) {
    var divSpan = $(target);
    if (divSpan.hasClass(this.markerClassName))
      return;
    divSpan.addClass(this.markerClassName).append(inst.dpDiv).
      bind("setData.datepicker", function(event, key, value){
        inst.settings[key] = value;
      }).bind("getData.datepicker", function(event, key){
        return this._get(inst, key);
      });
    $.data(target, PROP_NAME, inst);
    this._setDate(inst, this._getDefaultDate(inst), true);
    this._updateDatepicker(inst);
    this._updateAlternate(inst);
    //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
    if( inst.settings.disabled ) {
      this._disableDatepicker( target );
    }
    // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
    // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
    inst.dpDiv.css( "display", "block" );
  },

  /* Pop-up the date picker in a "dialog" box.
     @param  input     element - ignored
     @param  date      string or Date - the initial date to display
     @param  onSelect  function - the function to call when a date is selected
     @param  settings  object - update the dialog date picker instance's settings (anonymous object)
     @param  pos       int[2] - coordinates for the dialog's position within the screen or
                       event - with x/y coordinates or
                       leave empty for default (screen centre)
     @return the manager object */
  _dialogDatepicker: function(input, date, onSelect, settings, pos) {
    var inst = this._dialogInst; // internal instance
    if (!inst) {
      this.uuid += 1;
      var id = 'dp' + this.uuid;
      this._dialogInput = $('<input type="text" id="' + id +
        '" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');
      this._dialogInput.keydown(this._doKeyDown);
      $('body').append(this._dialogInput);
      inst = this._dialogInst = this._newInst(this._dialogInput, false);
      inst.settings = {};
      $.data(this._dialogInput[0], PROP_NAME, inst);
    }
    extendRemove(inst.settings, settings || {});
    date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
    this._dialogInput.val(date);

    this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
    if (!this._pos) {
      var browserWidth = document.documentElement.clientWidth;
      var browserHeight = document.documentElement.clientHeight;
      var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
      var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
      this._pos = // should use actual width/height below
        [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
    }

    // move input on screen for focus, but hidden behind dialog
    this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
    inst.settings.onSelect = onSelect;
    this._inDialog = true;
    this.dpDiv.addClass(this._dialogClass);
    this._showDatepicker(this._dialogInput[0]);
    if ($.blockUI)
      $.blockUI(this.dpDiv);
    $.data(this._dialogInput[0], PROP_NAME, inst);
    return this;
  },

  /* Detach a datepicker from its control.
     @param  target    element - the target input field or division or span */
  _destroyDatepicker: function(target) {
    var $target = $(target);
    var inst = $.data(target, PROP_NAME);
    if (!$target.hasClass(this.markerClassName)) {
      return;
    }
    var nodeName = target.nodeName.toLowerCase();
    $.removeData(target, PROP_NAME);
    if (nodeName == 'input') {
      inst.append.remove();
      inst.trigger.remove();
      $target.removeClass(this.markerClassName).
        unbind('focus', this._showDatepicker).
        unbind('keydown', this._doKeyDown).
        unbind('keypress', this._doKeyPress).
        unbind('keyup', this._doKeyUp);
    } else if (nodeName == 'div' || nodeName == 'span')
      $target.removeClass(this.markerClassName).empty();
  },

  /* Enable the date picker to a jQuery selection.
     @param  target    element - the target input field or division or span */
  _enableDatepicker: function(target) {
    var $target = $(target);
    var inst = $.data(target, PROP_NAME);
    if (!$target.hasClass(this.markerClassName)) {
      return;
    }
    var nodeName = target.nodeName.toLowerCase();
    if (nodeName == 'input') {
      target.disabled = false;
      inst.trigger.filter('button').
        each(function() { this.disabled = false; }).end().
        filter('img').css({opacity: '1.0', cursor: ''});
    }
    else if (nodeName == 'div' || nodeName == 'span') {
      var inline = $target.children('.' + this._inlineClass);
      inline.children().removeClass('ui-state-disabled');
      inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
        removeAttr("disabled");
    }
    this._disabledInputs = $.map(this._disabledInputs,
      function(value) { return (value == target ? null : value); }); // delete entry
  },

  /* Disable the date picker to a jQuery selection.
     @param  target    element - the target input field or division or span */
  _disableDatepicker: function(target) {
    var $target = $(target);
    var inst = $.data(target, PROP_NAME);
    if (!$target.hasClass(this.markerClassName)) {
      return;
    }
    var nodeName = target.nodeName.toLowerCase();
    if (nodeName == 'input') {
      target.disabled = true;
      inst.trigger.filter('button').
        each(function() { this.disabled = true; }).end().
        filter('img').css({opacity: '0.5', cursor: 'default'});
    }
    else if (nodeName == 'div' || nodeName == 'span') {
      var inline = $target.children('.' + this._inlineClass);
      inline.children().addClass('ui-state-disabled');
      inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
        attr("disabled", "disabled");
    }
    this._disabledInputs = $.map(this._disabledInputs,
      function(value) { return (value == target ? null : value); }); // delete entry
    this._disabledInputs[this._disabledInputs.length] = target;
  },

  /* Is the first field in a jQuery collection disabled as a datepicker?
     @param  target    element - the target input field or division or span
     @return boolean - true if disabled, false if enabled */
  _isDisabledDatepicker: function(target) {
    if (!target) {
      return false;
    }
    for (var i = 0; i < this._disabledInputs.length; i++) {
      if (this._disabledInputs[i] == target)
        return true;
    }
    return false;
  },

  /* Retrieve the instance data for the target control.
     @param  target  element - the target input field or division or span
     @return  object - the associated instance data
     @throws  error if a jQuery problem getting data */
  _getInst: function(target) {
    try {
      return $.data(target, PROP_NAME);
    }
    catch (err) {
      throw 'Missing instance data for this datepicker';
    }
  },

  /* Update or retrieve the settings for a date picker attached to an input field or division.
     @param  target  element - the target input field or division or span
     @param  name    object - the new settings to update or
                     string - the name of the setting to change or retrieve,
                     when retrieving also 'all' for all instance settings or
                     'defaults' for all global defaults
     @param  value   any - the new value for the setting
                     (omit if above is an object or to retrieve a value) */
  _optionDatepicker: function(target, name, value) {
    var inst = this._getInst(target);
    if (arguments.length == 2 && typeof name == 'string') {
      return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :
        (inst ? (name == 'all' ? $.extend({}, inst.settings) :
        this._get(inst, name)) : null));
    }
    var settings = name || {};
    if (typeof name == 'string') {
      settings = {};
      settings[name] = value;
    }
    if (inst) {
      if (this._curInst == inst) {
        this._hideDatepicker();
      }
      var date = this._getDateDatepicker(target, true);
      var minDate = this._getMinMaxDate(inst, 'min');
      var maxDate = this._getMinMaxDate(inst, 'max');
      extendRemove(inst.settings, settings);
      // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
      if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)
        inst.settings.minDate = this._formatDate(inst, minDate);
      if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)
        inst.settings.maxDate = this._formatDate(inst, maxDate);
      this._attachments($(target), inst);
      this._autoSize(inst);
      this._setDate(inst, date);
      this._updateAlternate(inst);
      this._updateDatepicker(inst);
    }
  },

  // change method deprecated
  _changeDatepicker: function(target, name, value) {
    this._optionDatepicker(target, name, value);
  },

  /* Redraw the date picker attached to an input field or division.
     @param  target  element - the target input field or division or span */
  _refreshDatepicker: function(target) {
    var inst = this._getInst(target);
    if (inst) {
      this._updateDatepicker(inst);
    }
  },

  /* Set the dates for a jQuery selection.
     @param  target   element - the target input field or division or span
     @param  date     Date - the new date */
  _setDateDatepicker: function(target, date) {
    var inst = this._getInst(target);
    if (inst) {
      this._setDate(inst, date);
      this._updateDatepicker(inst);
      this._updateAlternate(inst);
    }
  },

  /* Get the date(s) for the first entry in a jQuery selection.
     @param  target     element - the target input field or division or span
     @param  noDefault  boolean - true if no default date is to be used
     @return Date - the current date */
  _getDateDatepicker: function(target, noDefault) {
    var inst = this._getInst(target);
    if (inst && !inst.inline)
      this._setDateFromField(inst, noDefault);
    return (inst ? this._getDate(inst) : null);
  },

  /* Handle keystrokes. */
  _doKeyDown: function(event) {
    var inst = $.datepicker._getInst(event.target);
    var handled = true;
    var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
    inst._keyEvent = true;
    if ($.datepicker._datepickerShowing)
      switch (event.keyCode) {
        case 9: $.datepicker._hideDatepicker();
            handled = false;
            break; // hide on tab out
        case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' +
                  $.datepicker._currentClass + ')', inst.dpDiv);
            if (sel[0])
              $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
              var onSelect = $.datepicker._get(inst, 'onSelect');
              if (onSelect) {
                var dateStr = $.datepicker._formatDate(inst);

                // trigger custom callback
                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
              }
            else
              $.datepicker._hideDatepicker();
            return false; // don't submit the form
            break; // select the value on enter
        case 27: $.datepicker._hideDatepicker();
            break; // hide on escape
        case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
              -$.datepicker._get(inst, 'stepBigMonths') :
              -$.datepicker._get(inst, 'stepMonths')), 'M');
            break; // previous month/year on page up/+ ctrl
        case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
              +$.datepicker._get(inst, 'stepBigMonths') :
              +$.datepicker._get(inst, 'stepMonths')), 'M');
            break; // next month/year on page down/+ ctrl
        case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
            handled = event.ctrlKey || event.metaKey;
            break; // clear on ctrl or command +end
        case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
            handled = event.ctrlKey || event.metaKey;
            break; // current on ctrl or command +home
        case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
            handled = event.ctrlKey || event.metaKey;
            // -1 day on ctrl or command +left
            if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                  -$.datepicker._get(inst, 'stepBigMonths') :
                  -$.datepicker._get(inst, 'stepMonths')), 'M');
            // next month/year on alt +left on Mac
            break;
        case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D');
            handled = event.ctrlKey || event.metaKey;
            break; // -1 week on ctrl or command +up
        case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
            handled = event.ctrlKey || event.metaKey;
            // +1 day on ctrl or command +right
            if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                  +$.datepicker._get(inst, 'stepBigMonths') :
                  +$.datepicker._get(inst, 'stepMonths')), 'M');
            // next month/year on alt +right
            break;
        case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D');
            handled = event.ctrlKey || event.metaKey;
            break; // +1 week on ctrl or command +down
        default: handled = false;
      }
    else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
      $.datepicker._showDatepicker(this);
    else {
      handled = false;
    }
    if (handled) {
      event.preventDefault();
      event.stopPropagation();
    }
  },

  /* Filter entered characters - based on date format. */
  _doKeyPress: function(event) {
    var inst = $.datepicker._getInst(event.target);
    if ($.datepicker._get(inst, 'constrainInput')) {
      var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
      var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
      return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
    }
  },

  /* Synchronise manual entry and field/alternate field. */
  _doKeyUp: function(event) {
    var inst = $.datepicker._getInst(event.target);
    if (inst.input.val() != inst.lastVal) {
      try {
        var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
          (inst.input ? inst.input.val() : null),
          $.datepicker._getFormatConfig(inst));
        if (date) { // only if valid
          $.datepicker._setDateFromField(inst);
          $.datepicker._updateAlternate(inst);
          $.datepicker._updateDatepicker(inst);
        }
      }
      catch (err) {
        $.datepicker.log(err);
      }
    }
    return true;
  },

  /* Pop-up the date picker for a given input field.
       If false returned from beforeShow event handler do not show.
     @param  input  element - the input field attached to the date picker or
                    event - if triggered by focus */
  _showDatepicker: function(input) {
    input = input.target || input;
    if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
      input = $('input', input.parentNode)[0];
    if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
      return;
    var inst = $.datepicker._getInst(input);
    if ($.datepicker._curInst && $.datepicker._curInst != inst) {
      $.datepicker._curInst.dpDiv.stop(true, true);
      if ( inst && $.datepicker._datepickerShowing ) {
        $.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
      }
    }
    var beforeShow = $.datepicker._get(inst, 'beforeShow');
    var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
    if(beforeShowSettings === false){
            //false
      return;
    }
    extendRemove(inst.settings, beforeShowSettings);
    inst.lastVal = null;
    $.datepicker._lastInput = input;
    $.datepicker._setDateFromField(inst);
    if ($.datepicker._inDialog) // hide cursor
      input.value = '';
    if (!$.datepicker._pos) { // position below input
      $.datepicker._pos = $.datepicker._findPos(input);
      $.datepicker._pos[1] += input.offsetHeight; // add the height
    }
    var isFixed = false;
    $(input).parents().each(function() {
      isFixed |= $(this).css('position') == 'fixed';
      return !isFixed;
    });
    if (isFixed && $.browser.opera) { // correction for Opera when fixed and scrolled
      $.datepicker._pos[0] -= document.documentElement.scrollLeft;
      $.datepicker._pos[1] -= document.documentElement.scrollTop;
    }
    var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
    $.datepicker._pos = null;
    //to avoid flashes on Firefox
    inst.dpDiv.empty();
    // determine sizing offscreen
    inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});
    $.datepicker._updateDatepicker(inst);
    // fix width for dynamic number of date pickers
    // and adjust position before showing
    offset = $.datepicker._checkOffset(inst, offset, isFixed);
    inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
      'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
      left: offset.left + 'px', top: offset.top + 'px'});
    if (!inst.inline) {
      var showAnim = $.datepicker._get(inst, 'showAnim');
      var duration = $.datepicker._get(inst, 'duration');
      var postProcess = function() {
        var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
        if( !! cover.length ){
          var borders = $.datepicker._getBorders(inst.dpDiv);
          cover.css({left: -borders[0], top: -borders[1],
            width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
        }
      };
      inst.dpDiv.zIndex($(input).zIndex()+1);
      $.datepicker._datepickerShowing = true;
      if ($.effects && $.effects[showAnim])
        inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
      else
        inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
      if (!showAnim || !duration)
        postProcess();
      if (inst.input.is(':visible') && !inst.input.is(':disabled'))
        inst.input.focus();
      $.datepicker._curInst = inst;
    }
  },

  /* Generate the date picker content. */
  _updateDatepicker: function(inst) {
    var self = this;
    self.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
    var borders = $.datepicker._getBorders(inst.dpDiv);
    instActive = inst; // for delegate hover events
    inst.dpDiv.empty().append(this._generateHTML(inst));
    var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
    if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
      cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
    }
    inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();
    var numMonths = this._getNumberOfMonths(inst);
    var cols = numMonths[1];
    var width = 17;
    inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
    if (cols > 1)
      inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
    inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
      'Class']('ui-datepicker-multi');
    inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
      'Class']('ui-datepicker-rtl');
    if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
        // #6694 - don't focus the input if it's already focused
        // this breaks the change event in IE
        inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)
      inst.input.focus();
    // deffered render of the years select (to avoid flashes on Firefox)
    if( inst.yearshtml ){
      var origyearshtml = inst.yearshtml;
      setTimeout(function(){
        //assure that inst.yearshtml didn't change.
        if( origyearshtml === inst.yearshtml && inst.yearshtml ){
          inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
        }
        origyearshtml = inst.yearshtml = null;
      }, 0);
    }
  },

  /* Retrieve the size of left and top borders for an element.
     @param  elem  (jQuery object) the element of interest
     @return  (number[2]) the left and top borders */
  _getBorders: function(elem) {
    var convert = function(value) {
      return {thin: 1, medium: 2, thick: 3}[value] || value;
    };
    return [parseFloat(convert(elem.css('border-left-width'))),
      parseFloat(convert(elem.css('border-top-width')))];
  },

  /* Check positioning to remain on screen. */
  _checkOffset: function(inst, offset, isFixed) {
    var dpWidth = inst.dpDiv.outerWidth();
    var dpHeight = inst.dpDiv.outerHeight();
    var inputWidth = inst.input ? inst.input.outerWidth() : 0;
    var inputHeight = inst.input ? inst.input.outerHeight() : 0;
    var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();
    var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();

    offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
    offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
    offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

    // now check if datepicker is showing outside window viewport - move to a better place if so.
    offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
      Math.abs(offset.left + dpWidth - viewWidth) : 0);
    offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
      Math.abs(dpHeight + inputHeight) : 0);

    return offset;
  },

  /* Find an object's position on the screen. */
  _findPos: function(obj) {
    var inst = this._getInst(obj);
    var isRTL = this._get(inst, 'isRTL');
        while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
            obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
        }
        var position = $(obj).offset();
      return [position.left, position.top];
  },

  /* Hide the date picker from view.
     @param  input  element - the input field attached to the date picker */
  _hideDatepicker: function(input) {
    var inst = this._curInst;
    if (!inst || (input && inst != $.data(input, PROP_NAME)))
      return;
    if (this._datepickerShowing) {
      var showAnim = this._get(inst, 'showAnim');
      var duration = this._get(inst, 'duration');
      var postProcess = function() {
        $.datepicker._tidyDialog(inst);
      };
      if ($.effects && $.effects[showAnim])
        inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
      else
        inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
          (showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
      if (!showAnim)
        postProcess();
      this._datepickerShowing = false;
      var onClose = this._get(inst, 'onClose');
      if (onClose)
        onClose.apply((inst.input ? inst.input[0] : null),
          [(inst.input ? inst.input.val() : ''), inst]);
      this._lastInput = null;
      if (this._inDialog) {
        this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
        if ($.blockUI) {
          $.unblockUI();
          $('body').append(this.dpDiv);
        }
      }
      this._inDialog = false;
    }
  },

  /* Tidy up after a dialog display. */
  _tidyDialog: function(inst) {
    inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
  },

  /* Close date picker if clicked elsewhere. */
  _checkExternalClick: function(event) {
    if (!$.datepicker._curInst)
      return;

    var $target = $(event.target),
      inst = $.datepicker._getInst($target[0]);

    if ( ( ( $target[0].id != $.datepicker._mainDivId &&
        $target.parents('#' + $.datepicker._mainDivId).length == 0 &&
        !$target.hasClass($.datepicker.markerClassName) &&
        !$target.closest("." + $.datepicker._triggerClass).length &&
        $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
      ( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != inst ) )
      $.datepicker._hideDatepicker();
  },

  /* Adjust one of the date sub-fields. */
  _adjustDate: function(id, offset, period) {
    var target = $(id);
    var inst = this._getInst(target[0]);
    if (this._isDisabledDatepicker(target[0])) {
      return;
    }
    this._adjustInstDate(inst, offset +
      (period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
      period);
    this._updateDatepicker(inst);
  },

  /* Action for current link. */
  _gotoToday: function(id) {
    var target = $(id);
    var inst = this._getInst(target[0]);
    if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
      inst.selectedDay = inst.currentDay;
      inst.drawMonth = inst.selectedMonth = inst.currentMonth;
      inst.drawYear = inst.selectedYear = inst.currentYear;
    }
    else {
      var date = new Date();
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
    }
    this._notifyChange(inst);
    this._adjustDate(target);
  },

  /* Action for selecting a new month/year. */
  _selectMonthYear: function(id, select, period) {
    var target = $(id);
    var inst = this._getInst(target[0]);
    inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
    inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
      parseInt(select.options[select.selectedIndex].value,10);
    this._notifyChange(inst);
    this._adjustDate(target);
  },

  /* Action for selecting a day. */
  _selectDay: function(id, month, year, td) {
    var target = $(id);
    if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
      return;
    }
    var inst = this._getInst(target[0]);
    inst.selectedDay = inst.currentDay = $('a', td).html();
    inst.selectedMonth = inst.currentMonth = month;
    inst.selectedYear = inst.currentYear = year;
    this._selectDate(id, this._formatDate(inst,
      inst.currentDay, inst.currentMonth, inst.currentYear));
  },

  /* Erase the input field and hide the date picker. */
  _clearDate: function(id) {
    var target = $(id);
    var inst = this._getInst(target[0]);
    this._selectDate(target, '');
  },

  /* Update the input field with the selected date. */
  _selectDate: function(id, dateStr) {
    var target = $(id);
    var inst = this._getInst(target[0]);
    dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
    if (inst.input)
      inst.input.val(dateStr);
    this._updateAlternate(inst);
    var onSelect = this._get(inst, 'onSelect');
    if (onSelect)
      onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
    else if (inst.input)
      inst.input.trigger('change'); // fire the change event
    if (inst.inline)
      this._updateDatepicker(inst);
    else {
      this._hideDatepicker();
      this._lastInput = inst.input[0];
      if (typeof(inst.input[0]) != 'object')
        inst.input.focus(); // restore focus
      this._lastInput = null;
    }
  },

  /* Update any alternate field to synchronise with the main field. */
  _updateAlternate: function(inst) {
    var altField = this._get(inst, 'altField');
    if (altField) { // update alternate field too
      var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
      var date = this._getDate(inst);
      var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
      $(altField).each(function() { $(this).val(dateStr); });
    }
  },

  /* Set as beforeShowDay function to prevent selection of weekends.
     @param  date  Date - the date to customise
     @return [boolean, string] - is this date selectable?, what is its CSS class? */
  noWeekends: function(date) {
    var day = date.getDay();
    return [(day > 0 && day < 6), ''];
  },

  /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
     @param  date  Date - the date to get the week for
     @return  number - the number of the week within the year that contains this date */
  iso8601Week: function(date) {
    var checkDate = new Date(date.getTime());
    // Find Thursday of this week starting on Monday
    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
    var time = checkDate.getTime();
    checkDate.setMonth(0); // Compare with Jan 1
    checkDate.setDate(1);
    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
  },

  /* Parse a string value into a date object.
     See formatDate below for the possible formats.

     @param  format    string - the expected format of the date
     @param  value     string - the date in the above format
     @param  settings  Object - attributes include:
                       shortYearCutoff  number - the cutoff year for determining the century (optional)
                       dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
                       dayNames         string[7] - names of the days from Sunday (optional)
                       monthNamesShort  string[12] - abbreviated names of the months (optional)
                       monthNames       string[12] - names of the months (optional)
     @return  Date - the extracted date value or null if value is blank */
  parseDate: function (format, value, settings) {
    if (format == null || value == null)
      throw 'Invalid arguments';
    value = (typeof value == 'object' ? value.toString() : value + '');
    if (value == '')
      return null;
    var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
    shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
        new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
    var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
    var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
    var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
    var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
    var year = -1;
    var month = -1;
    var day = -1;
    var doy = -1;
    var literal = false;
    // Check whether a format character is doubled
    var lookAhead = function(match) {
      var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
      if (matches)
        iFormat++;
      return matches;
    };
    // Extract a number from the string value
    var getNumber = function(match) {
      var isDoubled = lookAhead(match);
      var size = (match == '@' ? 14 : (match == '!' ? 20 :
        (match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));
      var digits = new RegExp('^\\d{1,' + size + '}');
      var num = value.substring(iValue).match(digits);
      if (!num)
        throw 'Missing number at position ' + iValue;
      iValue += num[0].length;
      return parseInt(num[0], 10);
    };
    // Extract a name from the string value and convert to an index
    var getName = function(match, shortNames, longNames) {
      var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
        return [ [k, v] ];
      }).sort(function (a, b) {
        return -(a[1].length - b[1].length);
      });
      var index = -1;
      $.each(names, function (i, pair) {
        var name = pair[1];
        if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
          index = pair[0];
          iValue += name.length;
          return false;
        }
      });
      if (index != -1)
        return index + 1;
      else
        throw 'Unknown name at position ' + iValue;
    };
    // Confirm that a literal character matches the string value
    var checkLiteral = function() {
      if (value.charAt(iValue) != format.charAt(iFormat))
        throw 'Unexpected literal at position ' + iValue;
      iValue++;
    };
    var iValue = 0;
    for (var iFormat = 0; iFormat < format.length; iFormat++) {
      if (literal)
        if (format.charAt(iFormat) == "'" && !lookAhead("'"))
          literal = false;
        else
          checkLiteral();
      else
        switch (format.charAt(iFormat)) {
          case 'd':
            day = getNumber('d');
            break;
          case 'D':
            getName('D', dayNamesShort, dayNames);
            break;
          case 'o':
            doy = getNumber('o');
            break;
          case 'm':
            month = getNumber('m');
            break;
          case 'M':
            month = getName('M', monthNamesShort, monthNames);
            break;
          case 'y':
            year = getNumber('y');
            break;
          case '@':
            var date = new Date(getNumber('@'));
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case '!':
            var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case "'":
            if (lookAhead("'"))
              checkLiteral();
            else
              literal = true;
            break;
          default:
            checkLiteral();
        }
    }
    if (iValue < value.length){
      throw "Extra/unparsed characters found in date: " + value.substring(iValue);
    }
    if (year == -1)
      year = new Date().getFullYear();
    else if (year < 100)
      year += new Date().getFullYear() - new Date().getFullYear() % 100 +
        (year <= shortYearCutoff ? 0 : -100);
    if (doy > -1) {
      month = 1;
      day = doy;
      do {
        var dim = this._getDaysInMonth(year, month - 1);
        if (day <= dim)
          break;
        month++;
        day -= dim;
      } while (true);
    }
    var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
    if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
      throw 'Invalid date'; // E.g. 31/02/00
    return date;
  },

  /* Standard date formats. */
  ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
  COOKIE: 'D, dd M yy',
  ISO_8601: 'yy-mm-dd',
  RFC_822: 'D, d M y',
  RFC_850: 'DD, dd-M-y',
  RFC_1036: 'D, d M y',
  RFC_1123: 'D, d M yy',
  RFC_2822: 'D, d M yy',
  RSS: 'D, d M y', // RFC 822
  TICKS: '!',
  TIMESTAMP: '@',
  W3C: 'yy-mm-dd', // ISO 8601

  _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
    Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

  /* Format a date object into a string value.
     The format can be combinations of the following:
     d  - day of month (no leading zero)
     dd - day of month (two digit)
     o  - day of year (no leading zeros)
     oo - day of year (three digit)
     D  - day name short
     DD - day name long
     m  - month of year (no leading zero)
     mm - month of year (two digit)
     M  - month name short
     MM - month name long
     y  - year (two digit)
     yy - year (four digit)
     @ - Unix timestamp (ms since 01/01/1970)
     ! - Windows ticks (100ns since 01/01/0001)
     '...' - literal text
     '' - single quote

     @param  format    string - the desired format of the date
     @param  date      Date - the date value to format
     @param  settings  Object - attributes include:
                       dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
                       dayNames         string[7] - names of the days from Sunday (optional)
                       monthNamesShort  string[12] - abbreviated names of the months (optional)
                       monthNames       string[12] - names of the months (optional)
     @return  string - the date in the above format */
  formatDate: function (format, date, settings) {
    if (!date)
      return '';
    var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
    var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
    var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
    var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
    // Check whether a format character is doubled
    var lookAhead = function(match) {
      var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
      if (matches)
        iFormat++;
      return matches;
    };
    // Format a number, with leading zero if necessary
    var formatNumber = function(match, value, len) {
      var num = '' + value;
      if (lookAhead(match))
        while (num.length < len)
          num = '0' + num;
      return num;
    };
    // Format a name, short or long as requested
    var formatName = function(match, value, shortNames, longNames) {
      return (lookAhead(match) ? longNames[value] : shortNames[value]);
    };
    var output = '';
    var literal = false;
    if (date)
      for (var iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal)
          if (format.charAt(iFormat) == "'" && !lookAhead("'"))
            literal = false;
          else
            output += format.charAt(iFormat);
        else
          switch (format.charAt(iFormat)) {
            case 'd':
              output += formatNumber('d', date.getDate(), 2);
              break;
            case 'D':
              output += formatName('D', date.getDay(), dayNamesShort, dayNames);
              break;
            case 'o':
              output += formatNumber('o',
                Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
              break;
            case 'm':
              output += formatNumber('m', date.getMonth() + 1, 2);
              break;
            case 'M':
              output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
              break;
            case 'y':
              output += (lookAhead('y') ? date.getFullYear() :
                (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
              break;
            case '@':
              output += date.getTime();
              break;
            case '!':
              output += date.getTime() * 10000 + this._ticksTo1970;
              break;
            case "'":
              if (lookAhead("'"))
                output += "'";
              else
                literal = true;
              break;
            default:
              output += format.charAt(iFormat);
          }
      }
    return output;
  },

  /* Extract all possible characters from the date format. */
  _possibleChars: function (format) {
    var chars = '';
    var literal = false;
    // Check whether a format character is doubled
    var lookAhead = function(match) {
      var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
      if (matches)
        iFormat++;
      return matches;
    };
    for (var iFormat = 0; iFormat < format.length; iFormat++)
      if (literal)
        if (format.charAt(iFormat) == "'" && !lookAhead("'"))
          literal = false;
        else
          chars += format.charAt(iFormat);
      else
        switch (format.charAt(iFormat)) {
          case 'd': case 'm': case 'y': case '@':
            chars += '0123456789';
            break;
          case 'D': case 'M':
            return null; // Accept anything
          case "'":
            if (lookAhead("'"))
              chars += "'";
            else
              literal = true;
            break;
          default:
            chars += format.charAt(iFormat);
        }
    return chars;
  },

  /* Get a setting value, defaulting if necessary. */
  _get: function(inst, name) {
    return inst.settings[name] !== undefined ?
      inst.settings[name] : this._defaults[name];
  },

  /* Parse existing date and initialise date picker. */
  _setDateFromField: function(inst, noDefault) {
    if (inst.input.val() == inst.lastVal) {
      return;
    }
    var dateFormat = this._get(inst, 'dateFormat');
    var dates = inst.lastVal = inst.input ? inst.input.val() : null;
    var date, defaultDate;
    date = defaultDate = this._getDefaultDate(inst);
    var settings = this._getFormatConfig(inst);
    try {
      date = this.parseDate(dateFormat, dates, settings) || defaultDate;
    } catch (event) {
      this.log(event);
      dates = (noDefault ? '' : dates);
    }
    inst.selectedDay = date.getDate();
    inst.drawMonth = inst.selectedMonth = date.getMonth();
    inst.drawYear = inst.selectedYear = date.getFullYear();
    inst.currentDay = (dates ? date.getDate() : 0);
    inst.currentMonth = (dates ? date.getMonth() : 0);
    inst.currentYear = (dates ? date.getFullYear() : 0);
    this._adjustInstDate(inst);
  },

  /* Retrieve the default date shown on opening. */
  _getDefaultDate: function(inst) {
    return this._restrictMinMax(inst,
      this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
  },

  /* A date may be specified as an exact value or a relative one. */
  _determineDate: function(inst, date, defaultDate) {
    var offsetNumeric = function(offset) {
      var date = new Date();
      date.setDate(date.getDate() + offset);
      return date;
    };
    var offsetString = function(offset) {
      try {
        return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
          offset, $.datepicker._getFormatConfig(inst));
      }
      catch (e) {
        // Ignore
      }
      var date = (offset.toLowerCase().match(/^c/) ?
        $.datepicker._getDate(inst) : null) || new Date();
      var year = date.getFullYear();
      var month = date.getMonth();
      var day = date.getDate();
      var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
      var matches = pattern.exec(offset);
      while (matches) {
        switch (matches[2] || 'd') {
          case 'd' : case 'D' :
            day += parseInt(matches[1],10); break;
          case 'w' : case 'W' :
            day += parseInt(matches[1],10) * 7; break;
          case 'm' : case 'M' :
            month += parseInt(matches[1],10);
            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
            break;
          case 'y': case 'Y' :
            year += parseInt(matches[1],10);
            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
            break;
        }
        matches = pattern.exec(offset);
      }
      return new Date(year, month, day);
    };
    var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :
      (typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
    newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);
    if (newDate) {
      newDate.setHours(0);
      newDate.setMinutes(0);
      newDate.setSeconds(0);
      newDate.setMilliseconds(0);
    }
    return this._daylightSavingAdjust(newDate);
  },

  /* Handle switch to/from daylight saving.
     Hours may be non-zero on daylight saving cut-over:
     > 12 when midnight changeover, but then cannot generate
     midnight datetime, so jump to 1AM, otherwise reset.
     @param  date  (Date) the date to check
     @return  (Date) the corrected date */
  _daylightSavingAdjust: function(date) {
    if (!date) return null;
    date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
    return date;
  },

  /* Set the date(s) directly. */
  _setDate: function(inst, date, noChange) {
    var clear = !date;
    var origMonth = inst.selectedMonth;
    var origYear = inst.selectedYear;
    var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
    inst.selectedDay = inst.currentDay = newDate.getDate();
    inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
    inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
    if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
      this._notifyChange(inst);
    this._adjustInstDate(inst);
    if (inst.input) {
      inst.input.val(clear ? '' : this._formatDate(inst));
    }
  },

  /* Retrieve the date(s) directly. */
  _getDate: function(inst) {
    var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :
      this._daylightSavingAdjust(new Date(
      inst.currentYear, inst.currentMonth, inst.currentDay)));
      return startDate;
  },

  /* Generate the HTML for the current state of the date picker. */
  _generateHTML: function(inst) {
    var today = new Date();
    today = this._daylightSavingAdjust(
      new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
    var isRTL = this._get(inst, 'isRTL');
    var showButtonPanel = this._get(inst, 'showButtonPanel');
    var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
    var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
    var numMonths = this._getNumberOfMonths(inst);
    var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
    var stepMonths = this._get(inst, 'stepMonths');
    var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
    var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
      new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
    var minDate = this._getMinMaxDate(inst, 'min');
    var maxDate = this._getMinMaxDate(inst, 'max');
    var drawMonth = inst.drawMonth - showCurrentAtPos;
    var drawYear = inst.drawYear;
    if (drawMonth < 0) {
      drawMonth += 12;
      drawYear--;
    }
    if (maxDate) {
      var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
        maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
      maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
      while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
        drawMonth--;
        if (drawMonth < 0) {
          drawMonth = 11;
          drawYear--;
        }
      }
    }
    inst.drawMonth = drawMonth;
    inst.drawYear = drawYear;
    var prevText = this._get(inst, 'prevText');
    prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
      this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
      this._getFormatConfig(inst)));
    var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
      '<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_' + dpuuid +
      '.datepicker._adjustDate(\'#' + inst.id + '\', -' + stepMonths + ', \'M\');"' +
      ' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
      (hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
    var nextText = this._get(inst, 'nextText');
    nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
      this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
      this._getFormatConfig(inst)));
    var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
      '<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_' + dpuuid +
      '.datepicker._adjustDate(\'#' + inst.id + '\', +' + stepMonths + ', \'M\');"' +
      ' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
      (hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
    var currentText = this._get(inst, 'currentText');
    var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
    currentText = (!navigationAsDateFormat ? currentText :
      this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
    var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
      '.datepicker._hideDatepicker();">' + this._get(inst, 'closeText') + '</button>' : '');
    var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
      (this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
      '.datepicker._gotoToday(\'#' + inst.id + '\');"' +
      '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
    var firstDay = parseInt(this._get(inst, 'firstDay'),10);
    firstDay = (isNaN(firstDay) ? 0 : firstDay);
    var showWeek = this._get(inst, 'showWeek');
    var dayNames = this._get(inst, 'dayNames');
    var dayNamesShort = this._get(inst, 'dayNamesShort');
    var dayNamesMin = this._get(inst, 'dayNamesMin');
    var monthNames = this._get(inst, 'monthNames');
    var monthNamesShort = this._get(inst, 'monthNamesShort');
    var beforeShowDay = this._get(inst, 'beforeShowDay');
    var showOtherMonths = this._get(inst, 'showOtherMonths');
    var selectOtherMonths = this._get(inst, 'selectOtherMonths');
    var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
    var defaultDate = this._getDefaultDate(inst);
    var html = '';
    for (var row = 0; row < numMonths[0]; row++) {
      var group = '';
      this.maxRows = 4;
      for (var col = 0; col < numMonths[1]; col++) {
        var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
        var cornerClass = ' ui-corner-all';
        var calender = '';
        if (isMultiMonth) {
          calender += '<div class="ui-datepicker-group';
          if (numMonths[1] > 1)
            switch (col) {
              case 0: calender += ' ui-datepicker-group-first';
                cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
              case numMonths[1]-1: calender += ' ui-datepicker-group-last';
                cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
              default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
            }
          calender += '">';
        }
        calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
          (/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
          (/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
          this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
          row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
          '</div><table class="ui-datepicker-calendar"><thead>' +
          '<tr>';
        var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
        for (var dow = 0; dow < 7; dow++) { // days of the week
          var day = (dow + firstDay) % 7;
          thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
            '<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
        }
        calender += thead + '</tr></thead><tbody>';
        var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
        if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
          inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
        var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
        var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
        var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
        this.maxRows = numRows;
        var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
        for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
          calender += '<tr>';
          var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
            this._get(inst, 'calculateWeek')(printDate) + '</td>');
          for (var dow = 0; dow < 7; dow++) { // create date picker days
            var daySettings = (beforeShowDay ?
              beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
            var otherMonth = (printDate.getMonth() != drawMonth);
            var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
              (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
            tbody += '<td class="' +
              ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
              (otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
              ((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key
              (defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
              // or defaultDate is current printedDate and defaultDate is selectedDate
              ' ' + this._dayOverClass : '') + // highlight selected day
              (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
              (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
              (printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
              (printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
              ((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
              (unselectable ? '' : ' onclick="DP_jQuery_' + dpuuid + '.datepicker._selectDay(\'#' +
              inst.id + '\',' + printDate.getMonth() + ',' + printDate.getFullYear() + ', this);return false;"') + '>' + // actions
              (otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
              (unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
              (printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
              (printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
              (otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
              '" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
            printDate.setDate(printDate.getDate() + 1);
            printDate = this._daylightSavingAdjust(printDate);
          }
          calender += tbody + '</tr>';
        }
        drawMonth++;
        if (drawMonth > 11) {
          drawMonth = 0;
          drawYear++;
        }
        calender += '</tbody></table>' + (isMultiMonth ? '</div>' +
              ((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
        group += calender;
      }
      html += group;
    }
    html += buttonPanel + ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?
      '<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
    inst._keyEvent = false;
    return html;
  },

  /* Generate the month and year header. */
  _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
      secondary, monthNames, monthNamesShort) {
    var changeMonth = this._get(inst, 'changeMonth');
    var changeYear = this._get(inst, 'changeYear');
    var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
    var html = '<div class="ui-datepicker-title">';
    var monthHtml = '';
    // month selection
    if (secondary || !changeMonth)
      monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
    else {
      var inMinYear = (minDate && minDate.getFullYear() == drawYear);
      var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
      monthHtml += '<select class="ui-datepicker-month" ' +
        'onchange="DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'M\');" ' +
        '>';
      for (var month = 0; month < 12; month++) {
        if ((!inMinYear || month >= minDate.getMonth()) &&
            (!inMaxYear || month <= maxDate.getMonth()))
          monthHtml += '<option value="' + month + '"' +
            (month == drawMonth ? ' selected="selected"' : '') +
            '>' + monthNamesShort[month] + '</option>';
      }
      monthHtml += '</select>';
    }
    if (!showMonthAfterYear)
      html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
    // year selection
    if ( !inst.yearshtml ) {
      inst.yearshtml = '';
      if (secondary || !changeYear)
        html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
      else {
        // determine range of years to display
        var years = this._get(inst, 'yearRange').split(':');
        var thisYear = new Date().getFullYear();
        var determineYear = function(value) {
          var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
            (value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
            parseInt(value, 10)));
          return (isNaN(year) ? thisYear : year);
        };
        var year = determineYear(years[0]);
        var endYear = Math.max(year, determineYear(years[1] || ''));
        year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
        endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
        inst.yearshtml += '<select class="ui-datepicker-year" ' +
          'onchange="DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'Y\');" ' +
          '>';
        for (; year <= endYear; year++) {
          inst.yearshtml += '<option value="' + year + '"' +
            (year == drawYear ? ' selected="selected"' : '') +
            '>' + year + '</option>';
        }
        inst.yearshtml += '</select>';

        html += inst.yearshtml;
        inst.yearshtml = null;
      }
    }
    html += this._get(inst, 'yearSuffix');
    if (showMonthAfterYear)
      html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
    html += '</div>'; // Close datepicker_header
    return html;
  },

  /* Adjust one of the date sub-fields. */
  _adjustInstDate: function(inst, offset, period) {
    var year = inst.drawYear + (period == 'Y' ? offset : 0);
    var month = inst.drawMonth + (period == 'M' ? offset : 0);
    var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
      (period == 'D' ? offset : 0);
    var date = this._restrictMinMax(inst,
      this._daylightSavingAdjust(new Date(year, month, day)));
    inst.selectedDay = date.getDate();
    inst.drawMonth = inst.selectedMonth = date.getMonth();
    inst.drawYear = inst.selectedYear = date.getFullYear();
    if (period == 'M' || period == 'Y')
      this._notifyChange(inst);
  },

  /* Ensure a date is within any min/max bounds. */
  _restrictMinMax: function(inst, date) {
    var minDate = this._getMinMaxDate(inst, 'min');
    var maxDate = this._getMinMaxDate(inst, 'max');
    var newDate = (minDate && date < minDate ? minDate : date);
    newDate = (maxDate && newDate > maxDate ? maxDate : newDate);
    return newDate;
  },

  /* Notify change of month/year. */
  _notifyChange: function(inst) {
    var onChange = this._get(inst, 'onChangeMonthYear');
    if (onChange)
      onChange.apply((inst.input ? inst.input[0] : null),
        [inst.selectedYear, inst.selectedMonth + 1, inst]);
  },

  /* Determine the number of months to show. */
  _getNumberOfMonths: function(inst) {
    var numMonths = this._get(inst, 'numberOfMonths');
    return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
  },

  /* Determine the current maximum date - ensure no time components are set. */
  _getMinMaxDate: function(inst, minMax) {
    return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
  },

  /* Find the number of days in a given month. */
  _getDaysInMonth: function(year, month) {
    return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
  },

  /* Find the day of the week of the first of a month. */
  _getFirstDayOfMonth: function(year, month) {
    return new Date(year, month, 1).getDay();
  },

  /* Determines if we should allow a "next/prev" month display change. */
  _canAdjustMonth: function(inst, offset, curYear, curMonth) {
    var numMonths = this._getNumberOfMonths(inst);
    var date = this._daylightSavingAdjust(new Date(curYear,
      curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
    if (offset < 0)
      date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
    return this._isInRange(inst, date);
  },

  /* Is the given date in the accepted range? */
  _isInRange: function(inst, date) {
    var minDate = this._getMinMaxDate(inst, 'min');
    var maxDate = this._getMinMaxDate(inst, 'max');
    return ((!minDate || date.getTime() >= minDate.getTime()) &&
      (!maxDate || date.getTime() <= maxDate.getTime()));
  },

  /* Provide the configuration settings for formatting/parsing. */
  _getFormatConfig: function(inst) {
    var shortYearCutoff = this._get(inst, 'shortYearCutoff');
    shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
      new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
    return {shortYearCutoff: shortYearCutoff,
      dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
      monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
  },

  /* Format the given date for display. */
  _formatDate: function(inst, day, month, year) {
    if (!day) {
      inst.currentDay = inst.selectedDay;
      inst.currentMonth = inst.selectedMonth;
      inst.currentYear = inst.selectedYear;
    }
    var date = (day ? (typeof day == 'object' ? day :
      this._daylightSavingAdjust(new Date(year, month, day))) :
      this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
    return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
  }
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
  var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
  return dpDiv.bind('mouseout', function(event) {
      var elem = $( event.target ).closest( selector );
      if ( !elem.length ) {
        return;
      }
      elem.removeClass( "ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover" );
    })
    .bind('mouseover', function(event) {
      var elem = $( event.target ).closest( selector );
      if ($.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) ||
          !elem.length ) {
        return;
      }
      elem.parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
      elem.addClass('ui-state-hover');
      if (elem.hasClass('ui-datepicker-prev')) elem.addClass('ui-datepicker-prev-hover');
      if (elem.hasClass('ui-datepicker-next')) elem.addClass('ui-datepicker-next-hover');
    });
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
  $.extend(target, props);
  for (var name in props)
    if (props[name] == null || props[name] == undefined)
      target[name] = props[name];
  return target;
};

/* Determine whether an object is an array. */
function isArray(a) {
  return (a && (($.browser.safari && typeof a == 'object' && a.length) ||
    (a.constructor && a.constructor.toString().match(/\Array\(\)/))));
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
                    Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

  /* Verify an empty collection wasn't passed - Fixes #6976 */
  if ( !this.length ) {
    return this;
  }

  /* Initialise the date picker. */
  if (!$.datepicker.initialized) {
    $(document).mousedown($.datepicker._checkExternalClick).
      find('body').append($.datepicker.dpDiv);
    $.datepicker.initialized = true;
  }

  var otherArgs = Array.prototype.slice.call(arguments, 1);
  if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))
    return $.datepicker['_' + options + 'Datepicker'].
      apply($.datepicker, [this[0]].concat(otherArgs));
  if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
    return $.datepicker['_' + options + 'Datepicker'].
      apply($.datepicker, [this[0]].concat(otherArgs));
  return this.each(function() {
    typeof options == 'string' ?
      $.datepicker['_' + options + 'Datepicker'].
        apply($.datepicker, [this].concat(otherArgs)) :
      $.datepicker._attachDatepicker(this, options);
  });
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.8.20";

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window['DP_jQuery_' + dpuuid] = $;

})(jQuery);
/*!
 * jQuery UI Progressbar 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( "ui.progressbar", {
  options: {
    value: 0,
    max: 100
  },

  min: 0,

  _create: function() {
    this.element
      .addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
      .attr({
        role: "progressbar",
        "aria-valuemin": this.min,
        "aria-valuemax": this.options.max,
        "aria-valuenow": this._value()
      });

    this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
      .appendTo( this.element );

    this.oldValue = this._value();
    this._refreshValue();
  },

  destroy: function() {
    this.element
      .removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
      .removeAttr( "role" )
      .removeAttr( "aria-valuemin" )
      .removeAttr( "aria-valuemax" )
      .removeAttr( "aria-valuenow" );

    this.valueDiv.remove();

    $.Widget.prototype.destroy.apply( this, arguments );
  },

  value: function( newValue ) {
    if ( newValue === undefined ) {
      return this._value();
    }

    this._setOption( "value", newValue );
    return this;
  },

  _setOption: function( key, value ) {
    if ( key === "value" ) {
      this.options.value = value;
      this._refreshValue();
      if ( this._value() === this.options.max ) {
        this._trigger( "complete" );
      }
    }

    $.Widget.prototype._setOption.apply( this, arguments );
  },

  _value: function() {
    var val = this.options.value;
    // normalize invalid value
    if ( typeof val !== "number" ) {
      val = 0;
    }
    return Math.min( this.options.max, Math.max( this.min, val ) );
  },

  _percentage: function() {
    return 100 * this._value() / this.options.max;
  },

  _refreshValue: function() {
    var value = this.value();
    var percentage = this._percentage();

    if ( this.oldValue !== value ) {
      this.oldValue = value;
      this._trigger( "change" );
    }

    this.valueDiv
      .toggle( value > this.min )
      .toggleClass( "ui-corner-right", value === this.options.max )
      .width( percentage.toFixed(0) + "%" );
    this.element.attr( "aria-valuenow", value );
  }
});

$.extend( $.ui.progressbar, {
  version: "1.8.20"
});

})( jQuery );
/*!
 * jQuery UI Effects 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
;jQuery.effects || (function($, undefined) {

$.effects = {};



/******************************************************************************/
/****************************** COLOR ANIMATIONS ******************************/
/******************************************************************************/

// override the animation for color styles
$.each(['backgroundColor', 'borderBottomColor', 'borderLeftColor',
  'borderRightColor', 'borderTopColor', 'borderColor', 'color', 'outlineColor'],
function(i, attr) {
  $.fx.step[attr] = function(fx) {
    if (!fx.colorInit) {
      fx.start = getColor(fx.elem, attr);
      fx.end = getRGB(fx.end);
      fx.colorInit = true;
    }

    fx.elem.style[attr] = 'rgb(' +
      Math.max(Math.min(parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0], 10), 255), 0) + ',' +
      Math.max(Math.min(parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1], 10), 255), 0) + ',' +
      Math.max(Math.min(parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2], 10), 255), 0) + ')';
  };
});

// Color Conversion functions from highlightFade
// By Blair Mitchelmore
// http://jquery.offput.ca/highlightFade/

// Parse strings looking for color tuples [255,255,255]
function getRGB(color) {
    var result;

    // Check if we're already dealing with an array of colors
    if ( color && color.constructor == Array && color.length == 3 )
        return color;

    // Look for rgb(num,num,num)
    if (result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color))
        return [parseInt(result[1],10), parseInt(result[2],10), parseInt(result[3],10)];

    // Look for rgb(num%,num%,num%)
    if (result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(color))
        return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];

    // Look for #a0b1c2
    if (result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color))
        return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];

    // Look for #fff
    if (result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color))
        return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];

    // Look for rgba(0, 0, 0, 0) == transparent in Safari 3
    if (result = /rgba\(0, 0, 0, 0\)/.exec(color))
        return colors['transparent'];

    // Otherwise, we're most likely dealing with a named color
    return colors[$.trim(color).toLowerCase()];
}

function getColor(elem, attr) {
    var color;

    do {
        color = $.curCSS(elem, attr);

        // Keep going until we find an element that has color, or we hit the body
        if ( color != '' && color != 'transparent' || $.nodeName(elem, "body") )
            break;

        attr = "backgroundColor";
    } while ( elem = elem.parentNode );

    return getRGB(color);
};

// Some named colors to work with
// From Interface by Stefan Petre
// http://interface.eyecon.ro/

var colors = {
  aqua:[0,255,255],
  azure:[240,255,255],
  beige:[245,245,220],
  black:[0,0,0],
  blue:[0,0,255],
  brown:[165,42,42],
  cyan:[0,255,255],
  darkblue:[0,0,139],
  darkcyan:[0,139,139],
  darkgrey:[169,169,169],
  darkgreen:[0,100,0],
  darkkhaki:[189,183,107],
  darkmagenta:[139,0,139],
  darkolivegreen:[85,107,47],
  darkorange:[255,140,0],
  darkorchid:[153,50,204],
  darkred:[139,0,0],
  darksalmon:[233,150,122],
  darkviolet:[148,0,211],
  fuchsia:[255,0,255],
  gold:[255,215,0],
  green:[0,128,0],
  indigo:[75,0,130],
  khaki:[240,230,140],
  lightblue:[173,216,230],
  lightcyan:[224,255,255],
  lightgreen:[144,238,144],
  lightgrey:[211,211,211],
  lightpink:[255,182,193],
  lightyellow:[255,255,224],
  lime:[0,255,0],
  magenta:[255,0,255],
  maroon:[128,0,0],
  navy:[0,0,128],
  olive:[128,128,0],
  orange:[255,165,0],
  pink:[255,192,203],
  purple:[128,0,128],
  violet:[128,0,128],
  red:[255,0,0],
  silver:[192,192,192],
  white:[255,255,255],
  yellow:[255,255,0],
  transparent: [255,255,255]
};



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/

var classAnimationActions = ['add', 'remove', 'toggle'],
  shorthandStyles = {
    border: 1,
    borderBottom: 1,
    borderColor: 1,
    borderLeft: 1,
    borderRight: 1,
    borderTop: 1,
    borderWidth: 1,
    margin: 1,
    padding: 1
  };

function getElementStyles() {
  var style = document.defaultView
      ? document.defaultView.getComputedStyle(this, null)
      : this.currentStyle,
    newStyle = {},
    key,
    camelCase;

  // webkit enumerates style porperties
  if (style && style.length && style[0] && style[style[0]]) {
    var len = style.length;
    while (len--) {
      key = style[len];
      if (typeof style[key] == 'string') {
        camelCase = key.replace(/\-(\w)/g, function(all, letter){
          return letter.toUpperCase();
        });
        newStyle[camelCase] = style[key];
      }
    }
  } else {
    for (key in style) {
      if (typeof style[key] === 'string') {
        newStyle[key] = style[key];
      }
    }
  }

  return newStyle;
}

function filterStyles(styles) {
  var name, value;
  for (name in styles) {
    value = styles[name];
    if (
      // ignore null and undefined values
      value == null ||
      // ignore functions (when does this occur?)
      $.isFunction(value) ||
      // shorthand styles that need to be expanded
      name in shorthandStyles ||
      // ignore scrollbars (break in IE)
      (/scrollbar/).test(name) ||

      // only colors or values that can be converted to numbers
      (!(/color/i).test(name) && isNaN(parseFloat(value)))
    ) {
      delete styles[name];
    }
  }

  return styles;
}

function styleDifference(oldStyle, newStyle) {
  var diff = { _: 0 }, // http://dev.jquery.com/ticket/5459
    name;

  for (name in newStyle) {
    if (oldStyle[name] != newStyle[name]) {
      diff[name] = newStyle[name];
    }
  }

  return diff;
}

$.effects.animateClass = function(value, duration, easing, callback) {
  if ($.isFunction(easing)) {
    callback = easing;
    easing = null;
  }

  return this.queue(function() {
    var that = $(this),
      originalStyleAttr = that.attr('style') || ' ',
      originalStyle = filterStyles(getElementStyles.call(this)),
      newStyle,
      className = that.attr('class') || "";

    $.each(classAnimationActions, function(i, action) {
      if (value[action]) {
        that[action + 'Class'](value[action]);
      }
    });
    newStyle = filterStyles(getElementStyles.call(this));
    that.attr('class', className);

    that.animate(styleDifference(originalStyle, newStyle), {
      queue: false,
      duration: duration,
      easing: easing,
      complete: function() {
        $.each(classAnimationActions, function(i, action) {
          if (value[action]) { that[action + 'Class'](value[action]); }
        });
        // work around bug in IE by clearing the cssText before setting it
        if (typeof that.attr('style') == 'object') {
          that.attr('style').cssText = '';
          that.attr('style').cssText = originalStyleAttr;
        } else {
          that.attr('style', originalStyleAttr);
        }
        if (callback) { callback.apply(this, arguments); }
        $.dequeue( this );
      }
    });
  });
};

$.fn.extend({
  _addClass: $.fn.addClass,
  addClass: function(classNames, speed, easing, callback) {
    return speed ? $.effects.animateClass.apply(this, [{ add: classNames },speed,easing,callback]) : this._addClass(classNames);
  },

  _removeClass: $.fn.removeClass,
  removeClass: function(classNames,speed,easing,callback) {
    return speed ? $.effects.animateClass.apply(this, [{ remove: classNames },speed,easing,callback]) : this._removeClass(classNames);
  },

  _toggleClass: $.fn.toggleClass,
  toggleClass: function(classNames, force, speed, easing, callback) {
    if ( typeof force == "boolean" || force === undefined ) {
      if ( !speed ) {
        // without speed parameter;
        return this._toggleClass(classNames, force);
      } else {
        return $.effects.animateClass.apply(this, [(force?{add:classNames}:{remove:classNames}),speed,easing,callback]);
      }
    } else {
      // without switch parameter;
      return $.effects.animateClass.apply(this, [{ toggle: classNames },force,speed,easing]);
    }
  },

  switchClass: function(remove,add,speed,easing,callback) {
    return $.effects.animateClass.apply(this, [{ add: add, remove: remove },speed,easing,callback]);
  }
});



/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

$.extend($.effects, {
  version: "1.8.20",

  // Saves a set of properties in a data storage
  save: function(element, set) {
    for(var i=0; i < set.length; i++) {
      if(set[i] !== null) element.data("ec.storage."+set[i], element[0].style[set[i]]);
    }
  },

  // Restores a set of previously saved properties from a data storage
  restore: function(element, set) {
    for(var i=0; i < set.length; i++) {
      if(set[i] !== null) element.css(set[i], element.data("ec.storage."+set[i]));
    }
  },

  setMode: function(el, mode) {
    if (mode == 'toggle') mode = el.is(':hidden') ? 'show' : 'hide'; // Set for toggle
    return mode;
  },

  getBaseline: function(origin, original) { // Translates a [top,left] array into a baseline value
    // this should be a little more flexible in the future to handle a string & hash
    var y, x;
    switch (origin[0]) {
      case 'top': y = 0; break;
      case 'middle': y = 0.5; break;
      case 'bottom': y = 1; break;
      default: y = origin[0] / original.height;
    };
    switch (origin[1]) {
      case 'left': x = 0; break;
      case 'center': x = 0.5; break;
      case 'right': x = 1; break;
      default: x = origin[1] / original.width;
    };
    return {x: x, y: y};
  },

  // Wraps the element around a wrapper that copies position properties
  createWrapper: function(element) {

    // if the element is already wrapped, return it
    if (element.parent().is('.ui-effects-wrapper')) {
      return element.parent();
    }

    // wrap the element
    var props = {
        width: element.outerWidth(true),
        height: element.outerHeight(true),
        'float': element.css('float')
      },
      wrapper = $('<div></div>')
        .addClass('ui-effects-wrapper')
        .css({
          fontSize: '100%',
          background: 'transparent',
          border: 'none',
          margin: 0,
          padding: 0
        }),
      active = document.activeElement;

    element.wrap(wrapper);

    // Fixes #7595 - Elements lose focus when wrapped.
    if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
      $( active ).focus();
    }

    wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element

    // transfer positioning properties to the wrapper
    if (element.css('position') == 'static') {
      wrapper.css({ position: 'relative' });
      element.css({ position: 'relative' });
    } else {
      $.extend(props, {
        position: element.css('position'),
        zIndex: element.css('z-index')
      });
      $.each(['top', 'left', 'bottom', 'right'], function(i, pos) {
        props[pos] = element.css(pos);
        if (isNaN(parseInt(props[pos], 10))) {
          props[pos] = 'auto';
        }
      });
      element.css({position: 'relative', top: 0, left: 0, right: 'auto', bottom: 'auto' });
    }

    return wrapper.css(props).show();
  },

  removeWrapper: function(element) {
    var parent,
      active = document.activeElement;

    if (element.parent().is('.ui-effects-wrapper')) {
      parent = element.parent().replaceWith(element);
      // Fixes #7595 - Elements lose focus when wrapped.
      if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
        $( active ).focus();
      }
      return parent;
    }

    return element;
  },

  setTransition: function(element, list, factor, value) {
    value = value || {};
    $.each(list, function(i, x){
      var unit = element.cssUnit(x);
      if (unit[0] > 0) value[x] = unit[0] * factor + unit[1];
    });
    return value;
  }
});


function _normalizeArguments(effect, options, speed, callback) {
  // shift params for method overloading
  if (typeof effect == 'object') {
    callback = options;
    speed = null;
    options = effect;
    effect = options.effect;
  }
  if ($.isFunction(options)) {
    callback = options;
    speed = null;
    options = {};
  }
        if (typeof options == 'number' || $.fx.speeds[options]) {
    callback = speed;
    speed = options;
    options = {};
  }
  if ($.isFunction(speed)) {
    callback = speed;
    speed = null;
  }

  options = options || {};

  speed = speed || options.duration;
  speed = $.fx.off ? 0 : typeof speed == 'number'
    ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;

  callback = callback || options.complete;

  return [effect, options, speed, callback];
}

function standardSpeed( speed ) {
  // valid standard speeds
  if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
    return true;
  }

  // invalid strings - treat as "normal" speed
  if ( typeof speed === "string" && !$.effects[ speed ] ) {
    return true;
  }

  return false;
}

$.fn.extend({
  effect: function(effect, options, speed, callback) {
    var args = _normalizeArguments.apply(this, arguments),
      // TODO: make effects take actual parameters instead of a hash
      args2 = {
        options: args[1],
        duration: args[2],
        callback: args[3]
      },
      mode = args2.options.mode,
      effectMethod = $.effects[effect];

    if ( $.fx.off || !effectMethod ) {
      // delegate to the original method (e.g., .show()) if possible
      if ( mode ) {
        return this[ mode ]( args2.duration, args2.callback );
      } else {
        return this.each(function() {
          if ( args2.callback ) {
            args2.callback.call( this );
          }
        });
      }
    }

    return effectMethod.call(this, args2);
  },

  _show: $.fn.show,
  show: function(speed) {
    if ( standardSpeed( speed ) ) {
      return this._show.apply(this, arguments);
    } else {
      var args = _normalizeArguments.apply(this, arguments);
      args[1].mode = 'show';
      return this.effect.apply(this, args);
    }
  },

  _hide: $.fn.hide,
  hide: function(speed) {
    if ( standardSpeed( speed ) ) {
      return this._hide.apply(this, arguments);
    } else {
      var args = _normalizeArguments.apply(this, arguments);
      args[1].mode = 'hide';
      return this.effect.apply(this, args);
    }
  },

  // jQuery core overloads toggle and creates _toggle
  __toggle: $.fn.toggle,
  toggle: function(speed) {
    if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
      return this.__toggle.apply(this, arguments);
    } else {
      var args = _normalizeArguments.apply(this, arguments);
      args[1].mode = 'toggle';
      return this.effect.apply(this, args);
    }
  },

  // helper functions
  cssUnit: function(key) {
    var style = this.css(key), val = [];
    $.each( ['em','px','%','pt'], function(i, unit){
      if(style.indexOf(unit) > 0)
        val = [parseFloat(style), unit];
    });
    return val;
  }
});



/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 *
 * Open source under the BSD License.
 *
 * Copyright 2008 George McGinley Smith
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
$.easing.jswing = $.easing.swing;

$.extend($.easing,
{
  def: 'easeOutQuad',
  swing: function (x, t, b, c, d) {
    //alert($.easing.default);
    return $.easing[$.easing.def](x, t, b, c, d);
  },
  easeInQuad: function (x, t, b, c, d) {
    return c*(t/=d)*t + b;
  },
  easeOutQuad: function (x, t, b, c, d) {
    return -c *(t/=d)*(t-2) + b;
  },
  easeInOutQuad: function (x, t, b, c, d) {
    if ((t/=d/2) < 1) return c/2*t*t + b;
    return -c/2 * ((--t)*(t-2) - 1) + b;
  },
  easeInCubic: function (x, t, b, c, d) {
    return c*(t/=d)*t*t + b;
  },
  easeOutCubic: function (x, t, b, c, d) {
    return c*((t=t/d-1)*t*t + 1) + b;
  },
  easeInOutCubic: function (x, t, b, c, d) {
    if ((t/=d/2) < 1) return c/2*t*t*t + b;
    return c/2*((t-=2)*t*t + 2) + b;
  },
  easeInQuart: function (x, t, b, c, d) {
    return c*(t/=d)*t*t*t + b;
  },
  easeOutQuart: function (x, t, b, c, d) {
    return -c * ((t=t/d-1)*t*t*t - 1) + b;
  },
  easeInOutQuart: function (x, t, b, c, d) {
    if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
    return -c/2 * ((t-=2)*t*t*t - 2) + b;
  },
  easeInQuint: function (x, t, b, c, d) {
    return c*(t/=d)*t*t*t*t + b;
  },
  easeOutQuint: function (x, t, b, c, d) {
    return c*((t=t/d-1)*t*t*t*t + 1) + b;
  },
  easeInOutQuint: function (x, t, b, c, d) {
    if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
    return c/2*((t-=2)*t*t*t*t + 2) + b;
  },
  easeInSine: function (x, t, b, c, d) {
    return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
  },
  easeOutSine: function (x, t, b, c, d) {
    return c * Math.sin(t/d * (Math.PI/2)) + b;
  },
  easeInOutSine: function (x, t, b, c, d) {
    return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
  },
  easeInExpo: function (x, t, b, c, d) {
    return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
  },
  easeOutExpo: function (x, t, b, c, d) {
    return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
  },
  easeInOutExpo: function (x, t, b, c, d) {
    if (t==0) return b;
    if (t==d) return b+c;
    if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
    return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
  },
  easeInCirc: function (x, t, b, c, d) {
    return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
  },
  easeOutCirc: function (x, t, b, c, d) {
    return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
  },
  easeInOutCirc: function (x, t, b, c, d) {
    if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
    return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
  },
  easeInElastic: function (x, t, b, c, d) {
    var s=1.70158;var p=0;var a=c;
    if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
    if (a < Math.abs(c)) { a=c; var s=p/4; }
    else var s = p/(2*Math.PI) * Math.asin (c/a);
    return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
  },
  easeOutElastic: function (x, t, b, c, d) {
    var s=1.70158;var p=0;var a=c;
    if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
    if (a < Math.abs(c)) { a=c; var s=p/4; }
    else var s = p/(2*Math.PI) * Math.asin (c/a);
    return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
  },
  easeInOutElastic: function (x, t, b, c, d) {
    var s=1.70158;var p=0;var a=c;
    if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
    if (a < Math.abs(c)) { a=c; var s=p/4; }
    else var s = p/(2*Math.PI) * Math.asin (c/a);
    if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
    return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
  },
  easeInBack: function (x, t, b, c, d, s) {
    if (s == undefined) s = 1.70158;
    return c*(t/=d)*t*((s+1)*t - s) + b;
  },
  easeOutBack: function (x, t, b, c, d, s) {
    if (s == undefined) s = 1.70158;
    return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
  },
  easeInOutBack: function (x, t, b, c, d, s) {
    if (s == undefined) s = 1.70158;
    if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
    return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
  },
  easeInBounce: function (x, t, b, c, d) {
    return c - $.easing.easeOutBounce (x, d-t, 0, c, d) + b;
  },
  easeOutBounce: function (x, t, b, c, d) {
    if ((t/=d) < (1/2.75)) {
      return c*(7.5625*t*t) + b;
    } else if (t < (2/2.75)) {
      return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
    } else if (t < (2.5/2.75)) {
      return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
    } else {
      return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
    }
  },
  easeInOutBounce: function (x, t, b, c, d) {
    if (t < d/2) return $.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
    return $.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
  }
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

})(jQuery);
/*!
 * jQuery UI Effects Blind 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Blind
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.blind = function(o) {

  return this.queue(function() {

    // Create element
    var el = $(this), props = ['position','top','bottom','left','right'];

    // Set options
    var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
    var direction = o.options.direction || 'vertical'; // Default direction

    // Adjust
    $.effects.save(el, props); el.show(); // Save & Show
    var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
    var ref = (direction == 'vertical') ? 'height' : 'width';
    var distance = (direction == 'vertical') ? wrapper.height() : wrapper.width();
    if(mode == 'show') wrapper.css(ref, 0); // Shift

    // Animation
    var animation = {};
    animation[ref] = mode == 'show' ? distance : 0;

    // Animate
    wrapper.animate(animation, o.duration, o.options.easing, function() {
      if(mode == 'hide') el.hide(); // Hide
      $.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
      if(o.callback) o.callback.apply(el[0], arguments); // Callback
      el.dequeue();
    });

  });

};

})(jQuery);
/*!
 * jQuery UI Effects Bounce 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Bounce
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.bounce = function(o) {

  return this.queue(function() {

    // Create element
    var el = $(this), props = ['position','top','bottom','left','right'];

    // Set options
    var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
    var direction = o.options.direction || 'up'; // Default direction
    var distance = o.options.distance || 20; // Default distance
    var times = o.options.times || 5; // Default # of times
    var speed = o.duration || 250; // Default speed per bounce
    if (/show|hide/.test(mode)) props.push('opacity'); // Avoid touching opacity to prevent clearType and PNG issues in IE

    // Adjust
    $.effects.save(el, props); el.show(); // Save & Show
    $.effects.createWrapper(el); // Create Wrapper
    var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
    var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
    var distance = o.options.distance || (ref == 'top' ? el.outerHeight({margin:true}) / 3 : el.outerWidth({margin:true}) / 3);
    if (mode == 'show') el.css('opacity', 0).css(ref, motion == 'pos' ? -distance : distance); // Shift
    if (mode == 'hide') distance = distance / (times * 2);
    if (mode != 'hide') times--;

    // Animate
    if (mode == 'show') { // Show Bounce
      var animation = {opacity: 1};
      animation[ref] = (motion == 'pos' ? '+=' : '-=') + distance;
      el.animate(animation, speed / 2, o.options.easing);
      distance = distance / 2;
      times--;
    };
    for (var i = 0; i < times; i++) { // Bounces
      var animation1 = {}, animation2 = {};
      animation1[ref] = (motion == 'pos' ? '-=' : '+=') + distance;
      animation2[ref] = (motion == 'pos' ? '+=' : '-=') + distance;
      el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing);
      distance = (mode == 'hide') ? distance * 2 : distance / 2;
    };
    if (mode == 'hide') { // Last Bounce
      var animation = {opacity: 0};
      animation[ref] = (motion == 'pos' ? '-=' : '+=')  + distance;
      el.animate(animation, speed / 2, o.options.easing, function(){
        el.hide(); // Hide
        $.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
        if(o.callback) o.callback.apply(this, arguments); // Callback
      });
    } else {
      var animation1 = {}, animation2 = {};
      animation1[ref] = (motion == 'pos' ? '-=' : '+=') + distance;
      animation2[ref] = (motion == 'pos' ? '+=' : '-=') + distance;
      el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing, function(){
        $.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
        if(o.callback) o.callback.apply(this, arguments); // Callback
      });
    };
    el.queue('fx', function() { el.dequeue(); });
    el.dequeue();
  });

};

})(jQuery);
/*!
 * jQuery UI Effects Clip 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Clip
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.clip = function(o) {

  return this.queue(function() {

    // Create element
    var el = $(this), props = ['position','top','bottom','left','right','height','width'];

    // Set options
    var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
    var direction = o.options.direction || 'vertical'; // Default direction

    // Adjust
    $.effects.save(el, props); el.show(); // Save & Show
    var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
    var animate = el[0].tagName == 'IMG' ? wrapper : el;
    var ref = {
      size: (direction == 'vertical') ? 'height' : 'width',
      position: (direction == 'vertical') ? 'top' : 'left'
    };
    var distance = (direction == 'vertical') ? animate.height() : animate.width();
    if(mode == 'show') { animate.css(ref.size, 0); animate.css(ref.position, distance / 2); } // Shift

    // Animation
    var animation = {};
    animation[ref.size] = mode == 'show' ? distance : 0;
    animation[ref.position] = mode == 'show' ? 0 : distance / 2;

    // Animate
    animate.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
      if(mode == 'hide') el.hide(); // Hide
      $.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
      if(o.callback) o.callback.apply(el[0], arguments); // Callback
      el.dequeue();
    }});

  });

};

})(jQuery);
/*!
 * jQuery UI Effects Drop 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Drop
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.drop = function(o) {

  return this.queue(function() {

    // Create element
    var el = $(this), props = ['position','top','bottom','left','right','opacity'];

    // Set options
    var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
    var direction = o.options.direction || 'left'; // Default Direction

    // Adjust
    $.effects.save(el, props); el.show(); // Save & Show
    $.effects.createWrapper(el); // Create Wrapper
    var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
    var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
    var distance = o.options.distance || (ref == 'top' ? el.outerHeight({margin:true}) / 2 : el.outerWidth({margin:true}) / 2);
    if (mode == 'show') el.css('opacity', 0).css(ref, motion == 'pos' ? -distance : distance); // Shift

    // Animation
    var animation = {opacity: mode == 'show' ? 1 : 0};
    animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance;

    // Animate
    el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
      if(mode == 'hide') el.hide(); // Hide
      $.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
      if(o.callback) o.callback.apply(this, arguments); // Callback
      el.dequeue();
    }});

  });

};

})(jQuery);
/*!
 * jQuery UI Effects Explode 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Explode
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.explode = function(o) {

  return this.queue(function() {

  var rows = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;
  var cells = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;

  o.options.mode = o.options.mode == 'toggle' ? ($(this).is(':visible') ? 'hide' : 'show') : o.options.mode;
  var el = $(this).show().css('visibility', 'hidden');
  var offset = el.offset();

  //Substract the margins - not fixing the problem yet.
  offset.top -= parseInt(el.css("marginTop"),10) || 0;
  offset.left -= parseInt(el.css("marginLeft"),10) || 0;

  var width = el.outerWidth(true);
  var height = el.outerHeight(true);

  for(var i=0;i<rows;i++) { // =
    for(var j=0;j<cells;j++) { // ||
      el
        .clone()
        .appendTo('body')
        .wrap('<div></div>')
        .css({
          position: 'absolute',
          visibility: 'visible',
          left: -j*(width/cells),
          top: -i*(height/rows)
        })
        .parent()
        .addClass('ui-effects-explode')
        .css({
          position: 'absolute',
          overflow: 'hidden',
          width: width/cells,
          height: height/rows,
          left: offset.left + j*(width/cells) + (o.options.mode == 'show' ? (j-Math.floor(cells/2))*(width/cells) : 0),
          top: offset.top + i*(height/rows) + (o.options.mode == 'show' ? (i-Math.floor(rows/2))*(height/rows) : 0),
          opacity: o.options.mode == 'show' ? 0 : 1
        }).animate({
          left: offset.left + j*(width/cells) + (o.options.mode == 'show' ? 0 : (j-Math.floor(cells/2))*(width/cells)),
          top: offset.top + i*(height/rows) + (o.options.mode == 'show' ? 0 : (i-Math.floor(rows/2))*(height/rows)),
          opacity: o.options.mode == 'show' ? 1 : 0
        }, o.duration || 500);
    }
  }

  // Set a timeout, to call the callback approx. when the other animations have finished
  setTimeout(function() {

    o.options.mode == 'show' ? el.css({ visibility: 'visible' }) : el.css({ visibility: 'visible' }).hide();
        if(o.callback) o.callback.apply(el[0]); // Callback
        el.dequeue();

        $('div.ui-effects-explode').remove();

  }, o.duration || 500);


  });

};

})(jQuery);
/*!
 * jQuery UI Effects Fade 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fade
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.fade = function(o) {
  return this.queue(function() {
    var elem = $(this),
      mode = $.effects.setMode(elem, o.options.mode || 'hide');

    elem.animate({ opacity: mode }, {
      queue: false,
      duration: o.duration,
      easing: o.options.easing,
      complete: function() {
        (o.callback && o.callback.apply(this, arguments));
        elem.dequeue();
      }
    });
  });
};

})(jQuery);
/*!
 * jQuery UI Effects Fold 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fold
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.fold = function(o) {

  return this.queue(function() {

    // Create element
    var el = $(this), props = ['position','top','bottom','left','right'];

    // Set options
    var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
    var size = o.options.size || 15; // Default fold size
    var horizFirst = !(!o.options.horizFirst); // Ensure a boolean value
    var duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2;

    // Adjust
    $.effects.save(el, props); el.show(); // Save & Show
    var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
    var widthFirst = ((mode == 'show') != horizFirst);
    var ref = widthFirst ? ['width', 'height'] : ['height', 'width'];
    var distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];
    var percent = /([0-9]+)%/.exec(size);
    if(percent) size = parseInt(percent[1],10) / 100 * distance[mode == 'hide' ? 0 : 1];
    if(mode == 'show') wrapper.css(horizFirst ? {height: 0, width: size} : {height: size, width: 0}); // Shift

    // Animation
    var animation1 = {}, animation2 = {};
    animation1[ref[0]] = mode == 'show' ? distance[0] : size;
    animation2[ref[1]] = mode == 'show' ? distance[1] : 0;

    // Animate
    wrapper.animate(animation1, duration, o.options.easing)
    .animate(animation2, duration, o.options.easing, function() {
      if(mode == 'hide') el.hide(); // Hide
      $.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
      if(o.callback) o.callback.apply(el[0], arguments); // Callback
      el.dequeue();
    });

  });

};

})(jQuery);
/*!
 * jQuery UI Effects Highlight 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Highlight
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.highlight = function(o) {
  return this.queue(function() {
    var elem = $(this),
      props = ['backgroundImage', 'backgroundColor', 'opacity'],
      mode = $.effects.setMode(elem, o.options.mode || 'show'),
      animation = {
        backgroundColor: elem.css('backgroundColor')
      };

    if (mode == 'hide') {
      animation.opacity = 0;
    }

    $.effects.save(elem, props);
    elem
      .show()
      .css({
        backgroundImage: 'none',
        backgroundColor: o.options.color || '#ffff99'
      })
      .animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.options.easing,
        complete: function() {
          (mode == 'hide' && elem.hide());
          $.effects.restore(elem, props);
          (mode == 'show' && !$.support.opacity && this.style.removeAttribute('filter'));
          (o.callback && o.callback.apply(this, arguments));
          elem.dequeue();
        }
      });
  });
};

})(jQuery);
/*!
 * jQuery UI Effects Pulsate 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Pulsate
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.pulsate = function(o) {
  return this.queue(function() {
    var elem = $(this),
      mode = $.effects.setMode(elem, o.options.mode || 'show'),
      times = ((o.options.times || 5) * 2) - 1,
      duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2,
      isVisible = elem.is(':visible'),
      animateTo = 0;

    if (!isVisible) {
      elem.css('opacity', 0).show();
      animateTo = 1;
    }

    if ((mode == 'hide' && isVisible) || (mode == 'show' && !isVisible)) {
      times--;
    }

    for (var i = 0; i < times; i++) {
      elem.animate({ opacity: animateTo }, duration, o.options.easing);
      animateTo = (animateTo + 1) % 2;
    }

    elem.animate({ opacity: animateTo }, duration, o.options.easing, function() {
      if (animateTo == 0) {
        elem.hide();
      }
      (o.callback && o.callback.apply(this, arguments));
    });

    elem
      .queue('fx', function() { elem.dequeue(); })
      .dequeue();
  });
};

})(jQuery);
/*!
 * jQuery UI Effects Scale 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Scale
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.puff = function(o) {
  return this.queue(function() {
    var elem = $(this),
      mode = $.effects.setMode(elem, o.options.mode || 'hide'),
      percent = parseInt(o.options.percent, 10) || 150,
      factor = percent / 100,
      original = { height: elem.height(), width: elem.width() };

    $.extend(o.options, {
      fade: true,
      mode: mode,
      percent: mode == 'hide' ? percent : 100,
      from: mode == 'hide'
        ? original
        : {
          height: original.height * factor,
          width: original.width * factor
        }
    });

    elem.effect('scale', o.options, o.duration, o.callback);
    elem.dequeue();
  });
};

$.effects.scale = function(o) {

  return this.queue(function() {

    // Create element
    var el = $(this);

    // Set options
    var options = $.extend(true, {}, o.options);
    var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
    var percent = parseInt(o.options.percent,10) || (parseInt(o.options.percent,10) == 0 ? 0 : (mode == 'hide' ? 0 : 100)); // Set default scaling percent
    var direction = o.options.direction || 'both'; // Set default axis
    var origin = o.options.origin; // The origin of the scaling
    if (mode != 'effect') { // Set default origin and restore for show/hide
      options.origin = origin || ['middle','center'];
      options.restore = true;
    }
    var original = {height: el.height(), width: el.width()}; // Save original
    el.from = o.options.from || (mode == 'show' ? {height: 0, width: 0} : original); // Default from state

    // Adjust
    var factor = { // Set scaling factor
      y: direction != 'horizontal' ? (percent / 100) : 1,
      x: direction != 'vertical' ? (percent / 100) : 1
    };
    el.to = {height: original.height * factor.y, width: original.width * factor.x}; // Set to state

    if (o.options.fade) { // Fade option to support puff
      if (mode == 'show') {el.from.opacity = 0; el.to.opacity = 1;};
      if (mode == 'hide') {el.from.opacity = 1; el.to.opacity = 0;};
    };

    // Animation
    options.from = el.from; options.to = el.to; options.mode = mode;

    // Animate
    el.effect('size', options, o.duration, o.callback);
    el.dequeue();
  });

};

$.effects.size = function(o) {

  return this.queue(function() {

    // Create element
    var el = $(this), props = ['position','top','bottom','left','right','width','height','overflow','opacity'];
    var props1 = ['position','top','bottom','left','right','overflow','opacity']; // Always restore
    var props2 = ['width','height','overflow']; // Copy for children
    var cProps = ['fontSize'];
    var vProps = ['borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'];
    var hProps = ['borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight'];

    // Set options
    var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
    var restore = o.options.restore || false; // Default restore
    var scale = o.options.scale || 'both'; // Default scale mode
    var origin = o.options.origin; // The origin of the sizing
    var original = {height: el.height(), width: el.width()}; // Save original
    el.from = o.options.from || original; // Default from state
    el.to = o.options.to || original; // Default to state
    // Adjust
    if (origin) { // Calculate baseline shifts
      var baseline = $.effects.getBaseline(origin, original);
      el.from.top = (original.height - el.from.height) * baseline.y;
      el.from.left = (original.width - el.from.width) * baseline.x;
      el.to.top = (original.height - el.to.height) * baseline.y;
      el.to.left = (original.width - el.to.width) * baseline.x;
    };
    var factor = { // Set scaling factor
      from: {y: el.from.height / original.height, x: el.from.width / original.width},
      to: {y: el.to.height / original.height, x: el.to.width / original.width}
    };
    if (scale == 'box' || scale == 'both') { // Scale the css box
      if (factor.from.y != factor.to.y) { // Vertical props scaling
        props = props.concat(vProps);
        el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
        el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
      };
      if (factor.from.x != factor.to.x) { // Horizontal props scaling
        props = props.concat(hProps);
        el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
        el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
      };
    };
    if (scale == 'content' || scale == 'both') { // Scale the content
      if (factor.from.y != factor.to.y) { // Vertical props scaling
        props = props.concat(cProps);
        el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
        el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
      };
    };
    $.effects.save(el, restore ? props : props1); el.show(); // Save & Show
    $.effects.createWrapper(el); // Create Wrapper
    el.css('overflow','hidden').css(el.from); // Shift

    // Animate
    if (scale == 'content' || scale == 'both') { // Scale the children
      vProps = vProps.concat(['marginTop','marginBottom']).concat(cProps); // Add margins/font-size
      hProps = hProps.concat(['marginLeft','marginRight']); // Add margins
      props2 = props.concat(vProps).concat(hProps); // Concat
      el.find("*[width]").each(function(){
        var child = $(this);
        if (restore) $.effects.save(child, props2);
        var c_original = {height: child.height(), width: child.width()}; // Save original
        child.from = {height: c_original.height * factor.from.y, width: c_original.width * factor.from.x};
        child.to = {height: c_original.height * factor.to.y, width: c_original.width * factor.to.x};
        if (factor.from.y != factor.to.y) { // Vertical props scaling
          child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
          child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
        };
        if (factor.from.x != factor.to.x) { // Horizontal props scaling
          child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
          child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
        };
        child.css(child.from); // Shift children
        child.animate(child.to, o.duration, o.options.easing, function(){
          if (restore) $.effects.restore(child, props2); // Restore children
        }); // Animate children
      });
    };

    // Animate
    el.animate(el.to, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
      if (el.to.opacity === 0) {
        el.css('opacity', el.from.opacity);
      }
      if(mode == 'hide') el.hide(); // Hide
      $.effects.restore(el, restore ? props : props1); $.effects.removeWrapper(el); // Restore
      if(o.callback) o.callback.apply(this, arguments); // Callback
      el.dequeue();
    }});

  });

};

})(jQuery);
/*!
 * jQuery UI Effects Shake 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Shake
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.shake = function(o) {

  return this.queue(function() {

    // Create element
    var el = $(this), props = ['position','top','bottom','left','right'];

    // Set options
    var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
    var direction = o.options.direction || 'left'; // Default direction
    var distance = o.options.distance || 20; // Default distance
    var times = o.options.times || 3; // Default # of times
    var speed = o.duration || o.options.duration || 140; // Default speed per shake

    // Adjust
    $.effects.save(el, props); el.show(); // Save & Show
    $.effects.createWrapper(el); // Create Wrapper
    var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
    var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';

    // Animation
    var animation = {}, animation1 = {}, animation2 = {};
    animation[ref] = (motion == 'pos' ? '-=' : '+=')  + distance;
    animation1[ref] = (motion == 'pos' ? '+=' : '-=')  + distance * 2;
    animation2[ref] = (motion == 'pos' ? '-=' : '+=')  + distance * 2;

    // Animate
    el.animate(animation, speed, o.options.easing);
    for (var i = 1; i < times; i++) { // Shakes
      el.animate(animation1, speed, o.options.easing).animate(animation2, speed, o.options.easing);
    };
    el.animate(animation1, speed, o.options.easing).
    animate(animation, speed / 2, o.options.easing, function(){ // Last shake
      $.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
      if(o.callback) o.callback.apply(this, arguments); // Callback
    });
    el.queue('fx', function() { el.dequeue(); });
    el.dequeue();
  });

};

})(jQuery);
/*!
 * jQuery UI Effects Slide 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Slide
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.slide = function(o) {

  return this.queue(function() {

    // Create element
    var el = $(this), props = ['position','top','bottom','left','right'];

    // Set options
    var mode = $.effects.setMode(el, o.options.mode || 'show'); // Set Mode
    var direction = o.options.direction || 'left'; // Default Direction

    // Adjust
    $.effects.save(el, props); el.show(); // Save & Show
    $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
    var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
    var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
    var distance = o.options.distance || (ref == 'top' ? el.outerHeight({margin:true}) : el.outerWidth({margin:true}));
    if (mode == 'show') el.css(ref, motion == 'pos' ? (isNaN(distance) ? "-" + distance : -distance) : distance); // Shift

    // Animation
    var animation = {};
    animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance;

    // Animate
    el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
      if(mode == 'hide') el.hide(); // Hide
      $.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
      if(o.callback) o.callback.apply(this, arguments); // Callback
      el.dequeue();
    }});

  });

};

})(jQuery);
/*!
 * jQuery UI Effects Transfer 1.8.20
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Transfer
 *
 * Depends:
 *  jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.transfer = function(o) {
  return this.queue(function() {
    var elem = $(this),
      target = $(o.options.to),
      endPosition = target.offset(),
      animation = {
        top: endPosition.top,
        left: endPosition.left,
        height: target.innerHeight(),
        width: target.innerWidth()
      },
      startPosition = elem.offset(),
      transfer = $('<div class="ui-effects-transfer"></div>')
        .appendTo(document.body)
        .addClass(o.options.className)
        .css({
          top: startPosition.top,
          left: startPosition.left,
          height: elem.innerHeight(),
          width: elem.innerWidth(),
          position: 'absolute'
        })
        .animate(animation, o.duration, o.options.easing, function() {
          transfer.remove();
          (o.callback && o.callback.apply(elem[0], arguments));
          elem.dequeue();
        });
  });
};

})(jQuery);


// assets/js/bundle/third_party/jquery/typeahead.js
/**
 * This file contains an unaltered copy of the typeahead.js 0.9.3 code.
 *
 * Do not change it, simply monkey-patch if (absolutely) necessary.
 */

goog.provide("optly.jquery.typeahead");

goog.require("optly.jquery");

/*!
 * typeahead.js 0.9.3
 * https://github.com/twitter/typeahead
 * Copyright 2013 Twitter, Inc. and other contributors; Licensed MIT
 */

(function($, window) {
    var VERSION = "0.9.3";
    var utils = {
        isMsie: function() {
            var match = /(msie) ([\w.]+)/i.exec(navigator.userAgent);
            return match ? parseInt(match[2], 10) : false;
        },
        isBlankString: function(str) {
            return !str || /^\s*$/.test(str);
        },
        escapeRegExChars: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        },
        isString: function(obj) {
            return typeof obj === "string";
        },
        isNumber: function(obj) {
            return typeof obj === "number";
        },
        isArray: $.isArray,
        isFunction: $.isFunction,
        isObject: $.isPlainObject,
        isUndefined: function(obj) {
            return typeof obj === "undefined";
        },
        bind: $.proxy,
        bindAll: function(obj) {
            var val;
            for (var key in obj) {
                $.isFunction(val = obj[key]) && (obj[key] = $.proxy(val, obj));
            }
        },
        indexOf: function(haystack, needle) {
            for (var i = 0; i < haystack.length; i++) {
                if (haystack[i] === needle) {
                    return i;
                }
            }
            return -1;
        },
        each: $.each,
        map: $.map,
        filter: $.grep,
        every: function(obj, test) {
            var result = true;
            if (!obj) {
                return result;
            }
            $.each(obj, function(key, val) {
                if (!(result = test.call(null, val, key, obj))) {
                    return false;
                }
            });
            return !!result;
        },
        some: function(obj, test) {
            var result = false;
            if (!obj) {
                return result;
            }
            $.each(obj, function(key, val) {
                if (result = test.call(null, val, key, obj)) {
                    return false;
                }
            });
            return !!result;
        },
        mixin: $.extend,
        getUniqueId: function() {
            var counter = 0;
            return function() {
                return counter++;
            };
        }(),
        defer: function(fn) {
            setTimeout(fn, 0);
        },
        debounce: function(func, wait, immediate) {
            var timeout, result;
            return function() {
                var context = this, args = arguments, later, callNow;
                later = function() {
                    timeout = null;
                    if (!immediate) {
                        result = func.apply(context, args);
                    }
                };
                callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) {
                    result = func.apply(context, args);
                }
                return result;
            };
        },
        throttle: function(func, wait) {
            var context, args, timeout, result, previous, later;
            previous = 0;
            later = function() {
                previous = new Date();
                timeout = null;
                result = func.apply(context, args);
            };
            return function() {
                var now = new Date(), remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                    clearTimeout(timeout);
                    timeout = null;
                    previous = now;
                    result = func.apply(context, args);
                } else if (!timeout) {
                    timeout = setTimeout(later, remaining);
                }
                return result;
            };
        },
        tokenizeQuery: function(str) {
            return $.trim(str).toLowerCase().split(/[\s]+/);
        },
        tokenizeText: function(str) {
            return $.trim(str).toLowerCase().split(/[\s\-_]+/);
        },
        getProtocol: function() {
            return location.protocol;
        },
        noop: function() {}
    };
    var EventTarget = function() {
        var eventSplitter = /\s+/;
        return {
            on: function(events, callback) {
                var event;
                if (!callback) {
                    return this;
                }
                this._callbacks = this._callbacks || {};
                events = events.split(eventSplitter);
                while (event = events.shift()) {
                    this._callbacks[event] = this._callbacks[event] || [];
                    this._callbacks[event].push(callback);
                }
                return this;
            },
            trigger: function(events, data) {
                var event, callbacks;
                if (!this._callbacks) {
                    return this;
                }
                events = events.split(eventSplitter);
                while (event = events.shift()) {
                    if (callbacks = this._callbacks[event]) {
                        for (var i = 0; i < callbacks.length; i += 1) {
                            callbacks[i].call(this, {
                                type: event,
                                data: data
                            });
                        }
                    }
                }
                return this;
            }
        };
    }();
    var EventBus = function() {
        var namespace = "typeahead:";
        function EventBus(o) {
            if (!o || !o.el) {
                $.error("EventBus initialized without el");
            }
            this.$el = $(o.el);
        }
        utils.mixin(EventBus.prototype, {
            trigger: function(type) {
                var args = [].slice.call(arguments, 1);
                this.$el.trigger(namespace + type, args);
            }
        });
        return EventBus;
    }();
    var PersistentStorage = function() {
        var ls, methods;
        try {
            ls = window.localStorage;
            ls.setItem("~~~", "!");
            ls.removeItem("~~~");
        } catch (err) {
            ls = null;
        }
        function PersistentStorage(namespace) {
            this.prefix = [ "__", namespace, "__" ].join("");
            this.ttlKey = "__ttl__";
            this.keyMatcher = new RegExp("^" + this.prefix);
        }
        if (ls && window.JSON) {
            methods = {
                _prefix: function(key) {
                    return this.prefix + key;
                },
                _ttlKey: function(key) {
                    return this._prefix(key) + this.ttlKey;
                },
                get: function(key) {
                    if (this.isExpired(key)) {
                        this.remove(key);
                    }
                    return decode(ls.getItem(this._prefix(key)));
                },
                set: function(key, val, ttl) {
                    if (utils.isNumber(ttl)) {
                        ls.setItem(this._ttlKey(key), encode(now() + ttl));
                    } else {
                        ls.removeItem(this._ttlKey(key));
                    }
                    return ls.setItem(this._prefix(key), encode(val));
                },
                remove: function(key) {
                    ls.removeItem(this._ttlKey(key));
                    ls.removeItem(this._prefix(key));
                    return this;
                },
                clear: function() {
                    var i, key, keys = [], len = ls.length;
                    for (i = 0; i < len; i++) {
                        if ((key = ls.key(i)).match(this.keyMatcher)) {
                            keys.push(key.replace(this.keyMatcher, ""));
                        }
                    }
                    for (i = keys.length; i--; ) {
                        this.remove(keys[i]);
                    }
                    return this;
                },
                isExpired: function(key) {
                    var ttl = decode(ls.getItem(this._ttlKey(key)));
                    return utils.isNumber(ttl) && now() > ttl ? true : false;
                }
            };
        } else {
            methods = {
                get: utils.noop,
                set: utils.noop,
                remove: utils.noop,
                clear: utils.noop,
                isExpired: utils.noop
            };
        }
        utils.mixin(PersistentStorage.prototype, methods);
        return PersistentStorage;
        function now() {
            return new Date().getTime();
        }
        function encode(val) {
            return JSON.stringify(utils.isUndefined(val) ? null : val);
        }
        function decode(val) {
            return JSON.parse(val);
        }
    }();
    var RequestCache = function() {
        function RequestCache(o) {
            utils.bindAll(this);
            o = o || {};
            this.sizeLimit = o.sizeLimit || 10;
            this.cache = {};
            this.cachedKeysByAge = [];
        }
        utils.mixin(RequestCache.prototype, {
            get: function(url) {
                return this.cache[url];
            },
            set: function(url, resp) {
                var requestToEvict;
                if (this.cachedKeysByAge.length === this.sizeLimit) {
                    requestToEvict = this.cachedKeysByAge.shift();
                    delete this.cache[requestToEvict];
                }
                this.cache[url] = resp;
                this.cachedKeysByAge.push(url);
            }
        });
        return RequestCache;
    }();
    var Transport = function() {
        var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests, requestCache;
        function Transport(o) {
            utils.bindAll(this);
            o = utils.isString(o) ? {
                url: o
            } : o;
            requestCache = requestCache || new RequestCache();
            maxPendingRequests = utils.isNumber(o.maxParallelRequests) ? o.maxParallelRequests : maxPendingRequests || 6;
            this.url = o.url;
            this.wildcard = o.wildcard || "%QUERY";
            this.filter = o.filter;
            this.replace = o.replace;
            this.ajaxSettings = {
                type: "get",
                cache: o.cache,
                timeout: o.timeout,
                dataType: o.dataType || "json",
                beforeSend: o.beforeSend
            };
            this._get = (/^throttle$/i.test(o.rateLimitFn) ? utils.throttle : utils.debounce)(this._get, o.rateLimitWait || 300);
        }
        utils.mixin(Transport.prototype, {
            _get: function(url, cb) {
                var that = this;
                if (belowPendingRequestsThreshold()) {
                    this._sendRequest(url).done(done);
                } else {
                    this.onDeckRequestArgs = [].slice.call(arguments, 0);
                }
                function done(resp) {
                    var data = that.filter ? that.filter(resp) : resp;
                    cb && cb(data);
                    requestCache.set(url, resp);
                }
            },
            _sendRequest: function(url) {
                var that = this, jqXhr = pendingRequests[url];
                if (!jqXhr) {
                    incrementPendingRequests();
                    jqXhr = pendingRequests[url] = $.ajax(url, this.ajaxSettings).always(always);
                }
                return jqXhr;
                function always() {
                    decrementPendingRequests();
                    pendingRequests[url] = null;
                    if (that.onDeckRequestArgs) {
                        that._get.apply(that, that.onDeckRequestArgs);
                        that.onDeckRequestArgs = null;
                    }
                }
            },
            get: function(query, cb) {
                var that = this, encodedQuery = encodeURIComponent(query || ""), url, resp;
                cb = cb || utils.noop;
                url = this.replace ? this.replace(this.url, encodedQuery) : this.url.replace(this.wildcard, encodedQuery);
                if (resp = requestCache.get(url)) {
                    utils.defer(function() {
                        cb(that.filter ? that.filter(resp) : resp);
                    });
                } else {
                    this._get(url, cb);
                }
                return !!resp;
            }
        });
        return Transport;
        function incrementPendingRequests() {
            pendingRequestsCount++;
        }
        function decrementPendingRequests() {
            pendingRequestsCount--;
        }
        function belowPendingRequestsThreshold() {
            return pendingRequestsCount < maxPendingRequests;
        }
    }();
    var Dataset = function() {
        var keys = {
            thumbprint: "thumbprint",
            protocol: "protocol",
            itemHash: "itemHash",
            adjacencyList: "adjacencyList"
        };
        function Dataset(o) {
            utils.bindAll(this);
            if (utils.isString(o.template) && !o.engine) {
                $.error("no template engine specified");
            }
            if (!o.local && !o.prefetch && !o.remote) {
                $.error("one of local, prefetch, or remote is required");
            }
            this.name = o.name || utils.getUniqueId();
            this.limit = o.limit || 5;
            this.minLength = o.minLength || 1;
            this.header = o.header;
            this.footer = o.footer;
            this.valueKey = o.valueKey || "value";
            this.template = compileTemplate(o.template, o.engine, this.valueKey);
            this.local = o.local;
            this.prefetch = o.prefetch;
            this.remote = o.remote;
            this.itemHash = {};
            this.adjacencyList = {};
            this.storage = o.name ? new PersistentStorage(o.name) : null;
        }
        utils.mixin(Dataset.prototype, {
            _processLocalData: function(data) {
                this._mergeProcessedData(this._processData(data));
            },
            _loadPrefetchData: function(o) {
                var that = this, thumbprint = VERSION + (o.thumbprint || ""), storedThumbprint, storedProtocol, storedItemHash, storedAdjacencyList, isExpired, deferred;
                if (this.storage) {
                    storedThumbprint = this.storage.get(keys.thumbprint);
                    storedProtocol = this.storage.get(keys.protocol);
                    storedItemHash = this.storage.get(keys.itemHash);
                    storedAdjacencyList = this.storage.get(keys.adjacencyList);
                }
                isExpired = storedThumbprint !== thumbprint || storedProtocol !== utils.getProtocol();
                o = utils.isString(o) ? {
                    url: o
                } : o;
                o.ttl = utils.isNumber(o.ttl) ? o.ttl : 24 * 60 * 60 * 1e3;
                if (storedItemHash && storedAdjacencyList && !isExpired) {
                    this._mergeProcessedData({
                        itemHash: storedItemHash,
                        adjacencyList: storedAdjacencyList
                    });
                    deferred = $.Deferred().resolve();
                } else {
                    deferred = $.getJSON(o.url).done(processPrefetchData);
                }
                return deferred;
                function processPrefetchData(data) {
                    var filteredData = o.filter ? o.filter(data) : data, processedData = that._processData(filteredData), itemHash = processedData.itemHash, adjacencyList = processedData.adjacencyList;
                    if (that.storage) {
                        that.storage.set(keys.itemHash, itemHash, o.ttl);
                        that.storage.set(keys.adjacencyList, adjacencyList, o.ttl);
                        that.storage.set(keys.thumbprint, thumbprint, o.ttl);
                        that.storage.set(keys.protocol, utils.getProtocol(), o.ttl);
                    }
                    that._mergeProcessedData(processedData);
                }
            },
            _transformDatum: function(datum) {
                var value = utils.isString(datum) ? datum : datum[this.valueKey], tokens = datum.tokens || utils.tokenizeText(value), item = {
                    value: value,
                    tokens: tokens
                };
                if (utils.isString(datum)) {
                    item.datum = {};
                    item.datum[this.valueKey] = datum;
                } else {
                    item.datum = datum;
                }
                item.tokens = utils.filter(item.tokens, function(token) {
                    return !utils.isBlankString(token);
                });
                item.tokens = utils.map(item.tokens, function(token) {
                    return token.toLowerCase();
                });
                return item;
            },
            _processData: function(data) {
                var that = this, itemHash = {}, adjacencyList = {};
                utils.each(data, function(i, datum) {
                    var item = that._transformDatum(datum), id = utils.getUniqueId(item.value);
                    itemHash[id] = item;
                    utils.each(item.tokens, function(i, token) {
                        var character = token.charAt(0), adjacency = adjacencyList[character] || (adjacencyList[character] = [ id ]);
                        !~utils.indexOf(adjacency, id) && adjacency.push(id);
                    });
                });
                return {
                    itemHash: itemHash,
                    adjacencyList: adjacencyList
                };
            },
            _mergeProcessedData: function(processedData) {
                var that = this;
                utils.mixin(this.itemHash, processedData.itemHash);
                utils.each(processedData.adjacencyList, function(character, adjacency) {
                    var masterAdjacency = that.adjacencyList[character];
                    that.adjacencyList[character] = masterAdjacency ? masterAdjacency.concat(adjacency) : adjacency;
                });
            },
            _getLocalSuggestions: function(terms) {
                var that = this, firstChars = [], lists = [], shortestList, suggestions = [];
                utils.each(terms, function(i, term) {
                    var firstChar = term.charAt(0);
                    !~utils.indexOf(firstChars, firstChar) && firstChars.push(firstChar);
                });
                utils.each(firstChars, function(i, firstChar) {
                    var list = that.adjacencyList[firstChar];
                    if (!list) {
                        return false;
                    }
                    lists.push(list);
                    if (!shortestList || list.length < shortestList.length) {
                        shortestList = list;
                    }
                });
                if (lists.length < firstChars.length) {
                    return [];
                }
                utils.each(shortestList, function(i, id) {
                    var item = that.itemHash[id], isCandidate, isMatch;
                    isCandidate = utils.every(lists, function(list) {
                        return ~utils.indexOf(list, id);
                    });
                    isMatch = isCandidate && utils.every(terms, function(term) {
                        return utils.some(item.tokens, function(token) {
                            return token.indexOf(term) === 0;
                        });
                    });
                    isMatch && suggestions.push(item);
                });
                return suggestions;
            },
            initialize: function() {
                var deferred;
                this.local && this._processLocalData(this.local);
                this.transport = this.remote ? new Transport(this.remote) : null;
                deferred = this.prefetch ? this._loadPrefetchData(this.prefetch) : $.Deferred().resolve();
                this.local = this.prefetch = this.remote = null;
                this.initialize = function() {
                    return deferred;
                };
                return deferred;
            },
            getSuggestions: function(query, cb) {
                var that = this, terms, suggestions, cacheHit = false;
                if (query.length < this.minLength) {
                    return;
                }
                terms = utils.tokenizeQuery(query);
                suggestions = this._getLocalSuggestions(terms).slice(0, this.limit);
                if (suggestions.length < this.limit && this.transport) {
                    cacheHit = this.transport.get(query, processRemoteData);
                }
                !cacheHit && cb && cb(suggestions);
                function processRemoteData(data) {
                    suggestions = suggestions.slice(0);
                    utils.each(data, function(i, datum) {
                        var item = that._transformDatum(datum), isDuplicate;
                        isDuplicate = utils.some(suggestions, function(suggestion) {
                            return item.value === suggestion.value;
                        });
                        !isDuplicate && suggestions.push(item);
                        return suggestions.length < that.limit;
                    });
                    cb && cb(suggestions);
                }
            }
        });
        return Dataset;
        function compileTemplate(template, engine, valueKey) {
            var renderFn, compiledTemplate;
            if (utils.isFunction(template)) {
                renderFn = template;
            } else if (utils.isString(template)) {
                compiledTemplate = engine.compile(template);
                renderFn = utils.bind(compiledTemplate.render, compiledTemplate);
            } else {
                renderFn = function(context) {
                    return "<p>" + context[valueKey] + "</p>";
                };
            }
            return renderFn;
        }
    }();
    var InputView = function() {
        function InputView(o) {
            var that = this;
            utils.bindAll(this);
            this.specialKeyCodeMap = {
                9: "tab",
                27: "esc",
                37: "left",
                39: "right",
                13: "enter",
                38: "up",
                40: "down"
            };
            this.$hint = $(o.hint);
            this.$input = $(o.input).on("blur.tt", this._handleBlur).on("focus.tt", this._handleFocus).on("keydown.tt", this._handleSpecialKeyEvent);
            if (!utils.isMsie()) {
                this.$input.on("input.tt", this._compareQueryToInputValue);
            } else {
                this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
                    if (that.specialKeyCodeMap[$e.which || $e.keyCode]) {
                        return;
                    }
                    utils.defer(that._compareQueryToInputValue);
                });
            }
            this.query = this.$input.val();
            this.$overflowHelper = buildOverflowHelper(this.$input);
        }
        utils.mixin(InputView.prototype, EventTarget, {
            _handleFocus: function() {
                this.trigger("focused");
            },
            _handleBlur: function() {
                this.trigger("blured");
            },
            _handleSpecialKeyEvent: function($e) {
                var keyName = this.specialKeyCodeMap[$e.which || $e.keyCode];
                keyName && this.trigger(keyName + "Keyed", $e);
            },
            _compareQueryToInputValue: function() {
                var inputValue = this.getInputValue(), isSameQuery = compareQueries(this.query, inputValue), isSameQueryExceptWhitespace = isSameQuery ? this.query.length !== inputValue.length : false;
                if (isSameQueryExceptWhitespace) {
                    this.trigger("whitespaceChanged", {
                        value: this.query
                    });
                } else if (!isSameQuery) {
                    this.trigger("queryChanged", {
                        value: this.query = inputValue
                    });
                }
            },
            destroy: function() {
                this.$hint.off(".tt");
                this.$input.off(".tt");
                this.$hint = this.$input = this.$overflowHelper = null;
            },
            focus: function() {
                this.$input.focus();
            },
            blur: function() {
                this.$input.blur();
            },
            getQuery: function() {
                return this.query;
            },
            setQuery: function(query) {
                this.query = query;
            },
            getInputValue: function() {
                return this.$input.val();
            },
            setInputValue: function(value, silent) {
                this.$input.val(value);
                !silent && this._compareQueryToInputValue();
            },
            getHintValue: function() {
                return this.$hint.val();
            },
            setHintValue: function(value) {
                this.$hint.val(value);
            },
            getLanguageDirection: function() {
                return (this.$input.css("direction") || "ltr").toLowerCase();
            },
            isOverflow: function() {
                this.$overflowHelper.text(this.getInputValue());
                return this.$overflowHelper.width() > this.$input.width();
            },
            isCursorAtEnd: function() {
                var valueLength = this.$input.val().length, selectionStart = this.$input[0].selectionStart, range;
                if (utils.isNumber(selectionStart)) {
                    return selectionStart === valueLength;
                } else if (document.selection) {
                    range = document.selection.createRange();
                    range.moveStart("character", -valueLength);
                    return valueLength === range.text.length;
                }
                return true;
            }
        });
        return InputView;
        function buildOverflowHelper($input) {
            return $("<span></span>").css({
                position: "absolute",
                left: "-9999px",
                visibility: "hidden",
                whiteSpace: "nowrap",
                fontFamily: $input.css("font-family"),
                fontSize: $input.css("font-size"),
                fontStyle: $input.css("font-style"),
                fontVariant: $input.css("font-variant"),
                fontWeight: $input.css("font-weight"),
                wordSpacing: $input.css("word-spacing"),
                letterSpacing: $input.css("letter-spacing"),
                textIndent: $input.css("text-indent"),
                textRendering: $input.css("text-rendering"),
                textTransform: $input.css("text-transform")
            }).insertAfter($input);
        }
        function compareQueries(a, b) {
            a = (a || "").replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
            b = (b || "").replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
            return a === b;
        }
    }();
    var DropdownView = function() {
        var html = {
            suggestionsList: '<span class="tt-suggestions"></span>'
        }, css = {
            suggestionsList: {
                display: "block"
            },
            suggestion: {
                whiteSpace: "nowrap",
                cursor: "pointer"
            },
            suggestionChild: {
                whiteSpace: "normal"
            }
        };
        function DropdownView(o) {
            utils.bindAll(this);
            this.isOpen = false;
            this.isEmpty = true;
            this.isMouseOverDropdown = false;
            this.$menu = $(o.menu).on("mouseenter.tt", this._handleMouseenter).on("mouseleave.tt", this._handleMouseleave).on("click.tt", ".tt-suggestion", this._handleSelection).on("mouseover.tt", ".tt-suggestion", this._handleMouseover);
        }
        utils.mixin(DropdownView.prototype, EventTarget, {
            _handleMouseenter: function() {
                this.isMouseOverDropdown = true;
            },
            _handleMouseleave: function() {
                this.isMouseOverDropdown = false;
            },
            _handleMouseover: function($e) {
                var $suggestion = $($e.currentTarget);
                this._getSuggestions().removeClass("tt-is-under-cursor");
                $suggestion.addClass("tt-is-under-cursor");
            },
            _handleSelection: function($e) {
                var $suggestion = $($e.currentTarget);
                this.trigger("suggestionSelected", extractSuggestion($suggestion));
            },
            _show: function() {
                this.$menu.css("display", "block");
            },
            _hide: function() {
                this.$menu.hide();
            },
            _moveCursor: function(increment) {
                var $suggestions, $cur, nextIndex, $underCursor;
                if (!this.isVisible()) {
                    return;
                }
                $suggestions = this._getSuggestions();
                $cur = $suggestions.filter(".tt-is-under-cursor");
                $cur.removeClass("tt-is-under-cursor");
                nextIndex = $suggestions.index($cur) + increment;
                nextIndex = (nextIndex + 1) % ($suggestions.length + 1) - 1;
                if (nextIndex === -1) {
                    this.trigger("cursorRemoved");
                    return;
                } else if (nextIndex < -1) {
                    nextIndex = $suggestions.length - 1;
                }
                $underCursor = $suggestions.eq(nextIndex).addClass("tt-is-under-cursor");
                this._ensureVisibility($underCursor);
                this.trigger("cursorMoved", extractSuggestion($underCursor));
            },
            _getSuggestions: function() {
                return this.$menu.find(".tt-suggestions > .tt-suggestion");
            },
            _ensureVisibility: function($el) {
                var menuHeight = this.$menu.height() + parseInt(this.$menu.css("paddingTop"), 10) + parseInt(this.$menu.css("paddingBottom"), 10), menuScrollTop = this.$menu.scrollTop(), elTop = $el.position().top, elBottom = elTop + $el.outerHeight(true);
                if (elTop < 0) {
                    this.$menu.scrollTop(menuScrollTop + elTop);
                } else if (menuHeight < elBottom) {
                    this.$menu.scrollTop(menuScrollTop + (elBottom - menuHeight));
                }
            },
            destroy: function() {
                this.$menu.off(".tt");
                this.$menu = null;
            },
            isVisible: function() {
                return this.isOpen && !this.isEmpty;
            },
            closeUnlessMouseIsOverDropdown: function() {
                if (!this.isMouseOverDropdown) {
                    this.close();
                }
            },
            close: function() {
                if (this.isOpen) {
                    this.isOpen = false;
                    this.isMouseOverDropdown = false;
                    this._hide();
                    this.$menu.find(".tt-suggestions > .tt-suggestion").removeClass("tt-is-under-cursor");
                    this.trigger("closed");
                }
            },
            open: function() {
                if (!this.isOpen) {
                    this.isOpen = true;
                    !this.isEmpty && this._show();
                    this.trigger("opened");
                }
            },
            setLanguageDirection: function(dir) {
                var ltrCss = {
                    left: "0",
                    right: "auto"
                }, rtlCss = {
                    left: "auto",
                    right: " 0"
                };
                dir === "ltr" ? this.$menu.css(ltrCss) : this.$menu.css(rtlCss);
            },
            moveCursorUp: function() {
                this._moveCursor(-1);
            },
            moveCursorDown: function() {
                this._moveCursor(+1);
            },
            getSuggestionUnderCursor: function() {
                var $suggestion = this._getSuggestions().filter(".tt-is-under-cursor").first();
                return $suggestion.length > 0 ? extractSuggestion($suggestion) : null;
            },
            getFirstSuggestion: function() {
                var $suggestion = this._getSuggestions().first();
                return $suggestion.length > 0 ? extractSuggestion($suggestion) : null;
            },
            renderSuggestions: function(dataset, suggestions) {
                var datasetClassName = "tt-dataset-" + dataset.name, wrapper = '<div class="tt-suggestion">%body</div>', compiledHtml, $suggestionsList, $dataset = this.$menu.find("." + datasetClassName), elBuilder, fragment, $el;
                if ($dataset.length === 0) {
                    $suggestionsList = $(html.suggestionsList).css(css.suggestionsList);
                    $dataset = $("<div></div>").addClass(datasetClassName).append(dataset.header).append($suggestionsList).append(dataset.footer).appendTo(this.$menu);
                }
                if (suggestions.length > 0) {
                    this.isEmpty = false;
                    this.isOpen && this._show();
                    elBuilder = document.createElement("div");
                    fragment = document.createDocumentFragment();
                    utils.each(suggestions, function(i, suggestion) {
                        suggestion.dataset = dataset.name;
                        compiledHtml = dataset.template(suggestion.datum);
                        elBuilder.innerHTML = wrapper.replace("%body", compiledHtml);
                        $el = $(elBuilder.firstChild).css(css.suggestion).data("suggestion", suggestion);
                        $el.children().each(function() {
                            $(this).css(css.suggestionChild);
                        });
                        fragment.appendChild($el[0]);
                    });
                    $dataset.show().find(".tt-suggestions").html(fragment);
                } else {
                    this.clearSuggestions(dataset.name);
                }
                this.trigger("suggestionsRendered");
            },
            clearSuggestions: function(datasetName) {
                var $datasets = datasetName ? this.$menu.find(".tt-dataset-" + datasetName) : this.$menu.find('[class^="tt-dataset-"]'), $suggestions = $datasets.find(".tt-suggestions");
                $datasets.hide();
                $suggestions.empty();
                if (this._getSuggestions().length === 0) {
                    this.isEmpty = true;
                    this._hide();
                }
            }
        });
        return DropdownView;
        function extractSuggestion($el) {
            return $el.data("suggestion");
        }
    }();
    var TypeaheadView = function() {
        var html = {
            wrapper: '<span class="twitter-typeahead"></span>',
            hint: '<input class="tt-hint" type="text" autocomplete="off" spellcheck="off" disabled>',
            dropdown: '<span class="tt-dropdown-menu"></span>'
        }, css = {
            wrapper: {
                position: "relative",
                display: "inline-block"
            },
            hint: {
                position: "absolute",
                top: "0",
                left: "0",
                borderColor: "transparent",
                boxShadow: "none"
            },
            query: {
                position: "relative",
                verticalAlign: "top",
                backgroundColor: "transparent"
            },
            dropdown: {
                position: "absolute",
                top: "100%",
                left: "0",
                zIndex: "100",
                display: "none"
            }
        };
        if (utils.isMsie()) {
            utils.mixin(css.query, {
                backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
            });
        }
        if (utils.isMsie() && utils.isMsie() <= 7) {
            utils.mixin(css.wrapper, {
                display: "inline",
                zoom: "1"
            });
            utils.mixin(css.query, {
                marginTop: "-1px"
            });
        }
        function TypeaheadView(o) {
            var $menu, $input, $hint;
            utils.bindAll(this);
            this.$node = buildDomStructure(o.input);
            this.datasets = o.datasets;
            this.dir = null;
            this.eventBus = o.eventBus;
            $menu = this.$node.find(".tt-dropdown-menu");
            $input = this.$node.find(".tt-query");
            $hint = this.$node.find(".tt-hint");
            this.dropdownView = new DropdownView({
                menu: $menu
            }).on("suggestionSelected", this._handleSelection).on("cursorMoved", this._clearHint).on("cursorMoved", this._setInputValueToSuggestionUnderCursor).on("cursorRemoved", this._setInputValueToQuery).on("cursorRemoved", this._updateHint).on("suggestionsRendered", this._updateHint).on("opened", this._updateHint).on("closed", this._clearHint).on("opened closed", this._propagateEvent);
            this.inputView = new InputView({
                input: $input,
                hint: $hint
            }).on("focused", this._openDropdown).on("blured", this._closeDropdown).on("blured", this._setInputValueToQuery).on("enterKeyed tabKeyed", this._handleSelection).on("queryChanged", this._clearHint).on("queryChanged", this._clearSuggestions).on("queryChanged", this._getSuggestions).on("whitespaceChanged", this._updateHint).on("queryChanged whitespaceChanged", this._openDropdown).on("queryChanged whitespaceChanged", this._setLanguageDirection).on("escKeyed", this._closeDropdown).on("escKeyed", this._setInputValueToQuery).on("tabKeyed upKeyed downKeyed", this._managePreventDefault).on("upKeyed downKeyed", this._moveDropdownCursor).on("upKeyed downKeyed", this._openDropdown).on("tabKeyed leftKeyed rightKeyed", this._autocomplete);
        }
        utils.mixin(TypeaheadView.prototype, EventTarget, {
            _managePreventDefault: function(e) {
                var $e = e.data, hint, inputValue, preventDefault = false;
                switch (e.type) {
                  case "tabKeyed":
                    hint = this.inputView.getHintValue();
                    inputValue = this.inputView.getInputValue();
                    preventDefault = hint && hint !== inputValue;
                    break;

                  case "upKeyed":
                  case "downKeyed":
                    preventDefault = !$e.shiftKey && !$e.ctrlKey && !$e.metaKey;
                    break;
                }
                preventDefault && $e.preventDefault();
            },
            _setLanguageDirection: function() {
                var dir = this.inputView.getLanguageDirection();
                if (dir !== this.dir) {
                    this.dir = dir;
                    this.$node.css("direction", dir);
                    this.dropdownView.setLanguageDirection(dir);
                }
            },
            _updateHint: function() {
                var suggestion = this.dropdownView.getFirstSuggestion(), hint = suggestion ? suggestion.value : null, dropdownIsVisible = this.dropdownView.isVisible(), inputHasOverflow = this.inputView.isOverflow(), inputValue, query, escapedQuery, beginsWithQuery, match;
                if (hint && dropdownIsVisible && !inputHasOverflow) {
                    inputValue = this.inputView.getInputValue();
                    query = inputValue.replace(/\s{2,}/g, " ").replace(/^\s+/g, "");
                    escapedQuery = utils.escapeRegExChars(query);
                    beginsWithQuery = new RegExp("^(?:" + escapedQuery + ")(.*$)", "i");
                    match = beginsWithQuery.exec(hint);
                    this.inputView.setHintValue(inputValue + (match ? match[1] : ""));
                }
            },
            _clearHint: function() {
                this.inputView.setHintValue("");
            },
            _clearSuggestions: function() {
                this.dropdownView.clearSuggestions();
            },
            _setInputValueToQuery: function() {
                this.inputView.setInputValue(this.inputView.getQuery());
            },
            _setInputValueToSuggestionUnderCursor: function(e) {
                var suggestion = e.data;
                this.inputView.setInputValue(suggestion.value, true);
            },
            _openDropdown: function() {
                this.dropdownView.open();
            },
            _closeDropdown: function(e) {
                this.dropdownView[e.type === "blured" ? "closeUnlessMouseIsOverDropdown" : "close"]();
            },
            _moveDropdownCursor: function(e) {
                var $e = e.data;
                if (!$e.shiftKey && !$e.ctrlKey && !$e.metaKey) {
                    this.dropdownView[e.type === "upKeyed" ? "moveCursorUp" : "moveCursorDown"]();
                }
            },
            _handleSelection: function(e) {
                var byClick = e.type === "suggestionSelected", suggestion = byClick ? e.data : this.dropdownView.getSuggestionUnderCursor();
                if (suggestion) {
                    this.inputView.setInputValue(suggestion.value);
                    byClick ? this.inputView.focus() : e.data.preventDefault();
                    byClick && utils.isMsie() ? utils.defer(this.dropdownView.close) : this.dropdownView.close();
                    this.eventBus.trigger("selected", suggestion.datum, suggestion.dataset);
                }
            },
            _getSuggestions: function() {
                var that = this, query = this.inputView.getQuery();
                if (utils.isBlankString(query)) {
                    return;
                }
                utils.each(this.datasets, function(i, dataset) {
                    dataset.getSuggestions(query, function(suggestions) {
                        if (query === that.inputView.getQuery()) {
                            that.dropdownView.renderSuggestions(dataset, suggestions);
                        }
                    });
                });
            },
            _autocomplete: function(e) {
                var isCursorAtEnd, ignoreEvent, query, hint, suggestion;
                if (e.type === "rightKeyed" || e.type === "leftKeyed") {
                    isCursorAtEnd = this.inputView.isCursorAtEnd();
                    ignoreEvent = this.inputView.getLanguageDirection() === "ltr" ? e.type === "leftKeyed" : e.type === "rightKeyed";
                    if (!isCursorAtEnd || ignoreEvent) {
                        return;
                    }
                }
                query = this.inputView.getQuery();
                hint = this.inputView.getHintValue();
                if (hint !== "" && query !== hint) {
                    suggestion = this.dropdownView.getFirstSuggestion();
                    this.inputView.setInputValue(suggestion.value);
                    this.eventBus.trigger("autocompleted", suggestion.datum, suggestion.dataset);
                }
            },
            _propagateEvent: function(e) {
                this.eventBus.trigger(e.type);
            },
            destroy: function() {
                this.inputView.destroy();
                this.dropdownView.destroy();
                destroyDomStructure(this.$node);
                this.$node = null;
            },
            setQuery: function(query) {
                this.inputView.setQuery(query);
                this.inputView.setInputValue(query);
                this._clearHint();
                this._clearSuggestions();
                this._getSuggestions();
            }
        });
        return TypeaheadView;
        function buildDomStructure(input) {
            var $wrapper = $(html.wrapper), $dropdown = $(html.dropdown), $input = $(input), $hint = $(html.hint);
            $wrapper = $wrapper.css(css.wrapper);
            $dropdown = $dropdown.css(css.dropdown);
            $hint.css(css.hint).css({
                backgroundAttachment: $input.css("background-attachment"),
                backgroundClip: $input.css("background-clip"),
                backgroundColor: $input.css("background-color"),
                backgroundImage: $input.css("background-image"),
                backgroundOrigin: $input.css("background-origin"),
                backgroundPosition: $input.css("background-position"),
                backgroundRepeat: $input.css("background-repeat"),
                backgroundSize: $input.css("background-size")
            });
            $input.data("ttAttrs", {
                dir: $input.attr("dir"),
                autocomplete: $input.attr("autocomplete"),
                spellcheck: $input.attr("spellcheck"),
                style: $input.attr("style")
            });
            $input.addClass("tt-query").attr({
                autocomplete: "off",
                spellcheck: false
            }).css(css.query);
            try {
                !$input.attr("dir") && $input.attr("dir", "auto");
            } catch (e) {}
            return $input.wrap($wrapper).parent().prepend($hint).append($dropdown);
        }
        function destroyDomStructure($node) {
            var $input = $node.find(".tt-query");
            utils.each($input.data("ttAttrs"), function(key, val) {
                utils.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
            });
            $input.detach().removeData("ttAttrs").removeClass("tt-query").insertAfter($node);
            $node.remove();
        }
    }();
    (function() {
        var cache = {}, viewKey = "ttView", methods;
        methods = {
            initialize: function(datasetDefs) {
                var datasets;
                datasetDefs = utils.isArray(datasetDefs) ? datasetDefs : [ datasetDefs ];
                if (datasetDefs.length === 0) {
                    $.error("no datasets provided");
                }
                datasets = utils.map(datasetDefs, function(o) {
                    var dataset = cache[o.name] ? cache[o.name] : new Dataset(o);
                    if (o.name) {
                        cache[o.name] = dataset;
                    }
                    return dataset;
                });
                return this.each(initialize);
                function initialize() {
                    var $input = $(this), deferreds, eventBus = new EventBus({
                        el: $input
                    });
                    deferreds = utils.map(datasets, function(dataset) {
                        return dataset.initialize();
                    });
                    $input.data(viewKey, new TypeaheadView({
                        input: $input,
                        eventBus: eventBus = new EventBus({
                            el: $input
                        }),
                        datasets: datasets
                    }));
                    $.when.apply($, deferreds).always(function() {
                        utils.defer(function() {
                            eventBus.trigger("initialized");
                        });
                    });
                }
            },
            destroy: function() {
                return this.each(destroy);
                function destroy() {
                    var $this = $(this), view = $this.data(viewKey);
                    if (view) {
                        view.destroy();
                        $this.removeData(viewKey);
                    }
                }
            },
            setQuery: function(query) {
                return this.each(setQuery);
                function setQuery() {
                    var view = $(this).data(viewKey);
                    view && view.setQuery(query);
                }
            }
        };
        jQuery.fn.typeahead = function(method) {
            if (methods[method]) {
                return methods[method].apply(this, [].slice.call(arguments, 1));
            } else {
                return methods.initialize.apply(this, arguments);
            }
        };
    })();
})(jQuery, window);


// assets/js/bundle/backend/request.js
goog.provide("optly.backend.Request");

/**
 * @constructor
 */
optly.backend.Request = function(apiPrefix, mode, pathParam, queryParams) {
  this.apiPrefix = apiPrefix;
  this.mode = mode;
  this.pathParam = pathParam;
  this.queryParams = queryParams;
  this.VERSION = "v1";
}

optly.backend.Request.prototype.buildRequest = function() {
  var parameters = {
    data: this.queryParams,
    dataType: "jsonp",
    optimizelyRetryLimit: 3,
    url: this.getUrl()
  };

  return $.ajax(parameters)
}

/**
 * @private
 */
optly.backend.Request.prototype.getUrl = function() {
  // If API prefix doesn't end with a slash /, append a slash /
  var prefix = this.apiPrefix;
  if (prefix[prefix.length - 1] !== '/') {
    prefix += '/';
  }

  return sprintf("%s%s/%s/%s", prefix, this.VERSION, this.mode, this.pathParam);
}


// assets/js/bundle/backend/usage.js
goog.provide("optly.backend.Usage");

goog.require("optly.backend.Request");

/**
 * @constructor
 */
optly.backend.Usage = function(apiPrefix, accountId, accountToken) {
  this.apiPrefix = apiPrefix;
  this.accountId = accountId;
  this.accountToken = accountToken;
  this.data = {};
}


// assets/js/bundle/backend/results.js
goog.provide("optly.backend.Results");

goog.require("optly.backend.Request");

/**
 * @constructor
 */
optly.backend.Results = function(apiPrefix, earliest, experimentId, token) {
  this.apiPrefix = apiPrefix;
  this.experimentId = experimentId;
  this.begin = earliest;
  this.end = "";
  // Allow bucket count to be set via an Optimizely experiment.
  this.bucketCount = window['bucketCount'] || 100;
  this.fromCache = false;
  this.token = token;
  this.segmentId = "";
  this.segmentValue = "";
}

optly.backend.Results.prototype.makeRequest = function(options) {
  var data = {
    begin: this.begin,
    bucket_count: this.bucketCount,
    end: this.end,
    fromCache: this.fromCache,
    token: this.token
  };

  var request = new optly.backend.Request(this.apiPrefix, "results", this.experimentId, $.extend(data, options));
  return request.buildRequest();
}


// assets/js/bundle/backend/segments.js
goog.provide("optly.backend.Segments");

goog.require("optly.backend.Request");

/**
 * @constructor
 */
optly.backend.Segments = function(apiPrefix, experimentId, token) {
  this.apiPrefix = apiPrefix;
  this.experimentId = experimentId;
  this.token = token;
  this.data = {};
}

optly.backend.Segments.prototype.makeRequest = function(options) {
  var data = {
    token: this.token
  };

  var request = new optly.backend.Request(this.apiPrefix, "segment_values", this.experimentId, $.extend(data, options));
  return request.buildRequest().done(goog.bind(this.handleSuccess, this));
}

/**
 * @private
 */
optly.backend.Segments.prototype.handleSuccess = function(data) {
  this.data = data;
}


// assets/js/bundle/backend/visitors.js
goog.provide("optly.backend.Visitors");

goog.require("optly.backend.Request");

/**
 * @constructor
 */
optly.backend.Visitors = function(apiPrefix, projectId, projectToken) {
  this.apiPrefix = apiPrefix;
  this.projectId = projectId;
  this.projectToken = projectToken;
  this.data = {};
}

optly.backend.Visitors.prototype.makeRequests = function(experiments, options) {
  var data = $.extend({
    token: this.projectToken
  }, options);

  var experimentIds = experiments.map(function(experiment) { return experiment.id });
  var experimentStartTimes = experiments.map(function(experiment) { return experiment.earliest });

  // max experiment IDs for each request
  var MAX_LENGTH = 45;

  var requests = [];
  var index = 0;
  while (index < experimentIds.length) {
    data.experiment_ids = experimentIds.slice(index, index + MAX_LENGTH);
    data.experiment_start_times = experimentStartTimes.slice(index, index + MAX_LENGTH);
    index += data.experiment_ids.length;

    var request = new optly.backend.Request(this.apiPrefix, "visitors", this.projectId, data);
    requests.push(request.buildRequest().done(goog.bind(this.handleSuccess, this)));
  }

  return requests;
}

/**
 * @private
 */
optly.backend.Visitors.prototype.handleSuccess = function(data) {
  this.data = data;
}


// assets/js/bundle/backend/api.js
goog.provide("optly.backend.Api");

goog.require("optly.backend.Results");
goog.require("optly.backend.Segments");
goog.require("optly.backend.Usage");
goog.require("optly.backend.Visitors");

/**
 * @constructor
 * @param apiPrefix  - either api.optimizely.test or api.optimizely.com, specifies api suffix
 * @param projectId  - the project id for this api
 * @param projectToken - the authorization token for this api
 * @param queryApiInstance - the apiInstance specified in the query parameter "instance"
 * @param {string} [experimentApiInstance] - the apiInstance specified as part of this experiment
 */
optly.backend.Api = function(apiPrefix, projectId, projectToken, queryApiInstance, experimentApiInstance) {
  this.apiPrefix = apiPrefix;
  this.projectId = projectId;
  this.projectToken = projectToken;
  this.results = {};
  this.segments = {};
  this.usage = {};
  this.visitors = {};
  this.queryApiInstance = queryApiInstance;
  this.experimentApiInstance = experimentApiInstance;
}

/**
 * Resolve the correct URL to use for the backend API.
 *
 * Uses the apiPrefix as specified by the hidden input element
 * #api-prefix as the base.
 *
 * Modifies the apiPrefix default with using one of the following
 * (in order of decreasing precedence):
 *  - "instance" query parameter
 *  - experimentApiInstance - from account.get_backend_api_host(experiment)
 *  - customApiInstance - parameter to this function
 *  - "api" - the default
 *
 * @param {string} [customApiInstance] see above priority order
 *
 * @return {string} base URL for the backend API
 */
optly.backend.Api.prototype.getApiPrefix = function(customApiInstance) {
  var apiInstance =
    this.queryApiInstance ||
    this.experimentApiInstance ||
    customApiInstance;

  if (!apiInstance) {
    return this.apiPrefix;
  }

  return optly.backend.Api.makeApiPrefix(this.apiPrefix, apiInstance);
}

/**
 * Update the URL provided by apiPrefix with apiInstance and return new URL.
 * This is done by replacing the part before the first period `.` in the host of the URL.
 *
 * @returns {string} base URL for API requests in the form of http://api.optimizely.com
 */
optly.backend.Api.makeApiPrefix = function(apiPrefix, apiInstance) {
  // apiInstance parameter optionally contains a port number
  var apiInstanceParts = apiInstance.split(':');
  var apiHost = apiInstanceParts[0];
  var apiPort = apiInstanceParts[1];

  // Start with the default URL
  var uri = new URI(apiPrefix);

  // Modify port if specified by user
  if (apiPort) {
    uri.port(apiPort);
  }

  // Update the part of the hostname before teh first period
  // api.optimizely.com with apiInstance=override becomes override.optimizely.com
  var hostnameParts = uri.hostname().split('.');
  hostnameParts[0] = apiHost;
  uri.hostname(hostnameParts.join('.'));

  // serialize the URL back
  return uri.toString();
}

optly.backend.Api.prototype.makeResultsRequest = function(experimentId, earliest, token, options) {
  this.results = new optly.backend.Results(this.getApiPrefix(), earliest, experimentId, token);
  return this.results.makeRequest(options);
}

optly.backend.Api.prototype.makeVisitorRequests = function(experiments, options) {
  var experimentsByApiInstance = {};
  $.each(experiments, function(_, experiment) {
    // in the REST API it is `backend_api_host`
    var apiInstance = experiment.api_instance || experiment.backend_api_host;
    if (!apiInstance) {
      console.warn("No api instance given for experiment", experiment);
      apiInstance = "api";
    }

    if (!experimentsByApiInstance[apiInstance]) {
      experimentsByApiInstance[apiInstance] = [];
    }
    experimentsByApiInstance[apiInstance].push(experiment);
  });

  var visitorRequestPromises = [];
  var self = this;
  $.each(experimentsByApiInstance, function(apiInstance, experiments) {
    var visitors = new optly.backend.Visitors(self.getApiPrefix(apiInstance), self.projectId, self.projectToken);
    var requests = visitors.makeRequests(experiments, options);
    visitorRequestPromises = visitorRequestPromises.concat(requests);
  });
  return visitorRequestPromises;
}

optly.backend.Api.prototype.makeSegmentRequest = function(experimentId, token, options) {
  this.segments = new optly.backend.Segments(this.getApiPrefix(), experimentId, token);
  return this.segments.makeRequest(options)
}

/**
 * Currently not implemented as this information is retrieved client side.
 * @param options
 */
optly.backend.Api.prototype.makeUsageRequest = function(options) {
  this.usage = new optly.backend.Usage(this.getApiPrefix(), this.projectId, this.projectToken);
}


// assets/js/bundle/third_party/guider.js
goog.provide("optly.guider");

/**
 * guider.js
 */

var guider = (function(){
  var guider = {
    _defaultSettings: {
      aboveDialogs: false,
      attachTo: null,
      buttons: [],
      buttonCustomHTML: "",
      description: "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
      overlay: false,
      onShow: null,
      onClose: null,
      xButton: false,
      position: 0, // 1-12 follows an analog clock, 0 means centered
      title: "Sample title goes here",
      width: 400
    },

    _htmlSkeleton: [
"<div class='guider'>",
"  <div class='guider_content'>",
"    <div class='guiders_close'></div>",
"    <h1 class='guider_title'></h1>",
"    <p class='guider_description'></p>",
"    <div class='guider_buttons'>",
"    </div>",
"  </div>",
"  <div class='guider_arrow'>",
"  </div>",
"</div>"].join(""),

    _arrowSize: 16, // = arrow's width and height
    _guiders: {},
    _currentGuiderID: null,
    _lastCreatedGuiderID: null,

    _addButtons: function(myGuider) {
      // Add buttons
      for (var i = myGuider.buttons.length-1; i >= 0; i--) {
        var thisButton = myGuider.buttons[i];
        var thisButtonHTML = "<a class='guider_button";
        if (typeof thisButton.classString !== "undefined" && thisButton.classString !== null) {
          thisButtonHTML = thisButtonHTML + " " + thisButton.classString;
        }
        thisButtonHTML = thisButtonHTML + "'>" + thisButton.name + "</a>";
        var thisButtonElem = $(thisButtonHTML);

        myGuider.elem.find(".guider_buttons").append(thisButtonElem);

        if (thisButton.onclick) {
          thisButtonElem.on("click", thisButton.onclick);
        } else if (!thisButton.onclick && thisButton.name.toLowerCase() === "close") {
          thisButtonElem.on("click", function() { guider.hideAll(); });
        } else if (!thisButton.onclick && thisButton.name.toLowerCase() === "next") {
          thisButtonElem.on("click", function() { guider.next(); });
        }
      }

      if (myGuider.buttonCustomHTML !== "") {
        var myCustomHTML = $(myGuider.buttonCustomHTML);
        myGuider.elem.find(".guider_buttons").append(myCustomHTML);
      }
    },
    _addXButton : function(myGuider) {
    var xButtonContainer = myGuider.elem.find(".guiders_close");
    var xButton = $("<div></div>", {
      "class" : "guider_x_button"

    });
    xButtonContainer.append(xButton);
    xButton.click(function() {
      guider.hideAll();
      if (myGuider.onClose) {
        myGuider.onClose(myGuider, true);
       }
       $("body").trigger("guidersClose");
    });
  },

    _attach: function(myGuider) {
      if (typeof myGuider.attachTo === "undefined" || myGuider === null) {
        return;
      }

      var myHeight = myGuider.elem.innerHeight();
      var myWidth = myGuider.elem.innerWidth();

      myGuider.attachToElem = $(myGuider.attachTo);
      if (myGuider.attachToElem.length === 0 ||
          myGuider.position === 0) {
        myGuider.elem.css("position", "absolute");
        myGuider.elem.css("top", ($(window).height() - myHeight) / 3.2 + $(window).scrollTop() + "px");
        myGuider.elem.css("left", ($(window).width() - myWidth) / 2 + $(window).scrollLeft() + "px");
        return;
      }

      var base = myGuider.attachToElem.offset();
      var attachToHeight = myGuider.attachToElem.innerHeight();
      var attachToWidth = myGuider.attachToElem.innerWidth();

      var top = base.top;
      var left = base.left;

      var bufferOffset = 0.9 * guider._arrowSize;

      var offsetMap = { // Follows the form: [height, width]
        1: [-bufferOffset - myHeight, attachToWidth - myWidth],
        2: [0, bufferOffset + attachToWidth],
        3: [attachToHeight/2 - myHeight/2, bufferOffset + attachToWidth],
        4: [attachToHeight - myHeight, bufferOffset + attachToWidth],
        5: [bufferOffset + attachToHeight, attachToWidth - myWidth],
        6: [bufferOffset + attachToHeight, attachToWidth/2 - myWidth/2],
        7: [bufferOffset + attachToHeight, 0],
        8: [attachToHeight - myHeight, -myWidth - bufferOffset],
        9: [attachToHeight/2 - myHeight/2, -myWidth - bufferOffset],
        10: [0, -myWidth - bufferOffset],
        11: [-bufferOffset - myHeight, 0],
        12: [-bufferOffset - myHeight, attachToWidth/2 - myWidth/2]
      }

      offset = offsetMap[myGuider.position];
      top += offset[0];
      left += offset[1];

      myGuider.elem.css({
        "position":"absolute",
        "top": top,
        "left": left
      });
    },

    _guiderById: function(id) {
      if (typeof guider._guiders[id] === "undefined") {
        throw "Cannot find guider with id " + id
      }
      return guider._guiders[id];
    },

    _showOverlay: function() {
      $("#guider_overlay").fadeIn(UI_EFFECT_DURATION)
    },

    _hideOverlay: function() {
      $("#guider_overlay").fadeOut(UI_EFFECT_DURATION);
    },

    _initializeOverlay: function() {
      if ($("#guider_overlay").length === 0) {
        $("<div id=\"guider_overlay\"></div>").hide().appendTo("body");
      }
    },

    _styleArrow: function(myGuider) {
      var position = myGuider.position || 0;
      if (!position) {
        return;
      }
      var myGuiderArrow = $(myGuider.elem.find(".guider_arrow"));
      var newClass = {
        1: "guider_arrow_down",
        2: "guider_arrow_left",
        3: "guider_arrow_left",
        4: "guider_arrow_left",
        5: "guider_arrow_up",
        6: "guider_arrow_up",
        7: "guider_arrow_up",
        8: "guider_arrow_right",
        9: "guider_arrow_right",
        10: "guider_arrow_right",
        11: "guider_arrow_down",
        12: "guider_arrow_down"
      };
      myGuiderArrow.addClass(newClass[position]);

      var myHeight = myGuider.elem.innerHeight();
      var myWidth = myGuider.elem.innerWidth();
      var arrowOffset = guider._arrowSize / 2;
      var positionMap = {
        1: ["right", arrowOffset],
        2: ["top", arrowOffset],
        3: ["top", myHeight/2 - arrowOffset],
        4: ["bottom", arrowOffset],
        5: ["right", arrowOffset],
        6: ["left", myWidth/2 - arrowOffset],
        7: ["left", arrowOffset],
        8: ["bottom", arrowOffset],
        9: ["top", myHeight/2 - arrowOffset],
        10: ["top", arrowOffset],
        11: ["left", arrowOffset],
        12: ["left", myWidth/2 - arrowOffset]
      };
      var position = positionMap[myGuider.position];
      myGuiderArrow.css(position[0], position[1] + "px");
    },

    next: function() {
      var currentGuider = guider._guiders[guider._currentGuiderID];
      if (typeof currentGuider === "undefined") {
        return;
      }
      var nextGuiderId = currentGuider.next || null;
      if (nextGuiderId !== null && nextGuiderId !== "") {
        var myGuider = guider._guiderById(nextGuiderId);
        var omitHidingOverlay = myGuider.overlay ? true : false;
        guider.hideAll(omitHidingOverlay);

        if (myGuider.aboveDialogs) {
          myGuider.elem.addClass('above_dialog')
          $("#guider_overlay").addClass('above_dialog')
        } else {
          myGuider.elem.removeClass('above_dialog')
          $("#guider_overlay").removeClass('above_dialog')          
        }
        guider.show(nextGuiderId);

      }
    },

    createGuider: function(passedSettings) {
      if ($.type(passedSettings) !== "object") {
        passedSettings = {};
      }

      // Extend those settings with passedSettings
      myGuider = $.extend(true, {}, guider._defaultSettings, passedSettings);
      myGuider.id = myGuider.id || String(Math.floor(Math.random() * 1000));

      var guiderElement = $(guider._htmlSkeleton);
      myGuider.elem = guiderElement;
      myGuider.elem.css("width", myGuider.width + "px");
      guiderElement.find("h1.guider_title").html(myGuider.title);
      guiderElement.find("p.guider_description").html(myGuider.description);

      guider._addButtons(myGuider);
      if (myGuider.xButton) {
        guider._addXButton(myGuider);
      }

      if (typeof myGuider.classString !== "undefined" && myGuider.classString !== null) {
        myGuider.elem.addClass(myGuider.classString);
      }

      guiderElement.hide();
      guiderElement.appendTo("body");

      // Ensure myGuider.attachTo is a jQuery element.
      if (typeof myGuider.attachTo !== "undefined" && myGuider !== null) {
        guider._attach(myGuider);
        guider._styleArrow(myGuider);
      }

      guider._initializeOverlay();

      guider._guiders[myGuider.id] = myGuider;
      if (guider._lastCreatedGuiderID != null) {
        myGuider.prev = guider._lastCreatedGuiderID;
      }
      guider._lastCreatedGuiderID = myGuider.id;
      return guider;
    },
    prev: function () {
      var currentGuider = guider._guiders[guider._currentGuiderID];
      if (typeof currentGuider === "undefined") {
        // not what we think it is
        return null;
      }
      if (currentGuider.prev === null) {
        // no previous to look at
        return null;
      }

      var prevGuider = guider._guiders[currentGuider.prev];

      // Note we use prevGuider.id as "prevGuider" is _already_ looking at the previous guider
      var prevGuiderId = prevGuider.id || null;
      if (prevGuiderId !== null && prevGuiderId !== "") {
        var myGuider = guider._guiderById(prevGuiderId);
        var omitHidingOverlay = myGuider.overlay ? true : false;
        guider.hideAll(omitHidingOverlay, true);
        guider.show(prevGuiderId);
        return myGuider;
      }
    },

    hideAll: function(omitHidingOverlay) {
      $(".guider").fadeOut("fast");
      if (typeof omitHidingOverlay !== "undefined" && omitHidingOverlay === true) {
      }
      else {
        guider._hideOverlay();
      }
      return guider;
    },

    show: function(id) {
      if (!id && guider._lastCreatedGuiderID) {
        id = guider._lastCreatedGuiderID;
      }

      var myGuider = guider._guiderById(id);
      if (myGuider.overlay) {
        guider._showOverlay();
      }
       // You can use an onShow function to take some action before the guider is shown.
      if (myGuider.onShow) {
        myGuider.onShow(myGuider);
      }
      guider._attach(myGuider);
      myGuider.elem.addClass("in");
      myGuider.elem.fadeIn("fast");

      guider._currentGuiderID = id;
      return guider;
    }
  };

  return guider;
}).call(this);


// assets/js/bundle/third_party/jquery/scrollbarwidth.js
goog.provide("optly.jquery.scrollbarwidth");

goog.require("optly.jquery");

/*!
 * jQuery scrollbarWidth - v0.2 - 2/11/2009
 * http://benalman.com/projects/jquery-misc-plugins/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Calculate the scrollbar width dynamically!

(function($,undefined,width){
  '$:nomunge'; // Used by YUI compressor.

  $.scrollbarWidth = function() {
    var parent,
      child;

    if ( width === undefined ) {
      parent = $('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo('body');
      child = parent.children();
      width = child.innerWidth() - child.height( 99 ).innerWidth();
      parent.remove();
    }

    return width;
  };

})(jQuery);


// assets/js/bundle/third_party/jquery/browser.js
goog.provide("optly.jquery.browser");

goog.require("optly.jquery");

/*

jQuery Browser Plugin
  * Version 2.3
  * 2008-09-17 19:27:05
  * URL: http://jquery.thewikies.com/browser
  * Description: jQuery Browser Plugin extends browser detection capabilities and can assign browser selectors to CSS classes.
  * Author: Nate Cavanaugh, Minhchau Dang, & Jonathan Neal
  * Copyright: Copyright (c) 2008 Jonathan Neal under dual MIT/GPL license.
  * JSLint: This javascript file passes JSLint verification.
*//*jslint
    bitwise: true,
    browser: true,
    eqeqeq: true,
    forin: true,
    nomen: true,
    plusplus: true,
    undef: true,
    white: true
*//*global
    jQuery
*/

(function ($) {
  $.browserTest = function (a, z) {
    var u = 'unknown';
    var x = 'X';

    var m = function (r, h) {
      for (var i = 0; i < h.length; ++i) {
        r = r.replace(h[i][0], h[i][1]);
      }
      return r;
    }

    var c = function (i, a, b, c) {
      var r = {
        name: m((a.exec(i) || [u, u])[1], b)
      };

      r[r.name] = true;
      r.version = (c.exec(i) || [x, x, x, x])[3];
      if (r.name.match(/safari/) && r.version > 400) {
        r.version = '2.0';
      }

      if (r.name === 'presto') {
        r.version = ($.browser.version > 9.27) ? 'futhark' : 'linear_b';
      }
      r.versionNumber = parseFloat(r.version, 10) || 0;
      r.versionX = (r.version !== x) ? (r.version + '').substr(0, 1) : x;
      r.className = r.name + r.versionX;

      return r;
    };

    a = (a.match(/Opera|Navigator|Minefield|KHTML|Chrome/) ? m(a, [
      [/(Firefox|MSIE|KHTML,\slike\sGecko|Konqueror)/, ''],
      ['Chrome Safari', 'Chrome'],
      ['KHTML', 'Konqueror'],
      ['Minefield', 'Firefox'],
      ['Navigator', 'Netscape']
    ]) : a).toLowerCase();

    $.browser = $.extend((!z) ? $.browser : {}, c(a, /(camino|chrome|firefox|netscape|konqueror|lynx|msie|opera|safari)/, [], /(camino|chrome|firefox|netscape|netscape6|opera|version|konqueror|lynx|msie|safari)(\/|\s)([a-z0-9\.\+]*?)(\;|dev|rel|\s|$)/));
  };

  $.browserTest(navigator.userAgent);
})(jQuery);


// assets/js/bundle/third_party/jquery/getUrlParam.js
goog.provide("optly.jquery.getUrlParam");

goog.require("optly.jquery");

/* Copyright (c) 2006-2007 Mathias Bank (http://www.mathias-bank.de)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Version 2.1
 *
 * Thanks to
 * Hinnerk Ruemenapf - http://hinnerk.ruemenapf.de/ for bug reporting and fixing.
 * Tom Leonard for some improvements
 *
 */

(function($) {
  $.fn.extend({
    /**
     * Returns get parameters.
     *
     * If the desired param does not exist, null will be returned
     *
     * To get the document params:
     * @example value = $(document).getUrlParam("paramName");
     *
     * To get the params of a html-attribut (uses src attribute)
     * @example value = $('#imgLink').getUrlParam("paramName");
     */
    getUrlParam: function(strParamName) {
      strParamName = escape(unescape(strParamName));

      var returnVal = new Array();
      var qString = null;

      if ($(this).attr("nodeName") == "#document") {
        //document-handler

        if (window.location.search.search(strParamName) > -1) {

          qString = window.location.search.substr(1, window.location.search.length).split("&");
        }

      }
      else
        if ($(this).attr("src") != "undefined") {

          var strHref = $(this).attr("src")
          if (strHref.indexOf("?") > -1) {
            var strQueryString = strHref.substr(strHref.indexOf("?") + 1);
            qString = strQueryString.split("&");
          }
        }
        else
          if ($(this).attr("href") != "undefined") {

            var strHref = $(this).attr("href")
            if (strHref.indexOf("?") > -1) {
              var strQueryString = strHref.substr(strHref.indexOf("?") + 1);
              qString = strQueryString.split("&");
            }
          }
          else {
            return null;
          }


      if (qString == null)
        return null;


      for (var i = 0; i < qString.length; i++) {
        if (escape(unescape(qString[i].split("=")[0])) == strParamName) {
          returnVal.push(qString[i].split("=")[1]);
        }

      }


      if (returnVal.length == 0)
        return null;
      else
        if (returnVal.length == 1)
          return returnVal[0];
        else
          return returnVal;
    }
  });
})(jQuery);


// assets/js/bundle/third_party/jquery/quickselect.js
goog.provide("optly.jquery.quickselect");

goog.require("optly.jquery");

/***
 * Taken with much gratitude from:
 * http://plugins.jquery.com/project/quickselect
 * http://github.com/dcparker/jquery_plugins/tree/master/quickselect
 *
 * Written by dparker
 **/

(function($){
  $.fn.indexOf = function(e) {
    for (var i = 0; i < this.length; i++) {
      if (this[i] == e)
        return i;
    }
    return -1;
  };

  function Populater(mode){
    this.populate = function(value){
      var that = this;
      if(!this.that.options.matchCase) value = value.toLowerCase();
      var data = this.that.cacheLength ? this.that.loadFromCache(value) : null;
      if(data){
        this.that.populate_list(value, data);
      }else{
        this.get_data(value, function(data){
          if(data) {
            that.that.populate_list(value, data);
          }
            else $(that.that.text_input).removeClass(that.that.options.loadingClass);
        });
      }
    };
  }

  function AjaxPopulate(that){
    this.that = that;
    var ajax = this;
    this.get_data = function(value, callback){
      $.getJSON(makeUrl(value), function(data){
        callback(ajax.importData(value, data));
      });
    };

    this.importData = function(value, data){
      this.that.addToCache(value, data);
      return data;
    };

    function makeUrl(q){
      var url = that.options.url + "?q=" + encodeURI(q);
      for (var i in that.options.extraParams){
        url += "&" + i + "=" + encodeURI(that.options.extraParams[i]);
      }
      return url;
    };
  }
  AjaxPopulate.prototype = new Populater('ajax');

  function DataPopulate(that){
    this.that = that;
    this.get_data = function(value, callback){
      if(!this.that.options.data) callback();
      else{
        var rows = [], row = [];

        // create a lookup by first letter.
        for(var i=0; i < this.that.options.data.length; i++){
          row = ((typeof this.that.options.data[i] == "string") ? [this.that.options.data[i]] : this.that.options.data[i]); // make sure each element is an array
          rows.push(row);                        // add row to blank lookup
        }
        // add the data items to the cache
        this.that.cacheLength++;
        this.that.addToCache('', rows);
        callback(this.that.loadFromCache(value));
      };
    };
  }
  DataPopulate.prototype = new Populater('data');

  // The QuickSelect Functions...
  function QuickSelectPrototype(){
    this.flushCache = function(){
      this.cache = {data:{},length:0};
    };
    this.addToCache = function(q, data){
      if(!data || !this.cacheLength) return;
      if(!this.cache.length || this.cache.length > this.cacheLength){
        this.flushCache();
        this.cache.length++;
      } else if(!this.cache[q]){
        this.cache.length++;
      }
      this.cache.data[q] = data;
     };
    this.loadFromCache = function(q){
      //if(!q) return null;
      if(this.cache.data[q]) return this.cache.data[q];
      for (var i = q.length - 1; i >= 0; i--){
        var qs = q.substr(0, i);
        var c = this.cache.data[qs];
        if(c){
          var csub = [];
          for (var j = 0; j < c.length; j++){
            var x = c[j];
            var x0 = x[1];  // changed by koomen
            if(this.findMatch(this.options.match, x0, q)) csub[csub.length] = x;
          }
          return csub; //.sort(sortMatches(this.options.match, q));
        }
      }
      return null;
    };

    this.findMatch = function(mode, str, sub){
      if(!this.options.matchCase) str = str.toLowerCase();
      switch(mode){
        case 'substring':
          var i = str.indexOf(sub);
          if(i == -1) return false;
          return i == 0 || this.options.matchContains;
        case 'quicksilver':
          return str.score(sub) > 0;
      };
    };

    function sortMatches(mode, sub){
      switch(mode){
        case 'substring':
          return function(a,b){
            var c = [a[0],b[0]].sort;
            return (a[0] == c[0]) - (b[0] == c[1]);
          };
        case 'quicksilver':
          return function(a,b){
            var as = a[0].toLowerCase().score(sub);
            var bs = b[0].toLowerCase().score(sub);
            return(as > bs ? -1 : (bs > as ? 1 : 0));
          };
      };
    };

    // Changed by koomen
     this.moveSelect = function(step){
      var trs = $("tr", this.results);
      if(!trs)return;

      this.active += step;

      if(this.active < 0)this.active = 0;
        else if(this.active >= trs.size())
          this.active = trs.size() - 1;

      trs.removeClass(this.options.selectedClass);
      $(trs[this.active]).addClass(this.options.selectedClass);
    };

    this.selectCurrent = function(){
      var tr = this.results.find("tr." + this.options.selectedClass);

      if (tr.length > 0){
        this.selectItem(tr);
        return true;
      }
//      else {
//        // blank the fields if options.mustMatch and current value isn't valid.
//        if(this.options.mustMatch && this.loadFromCache(this.$text_input.val().toLowerCase()).length == 0)
//          this.options.additional_fields.each(function(i,input){
//            $(input).val('');
//          });
//        return false;
//      }
    };

    this.selectItem = function(tr,from_hide_now_function){
      var that = this;

//      if(!li){
//        li = document.createElement("li");
//        li.values = [];
//      }
//      var v = $.trim(li.values[0] || li.innerHTML);
//      this.text_input.lastSelected = $.trim(li.values[0] || li.innerHTML);

      var v = tr.attr("title");
      this.text_input.lastSelected = v;

      // TODO: debug whether this should be the $.trim'd version or not.
      this.previous_value = v;
//      this.$results.html("");

      this.options.additional_fields.each(function(i,input){
        $(input).val(tr.attr("title"));
      });
//      if(!from_hide_now_function)
//        this.hideResultsNow();
//      if(this.options.onItemSelect) setTimeout(function(){ that.options.onItemSelect(tr) }, 1);
    };

    this.showResults = function(){
      // // get the position of the input field right now (in case the DOM is shifted)
      // var pos = findPos(this.text_input);
      // // either use the specified width, or autocalculate based on form element
      // var iWidth = (this.options.width > 0) ? this.options.width : this.$text_input.width();
      // // reposition
      //       this.$results.css({
      //        width: parseInt(iWidth) + "px",
      //        top: (pos.y + this.text_input.offsetHeight) + "px",
      //        left: pos.x + "px"
      //       }).show();
    };

    function findPos(obj){
      var curleft = obj.offsetLeft || 0;
      var curtop = obj.offsetTop || 0;
      while (obj = obj.offsetParent){
        curleft += obj.offsetLeft
        curtop += obj.offsetTop
      }
      return {x:curleft,y:curtop};
    }

    this.hideResults = function(){
      //      var that = this;
      // if(this.timeout) clearTimeout(this.timeout);
      // this.timeout = setTimeout(function(){that.hideResultsNow()}, 200);
    };

    this.hideResultsNow = function(){
      //      if(this.timeout)
      //        clearTimeout(this.timeout);
      //      this.$text_input.removeClass(this.options.loadingClass);
      //      if(this.$results.is(":visible"))
      //        this.$results.hide();
      // if(this.options.mustMatch && this.$text_input.val() != this.text_input.lastSelected)
      //   this.selectItem(null,true);
    };

    this.onChange = function(){
      // ignore if the following keys are pressed: [del] [shift] [capslock]
      if (this.last_keyCode == 46 || (this.last_keyCode > 8 && this.last_keyCode < 32)) {
        return this.$results
      } //.hide(); // koomen changed

      this.update();
    };

    this.update = function(shouldForce) {
      var v = this.$text_input.val();

      if(v == this.previous_value && !shouldForce) return;

      this.previous_value = v;
      if (v.length >= this.options.minChars) {
        this.$text_input.addClass(this.options.loadingClass);
        this.populater.populate(v);
      }
      else {
        if ((this.options.onBlank && this.options.onBlank()) || true) { // onBlank callback
          this.options.additional_fields.each(function(i, input) {
            $(input).val('');
          });
        }

        this.$text_input.removeClass(this.options.loadingClass);
      }
    };

    this.autoFill = function(str){
      // if the last user key pressed was backspace, don't autofill
      if(this.last_keyCode != 8){
        // fill in the value (keep the case the user has typed)
        this.$text_input.val(this.$text_input.val() + str.substring(this.previous_value.length));
        // select the portion of the value not typed by the user (so the next character will erase)
        createSelection(this, this.previous_value.length, str.length);
      }
    };

    function createSelection(that, start, end){
      // get a reference to the input element
      var field = $(that.text_input).get(0);
      if(field.createTextRange){
        var selRange = field.createTextRange();
        selRange.collapse(true);
        selRange.moveStart("character", start);
        selRange.moveEnd("character", end);
        selRange.select();
      } else if(field.setSelectionRange){
        field.setSelectionRange(start, end);
      } else {
        if(field.selectionStart){
          field.selectionStart = start;
          field.selectionEnd = end;
        }
      }
      field.focus();
    };

    this.populater = function(mode){
      if(mode == 'ajax') return new AjaxPopulate(this);
      if(mode == 'data') return new DataPopulate(this);
    };

    this.populate_list = function(q, data){
      if(data){
        this.$text_input.removeClass(this.options.loadingClass);
        // koomen changed
        //this.results.innerHTML = "";
        this.results.html("");


        // if the field no longer has focus or if there are no matches, do not display the drop down
        // koomen commented out
        //if(!this.hasFocus || data.length == 0) return this.hideResultsNow();

        // Remove when FAQ page is ready:
        if (data.length == 0) return this.hideResultsNow();

        // koomen changed
        //this.results.appendChild(dataToDom(data, this));
        this.results.html(dataToDom(data, this));
        if(this.options.autoFill && (this.$text_input.val().toLowerCase() == q.toLowerCase())) this.autoFill(data[0][0]); // autoFill the typing box, if option allows
        this.showResults();
        if(this.options.autoSelectFirst || (this.options.selectOnly && data.length == 1))
          this.moveSelect(0); // selects current selection or top listing if none, if option allows
      } else {
        this.hideResultsNow();
      }
    };

    function dataToDom(data, that){
     var tbody = $('<tbody></tbody>');

     var num = data.length;
     // limited results to a max number
     if((that.options.maxItemsToShow > 0) && (that.options.maxItemsToShow < num)) num = that.options.maxItemsToShow;

     for (var i=0; i < num; i++){
       var datum = data[i];
       if(!datum) continue;
       var newRow = $(that.options.formatItem ? that.options.formatItem(datum, i, num) : datum[0]);
       newRow.click(function() {
         $("tr", tbody).removeClass(that.options.selectedClass);
         $("tr", tbody).removeClass(that.options.hoverSelectedClass);
         $(this).addClass(that.options.selectedClass);
       });
       tbody.append(newRow);
       newRow.hover(
         function(){
           $("tr", tbody).removeClass(that.options.hoverSelectedClass);
           $(this).addClass(that.options.hoverSelectedClass);
//           that.active = $("tr", tbody).indexOf($(this).get(0))
          },
         function(){ $(this).removeClass(that.options.hoverSelectedClass) }
       );//.click(function(e){ e.preventDefault(); e.stopPropagation(); that.selectItem(this) });
     }

/* Uncomment when FAQ page is ready:
     tbody.append("\
<span class=\"faq\">We haven't detected any more pageviews or custom events. \
<a href=\"/faq#goals\">How can I track experiment goals</a></span>?");
*/

     return tbody;
    };

    // function dataToDom(data, that){
    //  var ul = document.createElement("ul");
    //
    //  var num = data.length;
    //  // limited results to a max number
    //  if((that.options.maxItemsToShow > 0) && (that.options.maxItemsToShow < num)) num = that.options.maxItemsToShow;
    //
    //  for (var i=0; i < num; i++){
    //    var row = data[i];
    //    if(!row) continue;
    //    var li = document.createElement("li");
    //        li.innerHTML = that.options.formatItem ? that.options.formatItem(row, i, num) : row[0];
    //    var values = [];
    //        for(var j=0; j < row.length; j++){
    //          values[values.length] = row[j];
    //        }
    //    li.values = values;
    //    ul.appendChild(li);
    //    $(li).hover(
    //      function(){ $("li", ul).removeClass(that.options.selectedClass); $(this).addClass(that.options.selectedClass); that.active = $("li", ul).indexOf($(this).get(0)) },
    //      function(){ $(this).removeClass(that.options.selectedClass) }
    //    ).click(function(e){ e.preventDefault(); e.stopPropagation(); that.selectItem(this) });
    //  }
    //  return ul;
    // };
  }

  // The QuickSelect Maker...
  function QuickSelect(text_input, options){
    var that = this;
    this.text_input = text_input; // make public
    this.options = options; // make public
    text_input.quickselector = this;

    // Create jQuery object for input element.
    var $text_input = $(text_input).attr("quickselect", "off");
    this.$text_input = $text_input;

    // Apply inputClass if necessary.
    if(options.inputClass) $text_input.addClass(options.inputClass);

    // Create results.
    // var results = document.createElement("div");
    // added by koomen
    var results = $("#pageview-simple-list");
    this.results = results; // make public

    // Create jQuery object for results.
    var $results = $(results);
    // koomen changed
    //$results.hide().addClass(options.resultsClass).css("position", "absolute");
    $results.addClass(options.resultsClass);
    // koomen changed
    //if(options.width > 0) $results.css("width", options.width);

    $results.click(function() {
      that.selectCurrent();
      $text_input.get(0).select();
    });

    // Add to body element.
    //$("body").append(results);

    // Initialize the cache
    this.flushCache();

    // Attach the action!
    this.active = -1;
    this.previous_value = '';
    this.timeout = null;
    this.last_keyCode = null;

    $text_input
    .keydown(function(e) {
      that.last_keyCode = e.keyCode;
      switch(e.keyCode){
        case 38: // up arrow - select prev item in the drop-down
          e.preventDefault();
          that.moveSelect(-1);
          break;
        case 40: // down arrow - select next item in the drop-down
          e.preventDefault();
          that.moveSelect(1);
          break;
        case 13: // return - select item and blur field
        case 9:  // tab - select the currently selected, let the regular stuff happen
          if(that.selectCurrent()){
            e.preventDefault();
            $text_input.get(0).select();
          }
          break;
        default:
          that.active = 0;
          if(that.timeout) clearTimeout(that.timeout);
          that.timeout = setTimeout(function(){that.onChange()}, options.delay);
          break;
      }
    })
    .focus(function(){
      // track whether the field has focus, we shouldn't process any results if the field no longer has focus
      that.hasFocus = true;
    })
    .blur(function(){
//      that.selectCurrent();
      // track whether the field has focus
      that.hasFocus = false;
//      that.hideResults();
    });

    this.cacheLength = 1;
    this.populater = this.populater(options.url ? 'ajax' : 'data');
    this.populater.populate('');

    this.hideResultsNow();
  };
  QuickSelect.prototype = new QuickSelectPrototype();

  // Make the quickselect form control...
  $.fn.quickselect = function(options, data){
    // Prepare options and set defaults.
    options = options || {};
    options.url           = options.url || options.ajax;
    options.extraParams   = options.extraParams || {};
    options.data          = ((typeof options.data == "object") && (options.data.constructor == Array)) ? options.data : null;
    if (typeof options.minChars == "undefined") {
      options.minChars = 0;
    }
//  	options.minChars      = options.minChars || 1; // koomen changed
    options.inputClass    = options.inputClass || "auto_select_input";
    options.loadingClass  = options.loadingClass || "auto_select_loading";
    options.resultsClass  = options.resultsClass || "auto_select_results";
    options.selectedClass = options.selectedClass || "auto_select_selected";
    options.hoverSelectedClass = options.hoverSelectedClass || "hover_select_selected"; // koomen added
    options.match         = options.match || ((typeof ''.score == 'function') && 'l'.score('l') == 1 ? 'quicksilver' : 'substring');
    options.matchContains = options.matchContains || false;
    options.autoSelectFirst = options.autoSelectFirst || true;
    options.selectOnly    = options.selectOnly || true;
    options.maxItemsToShow = options.maxItemsToShow || -1;
    options.autoFill      = options.autoFill || false;
      if(options.match == 'quicksilver') options.autoFill = false; // if you're using the quicksilver match, it really doesn't help to autoFill.
    options.width         = parseInt(options.width, 10) || 0;

    // Make quickselects.
    this.each(function(){
      var input = this;
        var shadow_options = function(){};
        shadow_options.prototype = options; // now a new instance of shadow "is a" options
      var my_options = new shadow_options();

      if(input.tagName == 'INPUT'){
        my_options.delay         = my_options.delay || 400;
        my_options.matchCase     = my_options.matchCase || false;
        my_options.mustMatch     = my_options.mustMatch || false;
        my_options.additional_fields = $(input).add(my_options.additional_fields);

        new QuickSelect(input, my_options);
      } else if(input.tagName == 'SELECT'){
        my_options.delay         = my_options.delay || 10; // for selects, we know we're not doing ajax, so we might as well speed up
        my_options.matchCase     = my_options.matchCase || false;
        my_options.mustMatch     = my_options.mustMatch || true;

        // Collect the data from the select/options, remove them and create an input box instead.
        var $select = $(input);
        my_options.data = [];
          $select.find('option').each(function(i,option){
            my_options.data[i] = [option.innerHTML, option.value];
          });

        // Record the html stuff from the select
        var name = $select[0].name;
        var id = $select[0].id;
        var className = $select[0].className;
        var accesskey = $select.attr('accesskey');
        var tabindex = $select.attr('tabindex');

        var selected = $select.find("option:selected")[0];

        // Create the text input and hidden input
        var text_input = document.createElement("input");
        text_input.type = 'text';
        text_input.className = className;
        text_input.id = id + '_quickselect';
        $(text_input).attr('accesskey', accesskey);
        $(text_input).attr('tabindex', tabindex);
        if(selected) text_input.value = selected.innerHTML;

        var hidden_input = document.createElement("input");
        hidden_input.type = 'hidden';
        hidden_input.id = id;
        hidden_input.name = $select[0].name;
        if(selected) hidden_input.value = selected.value;

        // We need to work off two values, from the label and value of the select options.
        // Record the first (label) in the text input, the second (value) in the hidden input.
        my_options.additional_fields = $(hidden_input);

        // Replace the select with a quickselect text_input
        $select.after(text_input).after(hidden_input).remove();
        $(text_input).quickselect(my_options);
      }
    });
  };
})(jQuery);


// assets/js/bundle/third_party/jquery/formatfilesize.js
goog.provide("optly.jquery.formatfilesize");

goog.require("optly.jquery");

/*
 * Format file sizes for display. Input in bytes.
 */

(function($) {
  /**
   * @param {Object} bytes
   * @param {number} decimals
   */
  $.formatFileSize = function(bytes, decimals) {
    if (!isNumeric(bytes)) {
      return "Bytes must be numeric.";
    }

    decimals = isNumeric(decimals) ? decimals : 0;

    if (bytes == 0) {
      return "0 Bytes";
    }
    else if (bytes == 1) {
      return "1 Byte";
    }
    else if (bytes < 1024) {
      return convertToUnit(bytes, 0, decimals) + " Bytes";
    }
    else if (bytes < Math.pow(1024, 2)) {
      return convertToUnit(bytes, 1, decimals) + " KB";
    }
    else if (bytes < Math.pow(1024, 3)) {
      return convertToUnit(bytes, 2, decimals) + " MB";
    }
    else {
      return convertToUnit(bytes, 3, decimals) + " GB";
    }
  };

  var convertToUnit = function(bytes, power, decimals) {
    var factor = Math.pow(10, decimals);
    return Math.round(bytes * factor / Math.pow(1024, power)) / factor;
  };

  var isNumeric = function(value) {
    return !isNaN(parseInt(value, 10));
  };
})(jQuery);


// assets/js/bundle/main.js
goog.provide("optly.main");

goog.require("goog.asserts");

// optly.*
goog.require("optly.common.main");
goog.require("optly.constant");
goog.require("optly.custom");
goog.require("optly.enums.main");

// third_party
goog.require("optly.jquery");
goog.require("optly.jquery.bbq");
goog.require("optly.jquery.browser");
goog.require("optly.jquery.contextmenu");
goog.require("optly.jquery.cookie");
goog.require("optly.jquery.dataTables");
goog.require("optly.jquery.easydate");
goog.require("optly.jquery.fancybox");
goog.require("optly.jquery.farbtastic");
goog.require("optly.jquery.FixedColumns");
goog.require("optly.jquery.form");
goog.require("optly.jquery.formatfilesize");
goog.require("optly.jquery.getUrlParam");
goog.require("optly.jquery.infieldlabel");
goog.require("optly.jquery.jcarousellite");
goog.require("optly.jquery.json");
goog.require("optly.jquery.metadata");
goog.require("optly.jquery.modal");
goog.require("optly.jquery.outerhtml");
goog.require("optly.jquery.popover");
goog.require("optly.jquery.quickselect");
goog.require("optly.jquery.readyordone");
goog.require("optly.jquery.scrollbarwidth");
goog.require("optly.jquery.tmpl");
goog.require("optly.jquery.tooltip");
goog.require("optly.jquery.typeahead");
goog.require("optly.jquery.ui");
goog.require("optly.jquery.validate");
goog.require('optly.esprima');
goog.require("optly.guider");
goog.require("optly.sprintf");
goog.require("optly.translate");
goog.require("optly.stats");

goog.require("optly.goals");
goog.require("optly.backend.Api");
goog.require("optly.guardian.Guardian");

// vue must go before app_bundle so it exports to window['Vue']

// node_modules/vue/dist/vue.min.js
/*
 Vue.js v0.10.6
 (c) 2014 Evan You
 License: MIT
*/
!function(){"use strict";function e(t,i,r){var n=e.resolve(t);if(null!=n){var s=e.modules[n];if(!s._resolving&&!s.exports){var o={};o.exports={},o.client=o.component=!0,s._resolving=!0,s.call(this,o.exports,e.relative(n),o),delete s._resolving,s.exports=o.exports}return s.exports}}e.modules={},e.aliases={},e.exts=["",".js",".json","/index.js","/index.json"],e.resolve=function(t){"/"===t.charAt(0)&&(t=t.slice(1));for(var i=0;5>i;i++){var r=t+e.exts[i];if(e.modules.hasOwnProperty(r))return r;if(e.aliases.hasOwnProperty(r))return e.aliases[r]}},e.normalize=function(e,t){var i=[];if("."!=t.charAt(0))return t;e=e.split("/"),t=t.split("/");for(var r=0;r<t.length;++r)".."===t[r]?e.pop():"."!=t[r]&&""!=t[r]&&i.push(t[r]);return e.concat(i).join("/")},e.register=function(t,i){e.modules[t]=i},e.alias=function(t,i){e.modules.hasOwnProperty(t)&&(e.aliases[i]=t)},e.relative=function(t){function i(r){var n=i.resolve(r);return e(n,t,r)}var r=e.normalize(t,"..");return i.resolve=function(i){var n=i.charAt(0);if("/"===n)return i.slice(1);if("."===n)return e.normalize(r,i);for(var s=t.split("/"),o=s.length;o--&&"deps"!==s[o];);return i=s.slice(0,o+2).join("/")+"/deps/"+i},i.exists=function(t){return e.modules.hasOwnProperty(i.resolve(t))},i},e.register("vue/src/main.js",function(e,t,i){function r(e){var t=this;e.data&&(e.defaultData=e.data,delete e.data),t!==o&&(e=n(e,t.options,!0)),a.processOptions(e);var i=function(i,r){r||(i=n(i,e,!0)),t.call(this,i,!0)},s=i.prototype=Object.create(t.prototype);return a.defProtected(s,"constructor",i),i.extend=r,i.super=t,i.options=e,l.forEach(function(e){i[e]=o[e]}),i.use=o.use,i.require=o.require,i}function n(e,t,i){if(e=e||{},!t)return e;for(var r in t)if("el"!==r){var s=e[r],c=t[r];i&&"function"==typeof s&&c?(e[r]=[s],Array.isArray(c)?e[r]=e[r].concat(c):e[r].push(c)):!i||!a.isTrueObject(s)&&!a.isTrueObject(c)||c instanceof o?void 0===s&&(e[r]=c):e[r]=n(s,c)}return e}var s=t("./config"),o=t("./viewmodel"),a=t("./utils"),c=a.hash,l=["directive","filter","partial","effect","component"],u={utils:a,config:s,transition:t("./transition"),observer:t("./observer")};o.options=s.globalAssets={directives:t("./directives"),filters:t("./filters"),partials:c(),effects:c(),components:c()},l.forEach(function(e){o[e]=function(t,i){var r=this.options[e+"s"];return r||(r=this.options[e+"s"]=c()),i?("partial"===e?i=a.parseTemplateOption(i):"component"===e?i=a.toConstructor(i):"filter"===e&&a.checkFilter(i),r[t]=i,this):r[t]}}),o.config=function(e,t){if("string"==typeof e){if(void 0===t)return s[e];s[e]=t}else a.extend(s,e);return this},o.use=function(e){if("string"==typeof e)try{e=t(e)}catch(i){return}var r=[].slice.call(arguments,1);return r.unshift(this),"function"==typeof e.install?e.install.apply(e,r):e.apply(null,r),this},o.require=function(e){return u[e]},o.extend=r,o.nextTick=a.nextTick,i.exports=o}),e.register("vue/src/emitter.js",function(e,t,i){function r(e){this._ctx=e||this}var n=[].slice,s=r.prototype;s.on=function(e,t){return this._cbs=this._cbs||{},(this._cbs[e]=this._cbs[e]||[]).push(t),this},s.once=function(e,t){function i(){r.off(e,i),t.apply(this,arguments)}var r=this;return this._cbs=this._cbs||{},i.fn=t,this.on(e,i),this},s.off=function(e,t){if(this._cbs=this._cbs||{},!arguments.length)return this._cbs={},this;var i=this._cbs[e];if(!i)return this;if(1===arguments.length)return delete this._cbs[e],this;for(var r,n=0;n<i.length;n++)if(r=i[n],r===t||r.fn===t){i.splice(n,1);break}return this},s.emit=function(e,t,i,r){this._cbs=this._cbs||{};var n=this._cbs[e];if(n){n=n.slice(0);for(var s=0,o=n.length;o>s;s++)n[s].call(this._ctx,t,i,r)}return this},s.applyEmit=function(e){this._cbs=this._cbs||{};var t,i=this._cbs[e];if(i){i=i.slice(0),t=n.call(arguments,1);for(var r=0,s=i.length;s>r;r++)i[r].apply(this._ctx,t)}return this},i.exports=r}),e.register("vue/src/config.js",function(e,t,i){var r=t("./text-parser");i.exports={prefix:"v",debug:!1,silent:!1,enterClass:"v-enter",leaveClass:"v-leave",interpolate:!0},Object.defineProperty(i.exports,"delimiters",{get:function(){return r.delimiters},set:function(e){r.setDelimiters(e)}})}),e.register("vue/src/utils.js",function(e,t,i){function r(e){return e.indexOf("[")<0?e:e.replace(h,".$1").replace(f,".$1")}var n,s=t("./config"),o={}.toString,a=window,c=(a.console,Object.defineProperty),l="object",u=/[^\w]this[^\w]/,h=/\['([^']+)'\]/g,f=/\["([^"]+)"\]/g,d="classList"in document.documentElement,p=a.requestAnimationFrame||a.webkitRequestAnimationFrame||a.setTimeout,v=i.exports={toFragment:t("./fragment"),parseTemplateOption:t("./template-parser.js"),get:function(e,t){if(t=r(t),t.indexOf(".")<0)return e[t];for(var i=t.split("."),n=-1,s=i.length;++n<s&&null!=e;)e=e[i[n]];return e},set:function(e,t,i){if(t=r(t),t.indexOf(".")<0)return void(e[t]=i);for(var n=t.split("."),s=-1,o=n.length-1;++s<o;)null==e[n[s]]&&(e[n[s]]={}),e=e[n[s]];e[n[s]]=i},baseKey:function(e){return e.indexOf(".")>0?e.split(".")[0]:e},hash:function(){return Object.create(null)},attr:function(e,t){var i=s.prefix+"-"+t,r=e.getAttribute(i);return null!==r&&e.removeAttribute(i),r},defProtected:function(e,t,i,r,n){c(e,t,{value:i,enumerable:r,writable:n,configurable:!0})},isObject:function(e){return typeof e===l&&e&&!Array.isArray(e)},isTrueObject:function(e){return"[object Object]"===o.call(e)},bind:function(e,t){return function(i){return e.call(t,i)}},guard:function(e){return null==e?"":"object"==typeof e?JSON.stringify(e):e},checkNumber:function(e){return isNaN(e)||null===e||"boolean"==typeof e?e:Number(e)},extend:function(e,t){for(var i in t)e[i]!==t[i]&&(e[i]=t[i]);return e},unique:function(e){for(var t,i=v.hash(),r=e.length,n=[];r--;)t=e[r],i[t]||(i[t]=1,n.push(t));return n},toConstructor:function(e){return n=n||t("./viewmodel"),v.isObject(e)?n.extend(e):"function"==typeof e?e:null},checkFilter:function(e){u.test(e.toString())&&(e.computed=!0)},processOptions:function(e){var t,i=e.components,r=e.partials,n=e.template,s=e.filters;if(i)for(t in i)i[t]=v.toConstructor(i[t]);if(r)for(t in r)r[t]=v.parseTemplateOption(r[t]);if(s)for(t in s)v.checkFilter(s[t]);n&&(e.template=v.parseTemplateOption(n))},nextTick:function(e){p(e,0)},addClass:function(e,t){if(d)e.classList.add(t);else{var i=" "+e.className+" ";i.indexOf(" "+t+" ")<0&&(e.className=(i+t).trim())}},removeClass:function(e,t){if(d)e.classList.remove(t);else{for(var i=" "+e.className+" ",r=" "+t+" ";i.indexOf(r)>=0;)i=i.replace(r," ");e.className=i.trim()}},objectToArray:function(e){var t,i,r=[];for(var n in e)t=e[n],i=v.isObject(t)?t:{$value:t},i.$key=n,r.push(i);return r}}}),e.register("vue/src/fragment.js",function(e,t,i){var r={legend:[1,"<fieldset>","</fieldset>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],_default:[0,"",""]};r.td=r.th=[3,"<table><tbody><tr>","</tr></tbody></table>"],r.option=r.optgroup=[1,'<select multiple="multiple">',"</select>"],r.thead=r.tbody=r.colgroup=r.caption=r.tfoot=[1,"<table>","</table>"],r.text=r.circle=r.ellipse=r.line=r.path=r.polygon=r.polyline=r.rect=[1,'<svg xmlns="http://www.w3.org/2000/svg" version="1.1">',"</svg>"];var n=/<([\w:]+)/;i.exports=function(e){var t=document.createDocumentFragment(),i=n.exec(e);if(!i)return t.appendChild(document.createTextNode(e)),t;var s=i[1],o=r[s]||r._default,a=o[0],c=o[1],l=o[2],u=document.createElement("div");for(u.innerHTML=c+e.trim()+l;a--;)u=u.lastChild;if(u.firstChild===u.lastChild)return t.appendChild(u.firstChild),t;for(var h;h=u.firstChild;)1===u.nodeType&&t.appendChild(h);return t}}),e.register("vue/src/compiler.js",function(e,t,i){function r(e,t){var i,r,s=this;s.init=!0,s.destroyed=!1,t=s.options=t||{},l.processOptions(t),m(s,t.compilerOptions),s.repeat=s.repeat||!1,s.expCache=s.expCache||{};var a=s.el=s.setupElement(t);s.vm=a.vue_vm=e,s.bindings=l.hash(),s.dirs=[],s.deferred=[],s.computed=[],s.children=[],s.emitter=new o(e),e.$={},e.$el=a,e.$options=t,e.$compiler=s,e.$event=null;var c=t.parent;if(c&&(s.parent=c.$compiler,c.$compiler.children.push(s),e.$parent=c,"lazy"in t||(t.lazy=s.parent.options.lazy)),e.$root=n(s).vm,s.setupObserver(),t.methods)for(i in t.methods)s.createBinding(i);if(t.computed)for(i in t.computed)s.createBinding(i);var u=s.data=t.data||{},h=t.defaultData;if(h)for(i in h)g.call(u,i)||(u[i]=h[i]);var f=t.paramAttributes;if(f)for(r=f.length;r--;)u[f[r]]=l.checkNumber(s.eval(a.getAttribute(f[r])));m(e,u),e.$data=u,s.execHook("created"),u=s.data=e.$data;var p;for(i in e)p=e[i],"$"!==i.charAt(0)&&u[i]!==p&&"function"!=typeof p&&(u[i]=p);for(s.observeData(u),t.template&&this.resolveContent(),s.compile(a,!0),r=s.deferred.length;r--;)s.bindDirective(s.deferred[r]);s.deferred=null,this.computed.length&&d.parse(this.computed),s.init=!1,s.execHook("ready")}function n(e){for(;e.parent;)e=e.parent;return e}var s,o=t("./emitter"),a=t("./observer"),c=t("./config"),l=t("./utils"),u=t("./binding"),h=t("./directive"),f=t("./text-parser"),d=t("./deps-parser"),p=t("./exp-parser"),v=[].slice,m=l.extend,g={}.hasOwnProperty,b=Object.defineProperty,y=["created","ready","beforeDestroy","afterDestroy","attached","detached"],_=["if","repeat","view","component"],x=r.prototype;x.setupElement=function(e){var t,i,r,n,s,o="string"==typeof e.el?document.querySelector(e.el):e.el||document.createElement(e.tagName||"div"),a=e.template;if(a){if(o.hasChildNodes())for(this.rawContent=document.createElement("div");t=o.firstChild;)this.rawContent.appendChild(t);if(e.replace&&a.firstChild===a.lastChild){if(i=a.firstChild.cloneNode(!0),o.parentNode&&(o.parentNode.insertBefore(i,o),o.parentNode.removeChild(o)),o.hasAttributes())for(r=o.attributes.length;r--;)n=o.attributes[r],i.setAttribute(n.name,n.value);o=i}else o.appendChild(a.cloneNode(!0))}if(e.id&&(o.id=e.id),e.className&&(o.className=e.className),s=e.attributes)for(n in s)o.setAttribute(n,s[n]);return o},x.resolveContent=function(){function e(e,t){for(var i=e.parentNode,r=0,n=t.length;n>r;r++)i.insertBefore(t[r],e);i.removeChild(e)}var t,i,r,n,s,o=v.call(this.el.getElementsByTagName("content")),a=this.rawContent;if(r=o.length){for(;r--;)t=o[r],a?(i=t.getAttribute("select"),i?t.content=v.call(a.querySelectorAll(i)):s=t):t.content=v.call(t.childNodes);for(r=0,n=o.length;n>r;r++)t=o[r],t!==s&&e(t,t.content);a&&s&&e(s,v.call(a.childNodes))}this.rawContent=null},x.setupObserver=function(){function e(e){n(e),d.catcher.emit("get",a[e])}function t(e,t,i){l.emit("change:"+e,t,i),n(e),a[e].update(t)}function i(e,t){l.on("hook:"+e,function(){t.call(s.vm)})}function r(e){var t=s.children;if(t)for(var i,r=t.length;r--;)i=t[r],i.el.parentNode&&(e="hook:"+(e?"attached":"detached"),i.observer.emit(e),i.emitter.emit(e))}function n(e){a[e]||s.createBinding(e)}var s=this,a=s.bindings,c=s.options,l=s.observer=new o(s.vm);l.proxies={},l.on("get",e).on("set",t).on("mutate",t);for(var u,h,f,p=y.length;p--;)if(h=y[p],f=c[h],Array.isArray(f))for(u=f.length;u--;)i(h,f[u]);else f&&i(h,f);l.on("hook:attached",function(){r(1)}).on("hook:detached",function(){r(0)})},x.observeData=function(e){function t(e){"$data"!==e&&i()}function i(){s.update(r.data),n.emit("change:$data",r.data)}var r=this,n=r.observer;a.observe(e,"",n);var s=r.bindings.$data=new u(r,"$data");s.update(e),b(r.vm,"$data",{get:function(){return r.observer.emit("get","$data"),r.data},set:function(e){var t=r.data;a.unobserve(t,"",n),r.data=e,a.copyPaths(e,t),a.observe(e,"",n),i()}}),n.on("set",t).on("mutate",t)},x.compile=function(e,t){var i=e.nodeType;1===i&&"SCRIPT"!==e.tagName?this.compileElement(e,t):3===i&&c.interpolate&&this.compileTextNode(e)},x.checkPriorityDir=function(e,t,i){var r,n,s;if("component"===e&&i!==!0&&(s=this.resolveComponent(t,void 0,!0))?(n=this.parseDirective(e,"",t),n.Ctor=s):(r=l.attr(t,e),n=r&&this.parseDirective(e,r,t)),n){if(i===!0)return;return this.deferred.push(n),!0}},x.compileElement=function(e,t){if("TEXTAREA"===e.tagName&&e.value&&(e.value=this.eval(e.value)),e.hasAttributes()||e.tagName.indexOf("-")>-1){if(null!==l.attr(e,"pre"))return;var i,r,n,s;for(i=0,r=_.length;r>i;i++)if(this.checkPriorityDir(_[i],e,t))return;e.vue_trans=l.attr(e,"transition"),e.vue_anim=l.attr(e,"animation"),e.vue_effect=this.eval(l.attr(e,"effect"));var o,a,u,h,d,p,m,g=c.prefix+"-",b=this.options.paramAttributes;if(t){var y=l.attr(e,"with");if(y)for(d=this.parseDirective("with",y,e,!0),n=0,s=d.length;s>n;n++)this.bindDirective(d[n],this.parent)}var x=v.call(e.attributes);for(i=0,r=x.length;r>i;i++){if(o=x[i],a=o.name,u=!1,0===a.indexOf(g))for(u=!0,m=a.slice(g.length),d=this.parseDirective(m,o.value,e,!0),n=0,s=d.length;s>n;n++)this.bindDirective(d[n]);else c.interpolate&&(h=f.parseAttr(o.value),h&&(p=this.parseDirective("attr",h,e),p.arg=a,b&&b.indexOf(a)>-1?this.bindDirective(p,this.parent):this.bindDirective(p)));u&&"cloak"!==m&&e.removeAttribute(a)}}e.hasChildNodes()&&v.call(e.childNodes).forEach(this.compile,this)},x.compileTextNode=function(e){var t=f.parse(e.nodeValue);if(t){for(var i,r,n,s=0,o=t.length;o>s;s++)r=t[s],n=null,r.key?">"===r.key.charAt(0)?(i=document.createComment("ref"),n=this.parseDirective("partial",r.key.slice(1),i)):r.html?(i=document.createComment(c.prefix+"-html"),n=this.parseDirective("html",r.key,i)):(i=document.createTextNode(""),n=this.parseDirective("text",r.key,i)):i=document.createTextNode(r),e.parentNode.insertBefore(i,e),this.bindDirective(n);e.parentNode.removeChild(e)}},x.parseDirective=function(e,t,i,r){function n(t){return new h(e,t,o,s,i)}var s=this,o=s.getOption("directives",e);if(o){var a=h.parse(t);return r?a.map(n):n(a[0])}},x.bindDirective=function(e,t){if(e){if(this.dirs.push(e),e.isEmpty||e.isLiteral)return void(e.bind&&e.bind());var i,r=t||this,n=e.key;if(e.isExp)i=r.createBinding(n,e);else{for(;r&&!r.hasKey(n);)r=r.parent;r=r||this,i=r.bindings[n]||r.createBinding(n)}i.dirs.push(e),e.binding=i;var s=i.val();e.bind&&e.bind(s),e.$update(s,!0)}},x.createBinding=function(e,t){var i=this,r=i.options.methods,n=t&&t.isExp,s=t&&t.isFn||r&&r[e],o=i.bindings,c=i.options.computed,h=new u(i,e,n,s);if(n)i.defineExp(e,h,t);else if(s)o[e]=h,i.defineVmProp(e,h,r[e]);else if(o[e]=h,h.root)c&&c[e]?i.defineComputed(e,h,c[e]):"$"!==e.charAt(0)?i.defineDataProp(e,h):(i.defineVmProp(e,h,i.data[e]),delete i.data[e]);else if(c&&c[l.baseKey(e)])i.defineExp(e,h);else{a.ensurePath(i.data,e);var f=e.slice(0,e.lastIndexOf("."));o[f]||i.createBinding(f)}return h},x.defineDataProp=function(e,t){var i=this,r=i.data,n=r.__emitter__;g.call(r,e)||(r[e]=void 0),n&&!g.call(n.values,e)&&a.convertKey(r,e),t.value=r[e],b(i.vm,e,{get:function(){return i.data[e]},set:function(t){i.data[e]=t}})},x.defineVmProp=function(e,t,i){var r=this.observer;t.value=i,b(this.vm,e,{get:function(){return a.shouldGet&&r.emit("get",e),t.value},set:function(t){r.emit("set",e,t)}})},x.defineExp=function(e,t,i){var r=i&&i.computedKey,n=r?i.expression:e,s=this.expCache[n];s||(s=this.expCache[n]=p.parse(r||e,this)),s&&this.markComputed(t,s)},x.defineComputed=function(e,t,i){this.markComputed(t,i),b(this.vm,e,{get:t.value.$get,set:t.value.$set})},x.markComputed=function(e,t){e.isComputed=!0,e.isFn?e.value=t:("function"==typeof t&&(t={$get:t}),e.value={$get:l.bind(t.$get,this.vm),$set:t.$set?l.bind(t.$set,this.vm):void 0}),this.computed.push(e)},x.getOption=function(e,t,i){var r=this.options,n=this.parent,s=c.globalAssets,o=r[e]&&r[e][t]||(n?n.getOption(e,t,i):s[e]&&s[e][t]);return o},x.execHook=function(e){e="hook:"+e,this.observer.emit(e),this.emitter.emit(e)},x.hasKey=function(e){var t=l.baseKey(e);return g.call(this.data,t)||g.call(this.vm,t)},x.eval=function(e,t){var i=f.parseAttr(e);return i?p.eval(i,this,t):e},x.resolveComponent=function(e,i,r){s=s||t("./viewmodel");var n=l.attr(e,"component"),o=e.tagName,a=this.eval(n,i),c=o.indexOf("-")>0&&o.toLowerCase(),u=this.getOption("components",a||c,!0);return r?""===n?s:u:u||s},x.destroy=function(e){if(!this.destroyed){var t,i,r,n,s,o,c=this,l=c.vm,u=c.el,h=c.dirs,f=c.computed,d=c.bindings,p=c.children,v=c.parent;for(c.execHook("beforeDestroy"),a.unobserve(c.data,"",c.observer),t=p.length;t--;)p[t].destroy(!0);for(t=h.length;t--;)n=h[t],n.binding&&n.binding.compiler!==c&&(s=n.binding.dirs,s&&(i=s.indexOf(n),i>-1&&s.splice(i,1))),n.$unbind();for(t=f.length;t--;)f[t].unbind();for(r in d)o=d[r],o&&o.unbind();v&&(i=v.children.indexOf(c),i>-1&&v.children.splice(i,1)),e||(u===document.body?u.innerHTML="":l.$remove()),u.vue_vm=null,c.destroyed=!0,c.execHook("afterDestroy"),c.observer.off(),c.emitter.off()}},i.exports=r}),e.register("vue/src/viewmodel.js",function(e,t,i){function r(e){e!==!1&&new s(this,e)}function n(e){return"string"==typeof e?document.querySelector(e):e}var s=t("./compiler"),o=t("./utils"),a=t("./transition"),c=t("./batcher"),l=[].slice,u=o.defProtected,h=o.nextTick,f=new c,d=1,p=r.prototype;u(p,"$init",function(e){new s(this,e)}),u(p,"$get",function(e){var t=o.get(this,e);return void 0===t&&this.$parent?this.$parent.$get(e):t}),u(p,"$set",function(e,t){o.set(this,e,t)}),u(p,"$watch",function(e,t){function i(){var e=l.call(arguments);f.push({id:r,override:!0,execute:function(){t.apply(n,e)}})}var r=d++,n=this;t._fn=i,n.$compiler.observer.on("change:"+e,i)}),u(p,"$unwatch",function(e,t){var i=["change:"+e],r=this.$compiler.observer;t&&i.push(t._fn),r.off.apply(r,i)}),u(p,"$destroy",function(e){this.$compiler.destroy(e)}),u(p,"$broadcast",function(){for(var e,t=this.$compiler.children,i=t.length;i--;)e=t[i],e.emitter.applyEmit.apply(e.emitter,arguments),e.vm.$broadcast.apply(e.vm,arguments)}),u(p,"$dispatch",function(){var e=this.$compiler,t=e.emitter,i=e.parent;t.applyEmit.apply(t,arguments),i&&i.vm.$dispatch.apply(i.vm,arguments)}),["emit","on","off","once"].forEach(function(e){var t="emit"===e?"applyEmit":e;u(p,"$"+e,function(){var e=this.$compiler.emitter;e[t].apply(e,arguments)})}),u(p,"$appendTo",function(e,t){e=n(e);var i=this.$el;a(i,1,function(){e.appendChild(i),t&&h(t)},this.$compiler)}),u(p,"$remove",function(e){var t=this.$el;a(t,-1,function(){t.parentNode&&t.parentNode.removeChild(t),e&&h(e)},this.$compiler)}),u(p,"$before",function(e,t){e=n(e);var i=this.$el;a(i,1,function(){e.parentNode.insertBefore(i,e),t&&h(t)},this.$compiler)}),u(p,"$after",function(e,t){e=n(e);var i=this.$el;a(i,1,function(){e.nextSibling?e.parentNode.insertBefore(i,e.nextSibling):e.parentNode.appendChild(i),t&&h(t)},this.$compiler)}),i.exports=r}),e.register("vue/src/binding.js",function(e,t,i){function r(e,t,i,r){this.id=o++,this.value=void 0,this.isExp=!!i,this.isFn=r,this.root=!this.isExp&&-1===t.indexOf("."),this.compiler=e,this.key=t,this.dirs=[],this.subs=[],this.deps=[],this.unbound=!1}var n=t("./batcher"),s=new n,o=1,a=r.prototype;a.update=function(e){if((!this.isComputed||this.isFn)&&(this.value=e),this.dirs.length||this.subs.length){var t=this;s.push({id:this.id,execute:function(){t.unbound||t._update()}})}},a._update=function(){for(var e=this.dirs.length,t=this.val();e--;)this.dirs[e].$update(t);this.pub()},a.val=function(){return this.isComputed&&!this.isFn?this.value.$get():this.value},a.pub=function(){for(var e=this.subs.length;e--;)this.subs[e].update()},a.unbind=function(){this.unbound=!0;for(var e=this.dirs.length;e--;)this.dirs[e].$unbind();e=this.deps.length;for(var t;e--;){t=this.deps[e].subs;var i=t.indexOf(this);i>-1&&t.splice(i,1)}},i.exports=r}),e.register("vue/src/observer.js",function(e,t,i){function r(e){x(O,e,function(){var t,i,r=E.call(arguments),o=Array.prototype[e].apply(this,r);return"push"===e||"unshift"===e?t=r:"pop"===e||"shift"===e?i=[o]:"splice"===e&&(t=r.slice(2),i=o),n(this,t),s(this,i),this.__emitter__.emit("mutate","",this,{method:e,args:r,result:o,inserted:t,removed:i}),o},!A)}function n(e,t){if(t)for(var i,r,n=t.length;n--;)i=t[n],o(i)&&(i.__emitter__||(a(i),l(i)),r=i.__emitter__.owners,r.indexOf(e)<0&&r.push(e))}function s(e,t){if(t)for(var i,r=t.length;r--;)if(i=t[r],i&&i.__emitter__){var n=i.__emitter__.owners;n&&n.splice(n.indexOf(e))}}function o(e){return"object"==typeof e&&e&&!e.$compiler}function a(e){if(e.__emitter__)return!0;var t=new y;return x(e,"__emitter__",t),t.on("set",function(t,i,r){r&&c(e)}).on("mutate",function(){c(e)}),t.values=_.hash(),t.owners=[],!1}function c(e){for(var t=e.__emitter__.owners,i=t.length;i--;)t[i].__emitter__.emit("set","","",!0)}function l(e){k(e)?f(e):h(e)}function u(e,t){if(A)e.__proto__=t;else for(var i in t)x(e,i,t[i])}function h(e){u(e,j);for(var t in e)d(e,t)}function f(e){u(e,O),n(e,e)}function d(e,t,i){function r(e,i){o[t]=e,s.emit("set",t,e,i),k(e)&&s.emit("set",t+".length",e.length,i),g(e,t,s)}var n=t.charAt(0);if("$"!==n&&"_"!==n){var s=e.__emitter__,o=s.values;r(e[t],i),C(e,t,{enumerable:!0,configurable:!0,get:function(){var e=o[t];return N.shouldGet&&s.emit("get",t),e},set:function(e){var i=o[t];b(i,t,s),v(e,i),r(e,!0)}})}}function p(e){var t=e&&e.__emitter__;if(t)if(k(e))t.emit("set","length",e.length);else{var i,r;for(i in e)r=e[i],t.emit("set",i,r),p(r)}}function v(e,t){if($(e)&&$(t)){var i,r,n;for(i in t)w.call(e,i)||(r=t[i],k(r)?e[i]=[]:$(r)?(n=e[i]={},v(n,r)):e[i]=void 0)}}function m(e,t){for(var i,r=t.split("."),n=0,s=r.length-1;s>n;n++)i=r[n],e[i]||(e[i]={},e.__emitter__&&d(e,i)),e=e[i];$(e)&&(i=r[n],w.call(e,i)||(e[i]=void 0,e.__emitter__&&d(e,i)))}function g(e,t,i){if(o(e)){var r=t?t+".":"",n=a(e),s=e.__emitter__;i.proxies=i.proxies||{};var c=i.proxies[r]={get:function(e){i.emit("get",r+e)},set:function(n,s,o){n&&i.emit("set",r+n,s),t&&o&&i.emit("set",t,e,!0)},mutate:function(e,n,s){var o=e?r+e:t;i.emit("mutate",o,n,s);var a=s.method;"sort"!==a&&"reverse"!==a&&i.emit("set",o+".length",n.length)}};s.on("get",c.get).on("set",c.set).on("mutate",c.mutate),n?p(e):l(e)}}function b(e,t,i){if(e&&e.__emitter__){t=t?t+".":"";var r=i.proxies[t];r&&(e.__emitter__.off("get",r.get).off("set",r.set).off("mutate",r.mutate),i.proxies[t]=null)}}var y=t("./emitter"),_=t("./utils"),x=_.defProtected,$=_.isObject,k=Array.isArray,w={}.hasOwnProperty,C=Object.defineProperty,E=[].slice,A={}.__proto__,O=Object.create(Array.prototype);["push","pop","shift","unshift","splice","sort","reverse"].forEach(r),x(O,"$set",function(e,t){return this.splice(e,1,t)[0]},!A),x(O,"$remove",function(e){return"number"!=typeof e&&(e=this.indexOf(e)),e>-1?this.splice(e,1)[0]:void 0},!A);var j=Object.create(Object.prototype);x(j,"$add",function(e,t){w.call(this,e)||(this[e]=t,d(this,e,!0))},!A),x(j,"$delete",function(e){w.call(this,e)&&(this[e]=void 0,delete this[e],this.__emitter__.emit("delete",e))},!A);var N=i.exports={shouldGet:!1,observe:g,unobserve:b,ensurePath:m,copyPaths:v,watch:l,convert:a,convertKey:d}}),e.register("vue/src/directive.js",function(e,t,i){function r(e,t,i,n,o){this.id=s++,this.name=e,this.compiler=n,this.vm=n.vm,this.el=o,this.computeFilters=!1,this.key=t.key,this.arg=t.arg,this.expression=t.expression;var a=""===this.expression;if("function"==typeof i)this[a?"bind":"update"]=i;else for(var u in i)this[u]=i[u];if(a||this.isEmpty)return void(this.isEmpty=!0);h.Regex.test(this.key)&&(this.key=n.eval(this.key),this.isLiteral&&(this.expression=this.key));var f,d,p,v,m,g=t.filters;if(g)for(this.filters=[],p=0,v=g.length;v>p;p++)f=g[p],d=this.compiler.getOption("filters",f.name),d&&(f.apply=d,this.filters.push(f),d.computed&&(m=!0));this.filters&&this.filters.length||(this.filters=null),m&&(this.computedKey=r.inlineFilters(this.key,this.filters),this.filters=null),this.isExp=m||!l.test(this.key)||c.test(this.key)}function n(e){return e.indexOf('"')>-1?e.replace(u,"'"):e}var s=1,o=/^[\w\$-]+$/,a=/[^\s'"]+|'[^']+'|"[^"]+"/g,c=/^\$(parent|root)\./,l=/^[\w\.$]+$/,u=/"/g,h=t("./text-parser"),f=r.prototype;f.$update=function(e,t){this.$lock||(t||e!==this.value||e&&"object"==typeof e)&&(this.value=e,this.update&&this.update(this.filters&&!this.computeFilters?this.$applyFilters(e):e,t))},f.$applyFilters=function(e){for(var t,i=e,r=0,n=this.filters.length;n>r;r++)t=this.filters[r],i=t.apply.apply(this.vm,[i].concat(t.args));return i},f.$unbind=function(){this.el&&this.vm&&(this.unbind&&this.unbind(),this.vm=this.el=this.binding=this.compiler=null)},r.parse=function(e){function t(){v.expression=e.slice(f,g).trim(),void 0===v.key?v.key=e.slice(d,g).trim():m!==f&&i(),(0===g||v.key)&&p.push(v)}function i(){var t,i=e.slice(m,g).trim();if(i){t={};var r=i.match(a);t.name=r[0],t.args=r.length>1?r.slice(1):null}t&&(v.filters=v.filters||[]).push(t),m=g+1}for(var r,n,s=!1,c=!1,l=0,u=0,h=0,f=0,d=0,p=[],v={},m=0,g=0,b=e.length;b>g;g++)n=e.charAt(g),s?"'"===n&&(s=!s):c?'"'===n&&(c=!c):","!==n||h||l||u?":"!==n||v.key||v.arg?"|"===n&&"|"!==e.charAt(g+1)&&"|"!==e.charAt(g-1)?void 0===v.key?(m=g+1,v.key=e.slice(d,g).trim()):i():'"'===n?c=!0:"'"===n?s=!0:"("===n?h++:")"===n?h--:"["===n?u++:"]"===n?u--:"{"===n?l++:"}"===n&&l--:(r=e.slice(f,g).trim(),o.test(r)&&(d=g+1,v.arg=r)):(t(),v={},f=d=m=g+1);return(0===g||f!==g)&&t(),p},r.inlineFilters=function(e,t){for(var i,r,s=0,o=t.length;o>s;s++)r=t[s],i=r.args?',"'+r.args.map(n).join('","')+'"':"",e='this.$compiler.getOption("filters", "'+r.name+'").call(this,'+e+i+")";return e},i.exports=r}),e.register("vue/src/exp-parser.js",function(e,t){function i(e){return e=e.replace(p,"").replace(v,",").replace(d,"").replace(m,"").replace(g,""),e?e.split(/,+/):[]}function r(e,t,i){var r="",n=0,s=t;if(i&&void 0!==o.get(i,e))return"$temp.";for(;t&&!t.hasKey(e);)t=t.parent,n++;if(t){for(;n--;)r+="$parent.";t.bindings[e]||"$"===e.charAt(0)||t.createBinding(e)}else s.createBinding(e);return r}function n(e,t){var i;try{i=new Function(e)}catch(r){}return i}function s(e){return"$"===e.charAt(0)?"\\"+e:e}var o=t("./utils"),a=/"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'/g,c=/"(\d+)"/g,l=/\n/g,u=new RegExp("constructor".split("").join("['\"+, ]*")),h=/\\u\d\d\d\d/,f="break,case,catch,continue,debugger,default,delete,do,else,false,finally,for,function,if,in,instanceof,new,null,return,switch,this,throw,true,try,typeof,var,void,while,with,undefined,abstract,boolean,byte,char,class,const,double,enum,export,extends,final,float,goto,implements,import,int,interface,long,native,package,private,protected,public,short,static,super,synchronized,throws,transient,volatile,arguments,let,yield,Math",d=new RegExp(["\\b"+f.replace(/,/g,"\\b|\\b")+"\\b"].join("|"),"g"),p=/\/\*(?:.|\n)*?\*\/|\/\/[^\n]*\n|\/\/[^\n]*$|'[^']*'|"[^"]*"|[\s\t\n]*\.[\s\t\n]*[$\w\.]+|[\{,]\s*[\w\$_]+\s*:/g,v=/[^\w$]+/g,m=/\b\d[^,]*/g,g=/^,+|,+$/g;e.parse=function(e,t,f){function d(e){var t=y.length;return y[t]=e.replace(l,"\\n"),'"'+t+'"'}function p(e){var i=e.charAt(0);e=e.slice(1);var n="this."+r(e,t,f)+e;return b[e]||(g+=n+";",b[e]=1),i+n}function v(e,t){return y[t]}if(!h.test(e)&&!u.test(e)){var m=i(e);if(!m.length)return n("return "+e,e);m=o.unique(m);var g="",b=o.hash(),y=[],_=new RegExp("[^$\\w\\.]("+m.map(s).join("|")+")[$\\w\\.]*\\b","g"),x=(" "+e).replace(a,d).replace(_,p).replace(c,v);return x=g+"return "+x,n(x,e)}},e.eval=function(t,i,r){var n,s=e.parse(t,i,r);return s&&(i.vm.$temp=r,n=s.call(i.vm),delete i.vm.$temp),n}}),e.register("vue/src/template-parser.js",function(e,t,i){var r=t("./fragment");i.exports=function(e){var t;if(e instanceof window.DocumentFragment)return e;if("string"==typeof e){if("#"!==e.charAt(0))return r(e);if(t=document.getElementById(e.slice(1)),!t)return}else{if(!e.nodeType)return;t=e}return"TEMPLATE"===t.tagName&&t.content?t.content:r("SCRIPT"===t.tagName?t.innerHTML:t.outerHTML)}}),e.register("vue/src/text-parser.js",function(e,t){function i(){var e=r(l),t=r(u);return new RegExp(e+e+e+"?(.+?)"+t+"?"+t+t)}function r(e){return e.replace(h,"\\$&")}function n(t){l=t[0],u=t[1],e.delimiters=t,e.Regex=i()}function s(t){if(!e.Regex.test(t))return null;for(var i,r,n,s,o=[];i=t.match(e.Regex);)r=i.index,r>0&&o.push(t.slice(0,r)),n={key:i[1].trim()},s=i[0],n.html=s.charAt(2)===l&&s.charAt(s.length-3)===u,o.push(n),t=t.slice(r+i[0].length);return t.length&&o.push(t),o}function o(e){c=c||t("./directive");var i=s(e);if(!i)return null;if(1===i.length)return i[0].key;for(var r,n=[],o=0,l=i.length;l>o;o++)r=i[o],n.push(r.key?a(r.key):'"'+r+'"');return n.join("+")}function a(e){if(e.indexOf("|")>-1){var t=c.parse(e),i=t&&t[0];i&&i.filters&&(e=c.inlineFilters(i.key,i.filters))}return"("+e+")"}var c,l="{",u="}",h=/[-.*+?^${}()|[\]\/\\]/g;e.Regex=i(),e.parse=s,e.parseAttr=o,e.setDelimiters=n,e.delimiters=[l,u]}),e.register("vue/src/deps-parser.js",function(e,t,i){function r(e){if(!e.isFn){var t=o.hash();e.deps=[],c.on("get",function(i){var r=t[i.key];r&&r.compiler===i.compiler||i.compiler.repeat&&!n(i.compiler,e.compiler)||(t[i.key]=i,e.deps.push(i),i.subs.push(e))}),e.value.$get(),c.off("get")}}function n(e,t){for(;t;){if(e===t)return!0;t=t.parent}}var s=t("./emitter"),o=t("./utils"),a=t("./observer"),c=new s;i.exports={catcher:c,parse:function(e){a.shouldGet=!0,e.forEach(r),a.shouldGet=!1}}}),e.register("vue/src/filters.js",function(e,t,i){function r(e,t){if(s.isObject(e)){for(var i in e)if(r(e[i],t))return!0}else if(null!=e)return e.toString().toLowerCase().indexOf(t)>-1}function n(e){return c.test(e)?e.slice(1,-1):void 0}var s=t("./utils"),o=s.get,a=[].slice,c=/^'.*'$/,l=i.exports=s.hash();l.capitalize=function(e){return e||0===e?(e=e.toString(),e.charAt(0).toUpperCase()+e.slice(1)):""},l.uppercase=function(e){return e||0===e?e.toString().toUpperCase():""},l.lowercase=function(e){return e||0===e?e.toString().toLowerCase():""},l.currency=function(e,t){if(e=parseFloat(e),!e&&0!==e)return"";t=t||"$";var i=Math.floor(e).toString(),r=i.length%3,n=r>0?i.slice(0,r)+(i.length>3?",":""):"",s="."+e.toFixed(2).slice(-2);return t+n+i.slice(r).replace(/(\d{3})(?=\d)/g,"$1,")+s},l.pluralize=function(e){var t=a.call(arguments,1);return t.length>1?t[e-1]||t[t.length-1]:t[e-1]||t[0]+"s"};var u={enter:13,tab:9,"delete":46,up:38,left:37,right:39,down:40,esc:27};l.key=function(e,t){if(e){var i=u[t];return i||(i=parseInt(t,10)),function(t){return t.keyCode===i?e.call(this,t):void 0}}},l.filterBy=function(e,t,i,a){i&&"in"!==i&&(a=i);var c=n(t)||this.$get(t);return c?(c=c.toLowerCase(),a=a&&(n(a)||this.$get(a)),Array.isArray(e)||(e=s.objectToArray(e)),e.filter(function(e){return a?r(o(e,a),c):r(e,c)})):e},l.filterBy.computed=!0,l.orderBy=function(e,t,i){var r=n(t)||this.$get(t);if(!r)return e;Array.isArray(e)||(e=s.objectToArray(e));var a=1;return i&&("-1"===i?a=-1:"!"===i.charAt(0)?(i=i.slice(1),a=this.$get(i)?1:-1):a=this.$get(i)?-1:1),e.slice().sort(function(e,t){return e=o(e,r),t=o(t,r),e===t?0:e>t?a:-a})},l.orderBy.computed=!0}),e.register("vue/src/transition.js",function(e,t,i){function r(e,t,i,r){if(!o.trans)return i(),f.CSS_SKIP;var n,s=e.classList,c=e.vue_trans_cb,u=a.enterClass,h=a.leaveClass,d=r?o.anim:o.trans;return c&&(e.removeEventListener(d,c),s.remove(u),s.remove(h),e.vue_trans_cb=null),t>0?(s.add(u),i(),r?(n=function(t){t.target===e&&(e.removeEventListener(d,n),e.vue_trans_cb=null,s.remove(u))},e.addEventListener(d,n),e.vue_trans_cb=n):l.push({execute:function(){s.remove(u)}}),f.CSS_E):(e.offsetWidth||e.offsetHeight?(s.add(h),n=function(t){t.target===e&&(e.removeEventListener(d,n),e.vue_trans_cb=null,i(),s.remove(h))},e.addEventListener(d,n),e.vue_trans_cb=n):i(),f.CSS_L)}function n(e,t,i,r,n){function s(t,i){var r=u(function(){t(),l.splice(l.indexOf(r),1),l.length||(e.vue_timeouts=null)},i);l.push(r)}var o=n.getOption("effects",r);if(!o)return i(),f.JS_SKIP;var a=o.enter,c=o.leave,l=e.vue_timeouts;if(l)for(var d=l.length;d--;)h(l[d]);return l=e.vue_timeouts=[],t>0?"function"!=typeof a?(i(),f.JS_SKIP_E):(a(e,i,s),f.JS_E):"function"!=typeof c?(i(),f.JS_SKIP_L):(c(e,i,s),f.JS_L)}function s(){var e=document.createElement("vue"),t="transitionend",i={webkitTransition:"webkitTransitionEnd",transition:t,mozTransition:t},r={};for(var n in i)if(void 0!==e.style[n]){r.trans=i[n];break}return r.anim=""===e.style.animation?"animationend":"webkitAnimationEnd",r}var o=s(),a=t("./config"),c=t("./batcher"),l=new c,u=window.setTimeout,h=window.clearTimeout,f={CSS_E:1,CSS_L:2,JS_E:3,JS_L:4,CSS_SKIP:-1,JS_SKIP:-2,JS_SKIP_E:-3,JS_SKIP_L:-4,INIT:-5,SKIP:-6};l._preFlush=function(){document.body.offsetHeight};var d=i.exports=function(e,t,i,s){var o=function(){i(),s.execHook(t>0?"attached":"detached")
};if(s.init)return o(),f.INIT;var a=""===e.vue_trans,c=""===e.vue_anim,l=e.vue_effect;return l?n(e,t,o,l,s):a||c?r(e,t,o,c):(o(),f.SKIP)};d.codes=f,d.sniff=s}),e.register("vue/src/batcher.js",function(e,t,i){function r(){this.reset()}var n=t("./utils"),s=r.prototype;s.push=function(e){if(e.id&&this.has[e.id]){if(e.override){var t=this.has[e.id];t.cancelled=!0,this.queue.push(e),this.has[e.id]=e}}else this.queue.push(e),this.has[e.id]=e,this.waiting||(this.waiting=!0,n.nextTick(n.bind(this.flush,this)))},s.flush=function(){this._preFlush&&this._preFlush();for(var e=0;e<this.queue.length;e++){var t=this.queue[e];t.cancelled||t.execute()}this.reset()},s.reset=function(){this.has=n.hash(),this.queue=[],this.waiting=!1},i.exports=r}),e.register("vue/src/directives/index.js",function(e,t,i){var r=t("../utils"),n=t("../config"),s=t("../transition"),o=i.exports=r.hash();o.component={isLiteral:!0,bind:function(){this.el.vue_vm||(this.childVM=new this.Ctor({el:this.el,parent:this.vm}))},unbind:function(){this.childVM&&this.childVM.$destroy()}},o.attr={bind:function(){var e=this.vm.$options.paramAttributes;this.isParam=e&&e.indexOf(this.arg)>-1},update:function(e){e||0===e?this.el.setAttribute(this.arg,e):this.el.removeAttribute(this.arg),this.isParam&&(this.vm[this.arg]=r.checkNumber(e))}},o.text={bind:function(){this.attr=3===this.el.nodeType?"nodeValue":"textContent"},update:function(e){this.el[this.attr]=r.guard(e)}},o.show=function(e){var t=this.el,i=e?"":"none",r=function(){t.style.display=i};s(t,e?1:-1,r,this.compiler)},o["class"]=function(e){this.arg?r[e?"addClass":"removeClass"](this.el,this.arg):(this.lastVal&&r.removeClass(this.el,this.lastVal),e&&(r.addClass(this.el,e),this.lastVal=e))},o.cloak={isEmpty:!0,bind:function(){var e=this.el;this.compiler.observer.once("hook:ready",function(){e.removeAttribute(n.prefix+"-cloak")})}},o.ref={isLiteral:!0,bind:function(){var e=this.expression;e&&(this.vm.$parent.$[e]=this.vm)},unbind:function(){var e=this.expression;e&&delete this.vm.$parent.$[e]}},o.on=t("./on"),o.repeat=t("./repeat"),o.model=t("./model"),o["if"]=t("./if"),o["with"]=t("./with"),o.html=t("./html"),o.style=t("./style"),o.partial=t("./partial"),o.view=t("./view")}),e.register("vue/src/directives/if.js",function(e,t,i){var r=t("../utils");i.exports={bind:function(){this.parent=this.el.parentNode,this.ref=document.createComment("vue-if"),this.Ctor=this.compiler.resolveComponent(this.el),this.parent.insertBefore(this.ref,this.el),this.parent.removeChild(this.el),r.attr(this.el,"view"),r.attr(this.el,"repeat")},update:function(e){e?this.childVM||(this.childVM=new this.Ctor({el:this.el.cloneNode(!0),parent:this.vm}),this.compiler.init?this.parent.insertBefore(this.childVM.$el,this.ref):this.childVM.$before(this.ref)):this.unbind()},unbind:function(){this.childVM&&(this.childVM.$destroy(),this.childVM=null)}}}),e.register("vue/src/directives/repeat.js",function(e,t,i){function r(e,t){for(var i,r=0,n=e.length;n>r;r++)if(i=e[r],!i.$reused&&i.$value===t)return r;return-1}var n=t("../utils"),s=t("../config");i.exports={bind:function(){this.identifier="$r"+this.id,this.expCache=n.hash();var e=this.el,t=this.container=e.parentNode;this.childId=this.compiler.eval(n.attr(e,"ref")),this.ref=document.createComment(s.prefix+"-repeat-"+this.key),t.insertBefore(this.ref,e),t.removeChild(e),this.collection=null,this.vms=null},update:function(e){Array.isArray(e)||n.isObject(e)&&(e=n.objectToArray(e)),this.oldVMs=this.vms,this.oldCollection=this.collection,e=this.collection=e||[];var t=e[0]&&n.isObject(e[0]);this.vms=this.oldCollection?this.diff(e,t):this.init(e,t),this.childId&&(this.vm.$[this.childId]=this.vms)},init:function(e,t){for(var i,r=[],n=0,s=e.length;s>n;n++)i=this.build(e[n],n,t),r.push(i),this.compiler.init?this.container.insertBefore(i.$el,this.ref):i.$before(this.ref);return r},diff:function(e,t){var i,n,s,o,a,c,l,u,h=this.container,f=this.oldVMs,d=[];for(d.length=e.length,i=0,n=e.length;n>i;i++)s=e[i],t?(s.$index=i,s.__emitter__&&s.__emitter__[this.identifier]?s.$reused=!0:d[i]=this.build(s,i,t)):(a=r(f,s),a>-1?(f[a].$reused=!0,f[a].$data.$index=i):d[i]=this.build(s,i,t));for(i=0,n=f.length;n>i;i++)o=f[i],s=this.arg?o.$data[this.arg]:o.$data,s.$reused&&(o.$reused=!0,delete s.$reused),o.$reused?(o.$index=s.$index,s.$key&&s.$key!==o.$key&&(o.$key=s.$key),d[o.$index]=o):(s.__emitter__&&delete s.__emitter__[this.identifier],o.$destroy());for(i=d.length;i--;)if(o=d[i],s=o.$data,c=d[i+1],o.$reused){for(u=o.$el.nextSibling;!u.vue_vm&&u!==this.ref;)u=u.nextSibling;if(l=u.vue_vm,l!==c)if(c){for(u=c.$el;!u.parentNode;)c=d[u.vue_vm.$index+1],u=c?c.$el:this.ref;h.insertBefore(o.$el,u)}else h.insertBefore(o.$el,this.ref);delete o.$reused,delete s.$index,delete s.$key}else o.$before(c?c.$el:this.ref);return d},build:function(e,t,i){var r,n,s=!i||this.arg;s&&(r=e,n=this.arg||"$value",e={},e[n]=r),e.$index=t;var o=this.el.cloneNode(!0),a=this.compiler.resolveComponent(o,e),c=new a({el:o,data:e,parent:this.vm,compilerOptions:{repeat:!0,expCache:this.expCache}});return i&&((r||e).__emitter__[this.identifier]=!0),c},unbind:function(){if(this.childId&&delete this.vm.$[this.childId],this.vms)for(var e=this.vms.length;e--;)this.vms[e].$destroy()}}}),e.register("vue/src/directives/on.js",function(e,t,i){t("../utils");i.exports={isFn:!0,bind:function(){if(this.context=this.binding.isExp?this.vm:this.binding.compiler.vm,"IFRAME"===this.el.tagName&&"load"!==this.arg){var e=this;this.iframeBind=function(){e.el.contentWindow.addEventListener(e.arg,e.handler)},this.el.addEventListener("load",this.iframeBind)}},update:function(e){if("function"==typeof e){this.reset();var t=this.vm,i=this.context;this.handler=function(r){r.targetVM=t,i.$event=r;var n=e.call(i,r);return i.$event=null,n},this.iframeBind?this.iframeBind():this.el.addEventListener(this.arg,this.handler)}},reset:function(){var e=this.iframeBind?this.el.contentWindow:this.el;this.handler&&e.removeEventListener(this.arg,this.handler)},unbind:function(){this.reset(),this.el.removeEventListener("load",this.iframeBind)}}}),e.register("vue/src/directives/model.js",function(e,t,i){function r(e){return o.call(e.options,function(e){return e.selected}).map(function(e){return e.value||e.text})}var n=t("../utils"),s=navigator.userAgent.indexOf("MSIE 9.0")>0,o=[].filter;i.exports={bind:function(){var e=this,t=e.el,i=t.type,r=t.tagName;e.lock=!1,e.ownerVM=e.binding.compiler.vm,e.event=e.compiler.options.lazy||"SELECT"===r||"checkbox"===i||"radio"===i?"change":"input",e.attr="checkbox"===i?"checked":"INPUT"===r||"SELECT"===r||"TEXTAREA"===r?"value":"innerHTML","SELECT"===r&&t.hasAttribute("multiple")&&(this.multi=!0);var o=!1;e.cLock=function(){o=!0},e.cUnlock=function(){o=!1},t.addEventListener("compositionstart",this.cLock),t.addEventListener("compositionend",this.cUnlock),e.set=e.filters?function(){if(!o){var i;try{i=t.selectionStart}catch(r){}e._set(),n.nextTick(function(){void 0!==i&&t.setSelectionRange(i,i)})}}:function(){o||(e.lock=!0,e._set(),n.nextTick(function(){e.lock=!1}))},t.addEventListener(e.event,e.set),s&&(e.onCut=function(){n.nextTick(function(){e.set()})},e.onDel=function(t){(46===t.keyCode||8===t.keyCode)&&e.set()},t.addEventListener("cut",e.onCut),t.addEventListener("keyup",e.onDel))},_set:function(){this.ownerVM.$set(this.key,this.multi?r(this.el):this.el[this.attr])},update:function(e,t){if(t&&void 0===e)return this._set();if(!this.lock){var i=this.el;"SELECT"===i.tagName?(i.selectedIndex=-1,this.multi&&Array.isArray(e)?e.forEach(this.updateSelect,this):this.updateSelect(e)):"radio"===i.type?i.checked=e==i.value:"checkbox"===i.type?i.checked=!!e:i[this.attr]=n.guard(e)}},updateSelect:function(e){for(var t=this.el.options,i=t.length;i--;)if(t[i].value==e){t[i].selected=!0;break}},unbind:function(){var e=this.el;e.removeEventListener(this.event,this.set),e.removeEventListener("compositionstart",this.cLock),e.removeEventListener("compositionend",this.cUnlock),s&&(e.removeEventListener("cut",this.onCut),e.removeEventListener("keyup",this.onDel))}}}),e.register("vue/src/directives/with.js",function(e,t,i){var r=t("../utils");i.exports={bind:function(){var e=this,t=e.arg,i=e.key,n=e.compiler,s=e.binding.compiler;return n===s?void(this.alone=!0):void(t&&(n.bindings[t]||n.createBinding(t),n.observer.on("change:"+t,function(t){n.init||(e.lock||(e.lock=!0,r.nextTick(function(){e.lock=!1})),s.vm.$set(i,t))})))},update:function(e){this.alone||this.lock||(this.arg?this.vm.$set(this.arg,e):this.vm.$data!==e&&(this.vm.$data=e))}}}),e.register("vue/src/directives/html.js",function(e,t,i){var r=t("../utils"),n=[].slice;i.exports={bind:function(){8===this.el.nodeType&&(this.nodes=[])},update:function(e){e=r.guard(e),this.nodes?this.swap(e):this.el.innerHTML=e},swap:function(e){for(var t=this.el.parentNode,i=this.nodes,s=i.length;s--;)t.removeChild(i[s]);var o=r.toFragment(e);this.nodes=n.call(o.childNodes),t.insertBefore(o,this.el)}}}),e.register("vue/src/directives/style.js",function(e,t,i){var r=["-webkit-","-moz-","-ms-"];i.exports={bind:function(){var e=this.arg;e&&("$"===e.charAt(0)&&(e=e.slice(1),this.prefixed=!0),this.prop=e)},update:function(e){var t,i=this.prop;if(null!=e&&(e+=""),i){if(e&&(t="!important"===e.slice(-10)?"important":"",t&&(e=e.slice(0,-10).trim())),this.el.style.setProperty(i,e,t),this.prefixed)for(var n=r.length;n--;)this.el.style.setProperty(r[n]+i,e,t)}else this.el.style.cssText=e}}}),e.register("vue/src/directives/partial.js",function(e,t,i){t("../utils");i.exports={isLiteral:!0,bind:function(){var e=this.expression;if(e){var t=this.el,i=this.compiler,r=i.getOption("partials",e);if(r)if(r=r.cloneNode(!0),8===t.nodeType){var n=[].slice.call(r.childNodes),s=t.parentNode;s.insertBefore(r,t),s.removeChild(t),n.forEach(i.compile,i)}else t.innerHTML="",t.appendChild(r)}}}}),e.register("vue/src/directives/view.js",function(e,t,i){i.exports={bind:function(){var e=this.raw=this.el,t=e.parentNode,i=this.ref=document.createComment("v-view");t.insertBefore(i,e),t.removeChild(e);for(var r,n=this.inner=document.createElement("div");r=e.firstChild;)n.appendChild(r)},update:function(e){this.unbind();var t=this.compiler.getOption("components",e);t&&(this.childVM=new t({el:this.raw.cloneNode(!0),parent:this.vm,compilerOptions:{rawContent:this.inner.cloneNode(!0)}}),this.el=this.childVM.$el,this.compiler.init?this.ref.parentNode.insertBefore(this.el,this.ref):this.childVM.$before(this.ref))},unbind:function(){this.childVM&&this.childVM.$destroy()}}}),e.alias("vue/src/main.js","vue/index.js"),"object"==typeof exports?module.exports=e("vue"):"function"==typeof define&&define.amd?define(function(){return e("vue")}):window.Vue=e("vue")}();

// tmp/app_bundle.js
/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

/**
 * @license
 * Lo-Dash 2.4.1 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used internally to indicate various things */
  var indicatorObject = {};

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to fix the JScript [[DontEnum]] bug */
  var shadowedProps = [
    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
    'toLocaleString', 'toString', 'valueOf'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      errorClass = '[object Error]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used as the data object for `iteratorTemplate` */
  var iteratorData = {
    'args': '',
    'array': null,
    'bottom': '',
    'firstArg': '',
    'init': '',
    'keys': null,
    'loop': '',
    'shadowedProps': null,
    'support': null,
    'top': '',
    'useHas': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Checks if `value` is a DOM node in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
   */
  function isNode(value) {
    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
    // methods that are `typeof` "string" and still can coerce nodes to strings
    return typeof value.toString != 'function' && typeof (value + '') == 'string';
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var errorProto = Error.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /** Used to avoid iterating non-enumerable properties in IE < 9 */
    var nonEnumProps = {};
    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
    nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
    nonEnumProps[objectClass] = { 'constructor': true };

    (function() {
      var length = shadowedProps.length;
      while (length--) {
        var key = shadowedProps[length];
        for (var className in nonEnumProps) {
          if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
            nonEnumProps[className][key] = false;
          }
        }
      }
    }());

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    (function() {
      var ctor = function() { this.x = 1; },
          object = { '0': 1, 'length': 1 },
          props = [];

      ctor.prototype = { 'valueOf': 1, 'y': 1 };
      for (var key in new ctor) { props.push(key); }
      for (key in arguments) { }

      /**
       * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.argsClass = toString.call(arguments) == argsClass;

      /**
       * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);

      /**
       * Detect if `name` or `message` properties of `Error.prototype` are
       * enumerable by default. (IE < 9, Safari < 5.1)
       *
       * @memberOf _.support
       * @type boolean
       */
      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');

      /**
       * Detect if `prototype` properties are enumerable by default.
       *
       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
       * (if the prototype or a property on the prototype has been set)
       * incorrectly sets a function's `prototype` property [[Enumerable]]
       * value to `true`.
       *
       * @memberOf _.support
       * @type boolean
       */
      support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');

      /**
       * Detect if functions can be decompiled by `Function#toString`
       * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

      /**
       * Detect if `Function#name` is supported (all but IE).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcNames = typeof Function.name == 'string';

      /**
       * Detect if `arguments` object indexes are non-enumerable
       * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.nonEnumArgs = key != 0;

      /**
       * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
       *
       * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
       * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.nonEnumShadows = !/valueOf/.test(props);

      /**
       * Detect if own properties are iterated after inherited properties (all but IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.ownLast = props[0] != 'x';

      /**
       * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
       *
       * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
       * and `splice()` functions that fail to remove the last element, `value[0]`,
       * of array-like objects even though the `length` property is set to `0`.
       * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
       * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
       *
       * @memberOf _.support
       * @type boolean
       */
      support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);

      /**
       * Detect lack of support for accessing string characters by index.
       *
       * IE < 8 can't access characters by index and IE 8 can only access
       * characters by index on string literals.
       *
       * @memberOf _.support
       * @type boolean
       */
      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';

      /**
       * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
       * and that the JS engine errors when attempting to coerce an object to
       * a string without a `toString` function.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
      } catch(e) {
        support.nodeClass = true;
      }
    }(1));

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The template used to create iterator functions.
     *
     * @private
     * @param {Object} data The data object used to populate the text.
     * @returns {string} Returns the interpolated text.
     */
    var iteratorTemplate = template(
      // the `iterable` may be reassigned by the `top` snippet
      'var index, iterable = <%= firstArg %>, ' +
      // assign the `result` variable an initial value
      'result = <%= init %>;\n' +
      // exit early if the first argument is falsey
      'if (!iterable) return result;\n' +
      // add code before the iteration branches
      '<%= top %>;' +

      // array-like iteration:
      '<% if (array) { %>\n' +
      'var length = iterable.length; index = -1;\n' +
      'if (<%= array %>) {' +

      // add support for accessing string characters by index if needed
      '  <% if (support.unindexedChars) { %>\n' +
      '  if (isString(iterable)) {\n' +
      "    iterable = iterable.split('')\n" +
      '  }' +
      '  <% } %>\n' +

      // iterate over the array-like value
      '  while (++index < length) {\n' +
      '    <%= loop %>;\n' +
      '  }\n' +
      '}\n' +
      'else {' +

      // object iteration:
      // add support for iterating over `arguments` objects if needed
      '  <% } else if (support.nonEnumArgs) { %>\n' +
      '  var length = iterable.length; index = -1;\n' +
      '  if (length && isArguments(iterable)) {\n' +
      '    while (++index < length) {\n' +
      "      index += '';\n" +
      '      <%= loop %>;\n' +
      '    }\n' +
      '  } else {' +
      '  <% } %>' +

      // avoid iterating over `prototype` properties in older Firefox, Opera, and Safari
      '  <% if (support.enumPrototypes) { %>\n' +
      "  var skipProto = typeof iterable == 'function';\n" +
      '  <% } %>' +

      // avoid iterating over `Error.prototype` properties in older IE and Safari
      '  <% if (support.enumErrorProps) { %>\n' +
      '  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n' +
      '  <% } %>' +

      // define conditions used in the loop
      '  <%' +
      '    var conditions = [];' +
      '    if (support.enumPrototypes) { conditions.push(\'!(skipProto && index == "prototype")\'); }' +
      '    if (support.enumErrorProps)  { conditions.push(\'!(skipErrorProps && (index == "message" || index == "name"))\'); }' +
      '  %>' +

      // iterate own properties using `Object.keys`
      '  <% if (useHas && keys) { %>\n' +
      '  var ownIndex = -1,\n' +
      '      ownProps = objectTypes[typeof iterable] && keys(iterable),\n' +
      '      length = ownProps ? ownProps.length : 0;\n\n' +
      '  while (++ownIndex < length) {\n' +
      '    index = ownProps[ownIndex];\n<%' +
      "    if (conditions.length) { %>    if (<%= conditions.join(' && ') %>) {\n  <% } %>" +
      '    <%= loop %>;' +
      '    <% if (conditions.length) { %>\n    }<% } %>\n' +
      '  }' +

      // else using a for-in loop
      '  <% } else { %>\n' +
      '  for (index in iterable) {\n<%' +
      '    if (useHas) { conditions.push("hasOwnProperty.call(iterable, index)"); }' +
      "    if (conditions.length) { %>    if (<%= conditions.join(' && ') %>) {\n  <% } %>" +
      '    <%= loop %>;' +
      '    <% if (conditions.length) { %>\n    }<% } %>\n' +
      '  }' +

      // Because IE < 9 can't set the `[[Enumerable]]` attribute of an
      // existing property and the `constructor` property of a prototype
      // defaults to non-enumerable, Lo-Dash skips the `constructor`
      // property when it infers it's iterating over a `prototype` object.
      '    <% if (support.nonEnumShadows) { %>\n\n' +
      '  if (iterable !== objectProto) {\n' +
      "    var ctor = iterable.constructor,\n" +
      '        isProto = iterable === (ctor && ctor.prototype),\n' +
      '        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n' +
      '        nonEnum = nonEnumProps[className];\n' +
      '      <% for (k = 0; k < 7; k++) { %>\n' +
      "    index = '<%= shadowedProps[k] %>';\n" +
      '    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))<%' +
      '        if (!useHas) { %> || (!nonEnum[index] && iterable[index] !== objectProto[index])<% }' +
      '      %>) {\n' +
      '      <%= loop %>;\n' +
      '    }' +
      '      <% } %>\n' +
      '  }' +
      '    <% } %>' +
      '  <% } %>' +
      '  <% if (array || support.nonEnumArgs) { %>\n}<% } %>\n' +

      // add code to the bottom of the iteration function
      '<%= bottom %>;\n' +
      // finally, return the `result`
      'return result'
    );

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className] || (!support.nodeClass && isNode(value))) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? baseEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Creates compiled iteration functions.
     *
     * @private
     * @param {...Object} [options] The compile options object(s).
     * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
     * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
     * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
     * @param {string} [options.args] A comma separated string of iteration function arguments.
     * @param {string} [options.top] Code to execute before the iteration branches.
     * @param {string} [options.loop] Code to execute in the object loop.
     * @param {string} [options.bottom] Code to execute after the iteration branches.
     * @returns {Function} Returns the compiled function.
     */
    function createIterator() {
      // data properties
      iteratorData.shadowedProps = shadowedProps;
      iteratorData.support = support;

      // iterator options
      iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
      iteratorData.init = 'iterable';
      iteratorData.useHas = true;

      // merge options into a template data object
      for (var object, index = 0; object = arguments[index]; index++) {
        for (var key in object) {
          iteratorData[key] = object[key];
        }
      }
      var args = iteratorData.args;
      iteratorData.firstArg = /^[^,]+/.exec(args)[0];

      // create the function factory
      var factory = Function(
          'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +
          'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' +
          'objectTypes, nonEnumProps, stringClass, stringProto, toString',
        'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}'
      );

      // return the compiled function
      return factory(
        baseCreateCallback, errorClass, errorProto, hasOwnProperty,
        indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto,
        objectTypes, nonEnumProps, stringClass, stringProto, toString
      );
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) ||
          (!support.argsClass && isArguments(value)) ||
          (!support.nodeClass && isNode(value))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      if (support.ownLast) {
        forIn(value, function(value, key, object) {
          result = hasOwnProperty.call(object, key);
          return false;
        });
        return result !== false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }
    // fallback for browsers that can't detect `arguments` objects by [[Class]]
    if (!support.argsClass) {
      isArguments = function(value) {
        return value && typeof value == 'object' && typeof value.length == 'number' &&
          hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
      };
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = createIterator({
      'args': 'object',
      'init': '[]',
      'top': 'if (!(objectTypes[typeof object])) return result',
      'loop': 'result.push(index)'
    });

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      if ((support.enumPrototypes && typeof object == 'function') ||
          (support.nonEnumArgs && object.length && isArguments(object))) {
        return shimKeys(object);
      }
      return nativeKeys(object);
    };

    /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
    var eachIteratorOptions = {
      'args': 'collection, callback, thisArg',
      'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
      'array': "typeof length == 'number'",
      'keys': keys,
      'loop': 'if (callback(iterable[index], index, collection) === false) return result'
    };

    /** Reusable iterator options for `assign` and `defaults` */
    var defaultsIteratorOptions = {
      'args': 'object, source, guard',
      'top':
        'var args = arguments,\n' +
        '    argsIndex = 0,\n' +
        "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
        'while (++argsIndex < argsLength) {\n' +
        '  iterable = args[argsIndex];\n' +
        '  if (iterable && objectTypes[typeof iterable]) {',
      'keys': keys,
      'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
      'bottom': '  }\n}'
    };

    /** Reusable iterator options for `forIn` and `forOwn` */
    var forOwnIteratorOptions = {
      'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
      'array': false
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /**
     * A function compiled to iterate `arguments` objects, arrays, objects, and
     * strings consistenly across environments, executing the callback for each
     * element in the collection. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index|key, collection). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @private
     * @type Function
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createIterator(eachIteratorOptions);

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = createIterator(defaultsIteratorOptions, {
      'top':
        defaultsIteratorOptions.top.replace(';',
          ';\n' +
          "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
          '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
          "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
          '  callback = args[--argsLength];\n' +
          '}'
        ),
      'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
    });

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = createIterator(defaultsIteratorOptions);

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
      'useHas': false
    });

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass ||
          (support.argsClass ? className == argsClass : isArguments(value))) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }
    // fallback for older versions of Chrome and Safari
    if (isFunction(/x/)) {
      isFunction = function(value) {
        return typeof value == 'function' && toString.call(value) == funcClass;
      };
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass) || (!support.argsClass && isArguments(value))) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? baseEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      if (support.unindexedChars && isString(collection)) {
        collection = collection.split('');
      }
      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        baseEach(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      if (isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        baseEach(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      if (isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        baseEach(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      if (isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        baseEach(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        baseEach(collection, callback, thisArg);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var iterable = collection,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (isArray(collection)) {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        if (typeof length != 'number') {
          var props = keys(collection);
          length = props.length;
        } else if (support.unindexedChars && isString(collection)) {
          iterable = collection.split('');
        }
        baseEach(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(iterable[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      callback = lodash.createCallback(callback, thisArg, 3);
      if (isArray(collection)) {
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        baseEach(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        baseEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        baseEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      if (isArray(collection)) {
        var index = -1,
            length = collection.length;

        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        baseEach(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      } else if (support.unindexedChars && isString(collection)) {
        collection = collection.split('');
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      if (isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        baseEach(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return (support.unindexedChars && isString(collection))
          ? collection.split('')
          : slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{ '{{' }}([\s\S]+?){{ '}}' }}/g
     * };
     *
     * _.template('hello {{ '{{' }} name {{ '}}' }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = iteratorTemplate ? defaults({}, options, settings) : settings;

      var imports = iteratorTemplate && defaults({}, options.imports, settings.imports),
          importsKeys = iteratorTemplate ? keys(imports) : ['_'],
          importsValues = iteratorTemplate ? values(imports) : [lodash];

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    baseEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    baseEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    baseEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    // avoid array-like object bugs with `Array#shift` and `Array#splice`
    // in IE < 9, Firefox < 10, Narwhal, and RingoJS
    if (!support.spliceObjects) {
      baseEach(['pop', 'shift', 'splice'], function(methodName) {
        var func = arrayRef[methodName],
            isSplice = methodName == 'splice';

        lodash.prototype[methodName] = function() {
          var chainAll = this.__chain__,
              value = this.__wrapped__,
              result = func.apply(value, arguments);

          if (value.length === 0) {
            delete value[0];
          }
          return (chainAll || isSplice)
            ? new lodashWrapper(result, chainAll)
            : result;
        };
      });
    }

    // add pseudo private property to be used and removed during the build process
    lodash._baseEach = baseEach;
    lodash._iteratorTemplate = iteratorTemplate;
    lodash._shimKeys = shimKeys;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define('lodash',[],function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

/**
 * Wraps Vue global in a define so it can be required/mocked
 */
define('vue',['require','exports','module'],function(require, exports, module) {
  module.exports = window['Vue'];
});

/**
 * Stores environment variables
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('env',['require','exports','module'],function(require, exports, module) {
  var config = module.config();

  module.exports = {
    IS_PRODUCTION: !!config.is_production,
    BACKEND_API_HOST: config.backend_api_host,
  };
});

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

define('utils/invariant',['require'],function(require) {
  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */
  return function(condition, format, a, b, c, d, e, f) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error(
          'Minified exception occurred; use the non-minified dev environment ' +
          'for the full error message and additional helpful warnings.'
        );
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(
          'Invariant Violation: ' +
          format.replace(/%s/g, function() { return args[argIndex++]; })
        );
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };
});

/*
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

define('flux/dispatcher',['utils/invariant'],function() {
  var invariant = require('utils/invariant');

  function Dispatcher() {
    this.$Dispatcher_callbacks = {};
    this.$Dispatcher_isPending = {};
    this.$Dispatcher_isHandled = {};
    this.$Dispatcher_isDispatching = false;
    this.$Dispatcher_pendingPayload = null;
  }

  /**
   * Registers a store `__handleAction__` method that is invoked with every
   * dispatched payload
   *
   * @param {Store} store
   */
  Dispatcher.prototype.register=function(store) {
    invariant(
      !this.$Dispatcher_callbacks[store.id],
      'Store with id=%s is already defined',
      store.id
    );
    this.$Dispatcher_callbacks[store.id] = store.__handleAction__.bind(store);
  };

  /**
   * Removes a store's callback based on the store.id
   *
   * @param {Store} store
   */
  Dispatcher.prototype.unregister=function(store) {
    invariant(
      this.$Dispatcher_callbacks[store.id],
      'Dispatcher.unregister(...): `%s` does not map to a registered callback.',
      id
    );
    delete this.$Dispatcher_callbacks[store.id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   *
   * @param {array.<string|number>} ids
   */
  Dispatcher.prototype.waitFor=function(ids) {
    invariant(
      this.$Dispatcher_isDispatching,
      'Dispatcher.waitFor(...): Must be invoked while dispatching.'
    );
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this.$Dispatcher_isPending[id]) {
        invariant(
          this.$Dispatcher_isHandled[id],
          'Dispatcher.waitFor(...): Circular dependency detected while ' +
          'waiting for `%s`.',
          id
        );
        continue;
      }
      invariant(
        this.$Dispatcher_callbacks[id],
        'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',
        id
      );
      this.$Dispatcher_invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   *
   * @param {object} payload
   */
  Dispatcher.prototype.dispatch=function(payload) {
    invariant(
      !this.$Dispatcher_isDispatching,
      'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'
    );
    this.$Dispatcher_startDispatching(payload);
    try {
      for (var id in this.$Dispatcher_callbacks) {
        if (this.$Dispatcher_isPending[id]) {
          continue;
        }
        this.$Dispatcher_invokeCallback(id);
      }
    } finally {
      this.$Dispatcher_stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   *
   * @return {boolean}
   */
  Dispatcher.prototype.isDispatching=function() {
    return this.$Dispatcher_isDispatching;
  };

  /**
   * Call the calback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @param {string} id
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_invokeCallback=function(id) {
    this.$Dispatcher_isPending[id] = true;
    this.$Dispatcher_callbacks[id](this.$Dispatcher_pendingPayload);
    this.$Dispatcher_isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @param {object} payload
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_startDispatching=function(payload) {
    for (var id in this.$Dispatcher_callbacks) {
      this.$Dispatcher_isPending[id] = false;
      this.$Dispatcher_isHandled[id] = false;
    }
    this.$Dispatcher_pendingPayload = payload;
    this.$Dispatcher_isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_stopDispatching=function() {
    this.$Dispatcher_pendingPayload = null;
    this.$Dispatcher_isDispatching = false;
  };

  return Dispatcher;
});

/**
 * Flux logger
 */
define('flux/logger',['require'],function(require) {
  function Logger() {
    // only 5 of the same action types can be logged per tick
    this.ACTION_LIMIT_THRESHOLD = 3;
    // mapping of actionTypes to number of times logged
    // this is reset after every event loop
    // used to throttle expensive _.cloneDeep when many dispatches
    // happen in the same tick
    this.__loggedActionsCount = {};
    this.__timeoutId = null;
    this.__currentDispatchAction = null;
  }

  /**
   * Logs the contents of all stores
   * @param {array.<{string: store}>} stores
   */
  Logger.prototype.dispatchStart = function(actionType, payload) {
    if (!this.__timeoutId) {
      this.__timeoutId = setTimeout(function() {
        // reset the logging state
        this.__currentDispatchAction = null
        this.__loggedActionsCount = {};
        this.__timeoutId = null;
      }.bind(this), 0);
    }

    // record the current dispatched action type for reference in dispatchEnd
    this.__currentDispatchAction = actionType;

    if (!this.__loggedActionsCount[actionType]) {
      this.__loggedActionsCount[actionType] = 0;
    }
    this.__loggedActionsCount[actionType]++;

    if (this.__loggedActionsCount[actionType] <= this.ACTION_LIMIT_THRESHOLD) {
      console.groupCollapsed('Dispatching: %s', actionType);
      console.group('payload');
      console.log(payload);
      console.groupEnd();
    } else {
      console.log('skip logging for Dispatch', actionType)
    }
  }

  /**
   * @param {array.<Store>} stores
   */
  Logger.prototype.dispatchEnd = function(stores) {
    var actionType = this.__currentDispatchAction;
    if (this.__loggedActionsCount[actionType] <= this.ACTION_LIMIT_THRESHOLD) {
      console.group('stores');
      console.log(_.cloneDeep(stores));
      console.groupEnd();
      // end dispatchStart goup
      console.groupEnd();
    }
  };

  /**
   * @param {string} storeId
   */
  Logger.prototype.handleActionStart = function(storeId, actionType) {
    if (this.__loggedActionsCount[actionType] <= this.ACTION_LIMIT_THRESHOLD) {
      console.group('handling: %s', storeId);
    }
  }

  Logger.prototype.handleActionEnd = function(actionType) {
    if (this.__loggedActionsCount[actionType] <= this.ACTION_LIMIT_THRESHOLD) {
      console.groupEnd();
    }
  }

  return Logger;
});

/**
 * Utils for flux getters
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/utils/getter',['require','exports','module','lodash'],function(require, exports, module) {
  var _ = require('lodash');

  /**
   * Takes a getter an returns a flat array of store dependencies
   */
  exports.flattenDeps = function(deps) {
    return _(deps)
      .flatten()
      .filter(_.isString)
      .uniq()
      .value()
  }

  /**
   * Helper function to recursively evaluate getters of the form
   *
   * ['dep1', 'dep2', function(dep1Value, dep2Value) { ... }]
   *
   * or recursively
   *
   * ['dep1', ['dep2', 'dep3', function(dep2Value, dep3Value) {...}], function(dep1Value, dep2Value) { ... }]
   *
   * @param {Flux} flux instance
   * @param {array} deps
   * @param {function} getterFn
   * @return {*}
   */
  exports.evaluate = function evaluate(flux, getter) {
    var len = getter.length;
    var deps = getter.slice(0, len - 1);
    var getterFn = getter.slice(len - 1)[0];

    var values = deps.map(function(dep) {
      if (_.isArray(dep)) {
        return evaluate(flux, dep);
      } else {
        return flux.store(dep);
      }
    })
    return getterFn.apply(null, values);
  }
});

/**
 * Creates a stream that consolidates stores changes
 */
define('flux/factories/store_change_stream_factory',['require'],function(require) {
  /**
   * @constructor
   * @param {Flux} flux
   */
  function StoreChangeStream(flux) {
    this.flux = flux;
    this.__storeUnwatchFns__ = [];
    this.__handlerMap__ = {};
    this.__handlers__ = [];
  }

  /**
   * Add event handler anytime an observed store changes
   * @param {string|array.<string>} storeIds
   * @param {function} handler
   * @return {this}
   */
  StoreChangeStream.prototype.onStoreChange = function(storeIds, handler) {
    if (!_.isArray(storeIds)) {
      storeIds = [storeIds];
    }

    var handlerEntry = {
      storeIds: storeIds,
      handler: handler,
    };

    this.__handlers__.push(handlerEntry);

    storeIds.forEach(function(id) {
      if (!this.__handlerMap__[id]) {
        this.__handlerMap__[id] = [];
        this._watchStore(id);
      }
      // pass in all the dependency storeIds so that they
      // can be injected as fn arguments to the handler
      this.__handlerMap__[id].push(handlerEntry)
    }.bind(this));

    // return for chaining
    return this;
  };

  /**
   * Forces all the registered handler functions to be run
   */
  StoreChangeStream.prototype.forceUpdate = function() {
    this.__handlers__.forEach(this._invokeHandler.bind(this));
    // for chaining
    return this;
  };

  /**
   * Cleans up all store event listeners
   */
  StoreChangeStream.prototype.destroy = function() {
    var unwatchFns = this.__storeUnwatchFns__;
    while (unwatchFns.length > 0) {
      unwatchFns.shift()();
    }
    delete this.__handlerMap__;
    delete this.__handlers__;
  };

  /**
   * Invokes a handler with the dependent stores passed in
   * @param {object} entry
   */
  StoreChangeStream.prototype._invokeHandler = function(entry) {
    var getStore = this.flux.store.bind(this.flux);
    // array.<storeIds> => array.<Store>
    var stores = entry.storeIds.map(getStore);
    // [handlerFn, store1, store2]
    var toApply = [entry.handler].concat(stores);
    // pass the stores to the handler function
    var handlerWithArgs = _.partial.apply(_, toApply);
    handlerWithArgs();
  };

  /**
   * @private
   * @param {string} storeId
   */
  StoreChangeStream.prototype._watchStore = function(storeId) {
    var flux = this.flux;
    var store = flux.store(storeId);
    var unwatch = store.addChangeListener(function() {
      this.__handlerMap__[storeId].forEach(this._invokeHandler.bind(this));
    }.bind(this));
    // save reference to all the unwatch functions
    this.__storeUnwatchFns__.push(unwatch);
  }

  return {
    create: function(flux) {
      return new StoreChangeStream(flux);
    }
  };
});

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define('flux/utils/update_array',factory);
	else if(typeof exports === 'object')
		exports["arrayUpdater"] = factory();
	else
		root["arrayUpdater"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var diff = __webpack_require__(1);
	var extend = __webpack_require__(2);

	/**
	 * Finds and returns the first instance of an object that has
	 * obj[idKey]===val
	 */
	function findByProp(arr, idKey, val) {
	  for (var i = 0; i < arr.length; i++) {
	    var entry = arr[i]
	    if (entry[idKey] === val) {
	      return entry;
	    }
	  }
	}

	module.exports = function execute(arr, newArr) {
	  var instructions = diff(arr, newArr)['ids'];

	  var pointer = 0;

	  var cache = (function createCache() {
	    var cache = {};

	    instructions.forEach(function(step) {
	      var action = step[0];
	      var id = step[1]
	      if (action === 'x') {
	        cache[id] = findByProp(arr, 'id', id)
	      }
	    });

	    return cache;
	  })();

	  instructions.forEach(function(step) {
	    var action = step[0];
	    var id = step[1];

	    switch (action) {
	      case 'x':
	      case '-':
	        // take out spliced item
	        arr.splice(pointer, 1);
	        break;

	      case '+':
	        arr.splice(pointer, 0, findByProp(newArr, 'id', id));
	        pointer++;
	        break

	      case 'p':
	        arr.splice(pointer, 0, cache[id]);
	      case '=':
	        extend(arr[pointer], findByProp(newArr, 'id', id));
	        pointer++;
	        break;

	    }
	  });
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var arrayDiff = __webpack_require__(3)({unique:true})

	var idMap = function(array) {
	  var map = {}
	  array.forEach(function(each) {
	    map[each.id] = each.value
	  })
	  return map
	}

	var ids = function(idValueArray) {
	  return idValueArray.map(function(each) {return each.id})
	}

	var diff = function(before, after) {
	  var valueDiff = {}
	  var afterMap = idMap(after)
	  before.forEach(function(each) {
	    var afterValue = afterMap[each.id]
	    if(afterValue === undefined) return valueDiff[each.id] = ['-', each.value]
	    if(each.value != afterValue) {
	      valueDiff[each.id] = ['m', each.value, afterValue]
	    } else {
	      valueDiff[each.id] = ['=', each.value]
	    }
	  })
	  var idDiff = arrayDiff(ids(before), ids(after))
	  idDiff.forEach(function(each) {
	    if(each[0] == '+') valueDiff[each[1]] = ['+', afterMap[each[1]]]
	  })
	  return {values: valueDiff, ids: idDiff}
	}

	module.exports = diff


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(6)

	module.exports = function extend(object, source) {
	  //console.log('extending', Osource.__proto__)
	  var props = keys(source);
	  var length = props.legnth;

	  keys(source).forEach(function(key) {
	    object[key] = source[key]
	  });
	  return object;
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var union = __webpack_require__(4)
	var longestCommonSubstring = __webpack_require__(5)

	var diff = function(before, after) {
	  var commonSeq = longestCommonSubstring(before, after)
	  var startBefore = commonSeq.startString1
	  var startAfter = commonSeq.startString2
	  if (commonSeq.length == 0) {
	    var result = before.map(function(each) { return ['-', each]})
	    return result.concat(after.map(function(each) { return ['+', each]}))
	  }
	  var beforeLeft = before.slice(0, startBefore)
	  var afterLeft = after.slice(0, startAfter)
	  var equal = after.slice(startAfter, startAfter + commonSeq.length)
	    .map(function(each) {return ['=', each]})
	  var beforeRight = before.slice(startBefore + commonSeq.length)
	  var afterRight = after.slice(startAfter + commonSeq.length)
	  return union(diff(beforeLeft, afterLeft), equal, diff(beforeRight, afterRight))
	}

	var orderedSetDiff = function(before, after) {
	  var diffRes = diff(before, after)
	  var result = []
	  diffRes.forEach(function(each) {
	    switch(each[0]) {
	      case '=':
	        result.push(each)
	        break
	      case '-':
	        result.push((after.indexOf(each[1]) > -1) ? ['x', each[1]] : ['-', each[1]])
	        break
	      case '+':
	        result.push((before.indexOf(each[1]) > -1) ? ['p', each[1]] : ['+', each[1]])
	    }
	  })
	  return result
	}

	var compress = function(diff) {
	  var result = []
	  var modifier
	  var section = []
	  diff.forEach(function(each) {
	    if(modifier && (each[0] == modifier)) {
	      section.push(each[1])
	    } else {
	      if(modifier) result.push([modifier, section])
	      section = [each[1]]
	      modifier = each[0]
	    }
	  })
	  if(modifier) result.push([modifier, section])
	  return result
	}

	module.exports = function(opts) {
	  opts = opts || {}
	  return function(before, after) {
	    var result = opts.unique ? orderedSetDiff(before, after) : diff(before, after)
	    return opts.compress ? compress(result) : result
	  }
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var ArrayProto = Array.prototype;
	var concat = ArrayProto.concat;
	var push = ArrayProto.push;

	function unique(array) {
	  var result = [];
	  array.forEach(function(value) {
	    if (result.indexOf(value) < 0) {
	      result.push(value);
	    }
	  })
	  return result;
	}

	function flatten(input) {
	  return concat.apply([], input)
	}

	module.exports = function union() {
	  return unique(flatten(arguments))
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	
	var indexMap = function(list) {
	  var map = {}
	  list.forEach(function(each, i) {
	    map[each] = map[each] || []
	    map[each].push(i)
	  })
	  return map
	}

	var longestCommonSubstring = function(seq1, seq2) {
	  var result = {startString1:0, startString2:0, length:0}
	  var indexMapBefore = indexMap(seq1)
	  var previousOverlap = []
	  seq2.forEach(function(eachAfter, indexAfter) {
	    var overlapLength
	    var overlap = []
	    var indexesBefore = indexMapBefore[eachAfter] || []
	    indexesBefore.forEach(function(indexBefore) {
	      overlapLength = ((indexBefore && previousOverlap[indexBefore-1]) || 0) + 1;
	      if (overlapLength > result.length) {
	        result.length = overlapLength;
	        result.startString1 = indexBefore - overlapLength + 1;
	        result.startString2 = indexAfter - overlapLength + 1;
	      }
	      overlap[indexBefore] = overlapLength
	    })
	    previousOverlap = overlap
	  })
	  return result
	}

	module.exports = longestCommonSubstring


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	

	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	var isArgs = __webpack_require__(7);
	var hasDontEnumBug = !({'toString': null}).propertyIsEnumerable('toString');
	var hasProtoEnumBug = (function () {}).propertyIsEnumerable('prototype');
	var dontEnums = [
		"toString",
		"toLocaleString",
		"valueOf",
		"hasOwnProperty",
		"isPrototypeOf",
		"propertyIsEnumerable",
		"constructor"
	];

	var keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toString.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toString.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError("Object.keys called on a non-object");
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var ctor = object.constructor;
			var skipConstructor = ctor && ctor.prototype === object;

			for (var j = 0; j < dontEnums.length; ++j) {
				if (!(skipConstructor && dontEnums[j] === 'constructor') && has.call(object, dontEnums[j])) {
					theKeys.push(dontEnums[j]);
				}
			}
		}
		return theKeys;
	};

	keysShim.shim = function shimObjectKeys() {
		if (!Object.keys) {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};

	module.exports = keysShim;



/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	

	var toString = Object.prototype.toString;

	module.exports = function isArguments(value) {
		var str = toString.call(value);
		var isArguments = str === '[object Arguments]';
		if (!isArguments) {
			isArguments = str !== '[object Array]'
				&& value !== null
				&& typeof value === 'object'
				&& typeof value.length === 'number'
				&& value.length >= 0
				&& toString.call(value.callee) === '[object Function]';
		}
		return isArguments;
	};



/***/ }
/******/ ])
});

/**
 * Creates a stream that consolidates stores changes
 */
define('flux/factories/vue_value_binder_factory',['require','flux/utils/update_array','flux/utils/getter'],function(require) {
  var updateArray = require('flux/utils/update_array');
  var getterUtils = require('flux/utils/getter');

  /**
   * Helper function to determine if we should use the
   * update-array function to mutate objects in place
   * instead of replacing the entire array
   *
   * @param {*}
   * @return {Boolean}
   */
  function shouldUseArrayUpdater(val) {
    return (
      _.isArray(val) &&
      val.length > 0 &&
      _.isObject(val[0]) &&
      val[0].id
    )
  }

  /**
   * @constructor
   * @param {Flux} flux
   */
  function VueValueBinder(flux, vm) {
    this.vm = vm;
    this.flux = flux;
    this.changeStream = flux.createChangeStream()

    vm.$on('hook:afterDestroy', function() {
      this.changeStream.destroy();
      delete this.vm;
      delete this.flux;
      delete this.changeStream;
    }.bind(this))
  }

  /**
   * Binds a VM property to some value computed from one or more flux
   * stores.  This value will always stay in sync
   *
   * @param {string} prop on the view model to set
   * @param {array} getter of form ['store1', 'store2', function(store1, store2) { ... })
   *                       where the last entry is a function that returns the value
   */
  VueValueBinder.prototype.bindValue = function(prop, getter) {
    if (_.isString(getter)) {
      throw new Error("Must pass Getter to bindVueValues" + getter);
    }

    var deps = getterUtils.flattenDeps(getter);
    // get the initial value
    this.vm.$set(prop, this.flux.evaluate(getter));

    this.changeStream.onStoreChange(deps, function() {
      var newValue = this.flux.evaluate(getter);

      if (shouldUseArrayUpdater(newValue)) {
        updateArray(this.vm.$get(prop), newValue);
      } else {
        this.vm.$set(prop, newValue);
      }
    }.bind(this));

    // for chaining
    return this;
  };

  return {
    create: function(flux, vm) {
      return new VueValueBinder(flux, vm);
    }
  }
});

/**
 * Flux app definition
 *
 * Registers stores on the main app dispatcher
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/factories/flux_factory',['require','lodash','flux/dispatcher','flux/logger','flux/utils/getter','flux/factories/store_change_stream_factory','flux/factories/vue_value_binder_factory'],function(require) {
  var _ = require('lodash');
  var Dispatcher = require('flux/dispatcher');
  var Logger = require('flux/logger');
  var getterUtils = require('flux/utils/getter');
  var storeChangeStreamFactory = require('flux/factories/store_change_stream_factory');
  var vueValueBinderFactory = require('flux/factories/vue_value_binder_factory');


  /**
   * @constructor
   * @param {object} stores
   */
  function Flux(config) {
    config = config || {};
    this.DEBUG = !!config.debug;
    this.logger = new Logger();
    this.dispatcher = new Dispatcher();
    this.__stores = {};
    this.__actions = {};
    this.getters = {};
    this.isInitialized = false;
  };

  /**
   * Configures and runs the flux application
   *
   * Config Options:
   * config.stores {array.<Store>}
   * config.actions {array.<Action>}
   *
   * @param {object} config
   */
  Flux.prototype.run = function(config) {
    _.each(config.actions, function(ActionGroup, id) {
      this.registerActionGroup(id, ActionGroup);
    }.bind(this));

    _.each(config.stores, function(Store, id) {
      this.registerStore(id, Store);
    }.bind(this));

    if (config.getters) {
      this.getters = Object.freeze(config.getters);
    }

    this.isInitialized = true;
  };


  /**
   * @param {array} getter of form ['store1', 'store2', function(store1, store2) { ... })
   *                       where the last entry is a function that returns the value
   * @return {*}
   */
  Flux.prototype.evaluate = function(getter) {
    return getterUtils.evaluate(this, getter);
  };

  /**
   * Registers a group of actions on the Flux App
   *
   * @param {Function} ActionGroup constructor
   * @param {string|number} id
   */
  Flux.prototype.registerActionGroup = function(id, ActionGroup) {
    // initialize the action with the flux instance, allowing
    // proxy of the `dispatcher.dispatch` method
    this.__actions[id] = new ActionGroup(this);
  };

  /**
   * Register the store on the Flux App
   *
   * @param {Function} Store create function
   * @param {string|number} id
   */
  Flux.prototype.registerStore = function(id, createStoreFn) {
    // initialize the store with the dispatcher
    var store = createStoreFn(id, this);

    this.__stores[id] = store;
    this.dispatcher.register(store);
  };

  /**
   * Creates a stream that aggregates store change events
   *
   * Usage:
   *  var stream = flux.createChangeStream()
   *    .onStoreChange('currentProject', onCurrentProjectChange)
   *    .onStoreChange('experiments', onExperimentsChange);
   * // to unregister listeners
   * stream.destroy()
   *
   * @return {StoreChangeStream}
   */
  Flux.prototype.createChangeStream = function() {
    return storeChangeStreamFactory.create(this);
  };

  /**
   * Creates a VueValueBinder that uses a changestream to keep
   * Vue VM props in sync with stores
   *
   * @return {VueValueBinder}
   */
  Flux.prototype.createVueValueBinder = function(vm) {
    return vueValueBinderFactory.create(this, vm);
  };

  /**
   * Convenience method for vueValueBinder where it can be passed
   * a mapping of vmProps => <Getter|getterKey>
   * @param {Vue} vm
   * @param {object} dataBindings
   */
  Flux.prototype.bindVueValues = function(vm, dataBindings) {
    var valueBinder = this.createVueValueBinder(vm);
    _.each(dataBindings, function(getterKey, vmProp) {
      valueBinder.bindValue(vmProp, getterKey);
    });
  };

  /**
   * Proxy the dispatch function for more convenient signature
   * @param {string} actionType
   * @param {object} payload
   */
  Flux.prototype.dispatch = function(actionType, payload) {
    if (this.DEBUG) {
      this.logger.dispatchStart(actionType, payload);
    }
    this.dispatcher.dispatch({
      type: actionType,
      payload: payload,
    });
    if (this.DEBUG) {
      this.logger.dispatchEnd(this.__stores);
    }
  };

  /**
   * Get store by id
   */
  Flux.prototype.store = function(id) {
    return this.__stores[id];
  };

  /**
   * Get action group by id
   */
  Flux.prototype.actions = function(id) {
    return this.__actions[id];
  };

  /**
   * Resets the state of all stores or a single store by id
   * @param {stirng} id
   */
  Flux.prototype.resetStores = function(id) {
    if (id) {
      this.__stores[id].reset();
    } else {
      _.each(this.__stores, function(store) {
        store.reset();
      });
    }
  };

  return {
    create: function(config) {
      return new Flux(config);
    },
  };
});

/**
 * Flux app definition
 *
 * Registers stores on the main app dispatcher
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux',['require','env','flux/factories/flux_factory'],function(require) {
  var env = require('env');
  var fluxFactory = require('flux/factories/flux_factory');

  // enable debug when not in production
  var debug = !env.IS_PRODUCTION;
  return fluxFactory.create({
    debug: true
  });
});

/**
 * (The MIT License)
 * Copyright (c) 2012 TJ Holowaychuk <tj@vision-media.ca>
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.))
 */
define('utils/page',['require','exports','module'],function(require, exports, module) {
  /**
   * Perform initial dispatch.
   */

  var dispatch = true;

  /**
   * Base path.
   */

  var base = '';

  /**
   * Running flag.
   */

  var running;

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page();
   *
   * @param {String|Function} path
   * @param {Function} fn...
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' == typeof path) {
      return page('*', path);
    }

    // route <path> to <callback ...>
    if ('function' == typeof fn) {
      var route = new Route(path);
      for (var i = 1; i < arguments.length; ++i) {
        page.callbacks.push(route.middleware(arguments[i]));
      }
    // show <path> with [state]
    } else if ('string' == typeof path) {
      page.show(path, fn);
    // start [options]
    } else {
      page.start(path);
    }
  }

  /**
   * Callback functions.
   */

  page.callbacks = [];

  /**
   * Get or set basepath to `path`.
   *
   * @param {String} path
   * @api public
   */

  page.base = function(path){
    if (0 == arguments.length) return base;
    base = path;
  };

  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  page.start = function(options){
    options = options || {};
    if (running) return;
    running = true;
    if (false === options.dispatch) dispatch = false;
    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
    if (false !== options.click) window.addEventListener('click', onclick, false);
    if (!dispatch) return;
    var url = location.pathname + location.search + location.hash;
    page.replace(url, null, true, dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  page.stop = function(){
    running = false;
    removeEventListener('click', onclick, false);
    removeEventListener('popstate', onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @param {Boolean} dispatch
   * @return {Context}
   * @api public
   */

  page.show = function(path, state, dispatch){
    var ctx = new Context(path, state);
    if (false !== dispatch) page.dispatch(ctx);
    if (!ctx.unhandled) ctx.pushState();
    return ctx;
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @return {Context}
   * @api public
   */

  page.replace = function(path, state, init, dispatch){
    var ctx = new Context(path, state);
    ctx.init = init;
    if (null == dispatch) dispatch = true;
    if (dispatch) page.dispatch(ctx);
    ctx.save();
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Object} ctx
   * @api private
   */

  page.dispatch = function(ctx){
    var i = 0;

    function next() {
      var fn = page.callbacks[i++];
      if (!fn) return unhandled(ctx);
      fn(ctx, next);
    }

    next();
  };

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */

  function unhandled(ctx) {
    var current = window.location.pathname + window.location.search;
    if (current == ctx.canonicalPath) return;
    page.stop();
    ctx.unhandled = true;
    window.location = ctx.canonicalPath;
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @param {String} path
   * @param {Object} state
   * @api public
   */

  function Context(path, state) {
    if ('/' == path[0] && 0 != path.indexOf(base)) path = base + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    this.path = path.replace(base, '') || '/';

    this.title = document.title;
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i ? path.slice(i + 1) : '';
    this.pathname = ~i ? path.slice(0, i) : path;
    this.params = [];

    // fragment
    this.hash = '';
    if (!~this.path.indexOf('#')) return;
    var parts = this.path.split('#');
    this.path = parts[0];
    this.hash = parts[1] || '';
    this.querystring = this.querystring.split('#')[0];
  }

  /**
   * Expose `Context`.
   */

  page.Context = Context;

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function(){
    history.pushState(this.state, this.title, this.canonicalPath);
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function(){
    history.replaceState(this.state, this.title, this.canonicalPath);
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

  function Route(path, options) {
    options = options || {};
    this.path = path;
    this.method = 'GET';
    this.regexp = pathtoRegexp(path
      , this.keys = []
      , options.sensitive
      , options.strict);
  }

  /**
   * Expose `Route`.
   */

  page.Route = Route;

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn){
    var self = this;
    return function(ctx, next){
      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {String} path
   * @param {Array} params
   * @return {Boolean}
   * @api private
   */

  Route.prototype.match = function(path, params){
    var keys = this.keys
      , qsIndex = path.indexOf('?')
      , pathname = ~qsIndex ? path.slice(0, qsIndex) : path
      , m = this.regexp.exec(pathname);

    if (!m) return false;

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];

      var val = 'string' == typeof m[i]
        ? decodeURIComponent(m[i])
        : m[i];

      if (key) {
        params[key.name] = undefined !== params[key.name]
          ? params[key.name]
          : val;
      } else {
        params.push(val);
      }
    }

    return true;
  };

  /**
   * Normalize the given path string,
   * returning a regular expression.
   *
   * An empty array should be passed,
   * which will contain the placeholder
   * key names. For example "/user/:id" will
   * then contain ["id"].
   *
   * @param  {String|RegExp|Array} path
   * @param  {Array} keys
   * @param  {Boolean} sensitive
   * @param  {Boolean} strict
   * @return {RegExp}
   * @api private
   */

  function pathtoRegexp(path, keys, sensitive, strict) {
    if (path instanceof RegExp) return path;
    if (path instanceof Array) path = '(' + path.join('|') + ')';
    path = path
      .concat(strict ? '' : '/?')
      .replace(/\/\(/g, '(?:/')
      .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g, function(_, slash, format, key, capture, optional){
        keys.push({ name: key, optional: !! optional });
        slash = slash || '';
        return ''
          + (optional ? '' : slash)
          + '(?:'
          + (optional ? slash : '')
          + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'
          + (optional || '');
      })
      .replace(/([\/.])/g, '\\$1')
      .replace(/\*/g, '(.*)');
    return new RegExp('^' + path + '$', sensitive ? '' : 'i');
  }

  /**
   * Handle "populate" events.
   */

  function onpopstate(e) {
    if (e.state) {
      var path = e.state.path;
      page.replace(path, e.state);
    }
  }

  /**
   * Handle "click" events.
   */

  function onclick(e) {
    if (1 != which(e)) return;
    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;

    // ensure link
    var el = e.target;
    while (el && 'A' != el.nodeName) el = el.parentNode;
    if (!el || 'A' != el.nodeName) return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if (el.pathname == location.pathname && (el.hash || '#' == link)) return;

    // check target
    if (el.target) return;

    // x-origin
    if (!sameOrigin(el.href)) return;

    // rebuild path
    var path = el.pathname + el.search + (el.hash || '');

    // same page
    var orig = path + el.hash;

    path = path.replace(base, '');
    if (base && orig == path) return;

    e.preventDefault();
    page.show(orig);
  }

  /**
   * Event button.
   */

  function which(e) {
    e = e || window.event;
    return null == e.which
      ? e.button
      : e.which;
  }

  /**
   * Check if `href` is the same origin.
   */

  function sameOrigin(href) {
    var origin = location.protocol + '//' + location.hostname;
    if (location.port) origin += ':' + location.port;
    return 0 == href.indexOf(origin);
  }

  /**
   * Expose `page`.
   */

  module.exports = page;
})
;
/**
 * Factory creating the App object
 *
 * Makes testing easier
 */
define('app_factory',['require','exports','module','lodash','vue','flux','utils/page'],function(require, module, exports) {
  var _ = require('lodash');
  var Vue = require('vue');
  var flux = require('flux');
  var page = require('utils/page');

  /**
   * App object
   * @constructor
   */
  function App() {
    /**
     * @type {boolean} Whether the vue app's `run` method has completed yet.
     * @public
     */
    this.isRunning = false;

    /**
     * @var {Vue} reference to the page level Vue ViewModel
     */
    this.rootComponent;

    // Calling app.$broadcast or app.$on before app.run() will queue up the broadcast
    // or event handlers in these queues and execute them when the app is run
    this.broadcastQueue = [];
    this.handlerQueue = []
  }

  /**
   * Runs the Vue app and attaches it to document.body
   * Also registers any directives/components/partials/effects/filters on the Vue global
   */
  App.prototype.run = function(config) {
    if (this.isRunning) {
      throw new Error("Application already running");
    }

    if (!config.vue) {
      throw new Error("Cannot run application without config.vue");
    }

    if (config.flux) {
      // Run the flux data system
      flux.run(config.flux);

      if (config.accountInfo) {
        // load the account info into flux before Vue starts
        flux.actions('app').loadAccountInfo(config.accountInfo);
      }
    }

    // registering Vue directives/filters/etc as globals
    this.__configureVue(config.vue);

    // mount the PageComponent at root, responsible for routing
    this.rootComponent = new Vue({
      el: document.body,
    });

    if (config.routes) {
      // load all the routes and start the router
      config.routes.forEach(function(route) {
        var args = [route.match].concat(route.handle);
        page.apply(null, args);
      });
      page.start({
        // dont hook on to click events
        click: false
      });
    }

    // TODO(jordan): decide if we still want a handler queue
    // this *shouldnt* really be needed since the app is guaranteed
    // to run first now

    // empty the handler queue when the app is first run
    while (this.handlerQueue.length > 0) {
      this.$on.apply(this, this.handlerQueue.shift());
    }
    // empty the $broadcast queue when the app is first run
    while (this.broadcastQueue.length > 0) {
      this.$broadcast.apply(this, this.broadcastQueue.shift());
    }

    this.isRunning = true;
  };

  /**
   * Sends an event to every view model on the page
   *
   * @param {string} eventName
   *
   * @param {args*} args
   */
  App.prototype.$broadcast = function() {
    if (!this.rootComponent) {
      this.broadcastQueue.push(arguments);
    } else {
      this.rootComponent.$emit.apply(this.rootComponent, arguments);
      this.rootComponent.$broadcast.apply(this.rootComponent, arguments);
    }
  };

  /**
   * Attaches an event handler to the page level viewModel
   *
   * @param {String} eventName
   * @param {Function} handler
   */
  App.prototype.$on = function(eventName, handler) {
    if (!this.rootComponent) {
      this.handlerQueue.push([eventName, handler]);
    } else {
      this.rootComponent.$on.call(this.rootComponent, eventName, handler);
    }
  };

  /**
   * Given a component name, returns the matching Vue component
   * Throws an error if no component name or an invalid component name is provided
   *
   * @param {string} componentName
   * @returns {function(new:Vue, Object)}
   */
  App.prototype.getComponent = function(componentName) {
    if (!componentName) {
      throw new Error('You must supply a component for the modal to instantiate');
    }
    var comp = Vue.options.components[componentName];
    if (!comp) {
      throw new Error('Component "' + componentName + '" does not exist.');
    }
    return comp;
  };

  /**
   * Given a component name and a configuration, creates a new component with that configuration.
   * If no parent is supplied as part of the configuration, the primary Vue app's rootComponent is used.
   * This helps ensure that imperatively instantiated components are still part of the VM hierarchy and thus
   * receive messages sent to app.$broadcast.
   *
   * @param componentName The name of the Vue component to be instantiated
   * @param config The configuration for that Vue component
   * @returns {Object}
   */
  App.prototype.attachComponent = function(componentName, config) {
    if (!this.isRunning) {
      var errorString = 'Tried to attach component ' + componentName + ' before Vue app started!';
      throw new Error(errorString);
    }
    var Component = this.getComponent(componentName);
    config.parent = config.parent || this.rootComponent;
    return new Component(config);
  };


  /**
   * Private method that populates the Vue global with all registered
   */
  App.prototype.__configureVue = function(vueConfig) {
    // put components/directives/etc on the Vue global
    _.forEach(vueConfig || {}, function(map, key) {
      var validKeys = ['component', 'directive', 'partial', 'effect', 'filter'];
      if (validKeys.indexOf(key) !== -1) {
        _.forEach(map, function(def, id) {
          // register Vue.component(componentId, { ... })
          Vue[key](id, def);
        });
      }
    });
  };

  return {
    create: function() {
      return new App();
    }
  };
});

/**
 * Main app entry-point
 */
define('app',['require','app_factory'],function(require) {
  var appFactory = require('app_factory');

  var app = appFactory.create();

  return appFactory.create();
});

define('facade/edit_code_drawer',[],function() {
  return function (page, editCodeDrawerComponent) {

    var editCodeComponent = editCodeDrawerComponent.$.editCode;
    var codeMirrorComponent = editCodeComponent.$.codeMirror;


    /*********************************************************
     ****************** Edit Code Drawer *********************
     *********************************************************/

    editCodeDrawerComponent.$on('editCodeDrawer:Resize', function (height) {
      page.variation.variationCode.onResize.fire(height);
    });

    editCodeDrawerComponent.$on('editCodeDrawer:ResizeStart', function () {
      page.variation.variationCode.onResizeStart.fire();
    });

    editCodeDrawerComponent.$on('editCodeDrawer:ResizeStop', function () {
      page.variation.variationCode.onResizeStop.fire();
    });

    editCodeDrawerComponent.$on('editCodeDrawer:OpenStart', function (wasAlreadyOpen) {
      if (!wasAlreadyOpen) {
        page.variation.variationCode.trackEditCode('open');
      }
    });

    editCodeDrawerComponent.$on('editCodeDrawer:CloseStart', function () {
      page.variation.variationCode.setSelectable(true);
    });


    /*********************************************************
     ********************* Edit Code  ************************
     *********************************************************/

    editCodeComponent.$on('editCode:Apply', function () {
      page.variation.variationCode.applyCode();
    });

    editCodeComponent.$on('editCode:Cancel', function () {
      page.variation.variationCode.handleCancel();
    });

    editCodeComponent.$on('editCode:ChangeHandled', function (change) {
      page.variation.variationCode.handleChange(change);
    });

    editCodeComponent.$on('editCode:KeyHandled', function (isDirty) {
      page.variation.variationCode.setSelectable(!isDirty);
    });

    editCodeComponent.$on('editCode:ShortCutHandled', function (event) {
      page.variation.variationCode.trackKeyboardShortcut(event);
    });

    editCodeComponent.$on('editCode:Mouseover', function (event) {
      page.variation.variationCode.handleMouseover(event);
    });

    // Return any functions we want to expose. We could probably use event passing for most things,
    // however at times we need to perform synchronous actions. We can do that via the functions
    // exposed here.
    return {


      /*********************************************************
       ****************** Edit Code Drawer *********************
       *********************************************************/

      close: function () {
        editCodeDrawerComponent.close();
      },

      enable: function () {
        editCodeDrawerComponent.enable();
      },

      disable: function () {
        editCodeDrawerComponent.disable();
      },

      open: function () {
        editCodeDrawerComponent.open();
      },

      openWithError: function (error) {
        editCodeDrawerComponent.$once('editCodeDrawer:OpenComplete', this.addAnnotation.bind(this, error));
        editCodeDrawerComponent.open();
      },

      /*********************************************************
       ********************* Code Mirror ***********************
       *********************************************************/

      addAnnotation: function (error) {
        codeMirrorComponent.addAnnotation(error);
      },

      getCodeFromEditor: function () {
        return codeMirrorComponent.editorCode;
      },

      getLine: function (index) {
        return codeMirrorComponent.getLine(index);
      },

      isDirty: function () {
        return codeMirrorComponent.isDirty;
      },

      setCode: function (code) {
        codeMirrorComponent.code = code;
      }
    };
  };
});

/**
 * This facade is the bridge between the new Experiment Code Vue Component and the old
 * closure logic for saving experiment JS/CSS code
 *
 * @author Mike Ng (mike.ng@optimizely.com)
 */
define('facade/experiment_code',['app'],function() {
  var app = require('app');
 // used to listen to events from the experiment code component
 var EXPERIMENT_CODE_PREFIX = 'experimentCode:';

 return function(page) {

   page.outie.onEvaluateCompleted.bind(handleEvaluationComplete, this);
   page.outie.onEvaluateFailure.bind(handleEvaluationFailure, this);

   // Handle closure logic when user hits 'apply'
   app.$on(EXPERIMENT_CODE_PREFIX + 'applyCode',
     /**
      * @param {string} code
      */
     function handleExperimentCodeApplyCodeMessage(code, type) {
       var isJavascript = type === 'javascript';
       var currentCode = isJavascript ? page.experiment.custom.js : page.experiment.custom.css;
       if (currentCode !== code ) {
         if (isJavascript) {
           page.experiment.custom.js = code;
         } else {
           // @Note: we currently don't have any CSS validation logic?
           page.experiment.custom.css = code;
         }
         page.outie.evaluate();

         // fire GA tracking call
         var gaTrackingOptionType = isJavascript ? optly.edit.option.OptionType.CUSTOM_JS : optly.edit.option.OptionType.CUSTOM_CSS;
         trackEventGA(optly.enums.TrackingEventCategory.WEB_EDITOR,
             'option-menu-' + gaTrackingOptionType,
           optly.enums.TrackingEventAction.APPLY);

         // let the page know that changes we made and they can be saved
         page.saver.setDirty();
       }
     }
   );

   // After the dialog is done loading, we set the default, preexisting code on the code editor.
   app.$on(EXPERIMENT_CODE_PREFIX + 'ready',
     /**
      * @param {string} type
      */
     function handleExperimentCodeReadyMessage(type) {
       // Note: even if there is no preexisting code, setting it on the editor will force the editor to do some essential updates
       // such as resizing correctly, determining what mode it is in (css or javascript)
       var code = (type === 'javascript') ? page.experiment.custom.js : page.experiment.custom.css;
       app.$broadcast(EXPERIMENT_CODE_PREFIX + 'setCode', code);
     }
   );

   /**
    * Private helper function to let the experimient code dialog know that the code evaluation was completed without errors
    * @private
    */
   function handleEvaluationComplete() {
     app.$broadcast(EXPERIMENT_CODE_PREFIX + 'evaluationCompleted');
   }

   /**
    * Private helper function that handles evaluation errors
    * @param {Object} details
    */
   function handleEvaluationFailure(details) {
     // if we have an evaluation error and the experiment code dialog is not shown, then show it
     // @TODO: it would be great if the dialog manager told us if the dialog is open or not
     if (details.codeType === optly.edit.CodeType.EXPERIMENT_JS.key) {
       if ($('.experiment_code_edit_container').length) {
         app.$broadcast(EXPERIMENT_CODE_PREFIX + 'evaluationError', details);
       } else {
         showDialog('javascript', details);
       }
     }
   }

   /**
    * Helper function to display the experiment code dialog of the given type
    * @param {String} type
    * @param {Object} error Optional error object to display on the code editor on open
    * @private
    */
   function showDialog(type, error) {
     app.$broadcast('showDialog', {
       component: 'dialogs/experiment-code',
       data: {
         type: type,
         error: error
       }
     });
   }

   /**
    * External APIs
    */
   return {
     showDialog: showDialog
   }
 }
});

/**
 * Contains constants used across Vue components.
 * @return {Object} object containing namespaced enums
 */
define('utils/enums',['require','lodash'],function(require) {
  var _ = require('lodash');
  var enums = {};

  var EmailSDKInstructionsState = {
    NOT_SENT: tr("Send Email &amp; Continue"),
    SENDING: tr("Sending..."),
    SENT: tr("Sent!")
  };

  var ExperimentStatusType = {
    ARCHIVED: "Archived",
    DELETED: "Deleted",
    ERROR: "Error",
    NOT_STARTED: "Not started",
    PAUSED: "Paused",
    PAUSING: "Pausing...",
    RUNNING: "Running",
    STARTING: "Starting..."
  };

  var GenericPropertyTypes = {
    BOOL: 'boolean',
    COLOR: 'color',
    FLOAT: 'float',
    INTEGER: 'integer',
    POINT: 'point',
    RECT: 'rectangle',
    SIZE: 'size',
    STRING: 'string',
    FONT: 'font'
  };

  var iOSPropertyTypes = {
    COLOR: 'UIColor',
    NUMBER: 'NSNumber',
    POINT: 'CGPoint',
    RECT: 'CGRect',
    SIZE: 'CGSize',
    STRING: 'NSString',
    FONT: 'UIFont',
    NUMBER_SUBTYPES: {
      BOOLEAN: 'c',
      FLOAT: 'f',
      INTEGER: 'i'
    }
  };

  var ProjectPlatforms = {
    ANDROID: 'android',
    IOS: 'ios',
    WEB: 'web'
  };

  var ProjectPlatformsMobile = [
    ProjectPlatforms.ANDROID,
    ProjectPlatforms.IOS
  ];

  enums.EmailSDKInstructionsState = EmailSDKInstructionsState;
  enums.ExperimentStatusType = ExperimentStatusType;
  enums.GenericPropertyTypes = GenericPropertyTypes;
  enums.iOSPropertyTypes = iOSPropertyTypes;
  enums.ProjectPlatforms = ProjectPlatforms;
  enums.ProjectPlatformsMobile = ProjectPlatformsMobile;

  return _.extend({},
    optly.enums,
    enums
  );
});

/**
 * Helper functions for converting between iOS/Android types and generic types
 * Need to require utils/enums in each function separately because it's not always ready
 * when this file is first required.
 *
 */
define('utils/mobile_type_helpers',['require','utils/enums','utils/enums','utils/enums'],function(require) {

  /**
   * Convert's a generic type to its iOS equivalent, so we can make the live_variables
   * component platform agnostic without rewritting everything.
   * NSNumbers have a subtype defining the underlying type used to create them.
   *
   * @param type The generic type to convert to the equivalent iOS type
   * @returns An object with the iOS type and subType equivalent to the generic type passed in
   */
  function convertGenericTypeToiOSType(type) {
    var enums = require('utils/enums');
    if (type === enums.GenericPropertyTypes.BOOL) {
      return {
        type: enums.iOSPropertyTypes.NUMBER,
        subType: enums.iOSPropertyTypes.NUMBER_SUBTYPES.BOOLEAN
      }
    } else if (type === enums.GenericPropertyTypes.COLOR) {
      return {
        type: enums.iOSPropertyTypes.COLOR,
        subType: ''
      };
    } else if (type === enums.GenericPropertyTypes.FLOAT) {
      return {
        type: enums.iOSPropertyTypes.NUMBER,
        subType: enums.iOSPropertyTypes.NUMBER_SUBTYPES.FLOAT
      }
    } else if (type === enums.GenericPropertyTypes.INTEGER) {
      return {
        type: enums.iOSPropertyTypes.NUMBER,
        subType: enums.iOSPropertyTypes.NUMBER_SUBTYPES.INTEGER
      }
    } else if (type === enums.GenericPropertyTypes.POINT) {
      return {
        type: enums.iOSPropertyTypes.POINT,
        subType: ''
      };
    } else if (type === enums.GenericPropertyTypes.RECT) {
      return {
        type: enums.iOSPropertyTypes.RECT,
        subType: ''
      };
    } else if (type === enums.GenericPropertyTypes.SIZE) {
      return {
        type: enums.iOSPropertyTypes.SIZE,
        subType: ''
      };
    } else if (type === enums.GenericPropertyTypes.STRING) {
      return {
        type: enums.iOSPropertyTypes.STRING,
        subType: ''
      };
    } else if (type === enums.GenericPropertyTypes.FONT) {
      return {
        type: enums.iOSPropertyTypes.FONT,
        subType: ''
      };
    }
    else {
      throw new Error('Unknown generic Type ' + type + '. Cannot convert to iOS type');
    }
  }

  /**
   * Convert's an iOS type to its generic equivalent, so we can make the live_variables
   * component platform agnostic without rewritting everything.
   * NSNumbers have a subtype defining the underlying type used to create them.
   *
   * @param type The iOS type to convert to the equivalent generic type
   * @returns The generic type equivalent to the iOS type passed in
   */
  function convertiOSTypeToGenericType(type, subtype) {
    var enums = require('utils/enums');

    if (type === enums.iOSPropertyTypes.NUMBER) {
      // For iOS, number primitives are wrapped in an
      // NSNumber. You can infer what the primitive's
      // type was from the subtype
      if (subtype === enums.iOSPropertyTypes.NUMBER_SUBTYPES.BOOLEAN) {
        return enums.GenericPropertyTypes.BOOL;
      } else if (subtype === enums.iOSPropertyTypes.NUMBER_SUBTYPES.INTEGER) {
        return enums.GenericPropertyTypes.INTEGER;
      } else if (subtype === enums.iOSPropertyTypes.NUMBER_SUBTYPES.FLOAT) {
        return enums.GenericPropertyTypes.FLOAT;
      } else {
        // Treat everything else as a float. It doesn't matter for iOS
        // anyway since on the SDK side we take the number and convert
        // it appropriately anyway (plus in javascript everything's a float)
        return enums.GenericPropertyTypes.FLOAT;
      }
    } else if (type === enums.iOSPropertyTypes.STRING) {
      return enums.GenericPropertyTypes.STRING;
    } else if (type === enums.iOSPropertyTypes.COLOR) {
      return enums.GenericPropertyTypes.COLOR;
    } else if (type === enums.iOSPropertyTypes.RECT) {
      return enums.GenericPropertyTypes.RECT;
    } else if (type === enums.iOSPropertyTypes.POINT) {
      return enums.GenericPropertyTypes.POINT;
    } else if (type === enums.iOSPropertyTypes.SIZE) {
      return enums.GenericPropertyTypes.SIZE;
    } else if (type === enums.iOSPropertyTypes.FONT) {
      return enums.GenericPropertyTypes.FONT;
    } else {
      throw new Error('Unknown iOS Type ' + type +'. Cannot convert to generic type');
    }
  }

  /**
   * Parse the variable value into the appropriate type. The v-model directive on inputs
   * of type "text" sets the variable's value to a string.
   *
   * @param value The value as passed down from the Vue component.
   * @param type The (generic) type of the variable whose value should be parsed
   * @returns A variable value of the appropriate type
   */
  function parseValueForType(value, type) {
    var enums = require('utils/enums');
    // If somehow an invalid value is passed in
    // just default to 0
    var parseFloatHelper = function(valToParse) {
      var parsedValue = parseFloat(valToParse, 10);
      return !_.isNaN(parsedValue) ? parsedValue : 0.0;
    };
    if (type === enums.GenericPropertyTypes.FLOAT) {
      return parseFloatHelper(value);
    } else if (type === enums.GenericPropertyTypes.INTEGER) {
      var parsedValue = parseInt(value, 10);
      return !_.isNaN(parsedValue) ? parsedValue : 0;
    } else if (type === enums.GenericPropertyTypes.POINT) {
      return {
        X: parseFloatHelper(value.X),
        Y: parseFloatHelper(value.Y)
      };
    } else if (type === enums.GenericPropertyTypes.RECT) {
      return {
        X: parseFloatHelper(value.X),
        Y: parseFloatHelper(value.Y),
        Width: parseFloatHelper(value.Width),
        Height: parseFloatHelper(value.Height)
      };
    } else if (type === enums.GenericPropertyTypes.SIZE) {
      return {
        Width: parseFloatHelper(value.Width),
        Height: parseFloatHelper(value.Height)
      };
    } else if (type === enums.GenericPropertyTypes.COLOR) {
      var alpha = 1;
      if (!isNaN(value.a)) {
        alpha = value.a;
        alpha = Math.max(0, alpha);
        alpha = Math.min(1, alpha);
      }

      return {
        Red: Math.min(value.r / 255, 1),
        Green: Math.min(value.g / 255, 1),
        Blue: Math.min(value.b / 255, 1),
        Alpha: alpha
      }
    } else {
      // this is for BOOL, STRING, and a catch-all
      return value;
    }
  }

  return {
    convertGenericTypeToiOSType: convertGenericTypeToiOSType,
    convertiOSTypeToGenericType: convertiOSTypeToGenericType,
    parseValueForType: parseValueForType
  };
});

/**
 * Helper functions for converting/cloning data to/from Angular and Vue
 *
 */
define('utils/mib_helpers',['require','lodash','utils/enums','utils/mobile_type_helpers'],function(require) {

  var _ = require('lodash');
  var enums = require('utils/enums');
  var mobileTypeHelpers = require('utils/mobile_type_helpers');

 /**
   * The data Vue sends back to us after user input has been triggered needs to be cleaned for 2 reasons:
   *
   * 1) To remove all of the getters and setters that Vue automatically adds
   * 2) To cast strings that should be numbers to numbers
   *
   * This function handles that and returns a new object.
   *
   * @param object oldObject View properties object coming from right_form_drawer Vue component
   * @param string parentKey Key (ie property type) of the current object being cleaned
   *
   * @return Object New, cleaned object
   */
  function cleanVuePropertiesObject (oldObject, parentKey) {
    var newObject = {};
    _.forOwn(oldObject, function (value, key) {

      // Clone all properties except 'image', whose updates are handled by the asset component
      if (key === 'image') {
        return oldObject;
      }

      // "Color" properties set by spectrum directive are in a specific format that needs
      // to be converted back to
      if (key === 'backgroundColor' || key === 'textColor') {
        newObject[key] = mobileTypeHelpers.parseValueForType(value, enums.GenericPropertyTypes.COLOR);
      // Recursively clone nested objects
      } else if (typeof value === 'object') {
        newObject[key] = cleanVuePropertiesObject(value, key);

      // Skip cloning functions -- these shouldnt exist anyway
      } else if (typeof value !== 'function') {

        // Annoyingly need to coerce these strings to numbers else the SDK crashes
        if (['frame', 'tintColor'].indexOf(parentKey) >= 0) {
          value = parseFloat(value);
          if (!_.isNaN(value)) {
            newObject[key] = value;
          }
        } else {
          newObject[key] = _.clone(value);
        }
      }
    });
    return newObject;
  }

  /**
   * Translate the angular properties to the format that is expected by Vue/spectrum
   *
   * @param {object} colorObject The object to translate
   *
   * @return {object} A new object representing the data in the correct format
   */
  function translateColorObjectToVueFormat (colorObject) {
    var alpha = 1;
    if (!isNaN(colorObject.Alpha)) {
      alpha = colorObject.Alpha;
      alpha = Math.max(0, alpha);
      alpha = Math.min(1, alpha);
    }
    return {
      r: Math.floor(colorObject.Red * 255),
      g: Math.floor(colorObject.Green * 255),
      b: Math.floor(colorObject.Blue * 255),
      a: alpha
    }
  }

  return {
    cleanVuePropertiesObject: cleanVuePropertiesObject,
    translateColorObjectToVueFormat: translateColorObjectToVueFormat
  };
});

/**
 * Hidden Features Helper
 *
 */
define('utils/hidden_features',['require','flux'],function(require) {

  /**
   * Helper function for determining whether a hidden feature should
   * be enabled / visible.
   *
   * @param featureCode The string code for the hidden feature
   * @param requiresAdmin Whether the feature requires you to be an admin
   * @returns Whether the hidden feature should be enabled
   */
  function isHiddenFeatureEnabled(featureCode, requiresAdmin) {
    var flux = require('flux');
    var isAdmin = flux.store('account').isAdmin();
    // If the feature requires being an admin and the currently
    // logged in user is not, return false
    if (requiresAdmin && isAdmin) {
      return false;
    }
    var queryParameters = $.deparam.querystring();

    // If there are no easter_eggs, return false
    var easterEgg = queryParameters['easter_egg'];
    if (!easterEgg) {
      return false;
    }
    if (typeof easterEgg === 'string') {
      return (easterEgg === featureCode);
    } else if (easterEgg instanceof Array) {
      return (easterEgg.indexOf(featureCode) > -1);
    } else {
      // Unknown easterEgg type??
      return false;
    }
  }

  return {
    isHiddenFeatureEnabled: isHiddenFeatureEnabled
  };
});

/**
 * This is the top level facade that mediates interaction between the mobile editor and
 * angular code
 *
 */
define('facade/mib',['app','lodash','utils/enums','utils/mobile_type_helpers','utils/mib_helpers','utils/hidden_features'],function() {
  var app = require('app');
  var _ = require('lodash');
  var enums = require('utils/enums');
  var typeHelpers = require('utils/mobile_type_helpers');
  var mibHelpers = require('utils/mib_helpers');

  // Require this here so that it's in the dependency tree
  // and gets loaded into app_bundle. Requiring it in bundle_ios
  // doesn't add it to the dependency tree.
  require('utils/hidden_features');

  /**
   * Creates a facade that has access to the editor components and handles
   * passing information from the angular code to those components.
   * Needs access to the Experiment singleton in order to update the active variation's information.
   * This allows us to route around the Data singleton, which has lots of angular magic and
   * causes some difficulties. For example, modifying the data object causes the DOM to be recompiled,
   * which leads to any input in a Vue component being deselected.
   *
   * @param editorScope   Scope for the editor controller that gives us access to basically everything
   * @param editorManager An instance of the Vue editor/mobile/editor_manager component
   * @param leftTabs      An instance of the Vue editor/mobile/left_tabs component
   * @param rightDrawer   An instance of the Vue editor/mobile/right_drawer component
   */
  return function (editorScope, editorManager, leftTabs, rightDrawer) {

    var _data = {
      currentlyConnectedDevice: null,
      connectedDeviceList: [],
      // Mapping of <code_block_key> to code block object of the form:
      // {key: <code_block_key>, value: <selected_block_key>, options: [<blockName1>, ...]}
      codeBlocks: {},
      // Mapping of <variable_key> to a variable object of the form:
      // {key: <variable_key>, value: <variable_value>, type: <generic_type>}
      liveVariables: {},
      /* computeds */
      /**
       * Get a reference to the active variation's code block changes
       */
      selectedVariationCodeBlocks: function() {
        // TODO(yonatan): Don't assume only one variation platform
        return editorScope.experiment.selectedVariation.variation_platforms[0].code_tests;
      },
      /**
       * Get a reference to the active variation's variable changes
       */
      selectedVariationVariables: function() {
        // TODO(yonatan): Don't assume only one variation platform
        return editorScope.experiment.selectedVariation.variation_platforms[0].variables;
      }
    }
    var _methods = {
      /** Helper method for broadcasting current code block values. Can do some pre-processing.*/
      broadcastCurrentCodeBlockValues: function() {
        leftTabs.$broadcast('mobileCodeBlocksChanged', _methods.getCurrentCodeBlockValues());
      },
      /** Helper method for broadcasting current variable values. Can do some pre-processing.*/
      broadcastCurrentVariableValues: function() {
        leftTabs.$broadcast('mobileLiveVariablesChanged', _methods.getCurrentVariableValues());
      },
      /** Helper method for broadcasting current variation values. Can do some pre-processing.*/
      broadcastSelectedVariationChanged: function() {
        editorManager.$broadcast('selectedVariationChanged', editorScope.experiment.selectedVariation);
      },
      /**
       * Combine the set of all registered code blocks with the set of code blocks
       * for which the currently selected variation has a non-null (non-default) value.
       *
       * @returns The current value of all registered code blocks
       */
      getCurrentCodeBlockValues: function() {
        var currentVariationValues = _data.selectedVariationCodeBlocks();
        var currentCodeBlockValues = {};

        _.each(_.keys(_data.codeBlocks), function(codeBlockKey) {
          currentCodeBlockValues[codeBlockKey] = _.cloneDeep(_data.codeBlocks[codeBlockKey]);
          // Overwrite defaults with the current variation's code block values ("blockKey"s)
          var currentValue = currentVariationValues[codeBlockKey] &&
            currentVariationValues[codeBlockKey].blockKey;
          if (currentValue) {
            currentCodeBlockValues[codeBlockKey].value = currentValue;
          }
        });

        return _.cloneDeep(currentCodeBlockValues);
      },
      /**
       * Combine the list of all registered variables with the list of variables changed in the active
       * variation so that we have an object where the value of each variable is either the default value
       * or the value of the change in the active variation.
       *
       * @returns The current value of all registered variables
       */
      getCurrentVariableValues: function() {
        // Don't want to change the Experiment singleton's variable types, so copy them over
        var currentVariationVariableValues = _.cloneDeep(_data.selectedVariationVariables());
        // Modify the variable types in place
        _.each(_.values(currentVariationVariableValues), function(variable) {
          // Convert the type to a generic type
          variable.type = typeHelpers.convertiOSTypeToGenericType(
            variable.type,
            variable.subType
          );
          // delete the subType, which is unused as part of the generic
          delete variable.subType;
        });

        // clone live variables so we don't end up changing the variable's original type
        var liveVariables = _.cloneDeep(_data.liveVariables);

        // Make sure the current variation's variable values have primacy
        liveVariables = _.extend(liveVariables, currentVariationVariableValues);

        _.each(liveVariables, function(variable) {
          // make sure we have a format that our spectrum directive can understand
          if (variable.type === enums.GenericPropertyTypes.COLOR) {
            variable.value = mibHelpers.translateColorObjectToVueFormat(variable.value);
            variable.value.propertyName = variable.key;
          }
          return variable;
        });

        return liveVariables;
      },

      /**
       * Copy the properties from an Angular View model into a plain JS object for use in Vue
       *
       * @param View view An angular view entity
       *
       * @return Object|null
       */
      getCurrentViewProperties: function (view) {
        if (view) {
          var properties = _.cloneDeep(view.serialize());

          // Not worrying about these for now. These could be used to support
          // move/resize across device types
          delete properties['_optimizelyFrames'];

          // Translate color properties appropriately
          if (properties.backgroundColor) {
            properties.backgroundColor = mibHelpers.translateColorObjectToVueFormat(properties.backgroundColor);
          }

          if (properties.textColor) {
            properties.textColor = mibHelpers.translateColorObjectToVueFormat(properties.textColor);
          }

          var fonts = [];
          if (properties.font) {
            fonts = _.cloneDeep(editorScope.device.fonts)
          }

          return {
            'class': view.class,
            fonts: fonts,
            id: view.id,
            key: view.key,
            properties: properties,
            readableLabel: view.readableLabel
          };
        } else {
          return null;
        }
      }
    };

    editorScope.$watch('experiment.selectedVariation.is_paused', function() {
      app.$broadcast('variationPauseStateChanged', editorScope.experiment.selectedVariation.is_paused);
    });

    // Set the initial state for the live_variables tab component
    app.$on('mobile-live-variables:getInitialState', function(component) {
      component.$emit('mobile-live-variables:componentInitialState', {
        variables: _methods.getCurrentVariableValues()
      })
    });

    // If a live variable's value changed, update the active variation's set of variable
    // changes to reflect the new, non-default value.
    app.$on('mobile-live-variables:variableChanged', function(key, value, type) {
      // Change the stored variable value
      editorScope.experiment.setChangedVariableValue(key, value, type);
    });

    app.$on('mobile-code-blocks:getInitialState', function(component) {
      component.$emit('mobile-code-blocks:componentInitialState', {
        codeBlocks: _methods.getCurrentCodeBlockValues()
      })
    });

    // Handle that the value for one of the code blocks changed
    app.$on('mobile-code-blocks:codeBlockChanged', function(key, value) {
      // Change the stored code block value
      editorScope.experiment.setChangedCodeBlockValue(key, value);
    });

    // Handle request for assets -- these are used to populate the select menu in the
    // right hand drawer that shows all possible image replacements we can find
    // in the customers app
    app.$on('mobile-assets:getInitialState', function (viewId) {
       var assets = [];

      // Filter the assets down to images, since at the moment
      // the only kind of asset we'll replace is in a UIImageView
      for (var key in Data.collections.assets.entities) {
        if (Data.collections.assets.entities.hasOwnProperty(key)) {
          // Add more types if this doesn't cover all image types we want to support
          if (key.match(/jpg|jpeg|png|gif$/)) {
            assets.push(key);
          }
        }
      }
      var angularSelectedView = Data.collections.views.entities[viewId];
      app.$broadcast('mobile-assets:componentInitialState', {
        replacements: _.cloneDeep(angularSelectedView.properties.image.scope.value),
        assets: assets
      });
    });

    // Handle user asset replacement (eg when a user wants to swap out an image in their app)
    app.$on('mobile-assets:replaceAsset', function (viewId,
                                                                 type,
                                                                 isUserUpload,
                                                                 replacement) {
      var angularSelectedView = Data.collections.views.entities[viewId];

      // Not sure that this if else is totally necessary, but keeping it as I don't want to
      // introduce regressions in the port
      if (isUserUpload) {
        angularSelectedView.properties.image.add(type, mibHelpers.cleanVuePropertiesObject(replacement[type]));
      } else {
        angularSelectedView.properties.image.set(mibHelpers.cleanVuePropertiesObject(replacement));
      }
      angularSelectedView.properties.image.scope.$apply();
      editorScope.experiment.didChange = true;
    });

    // Handle case that the user wants to undo one of the asset replacements they had set previously
    // (eg. the user had replaced an image, but now wants to get rid of it)
    app.$on('mobile-assets:removeAsset', function (viewId, type) {
      var angularSelectedView = Data.collections.views.entities[viewId];
      angularSelectedView.properties.image.remove(type);
      angularSelectedView.properties.image.scope.$apply();
      editorScope.experiment.didChange = true;
    });


    // Write property changes back to the Angular object
    app.$on('selectedForm:propertiesChanged', function (selectedView) {
      var angularSelectedView = Data.collections.views.entities[selectedView.id];
      var properties = {};

      var cleanedProperties = mibHelpers.cleanVuePropertiesObject(selectedView.properties);

      // Walk through and set all of the properties on the Angular data model
      _.forOwn(cleanedProperties, function (value, key) {

        // Only copy the properties we expect
        if (angularSelectedView.properties[key]) {
          angularSelectedView.properties[key].scope.value = value;

          // Need to invoke apply to trigger the watchers
          angularSelectedView.properties[key].scope.$apply();
        }
      });
    });

    app.$on('mobile-variation-settings:getInitialState', function(component) {
      component.$emit('mobile-variation-settings:componentInitialState', {
        connectedDevice: _data.currentlyConnectedDevice,
        connectedDeviceList: _data.connectedDeviceList,
        variation: editorScope.experiment.selectedVariation
      })
    });

    app.$on('socketConnectedDeviceChanged', function(newDevice) {
        _data.currentlyConnectedDevice = newDevice;
    });

    app.$on('socketDeviceListRefreshed', function(deviceList) {
      _data.connectedDeviceList = deviceList;
    });

    // pause variation clicked from variations tab
    app.$on('variationPaused', function() {
      editorScope.experiment.togglePaused();
      editorScope.$digest();
    });

    // Rename variation clicked
    app.$on('variationNameChanged', function(variationName) {
      editorScope.experiment.renameVariation(editorScope.experiment.selectedVariation.id, variationName);
    });

    return {
            // If the selected variation changed, broadcast the new set of variable values
      selectedVariationChanged: function() {
        // The active variation changed so update the component with current values
        _methods.broadcastCurrentVariableValues();
        _methods.broadcastCurrentCodeBlockValues();
        _methods.broadcastSelectedVariationChanged();
      },
      // Let the editor components know that whether a view is selected changed.
      setViewSelected: function(isViewSelected, view) {
        app.$broadcast('isViewSelectedChanged',
                              isViewSelected,
                              _methods.getCurrentViewProperties(view));
      },

      updateCodeBlocks: function(newSetOfCodeBlocks) {
        _data.codeBlocks = newSetOfCodeBlocks;
        _methods.broadcastCurrentCodeBlockValues();
      },
      updateDefaultVariables: function(newSetOfVariables) {
        _data.liveVariables = _.cloneDeep(newSetOfVariables);
        _methods.broadcastCurrentVariableValues();
      }
    }
  }
});

/**
 * This is the top level facade that mediates interaction between the drawer component and
 * closure code
 *
 * @author Sam Jackson (sam@optimizely.com)
 */

define('facade/web_drawer',['utils/enums'],function() {
  var enums = require('utils/enums');
  return function (page, drawerManagerComponent) {

    // Relay any user changes originating with the "element-text" component to innie
    drawerManagerComponent.$on('elementPropertyChanged', function (key, value) {
      var messageObject = {};

      // Not sure why the workflow is set up this way, but ahead of sending a change to innie, we have to
      // tell it what element to operate on (see "editElement" property in innie)
      page.outie.messenger.sendMessage(enums.MessageType.PREPARE_CHANGE,
                                       {selector: drawerManagerComponent.selectedElementInformation.selector});

      // Text changes have a slightly different format than style changes
      if (key === 'text') {
        messageObject.text = value;
        page.outie.messenger.sendMessage(enums.MessageType.CHANGE_ELEMENT, messageObject);
      } else {
        if (key === 'fontColor') {
          key = 'color';
        }
        messageObject.style = {};
        messageObject.style[key] = value;
      }
      page.outie.messenger.sendMessage(enums.MessageType.CHANGE_ELEMENT, messageObject);
    });

    return {

      /**
       * Set up any event listeners that need to wait for outie to be initialized
       *
       */
      finalizeOutie: function () {
        page.outie.messenger.onMessage.bind(function (type, elementInfo) {
          switch (type) {

            // Switch to the element unselected tab set
            case optly.enums.MessageType.ELEMENT_DESELECTED:
              drawerManagerComponent.$emit('elementSelectedChange', false);
              break;

            // Switch to element selected tab set and pass along element selected information
            case optly.enums.MessageType.ELEMENT_SELECTED:
              drawerManagerComponent.$emit('elementSelectedChange', true, elementInfo);
              break;
          }
        }, this);
      }
    }
  }
});

/**
 * This file exports a map of facades
 *
 * Define all facades in this file.
 *
 * @author Sam Jackson (sam@optimizely.com)
 */
define('facades',['require','facade/edit_code_drawer','facade/experiment_code','facade/mib','facade/web_drawer'],function(require) {
  return {
    'EditCodeDrawer': require('facade/edit_code_drawer'),
    'ExperimentCode': require('facade/experiment_code'),
    'MIB': require('facade/mib'),
    'WebDrawer': require('facade/web_drawer')
  };
});

/**
 * Mount component function that handles route switching.  This is called
 * to setup the *Page* level component that for a particular route
 *
 * See usage in optly/routes
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('routing/mount_component',['require','exports','module'],function(require, exports, module) {
  /**
   * Mounts a component on some dom node.  If the same component is already mounted
   * do nothing and return
   *
   * If another component is mounted, $destroy and mount the intended one
   *
   * Note: mountComponent doesnt call next because it is intended to be the last
   * step in the routing resolution
   * @param {App} app
   * @param {HTMLElement|string} el to $appendTo
   * @param {string} componentId to mount
   * @return {function} a pagejs function
   */
  function mountComponent(app, el, componentId) {
    return function(ctx) {
      if (_.isString(el)) {
        el = $(el).get(0)
        if (!el) {
          return
        }
      }
      var mountedComponent = $(el).data('mountedComponent');
      if (mountedComponent) {
        if (mountedComponent.id === componentId) {
          // the component is already mounted, no-op
          return;
        } else {
          $(el).removeData('mountedComponent');
          // we want to mount a different component
          mountedComponent.instance.$destroy();
        }
      }

      var Component = app.getComponent(componentId);
      var instance = new Component();
      instance.$appendTo(el);
      // save reference to the component at the dom element to be able to check if the component
      // is mounted already
      $(el).data('mountedComponent', {
        instance: instance,
        id: componentId,
      });
    };
  }

  module.exports = mountComponent;
});

define('services/api_factory',[],function() {
  /**
   * Config Options
   * config.headers {Object}
   * config.baseUrl {String}
   * config.transforms {Object.<{ serialize: function, deserialize: function}>}
   *
   * @constructor
   * @param {Object} config
   */
  function Api(config) {
    // config
    this._config = config || {};
    this._config.transforms = this._config.transforms || {};

    // stack of [('one' | 'all'), <noun>, <id?>]
    // ex [['all', 'experiments'] or ['one', 'projects', 4001]]
    this._stack = [];

    /**
     * Array of filters to apply to URL
     * ex: /api/v1/projects/4001/experiments?filter=status:Started&filter=project_id:55
     * @var Array.<{field: string, value: string}>
     */
    this._filter = [];

    /**
     * Array of filters to apply to URL
     * ex: /api/v1/projects/4001/experiments?order=created:desc
     * @var Array.<{field: string, value: string}>
     */
    this._order = [];

    /**
     *  to apply to URL
     * ex: /api/v1/projects/4001/experiments?limit:100
     * @var Array.<{field: string, value: string}>
     */
    this._limit = null;

    /**
     * Array of filters to apply to URL
     * ex: /api/v1/projects/4001/experiments?limit:20&offset:40
     * @var Array.<{field: string, value: string}>
     */
    this._offset = null;
  }

  /**
   * Class level method to make an ajax request
   * Exists at class level for ease of testability
   *
   * Opts:
   * 'data' {Object}
   * 'type' {String} 'GET', 'PUT', 'POST', 'DELETE'
   * 'url' {String}
   *
   * @param {Object} opts
   * @param {Object=} headers
   * @return {Deferred}
   */
  Api.request = function(opts, headers) {
    if (!opts.type || !opts.url) {
      throw new Error("Must supply `opts.type` and `opts.url` to Api.request(opts)");
    }

    var ajaxOpts = {
      type: opts.type,
      url: opts.url,
      contentType: 'application/json'
    };

    if (headers) {
      ajaxOpts.headers = headers;
    }

    if (opts.data) {
      ajaxOpts.data = JSON.stringify(opts.data);
      ajaxOpts.dataType = 'json';
    }

    return $.ajax(ajaxOpts);
  }

  /**
   * Appends '/{noun}/{id}' to the endpoint
   * @param {string} noun
   * @param {number} id
   * @return {Api}
   */
  Api.prototype.one = function(noun, id) {
    this._stack.push(['one', noun, id]);
    return this;
  };

  /**
   * Appends '/{noun}' to the endpoint
   * @param {string} noun
   * @return {Api}
   */
  Api.prototype.all = function(noun) {
    this._stack.push(['all', noun]);
    return this;
  };

  /**
   * Adds property to filter
   *
   * @param {String|Object} keyOrObject single key (to associate with val) or object of key/value pairs
   * @param {String=} val Value to match against
   * @return {Api}
   */
  Api.prototype.filter = function(keyOrObject, val) {
    if (this._getMode() !== 'all') {
      throw new Error("ApiService Error: .filter() must be called in 'all' mode");
    }

    var filters = keyOrObject;
    if (typeof keyOrObject === 'string') {
      filters = {};
      // use 'true' if no value is provided
      filters[keyOrObject] = val;
    }

    _.each(filters, function(val, key) {
      if (_.isArray(val)) {
        val.forEach(function (el) {
          this._filter.push([key, el]);
        }.bind(this));
      } else {
        this._filter.push([key, val]);
      }
    }.bind(this));

    return this;
  };

  /**
   * Adds property to order
   *
   * @param {Array|String} order string or array of key/value pair strings
   * @return {Api}
   */
  Api.prototype.order = function(order) {
    if (this._getMode() !== 'all') {
      throw new Error("ApiService Error: .order() must be called in 'all' mode");
    }

    if (order) {
      // If a string is passed in, coerce to an array
      if (typeof(order) === 'string') {
        order = [order];
      }

      order.forEach(function(val) {
        this._order.push(val);
      }.bind(this));
    }

    return this;
  };

  /**
   * Adds property to offset
   *
   * @param {Object} offset integer specifying page offset
   * @return {Api}
   */
  Api.prototype.offset = function(offset) {
    if (this._getMode() !== 'all') {
      throw new Error("ApiService Error: .offset() must be called in 'all' mode");
    }

    this._offset = offset;
    return this;
  };

  /**
   * Adds property to filter
   *
   * @param {Object} Object single key (to associate with val) or object of key/value pairs
   * @return {Api}
   */
  Api.prototype.limit = function(limit) {
    if (this._getMode() !== 'all') {
      throw new Error("ApiService Error: .limit() must be called in 'all' mode");
    }

    this._limit = limit;
    return this;
  };

  /**
   * Serializes instance data based on configured transforms on the entity
   *
   * @param {String} entity ex 'audiences'
   * @param {Object} data
   * @return {Object} serialized data
   */
  Api.prototype.serialize = function(entity, data) {
    data = _.cloneDeep(data);
    if (this._config.transforms[entity]) {
      return this._config.transforms[entity].serialize(data);
    }
    return data;
  };

  /**
   * Serializes instance data based on configured transforms the entity
   *
   * @param {String} entity ex 'audiences'
   * @param {Object} data
   * @return {Object} deserialized data
   */
  Api.prototype.deserialize = function(entity, data) {
    data = _.cloneDeep(data);
    if (this._config.transforms[entity]) {
      return this._config.transforms[entity].deserialize(data);
    }
    return data;
  };

  /**
   * Make POST request to current endpoint
   * @param {Object} data
   * @return {Deferred}
   */
  Api.prototype.post = function(data) {
    if (this._getMode() !== 'all') {
      throw new Error("ApiService Error: .post() must be called in 'all' mode");
    }

    var entity = this._getEntity();

    var opts = {
      type: 'POST',
      data: this.serialize(entity, data),
      url: this._getUrl()
    };

    return Api.request(opts, this._config.headers).pipe(function(response) {
      return this.deserialize(entity, response);
    }.bind(this));
  };

  /**
   * Update with data
   * @param {Object} data
   * @return {Deferred}
   */
  Api.prototype.put = function(data) {
    if (this._getMode() !== 'one') {
      throw new Error("ApiService Error: .put() must be called in 'one' mode");
    }

    var entity = this._getEntity();

    var opts = {
      type: 'PUT',
      data: this.serialize(entity, data),
      url: this._getUrl()
    };

    return Api.request(opts, this._config.headers).pipe(function(response) {
      return this.deserialize(entity, response);
    }.bind(this));
  };

  /**
   * Performs a GET request to the current endpoint the instance
   * is set to.
   *
   * @return {Deferred}
   */
  Api.prototype.get = function() {
    var opts = {
      type: 'GET',
      url: this._getUrl()
    };

    // create a serialize function to pass to pipe
    var deserialize = this.deserialize.bind(this, this._getEntity());
    var mode = this._getMode();

    return Api.request(opts, this._config.headers).pipe(function(results) {
      if (mode === 'one') {
        return deserialize(results);
      } else if (mode === 'all') {
        return results.map(deserialize);
      }
    });
  };

  /**
   * Performs a DELETE request to the current endpoint
   *
   * @return {Deferred}
   */
  Api.prototype.delete = function() {
    // TODO(jordan): should .delete() be callable after .all()
    if (this._getMode() !== 'one') {
      throw new Error("ApiService Error: .delete() must be called in 'one' mode");
    }

    var opts = {
      type: 'DELETE',
      url: this._getUrl()
    };

    return Api.request(opts, this._config.headers);
  };

  /**
   * Builds the url from this._stack
   * @private
   */
  Api.prototype._getUrl = function() {
    var url = this._config.baseUrl || '';
    var filters = [];
    var order = [];
    var params = [];

    url = this._stack.reduce(function(memo, item) {
      var mode = item[0]; // 'one' or 'all'
      memo += '/' + item[1] // noun
      if (mode === 'one') {
        memo += '/' + item[2] // id
      }
      return memo;
    }, url);

    if (this._filter.length > 0) {
      this._filter.forEach(function(tuple) {
        params.push('filter=' + tuple[0] + ':' + tuple[1]);
      });
    }

    if (this._order.length > 0) {
      this._order.forEach(function(order) {
        params.push('order=' + order);
      });
    }

    if (this._limit) {
      params.push('limit=' + this._limit);
    }

    if (this._offset) {
      params.push('offset=' + this._offset);
    }

    if (params.length > 0) {
      url += '?';
      url += params.join('&');
    }

    return url;
  };

  /**
   * Gets the entity of the url
   * @private
   */
  Api.prototype._getEntity = function() {
    return this._stack[this._stack.length - 1][1];
  };

  /**
   * Gets the mode of the request ('one' | 'all')
   * @private
   */
  Api.prototype._getMode = function() {
    return this._stack[this._stack.length - 1][0];
  };

  return {
    // expose the Api constructor
    Api: Api,
    // the create function used to make an api instance
    /**
     * @param {{ '{{' }}
     *    headers: object,
     *    baseUrl: string,
     *    transforms: {
     *      <string>: {
     *        serialize: function,
     *        deserialize: function 
     *      }
     *    }
     * {{ '}}' }} config
     */
    create: function(config) {
      return function() {
        return new Api(config);
      }
    }
  };
});

/**
 * Api service configured to work with the Experiment API
 *
 * Largely influenced by Restangular
 *
 * Usage:
 * ====================================================================
 * var api = require('services/api');
 * var project = api().one('projects', 4001)
 * project.get().then(function(data) {
 *   data.name = 'new name';
 *   // updates the project entity by performing a PUT request
 *   project.put(data);
 * });
 *
 * var experiments = project.all('experiments');
 * experiments.get(function(experiments) {
 *   // experiments is an Array.<Object> of experiment data
 * });
 *
 * ========== or =============
 *
 * var experiments = api().one('projects', 4001').all('experiments')
 * experiments.get().then(function(experiments) {
 *   // experiments is an Array.<Object> of experiment data
 * });
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/api',['require','services/api_factory'],function(require) {
  var apiFactory = require('services/api_factory');

  return apiFactory.create({
    baseUrl: 'https://www.optimizelyapis.com/experiment/v1',

    headers: {
      'Token': '60e081e89a2e8f263b42d1616dd9ffaa:0895b2f9',
    }, // noop

    /**
     * Mapping of entities to their serialize/deserialize functions
     */
    transforms: {
      'audiences': {
        serialize: function(data) {
          if (data.conditions) {
            data.conditions = JSON.stringify(data.conditions);
          }
          return data;
        },
        deserialize: function(data) {
          if (data.conditions) {
            data.conditions = JSON.parse(data.conditions);
          }
          return data;
        }
      },
      'experiments': {
        serialize: function(experiment) {
          if (experiment.display_goal_order_lst) {
            experiment.display_goal_order_lst = experiment.display_goal_order_lst.map(String);
          }
          return experiment;
        },
        deserialize: function(experiment) {
          if (experiment.display_goal_order_lst) {
            experiment.display_goal_order_lst = experiment.display_goal_order_lst.map(function(goalId){
              return parseInt(goalId, 10);
            });
          }
          return experiment;
        }
      }
    }
  });
});

/**
 * Creates a deterministic hash of a JS object
 *
 * @author Jordan Garcia
 */
define('utils/hasher',['require','lodash'],function(require) {
  var _ = require('lodash');

  /**
   * Creates a deterministic stringified JSON of a JS
   * object by ensuring deterministic key ordering
   *
   * @param {object} obj
   * @return {string}
   */
  function stringifyObject(obj) {
    function flatten(obj) {
      if (!_.isObject(obj)) {
        return obj;
      }
      return _.chain(obj)
        .pairs()
        .map(function(p) {
          return [p[0], flatten(p[1])];
        })
        .sortBy(function(p) {
          return p[0]
        })
        .valueOf()
    }

    return JSON.stringify(flatten(obj));
  }

  /**
   * Basic hash function
   * @param {string} str
   * @return {number}
   */
  function hash(str) {
    var res = 0, i, chr, len;
    if (!str) return res;
    for (i = 0, len = str.length; i < len; i++) {
      chr   = str.charCodeAt(i);
      res  = ((res << 5) - res) + chr;
      res |= 0; // Convert to 32bit integer
    }
    return res;
  }

  /**
   * Object hashing function
   * @param {object} obj
   * @return {string}
   */
  function hashObject(obj) {
    if (!_.isObject(obj)) {
      throw new Error('Cannot hash non-object');
    }

    return String(hash(stringifyObject(obj)));
  }

  return {
    hash: hashObject,
  }
});

/**
 * Factory for creating simple model objects with a restful interface
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/model_factory',['require','lodash','services/api','utils/hasher'],function(require) {
  var _ = require('lodash');
  var api = require('services/api');
  var hasher = require('utils/hasher');

  /**
   * Create a base model which provides common methods shared by Model and RelationshipModel
   * @param {Object} config for the model and extends the model object with any properties/methods
   * @return {Object} base model object
   */
  function createBaseModel(config) {
    var InstanceConstructor = config.instance || function ModelInstance() {};

    // Mixin methods that all models have
    return {
      // expose the instance constructor for `(instance instanceof Model.instance) checks
      instance: InstanceConstructor,

      /**
       * Creates a new object with the config.fields as the default values
       *
       * @param {Object} data
       * @return {Object}
       */
      create: function(data) {
        // use the supplied constructor
        // This allows a user to pass in instance: function Audience() {}
        // and have the Audience() function return an instance of Audience
        var instance = new InstanceConstructor();
        var instanceData = _.extend(
          {},
          _.cloneDeep(config.fields || {}),
          _.cloneDeep(data || {})
        );
        // populate the instance
        _.extend(instance, instanceData);
        return instance;
      },

      /**
       * Checks if the passed in object is an instance of the supplied
       * def.instance function constructor
       *
       * @param {Object} instance
       * @param {Boolean}
       */
      isInstance: function(instance) {
        return (instance instanceof this.instance);
      },

      /**
       * Deserializes API data to be used in Javascript
       * @param {Object} data
       * @return {Object}
       */
      deserialize: function(data) {
        return api().deserialize(config.entity, data);
      },

      /**
       * Serializes the model instance data and prepares it in a format that is
       * consumable by the API
       *
       * @param {Object} data
       * @return {Object}
       */
      serialize: function(data) {
        return api().serialize(config.entity, data);
      },
    };
  }

  /**
   * config options:
   * 'entity' {String} name of entity in the API, ex: 'experiments' (unique)
   * 'instance' {Function} blank named function used as instance constructor, ex: function Audience() {}
   * 'parent' {{ '{{' }} entity: String, key: String {{ '}}' }} the required parent association for fetches
   * 'fields' {Object} (optional) hash of default values of the entity when using Model.create()
   *
   * @param {Object} config for the model and extends the model object with any properties/methods
   * @return {Object} model object
   */
  function createModel(config) {
    if (!config.entity) {
      throw new Error('"entity" is required');
    }

    // Mixin methods that all classical (non-relationship) models have
    var Model = {
      hashCode: hasher.hash(_.pick(config, ['entity', 'parent'])),

      /**
       * Persists entity using rest API
       *
       * @param {Model} instance
       * @return {Deferred}
       */
      save: function(instance) {
        if (instance.id) {
          // do PUT save
          return api()
            .one(config.entity, instance.id)
            .put(instance);
        } else {
          // no id is set, do a POST
          var endpoint = api();
          if (config.parent) {
            endpoint.one(config.parent.entity, instance[config.parent.key]);
          }

          return endpoint
            .all(config.entity)
            .post(instance);
        }
      },

      /**
       * Fetch and return an entity
       * @param entityId Id of Entity to fetch
       * @returns {Deferred} Resolves to fetched Model instance
       */
      fetch: function(entityId) {
        return api()
          .one(config.entity, entityId)
          .get()
          .pipe(this.create);
      },

      /**
       * Fetches a page of entities that match the supplied filters
       * as well as the offset and limit defining the size of the page.
       * If the model has a parent association then the parent.key must be
       * supplied.
       * @param {Object|undefined} filters (optional)
       * @return {Deferred}
       */
      fetchPage: function(filters) {
        filters = filters || {};
        var $order = filters.$order;
        var $limit = filters.$limit;
        var $offset = filters.$offset || 0;
        var $filters = _.omit(filters, ["$order", "$limit", "$offset"]);
        var endpoint = api();

        if (config.parent && !$filters[config.parent.key]) {
          throw new Error("fetchPage: must supply the parent.key as a filter to fetch entities");
        }

        if (config.parent) {
          endpoint.one(config.parent.entity, $filters[config.parent.key]);
          // since the filtering is happening in the endpoint url we dont need filters
          delete $filters[config.parent.key];
        }

        return endpoint
          .all(config.entity)
          .filter($filters)
          .order($order)
          .limit($limit)
          .offset($offset)
          .get()
          .pipe(function(results) {
            return results.map(this.create);
          }.bind(this));
      },

      /**
       * Fetches all the entities that match the supplied filters
       * If the model has a parent association then the parent.key must be
       * supplied.
       * @param {Object|undefined} filters (optional)
       * @return {Deferred}
       */
      fetchAll: function(filters) {
        filters = filters || {};
        var $order = filters.$order;
        filters = _.omit(filters || {}, ['$order']);
        var endpoint = api();

        if (config.parent && !filters[config.parent.key]) {
          throw new Error("fetchAll: must supply the parent.key as a filter to fetch all entities");
        }

        if (config.parent) {
          endpoint.one(config.parent.entity, filters[config.parent.key]);
          // since the filtering is happening in the endpoint url we dont need filters
          delete filters[config.parent.key];
        }

        return endpoint
          .all(config.entity)
          .filter(filters)
          .order($order)
          .get()
          .pipe(function(results) {
            return results.map(this.create);
          }.bind(this));
      },

      /**
       * Makes an API request to delete the instance by id
       * @param {Model} instance
       */
      delete: function(instance) {
        if (!instance.id) {
          throw new Error("delete(): `id` must be defined");
        }

        return api()
          .one(config.entity, instance.id)
          .delete();
      },
    };

    return _.extend(createBaseModel(config), Model, config);
  }

  /**
   * config options:
   * 'entity' {String} name of entity in the API, ex: 'projectintegrations' (unique)
   * 'instance' {Function} blank named function used as instance constructor, ex: function ProjectIntegration() {}
   * 'parents' {[{ entity: String, key: String }]} the required parents association for fetches, note here that
   *                                               the order of parent configs in this property matters, e.g. for
   *                                               [{entity: 'projects', key: ...}, {entity: 'integrations', key: ...}],
   *                                               the fetchAll operation will use an API endpoint like below:
   *                                               /projects/<project_id>/integrations, reverse the parent configs
   *                                               the endpoint will then become /integrations/<integration_id>/projects
   * 'fields' {Object} (optional) hash of default values of the entity when using Model.create()
   *
   * @param {Object} config for the model and extends the model object with any properties/methods
   * @return {Object} relationship model
   */
  function createRelationshipModel(config) {
    // config.entity is required and acts as a unique identifier to support serialize / deserialize methods
    if (!(config.entity && config.parents)) {
      throw new Error('"entity" and "parents" are required');
    }

    // Mixin methods that all relationship models have
    var RelationshipModel = {
      hashCode: hasher.hash(_.pick(config, ['entity', 'parents'])),

      /**
       * Persists a relationship entity using rest API
       *
       * @param {Model} instance
       * @return {Deferred}
       */
      save: function(instance) {
        var endpoint = api();

        _.each(config.parents, function(parentConfig) {
          if (!instance[parentConfig.key]) {
            throw new Error(parentConfig.key + " must be supplied in instance.");
          }
          endpoint.one(parentConfig.entity, instance[parentConfig.key]);
        });

        // PUT endpoint will perform upsert operation for relationship entities
        return endpoint.put(instance);
      },

      /**
       * Fetch and return a relationship entity
       * @param {Object} parentIdMap Ids of parent entities which together identify the relationship entity to fetch
       * @returns {Deferred} Resolves to fetched Model instance
       */
      fetch: function(parentIdMap) {
        var endpoint = api();

        _.each(config.parents, function(parentConfig) {
          if (!parentIdMap[parentConfig.key]) {
            throw new Error(parentConfig.key + " must be supplied in parentIdMap.");
          }
          endpoint.one(parentConfig.entity, parentIdMap[parentConfig.key]);
        });

        return endpoint.get().pipe(this.create);
      },

      /**
       * Fetches a page of entities that match the supplied filters
       * TODO Implement fetchPage for relationship models
       */
      fetchPage: function(filters) {
        this.fetchAll(filters);
      },

      /**
       * Fetches all the entities that match the supplied filters
       * Exactly one of the parents' keys must not be supplied in filters.
       * @param {Object|undefined} filters (optional)
       * @return {Deferred}
       */
      fetchAll: function(filters) {
        filters = _.clone(filters || {});
        var endpoint = api();
        var missingParentEntity;

        _.each(config.parents, function(parentConfig) {
          if (filters[parentConfig.key]) {
            endpoint.one(parentConfig.entity, filters[parentConfig.key]);
            delete filters[parentConfig.key];
          } else {
            if (missingParentEntity) {
              throw new Error("fetchAll: miss too many parent IDs in filters: " +
                               [missingParentEntity.key, parentConfig.key].join(", "));
            } else {
              missingParentEntity = parentConfig;
            }
          }
        });

        if (!missingParentEntity) {
          throw new Error("fetchAll: exactly one of the parents' keys must not be supplied in filters.");
        }

        return endpoint.all(missingParentEntity.entity)
                       .filter(filters)
                       .get()
                       .pipe(function(results) {
                         return results.map(this.create);
                       }.bind(this));
      },

      /**
       * Makes an API request to delete a relationship entity by its parent ids
       * @param {Model} instance
       */
      delete: function(instance) {
        var endpoint = api();

        _.each(config.parents, function(parentConfig) {
          if (!instance[parentConfig.key]) {
            throw new Error(parentConfig.key + " must be supplied in instance.");
          }
          endpoint.one(parentConfig.entity, instance[parentConfig.key]);
        });

        return endpoint.delete();
      },
    };

    return _.extend(createBaseModel(config), RelationshipModel, config);
  }

  return {
    create: createModel,
    createRelationshipModel: createRelationshipModel,
  };
});

/**
 * Project model
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('models/project',['require','services/model_factory'],function(require) {
  var modelFactory = require('services/model_factory');

  return modelFactory.create({
    entity: 'projects',

    instance: function Project() {}
  });
});

/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

define('utils/key_mirror',[],function() {
  /**
   * Constructs an enumeration with keys equal to their value.
   *
   * For example:
   *
   *   var COLORS = keyMirror({blue: null, red: null});
   *   var myColor = COLORS.blue;
   *   var isColorValid = !!COLORS[myColor];
   *
   * The last line could not be performed if the values of the generated enum were
   * not equal to their keys.
   *
   *   Input:  {key1: val1, key2: val2}
   *   Output: {key1: key1, key2: key2}
   *
   * @param {object} obj
   * @return {object}
   */
  var keyMirror = function(obj) {
    var ret = {};
    var key;
    if (!(obj instanceof Object && !Array.isArray(obj))) {
      throw new Error('keyMirror(...): Argument must be an object.');
    }
    for (key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }
      ret[key] = key;
    }
    return ret;
  };

  return keyMirror;
});

/**
 * Constants for API actions
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/constants/action_types',['require','utils/key_mirror'],function(require) {
  var keyMirror = require('utils/key_mirror');

  /**
   * returns array of {
   *   SOME_ACTION_CONSTANT: SOME_ACTION_CONSTANT,
   *   ANOTHER_CONSTANT: ANOTHER_CONSTANT,
   * }
   */
  return keyMirror({
    // View actions
    ENTITY_DELETED: null,
    ENTITY_UPDATED: null,
    CHANGE_CURRENT_PROJECT_ID: null,

    // Application account actions
    ACCOUNT_INFO_LOADED: null,

    // API actions
    API_SYNC: null,
    API_ENTITY_FETCH_START: null,
    API_ENTITY_FETCH_SUCCESS: null,
    API_ENTITY_FETCH_FAIL: null,
    API_ENTITY_PERSIST_START: null,
    API_ENTITY_PERSIST_SUCCESS: null,
    API_ENTITY_PERSIST_FAIL: null,
    API_ENTITY_DELETED_SUCCESS: null,
    API_ENTITY_DELETED_FAIL: null,
    FLUSH_API_ENTITY_STORE: null,

    // EXPERIMENT RESULTS
    EXPERIMENT_RESULTS_FETCH_SUCCESS: null,
    EXPERIMENT_VISITOR_COUNT_FETCH_SUCCESS: null,

    // DASHBOARD ACTIONS
    DASHBOARD_SWITCH_MAIN_TAB: null,
    DASHBOARD_SWITCH_SUB_TAB: null,

    DASHBOARD_SET_TABLE_FILTERS: null,
    DASHBOARD_RESET_TABLE_FILTERS: null,

    DASHBOARD_SELECT_TABLE_ITEM: null,
    DASHBOARD_DESELECT_TABLE_ITEM: null,

    // DASHBOARD ACTIVITY ACTIONS
    DASHBOARD_SELECT_ACTIVITY_FILTER: null,
    DASHBOARD_SET_NEXT_PAGE_ACTIVITY_FILTER: null,
    DASHBOARD_SET_ACTIVITY_PAGE_RESULTS_LENGTH: null,

    DASHBOARD_SELECT_INTEGRATION: null,

    // INTEGRATION ACTIONS
    UPDATE_EXPERIMENT_INTEGRATION_SETTINGS: null,

    // SORTABLE TABLES
    SORT_TABLE: null,
    TOGGLE_SORT_TABLE_FIELD: null,
    RESET_TABLE_SORTING: null,

    // LOADING
    LOADING_START: null,
    LOADING_FINISH: null,
    ENTITY_LOADING_START: null,
    ENTITY_LOADING_FINISH: null,
    CLEAR_ALL_ENTITY_LOADING: null,

    // MOBILE ACTIONS
    CHANGE_MOBILE_PLATFORM: null
  });
});

/**
 * Extracts a JS object of query params from a string
 */
define('utils/parse_query_params',['require','exports','module'],function(require, exports, module) {
  module.exports = function queryParamsToObject(location) {
    var result = {};
    var parts = location.split('?')
    if (parts.length === 1) {
      return result;
    }
    parts[1].split('&').forEach(function(data) {
      var item = data.split('=');
      result[item[0]] = item[1];
    });
    return result;
  }
});

/**
 * Defines the types of property fields that can
 * exist on a model definition
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('models/field_types',['require','utils/key_mirror'],function(require) {
  var keyMirror = require('utils/key_mirror');
  return keyMirror({
    DATE: null,
    NUMBER: null,
    STRING: null,
    BOOLEAN: null,
    ARRAY: null,
    OBJECT: null,
  });
});

/**
 * Audience model
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('models/audience',['require','services/model_factory','models/field_types'],function(require) {
  var modelFactory = require('services/model_factory');
  var fieldTypes = require('models/field_types');

  return modelFactory.create({
    entity: 'audiences',

    parent: {
      entity: 'projects',
      key: 'project_id'
    },

    instance: function Audience() {},

    fields: {
      id: null,
      project_id: null,
      name: null,
      description: null,
      last_modified: null,
      conditions: [],
      segmentation: false
    },
  });
});

/**
 * Collaborator model
 * @author Cheston Lee(cheston@optimizely.com)
 */
define('models/collaborator',['require','services/api','services/model_factory','flux/constants/action_types','flux'],function(require) {
  var api = require('services/api');
  var modelFactory = require('services/model_factory');
  var actionTypes = require('flux/constants/action_types');
  var flux = require('flux');

  return modelFactory.createRelationshipModel({
    entity: 'collaborators',

    parents: [
      {
        entity: 'projects',
        key: 'project_id'
      },
      {
        entity: 'collaborators',
        key: 'user_id'
      }
    ],

    instance: function Collaborator() {},

    fields: {
      project_id: null,
      user_id: null,
      role_name: null,
      title: null,
      first_name: null,
      last_name: null
    },
  });
});

/**
 * CustomDimension model
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('models/dimension',['require','services/model_factory','models/field_types'],function(require) {
  var modelFactory = require('services/model_factory');
  var fieldTypes = require('models/field_types');

  return modelFactory.create({
    entity: 'dimensions',

    parent: {
      entity: 'projects',
      key: 'project_id'
    },

    instance: function Dimension() {},

    fields: {
      'id': null,
      'project_id': null,
      'name': null,
      'description': null,
      'status': null,
      'last_modified': null
    }
  });
});

/**
 * Experiment model
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('models/experiment',['require','services/api_factory','services/model_factory','models/field_types'],function(require) {
  var apiFactory = require('services/api_factory');
  var modelFactory = require('services/model_factory');
  var fieldTypes = require('models/field_types');

  return modelFactory.create({
    entity: 'experiments',

    parent: {
      entity: 'projects',
      key: 'project_id'
    },

    instance: function Experiment() {},

    // define array field types to allow _.contains filtering
    fieldTypes: {
      status: fieldTypes.STRING,
      audience_ids: fieldTypes.ARRAY,
      enabled_integration_ids: fieldTypes.ARRAY,
      variation_ids: fieldTypes.ARRAY,
    },

    /**
     * WARNING this function currently doesnt work, it relies on the
     * reper results api service to accept requests from optimizely.com
     * domains
     *
     * Fetches the results for an experiment by making a request
     * to the Reper backend
     * @param {Experiemnt} exp
     * @return {Deferred}
     */
    results: function(exp) {
      // TODO implement when reper is available
      var baseUrl = 'https://reper.dz.optimizely.com/v1';
      return $.ajax({
        headers: {
          'X-share-token': exp.share_token
        },
        url: baseUrl + '/experiments/'+exp.id+'/results',
        type: 'GET',
      })
    }
  });
});

/**
 * Goal model
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('models/goal',['require','services/model_factory','models/field_types'],function(require) {
  var modelFactory = require('services/model_factory');
  var fieldTypes = require('models/field_types');

  return modelFactory.create({
    entity: 'goals',

    parent: {
      entity: 'projects',
      key: 'project_id'
    },

    instance: function Goal() {},

    // define field types with special sorting rules
    fieldTypes: {
      experiment_ids: fieldTypes.ARRAY,
      created: fieldTypes.DATE,
    }
  });
});

/**
 * Integration model
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('models/integration',['require','services/model_factory','models/field_types'],function(require) {
  var modelFactory = require('services/model_factory');
  var fieldTypes = require('models/field_types');

  return modelFactory.create({
    entity: 'integrations',

    instance: function Integration() {},

    // define array field types to allow _.contains filtering
    fieldTypes: {
      categories: fieldTypes.ARRAY,
      channels: fieldTypes.ARRAY,
    },
  });
});

/**
 * Project Actvitiy model
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('models/activity/project_activity',['require','services/model_factory'],function(require) {
  var modelFactory = require('services/model_factory');

  return modelFactory.create({
    entity: 'activity',

    parent: {
      entity: 'projects',
      key: 'project_id'
    },

    instance: function ProjectActivity() {},
  });
});

/**
 * ProjectIntegration model
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('models/project_integration',['require','services/model_factory'],function(require) {
  var modelFactory = require('services/model_factory');

  return modelFactory.createRelationshipModel({
    entity: 'projectintegrations',

    parents: [
      {
        entity: 'projects',
        key: 'project_id',
      },
      {
        entity: 'integrations',
        key: 'integration_id',
      }
    ],

    instance: function ProjectIntegration() {},

    fields: {
      id: null,
      project_id: null,
      integration_id: null,
      enabled: false,
      settings: null,
      last_modified: null,
    },
  });
});

/**
 * Functions that are either pagejs style functions or return pagejs style
 * functions to be chained together when resolving routes
 *
 * PageJS functions are of the interface: function(ctx, next) : void
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('routing/dashboard_routing',['require','exports','module','flux','vue','models/project','flux/constants/action_types','utils/parse_query_params','models/audience','models/collaborator','models/dimension','models/experiment','models/goal','models/integration','models/activity/project_activity','models/project_integration','utils/enums'],function(require, exports, module) {
  var flux = require('flux');
  var vue = require('vue');
  var Project = require('models/project');
  var actionTypes = require('flux/constants/action_types');
  var parseQueryParams = require('utils/parse_query_params');

  var Audience = require('models/audience');
  var Collaborator = require('models/collaborator');
  var Dimension = require('models/dimension');
  var Experiment = require('models/experiment');
  var Goal = require('models/goal');
  var Integration = require('models/integration');
  var ProjectActivity = require('models/activity/project_activity');
  var ProjectIntegration = require('models/project_integration');
  var ProjectStatusType = require('utils/enums').ProjectStatusType

  /**
   * Fetches the necessary project data
   * this will populate the ctx.projects object with the fetched
   * data
   */
  exports.fetchProjects = function(ctx, next) {
    var projId = Number(ctx.params.proj_id);
    var accountId = flux.store('account').getId();
    var project;

    flux.actions('api').fetchAll(Project, {
      account_id: accountId,
    }).then(function(projects) {
      ctx.projects = projects;

      if (projId) {
        // try to find the project by id specified in URL
        project = _.find(ctx.projects, {
          id: projId
        })
      }

      if (!project) {
        project = _.find(ctx.projects, {
          project_status: ProjectStatusType.ACTIVE
        })
      }

      ctx.currentProject = project;
      flux.actions('currentProject').setCurrentProjectId(project.id);

      next();
    });
  };

  /**
   * Loads the necessary data into the frontend stores
   * for the experiments tab
   */
  exports.fetchExperimentsTabData = function(ctx, next) {
    var byProject = {
      project_id: ctx.currentProject.id
    };

    // Use the dashboard action to fetch experiments so it will only fetch
    // experiments matching the filters that are selected
    var shouldFetchResults = true;
    flux.actions('dashboard').fetchExperiments(shouldFetchResults);

    flux.actions('api').fetchAll(Audience, byProject);
    flux.actions('api').fetchAll(Goal, byProject);

    next();
  };

  exports.fetchAudiencesTabData = function(ctx, next) {
    var byProject = {
      project_id: ctx.currentProject.id
    };

    var audiences = flux.actions('api').fetchAll(Audience, byProject);
    var dimensions = flux.actions('api').fetchAll(Dimension, byProject);

    flux.actions('loading').when('dashboard.audiences', audiences);
    flux.actions('loading').when('dashboard.audiences.reportableCount', [audiences, dimensions]);

    flux.actions('api').fetchAll(Experiment, byProject);
    next();
  };

  exports.fetchDimensionsTabData = function(ctx, next) {
    var byProject = {
      project_id: ctx.currentProject.id
    };
    var dimensionDef = flux.actions('api').fetchAll(Dimension, byProject);

    flux.actions('loading').when('dashboard.dimensions', dimensionDef);

    flux.actions('api').fetchAll(Audience, byProject);
    next();
  };

  /**
   * Fetch the data required for the change history tab
   */
  exports.fetchChangeHistoryTabData = function(ctx, next) {
    var project = ctx.currentProject;
    if (flux.actions('permissions').canUseChangeHistory(project)) {
      var byProject = {
        project_id: ctx.currentProject.id
      };

      var activityFilters = flux.store('dashboard/activityFilters').getFilters();
      var byProjectActivities = _.extend({}, byProject, activityFilters);
      var loadingKey = 'dashboard.change-history';

      flux.actions('loading').start(loadingKey);

      flux.actions('dashboard').fetchExperiments().then(function() {
        flux.actions('api').fetchAll(Collaborator, byProject).then(function() {
          flux.actions('api')
            .fetchPage(ProjectActivity, byProjectActivities)
            .then(function (results) {
              flux.dispatch(actionTypes.DASHBOARD_SET_ACTIVITY_PAGE_RESULTS_LENGTH, {
                length: results.length
              });
              flux.actions('loading').stop(loadingKey);
            });
        });
      });
    }
    next();
  };

  exports.fetchIntegrationsTabData = function(ctx, next) {
    var byProject = {
      project_id: ctx.currentProject.id
    };

    var loading = [];

    loading.push(flux.actions('api').fetchAll(Integration));
    loading.push(flux.actions('api').fetchAll(ProjectIntegration, byProject));
    flux.actions('api').fetchAll(Experiment, byProject);

    flux.actions('loading').when('dashboard.integrations', loading);

    next();
  };

  exports.fetchCollaboratorsTabData = function(ctx, next) {
    var byProject = {
      project_id: ctx.currentProject.id
    };

    var loading = flux.actions('api').fetchAll(Collaborator, byProject);
    flux.actions('loading').when('dashboard.collaborators', loading);
    next();
  };

  /**
   * Parses filters from the query params for the audience search filter
   */
  exports.parseAudienceFilters = function(ctx, next) {
    var params = parseQueryParams(ctx.path);
    if (params.search) {
      var searchString = decodeURIComponent(params.search);
      flux.actions('dashboard').filterAudiencesByString(searchString);
    }
    if (params.status) {
      flux.actions('dashboard').filterAudiencesByStatus(params.status);
    }
    next();
  };

  /**
   * Parses filters from the query params for the dimensions search filter
   */
  exports.parseDimensionFilters = function(ctx, next) {
    var params = parseQueryParams(ctx.path);
    if (params.search) {
      var searchString = decodeURIComponent(params.search);
      flux.actions('dashboard').filterDimensionsByString(searchString);
    }
    next();
  };

  /**
   * Parses filters from the query params for the collaborators search filter
   */
  exports.parseCollaboratorFilters = function(ctx, next) {
    var params = parseQueryParams(ctx.path);
    if (params.search) {
      var searchString = decodeURIComponent(params.search);
      flux.actions('dashboard').filterCollaboratorsByString(searchString);
    }
    next();
  };

  /**
   * Parses filters from the query params for experiment data table
   * filtering
   */
  exports.parseExperimentFilters = function(ctx, next) {
    var params = parseQueryParams(ctx.path);
    if (params.search) {
      var searchString = decodeURIComponent(params.search);
      flux.actions('dashboard').filterExperimentsByString(searchString);
    }
    if (params.status) {
      flux.actions('dashboard').filterExperimentsByStatus(params.status);
    }
    next();
  };

  /**
   * Parses filters from the query params for experiment data table
   * filtering
   */
  exports.parseChangeHistoryFilters = function(ctx, next) {
    var params = parseQueryParams(ctx.path);
    if (params.expId) {
      var experiment_id = params.expId;
      flux.actions('dashboard/activity').selectActivityFilter('experiment_id', experiment_id);
    }
    next();
  };

  /**
   * Fetches projects for the manage projects page
   */
  exports.populateManageProjects = function(ctx, next) {
    flux.actions('api').fetchAll(Project, {
      account_id: flux.store('account').getId(),
    }).then(next);
  };

  /**
   * Returns a PageJS chainable function that selects a single item
   * in a table given a category (ex: 'experiments', 'audiences')
   */
  exports.selectTableItem = function(category) {
    return function(ctx, next) {
      var itemId = Number(ctx.params.item_id);
      if (itemId) {
        flux.actions('dashboard').selectItem(category, {
          id: itemId
        });
      }
      next();
    }
  }

  /**
   * Returns a PageJS chainable function that switches the dashboard
   * main tab
   */
  exports.showTabs = function(mainTabId, subTabId) {
    return function(ctx, next) {
      flux.actions('dashboard').switchMainTab(mainTabId);
      if (subTabId) {
        flux.actions('dashboard').switchSubtab(subTabId);
      }
      next();
    }
  };
});

/**
 * Routes definition
 */
define('routes',['require','exports','module','app','routing/mount_component','routing/dashboard_routing','utils/page'],function(require, exports, module) {
  var app = require('app');
  var mountComponent = require('routing/mount_component');
  var dash = require('routing/dashboard_routing');
  var Router = require('utils/page');

  var dashboardComp = 'dashboard/overview';
  var manageProjectsComp = 'pages/manage-projects';

  /**
   * Helper function to redirect to another path and re-evaluate the routes
   * Used as a catchall
   */
  function redirect(path) {
    return function() {
      Router(path)
    }
  }

  /**
   * export an array of objects with match<string|RegExp>
   * and handle: <array<function>>
   */
  module.exports = [
    {
      match: '/projects/manage',
      handle: [
        dash.populateManageProjects,
        mountComponent(app, '#body-wrapper', manageProjectsComp),
      ]
    },
    {
      match: '/projects/:proj_id?',
      handle: [
        dash.fetchProjects,
        dash.fetchExperimentsTabData,
        dash.showTabs('projects', 'experiments'),
        mountComponent(app, '#body-wrapper', dashboardComp),
      ]
    },
    {
      match: '/projects/:proj_id/experiments/:item_id?',
      handle: [
        dash.fetchProjects,
        dash.parseExperimentFilters,
        dash.fetchExperimentsTabData,
        dash.showTabs('projects', 'experiments'),
        dash.selectTableItem('experiments'),
        mountComponent(app, '#body-wrapper', dashboardComp),
      ]
    },
    {
      match: '/projects/:proj_id/audiences/:item_id?',
      handle: [
        dash.fetchProjects,
        dash.fetchAudiencesTabData,
        dash.parseAudienceFilters,
        dash.showTabs('projects', 'audiences'),
        dash.selectTableItem('audiences'),
        mountComponent(app, '#body-wrapper', dashboardComp),
      ]
    },
    {
      match: '/projects/:proj_id/dimensions/:item_id?',
      handle: [
        dash.fetchProjects,
        dash.fetchDimensionsTabData,
        dash.parseDimensionFilters,
        dash.showTabs('projects', 'dimensions'),
        dash.selectTableItem('dimensions'),
        mountComponent(app, '#body-wrapper', dashboardComp),
      ]
    },
    {
      match: '/projects/:proj_id/change-history/:item_id?',
      handle: [
        dash.fetchProjects,
        dash.parseChangeHistoryFilters,
        dash.parseExperimentFilters,
        dash.fetchChangeHistoryTabData,
        dash.showTabs('projects', 'change-history'),
        dash.selectTableItem('activities'),
        mountComponent(app, '#body-wrapper', dashboardComp),
      ]
    },
    {
      match: '/projects/:proj_id/integrations',
      handle: [
        dash.fetchProjects,
        dash.fetchIntegrationsTabData,
        dash.showTabs('integrations'),
        mountComponent(app, '#body-wrapper', dashboardComp),
      ]
    },
    {
      match: '/projects/:proj_id/collaborators/:item_id?',
      handle: [
        dash.fetchProjects,
        dash.fetchCollaboratorsTabData,
        dash.parseCollaboratorFilters,
        dash.showTabs('collaborators'),
        dash.selectTableItem('collaborators'),
        mountComponent(app, '#body-wrapper', dashboardComp),
      ]
    },
    {
      match: '/projects/:proj_id/settings',
      handle: [
        dash.fetchProjects,
        dash.showTabs('settings'),
        mountComponent(app, '#body-wrapper', dashboardComp),
      ]
    },
    {
      // Catch all for the dashboard
      match: /\/projects(.+)/,
      handle: [
        redirect('/projects'),
      ]
    },
    {
      match: '*',
      handle: [
        // catchall no-op
        function() {}
      ]
    }
  ]
});

/**
 * Browser port of Node's util.inherits
 *
 * Inherit the prototype methods from one constructor into another. The prototype of constructor will be set to a new object created from superConstructor.
 *
 * As an additional convenience, superConstructor will be accessible through the constructor.super_ property.
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('utils/inherits',[],function() {
  return function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
});

/*!
 * EventEmitter v4.2.7 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function () {
	

	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class EventEmitter Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size
	var proto = EventEmitter.prototype;
	var exports = this;
	var originalGlobalValue = exports.EventEmitter;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @param {Function} listener Method to look for.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listeners, listener) {
		var i = listeners.length;
		while (i--) {
			if (listeners[i].listener === listener) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Alias a method while keeping the context correct, to allow for overwriting of target method.
	 *
	 * @param {String} name The name of the target method.
	 * @return {Function} The aliased method
	 * @api private
	 */
	function alias(name) {
		return function aliasClosure() {
			return this[name].apply(this, arguments);
		};
	}

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function getListeners(evt) {
		var events = this._getEvents();
		var response;
		var key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (evt instanceof RegExp) {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Takes a list of listener objects and flattens it into a list of listener functions.
	 *
	 * @param {Object[]} listeners Raw listener objects.
	 * @return {Function[]} Just the listener functions.
	 */
	proto.flattenListeners = function flattenListeners(listeners) {
		var flatListeners = [];
		var i;

		for (i = 0; i < listeners.length; i += 1) {
			flatListeners.push(listeners[i].listener);
		}

		return flatListeners;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function getListenersAsObject(evt) {
		var listeners = this.getListeners(evt);
		var response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function addListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var listenerIsWrapped = typeof listener === 'object';
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
				listeners[key].push(listenerIsWrapped ? listener : {
					listener: listener,
					once: false
				});
			}
		}

		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = alias('addListener');

	/**
	 * Semi-alias of addListener. It will add a listener that will be
	 * automatically removed after it's first execution.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addOnceListener = function addOnceListener(evt, listener) {
		return this.addListener(evt, {
			listener: listener,
			once: true
		});
	};

	/**
	 * Alias of addOnceListener.
	 */
	proto.once = alias('addOnceListener');

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function defineEvent(evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function defineEvents(evts) {
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function removeListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var index;
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listeners[key], listener);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = alias('removeListener');

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function addListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function removeListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		var i;
		var value;
		var single = remove ? this.removeListener : this.addListener;
		var multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function removeEvent(evt) {
		var type = typeof evt;
		var events = this._getEvents();
		var key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (evt instanceof RegExp) {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		return this;
	};

	/**
	 * Alias of removeEvent.
	 *
	 * Added to mirror the node API.
	 */
	proto.removeAllListeners = alias('removeEvent');

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function emitEvent(evt, args) {
		var listeners = this.getListenersAsObject(evt);
		var listener;
		var i;
		var key;
		var response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					listener = listeners[key][i];

					if (listener.once === true) {
						this.removeListener(evt, listener.listener);
					}

					response = listener.listener.apply(this, args || []);

					if (response === this._getOnceReturnValue()) {
						this.removeListener(evt, listener.listener);
					}
				}
			}
		}

		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = alias('emitEvent');

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function emit(evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	/**
	 * Sets the current value to check against when executing listeners. If a
	 * listeners return value matches the one set here then it will be removed
	 * after execution. This value defaults to true.
	 *
	 * @param {*} value The new value to check for when executing listeners.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.setOnceReturnValue = function setOnceReturnValue(value) {
		this._onceReturnValue = value;
		return this;
	};

	/**
	 * Fetches the current value to check against when executing listeners. If
	 * the listeners return value matches this one then it should be removed
	 * automatically. It will return true by default.
	 *
	 * @return {*|Boolean} The current value to check for or the default, true.
	 * @api private
	 */
	proto._getOnceReturnValue = function _getOnceReturnValue() {
		if (this.hasOwnProperty('_onceReturnValue')) {
			return this._onceReturnValue;
		}
		else {
			return true;
		}
	};

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function _getEvents() {
		return this._events || (this._events = {});
	};

	/**
	 * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
	 *
	 * @return {Function} Non conflicting EventEmitter class.
	 */
	EventEmitter.noConflict = function noConflict() {
		exports.EventEmitter = originalGlobalValue;
		return EventEmitter;
	};

	// Expose the class either via AMD, CommonJS or the global object
	if (typeof define === 'function' && define.amd) {
		define('event_emitter',[],function () {
			return EventEmitter;
		});
	}
	else if (typeof module === 'object' && module.exports){
		module.exports = EventEmitter;
	}
	else {
		this.EventEmitter = EventEmitter;
	}
}.call(this));

/**
 * Base Store object
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/store',['require','utils/inherits','event_emitter'],function(require) {
  var inherits = require('utils/inherits');
  var EventEmitter = require('event_emitter');
  var CHANGE_EVENT = 'change';

  /**
   * spec config
   * ==========
   * spec.initialize {function} function that sets up action handlers/initial data
   *
   * @constructor
   *
   * @param {number|string} id
   * @param {Flux} flux
   * @param {Object} spec
   */
  function Store(id, flux, spec) {
    this.id = id;
    this.flux = flux;
    this.__actions = {};
    EventEmitter.call(this);

    // bind all functions in the spec to the instance
    for (var key in spec) {
       if (typeof spec[key] === "function") {
        this[key] = spec[key].bind(this);
      } else {
        this[key] = spec[key];
      }
    }

    if (spec.initialize) {
      spec.initialize.call(this);
    }
  }

  inherits(Store, EventEmitter);

  /**
   * Expose __handleAction__ function for dispatcher
   *
   * @param {object} action
   */
  Store.prototype.__handleAction__ = function(action) {
    var handler = this.__actions[action.type];
    if (handler && typeof handler === 'function') {
      if (this.flux.DEBUG) {
        //this.flux.logger.handleActionStart(this.id, action.type);
      }
      handler.call(this, action.payload, action.type);
      if (this.flux.DEBUG) {
        //this.flux.logger.handleActionEnd(action.type);
      }
    }
  };

  /**
   * Bind an action => handler
   */
  Store.prototype.bindActions = function() {
    var actions = Array.prototype.slice.call(arguments);
    if (actions.length % 2 !== 0) {
      throw new Error("bindActions must take an even number of arguments.");
    }

    for (var i = 0; i < actions.length; i += 2) {
      var type = actions[i];
      var handler = actions[i+1];

      this.__actions[type] = handler;
    }
  };

  /**
   * Calls to dispatcher.waitFor
   * @param {array.<string|number>} storeIds
   */
  Store.prototype.waitFor = function(storeIds) {
    this.flux.dispatcher.waitFor(storeIds);
  };

  /**
   * Helper function to emit change event
   */
  Store.prototype.emitChange = function() {
    this.emit(CHANGE_EVENT);
  };

  /**
   * Helper function to hook into change event
   * @param {function} callback
   * @return {function} unwatch function
   */
  Store.prototype.addChangeListener = function(callback) {
    this.on(CHANGE_EVENT, callback);

    return function unwatch() {
      this.removeListener(CHANGE_EVENT, callback);
    }.bind(this);
  };

  /**
   * This resets all state on the store, this is possible
   * only if the Store.initialize() function reset all stateful properties
   * on the store
   */
  Store.prototype.reset = function() {
    this.initialize();
  }

  return Store;
});

/**
 * Factory for creating flux datastores
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/factories/store_factory',['require','lodash','flux/store','utils/invariant'],function(require) {
  var _ = require('lodash');
  var Store = require('flux/store');
  var invariant = require('utils/invariant');

  /**
   * Create a store that is extended by the passed in `spec`
   *
   * spec config
   * ==========
   * spec.initialize {function} function that sets up action handlers/initial data
   *
   * @param {Object} spec
   * @return {Store} constructor
   */
  function createStore(spec) {
    invariant(
      (!spec.initialize || spec.initialize !== 'function'),
      'Must supply a `initialize` method when creating a store'
    );

    return function(id, flux) {
      return new Store(id, flux, spec);
    };
  }

  return {
    create: createStore,
  };
});

/**
 * Util for sort functions
 *
 * @author Jordan Garcia
 */
define('utils/sort',[],function() {
  // CONSTANTS
  var ASC = 'asc';
  var DESC = 'desc';

  var sortFunctions = {
    string: function(a, b) {
      a = a.toLowerCase ? a.toLowerCase() : a;
      b = b.toLowerCase ? b.toLowerCase() : b;
      if (a < b) {
        return 1;
      } else if (a > b) {
        return -1;
      } else {
        return 0;
      }
    },
    number: function(a, b) {
      return b - a;
    },
    date: function(a, b) {
      return new Date(b) - new Date(a);
    },
    length: function(a, b) {
      return b.length - a.length;
    },
    /**
     * Sort function based on truthiness
     * If a is truthy and b is falsy than a
     * comes before b in desc order
     */
    boolean: function(a, b) {
      if (a == b) {
        return 0;
      }
      if (a) {
        return -1;
      }
      if (b) {
        return 1;
      }
    }
  };

  /**
   * Returns a new function that sorts by some object property
   * @param {function} fn
   * @param {string} field
   * @return {function}
   */
  function sortByField(fn, field){
    return function(a, b) {
      return fn(a[field], b[field]);
    }
  }

  /**
   * Reverse the sort result of a compare function
   * @param {function} fn
   * @return {number}
   */
  function reverse(fn) {
    return function(a, b) {
      return -fn(a, b);
    }
  }

  /**
   * Combines an array of functions into a sort function
   * that handles ties by calling the next function
   * @param {array.<function>} fns
   * @return {function}
   */
  function combineComparators(fns) {
    var len = fns.length;
    return function(a, b) {
      var i = 0;
      var result = 0;
      while (i < len && result === 0) {
        result = fns[i](a, b);
        i++;
      }
      return result;
    }
  }

  return {
    functions: sortFunctions,
    field: sortByField,
    reverse: reverse,
    combineComparators: combineComparators,
    ASC: ASC,
    DESC: DESC,
  };
});

/**
 * Factory for creating flux datastores that are based off of
 * rest entities
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/factories/entity_store_factory',['require','lodash','flux/constants/action_types','flux/factories/store_factory','utils/invariant','utils/sort','models/field_types'],function(require) {
  var _ = require('lodash');
  var actionTypes = require('flux/constants/action_types');
  var storeFactory = require('flux/factories/store_factory');
  var invariant = require('utils/invariant');
  var sort = require('utils/sort');
  var fieldTypes = require('models/field_types');


  /**
   * Creates a sorting function based on the model.fieldTypes
   * and order string/array
   *
   * order is of the format 'created:desc' or ['created:desc', 'id:asc']
   * @param {Object} model
   * @param {Array|String} order
   * @return {Function}
   */
  function createSortFn(model, order) {
    // Define a mapping of field types to their sorting functions
    var fieldSortFuncs = {};
    fieldSortFuncs[fieldTypes.STRING] = sort.functions.string;
    fieldSortFuncs[fieldTypes.NUMBER] = sort.functions.number;
    fieldSortFuncs[fieldTypes.DATE] = sort.functions.date;
    fieldSortFuncs[fieldTypes.BOOLEAN] = sort.functions.boolean;

    var sortFns = [];
    // If a string is passed in, coerce to an array
    if (typeof(order) === 'string') {
      order = [order];
    }

    var sortFns = order.map(function(orderString) {
      var orderParts = orderString.split(':');
      var field = orderParts[0];
      var direction = (orderParts.length > 1 && orderParts[1] === sort.DESC)
        ? sort.DESC
        : sort.ASC;

      // default to string sort
      var fieldType = model.fieldTypes[field];
      if (fieldType && !fieldSortFuncs[fieldType]) {
        // if the field type is defined but there is no sort function ignore
        // by returning null we rely on `_.filter` to remove this entry
        // before it is passed to combineComparators
        console.warn('Cannot sort by fieldType', fieldType);
        return null;
      }
      // if there is a field type use the field sortFn
      // else use the string function
      var sortFn = fieldType
        ? fieldSortFuncs[fieldType]
        : sort.functions.string;

      // right now the sortFn is simply function(a, b) { return a < b }
      // it does not have a field getter, ie `a.id < b.id`
      // use the `sort.field` method to return a function that has a property getter
      sortFn = sort.field(sortFn, field);
      if (direction === sort.ASC) {
        sortFn = sort.reverse(sortFn);
      }

      return sortFn;
    });

    // filter out null sortFns to ignore
    return sort.combineComparators(_.filter(sortFns));
  }

  /**
   * Creates and returns a single function that returns true/false
   * whether an item meets all of the filters
   *
   * Supports doing a _.contains for ARRAY types
   *
   * @param {Model} model
   * @param {object} filters
   */
  function createFilterFn(model, filters) {
    var modelFieldTypes = model.fieldTypes || {};
    // map the current filters to filterFns
    var filterFns = _.map(filters, function(val, field) {
      if (modelFieldTypes[field] === fieldTypes.ARRAY) {
        return function(item) {
          return _.contains(item[field], val);
        }
      } else {
        return function(item) {
          return item[field] === val;
        }
      }
    })

    return function(item) {
      return filterFns.every(function(fn) {
        return fn(item);
      });
    }
  }

  /**
   * Creates a store that extends spec
   *
   * spec config
   * ==========
   * spec.model {Model} Optimizely Model object
   * spec.initialize {function} function that sets up action handlers/initial data
   *
   * @param {Object} spec
   * @return {Store}[]
   */
  function createEntityStore(spec) {
    invariant(
      spec.model,
      "`model` must be passed in the entity store configuration"
    );

    // Base level methods on every entity store
    var BaseEntityStore = {
      initialize: function() {
        // expose the model
        this.model = spec.model;

        // setup initial data storage
        this.__data = {};
        // map of entity id => last clean state (used for rollbacks)
        this.__outOfSyncEntities__ = {};
        this.__deletedIds__ = [];

        // setup action handlers
        this.bindActions(
          actionTypes.API_ENTITY_FETCH_SUCCESS, this._onEntityFetchSuccess,
          actionTypes.API_ENTITY_DELETED_SUCCESS, this._onEntityDeletedSuccess,
          actionTypes.API_ENTITY_PERSIST_SUCCESS, this._onEntityPersistSuccess,
          actionTypes.API_ENTITY_PERSIST_FAIL, this._onEntityPersistFail,
          // action handlers for view actions
          actionTypes.ENTITY_UPDATED, this._onViewEntityUpdated,
          actionTypes.ENTITY_DELETED, this._onViewEntityDeleted,
          actionTypes.FLUSH_API_ENTITY_STORE, this._resetEntities
        );

        if (spec.initialize && typeof spec.initialize === 'function') {
          spec.initialize.apply(this);
        }
      },

      /**
       * Get entity by id
       * @param {number} id
       * @return {object|undefined}
       */
      get: function(id) {
        var result = this.__data[id];
        if (!result) {
          return;
        }
        return _.cloneDeep(result);
      },

      /**
       * Get a page of data from the store, specified
       * by the filters
       * @param {object} filters
       * @return {array.<object>}
       */
      getPage: function(filters) {
        filters = filters || {};
        var ret = this.getAll(filters);

        if (filters.$limit || filters.$offset) {
          var $limit = filters.$limit;
          var $offset = filters.$offset ? filters.$offset : 0;

          var dataSet = _(ret);
          if ($offset > 0) {
            dataSet = dataSet.rest($offset);
          }
          if ($limit) {
            dataSet = dataSet.first($limit);
          }

          ret = dataSet.value();
        }
        // dont need to clone here since getAll does this for us
        return ret;
      },

      /**
       * Get all data in the store, can supply map of filters
       * @param {object|function|undefined} filters
       * @return {array.<object>}
       */
      getAll: function(filters) {
        filters = filters || {};
        var $order = filters.$order;
        var $filters = _.omit(filters, ["$order", "$limit", "$offset"]);
        var ret = _.values(this.__data);

        if (!_.isEmpty($filters)) {
          ret = ret.filter(createFilterFn(this.model, $filters));
        }

        if ($order) {
          ret = ret.sort(createSortFn(this.model, $order));
        }

        return _.cloneDeep(ret);
      },

      /**
       * Gets all the entities that haven't been synced to server
       * @return {array.<object>}
       */
      getUnsyncedApiEntities: function() {
        var entities = [];
        _.each(this.__outOfSyncEntities__, function(_, id) {
          entities.push(this.get(id));
        }.bind(this));
        return entities;
      },

      /**
       * Gets all deleted entity ids
       * @return {array.<object>}
       */
      getIdsToDelete: function() {
        return this.__deletedIds__;
      },

      /**
       * Handler to flush all the entities in a store and get new ones
       * @private
       * @param {object} payload
       */
      _resetEntities: function(payload) {
        if (payload.entity === spec.model.entity) {

          // Reset state
          this.__data = {};
          this.__outOfSyncEntities__ = {};
          this.__deletedIds__ = [];
          this.emitChange();
        }
      },

      /**
       * Handler when an entity is delete view side, (not via API)
       * @private
       * @param {object} payload
       */
      _onViewEntityDeleted: function(payload) {
        if (payload.entity === spec.model.entity) {
          console.log('onViewEntityDeleted');
          this._markToDelete(payload.id);
          this._deleteEntity(payload.id);
          this.emitChange();
        }
      },

      /**
       * Handler for an entity being updated by a view action
       * It is implied that this entity isn't synced to the server
       * @private
       * @param {object} payload
       */
      _onViewEntityUpdated: function(payload) {
        // see if the action corresponds to this store's entity
        if (payload.entity === spec.model.entity) {
          console.log('onViewEntityUpdated');
          var data = payload.data;
          var existingEntity = this.__data[data.id];
          if (this.flux.DEBUG) {
            invariant(
              existingEntity,
              "Cannot update entity with id=%s, does not exist",
              data.id
            );
          }
          if (!_.isEqual(existingEntity, data)) {
            this._markDirty(existingEntity);
            _.extend(existingEntity, data);
            this.emitChange();
          }
        }
      },

      /**
       * Handler for the entity fetch success event
       * @private
       * @param {object} payload
       */
      _onEntityFetchSuccess: function(payload) {
        // see if the action corresponds to this store's entity
        if (payload.entity === spec.model.entity) {
          console.log('onEntityFetchSuccess');
          this._loadData(payload.data);
          // TODO(jordan): if the entity was dirty and a fetch comes, should it still be dirty
          this.emitChange();
        }
      },

      /**
       * Handles an API entity being persisted successfully
       * @private
       * @param {object} payload
       */
      _onEntityPersistSuccess: function(payload) {
        // see if the action corresponds to this store's entity and the entity exists in the store
        if (payload.entity === spec.model.entity) {
          console.log('onEntityPersistSuccess');
          // TODO(jordan): this could cause a race condition if the entity is updated between the
          // persist api request and the response
          this._loadData(payload.data);
          this._markClean(payload.data.id);
          this.emitChange();
        }
      },

      /**
       * Handles an API entity persist operation failure by rolling back
       * the entity to the last known synced state
       * @private
       * @param {object} payload
       */
      _onEntityPersistFail: function(payload) {
        // see if the action corresponds to this store's entity and the entity exists in the store
        if (payload.entity === spec.model.entity) {
          console.log('onEntityPersistFail');
          if (payload.id) {
            // tried to save an existing entity and it failed
            this._rollback(payload.id)
            this.emitChange();
          }
        }
      },

      /**
       * Handler for the entity delete success event
       * @private
       * @param {object} payload
       */
      _onEntityDeletedSuccess: function(payload) {
        // see if the action corresponds to this store's entity and the entity exists in the store
        if (payload.entity === spec.model.entity && this.__data[payload.id]) {
          console.log('onEntityDeletedSuccess');
          this._deleteEntity(payload.id)
          this._markAsDeleted(payload.id)
          this.emitChange();
        }
      },

      /**
       * Deletes an entity from the store
       * @private
       * @param {number} id
       */
      _deleteEntity: function(id) {
        delete this.__data[id];
      },

      /**
       * Loads the data into the store
       * @private
       * @param {array.<object>} data
       */
      _loadData: function(data) {
        if (!_.isArray(data)) {
          data = [data];
        }
        data.forEach(function(instance) {
          this.__data[instance.id] = instance;
        }, this);
      },

      /**
       * Rollback an entity to it's last known clean state
       * @param {number} id
       */
      _rollback: function(id) {
        var lastClean = this.__outOfSyncEntities__[id];
        if (lastClean) {
          this._loadData(lastClean);
          this._markClean(id);
        }
      },

      /**
       * Sets an entity as dirty
       * @param {object} lastCleanState of the entity
       */
      _markDirty: function(lastCleanState) {
        if (this.__outOfSyncEntities__[lastCleanState.id]) {
          // already marked dirty
          return;
        }
        this.__outOfSyncEntities__[lastCleanState.id] = _.cloneDeep(lastCleanState);
      },

      /**
       * Mark an entity id as being clean (synced)
       * @param {number} id
       */
      _markClean: function(id) {
        if (this.__outOfSyncEntities__[id]) {
          delete this.__outOfSyncEntities__[id];
        }
      },

      /**
       * Marks an entity id as to be deleted
       * This action can happen when the entity is no longer in the store
       * it is used to keep track of persistence with the backend
       * @param {number} id
       */
      _markToDelete: function(id) {
        if (this.__deletedIds__.indexOf(id) === -1) {
          this.__deletedIds__.push(id);
        }
      },

      /**
       * Denotes an ID has successfully been deleted synced
       * @param {number} id
       */
      _markAsDeleted: function(id) {
        var ind = this.__deletedIds__.indexOf(id);
        if (ind !== -1) {
          this.__deletedIds__.splice(ind, 1);
        }
      },
    };

    // take out special properties like `initialize` and `model`
    // what is left is an object with user defined functions/properties
    var toExtend = _.omit(spec, ['initialize', 'model']);

    // create the final configuration
    var storeDefinition = _.extend({}, BaseEntityStore, toExtend);

    return storeFactory.create(storeDefinition);
  };

  return {
    create: createEntityStore,
  };
});

/**
 * Base Actvitiy model
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('models/activity/base_activity',['require','services/model_factory','models/field_types'],function(require) {
  var modelFactory = require('services/model_factory');
  var fieldTypes = require('models/field_types');

  return modelFactory.create({
    entity: 'activity',

    fields: {
      id: null,
      account_id: null,
      category: null,
      created: null,
      email: null,
      event: null,
      experiment_id: null,
      project_id: null,
    },

    fieldTypes: {
      id: fieldTypes.NUMBER,
      account_id: fieldTypes.NUMBER,
      category: fieldTypes.STRING,
      created: fieldTypes.DATE,
      email: fieldTypes.STRING,
      event: fieldTypes.STRING,
      experiment_id: fieldTypes.NUMBER,
      project_id: fieldTypes.NUMBER,
    },

    instance: function Activity() {},
  });
});

define('flux/stores/entity/activity_store',['require','flux/factories/entity_store_factory','models/activity/base_activity'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/activity/base_activity'),
  });
});

define('flux/stores/entity/audience_store',['require','flux/factories/entity_store_factory','models/audience'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/audience'),
  });
});

define('flux/stores/entity/collaborators_store',['require','flux/factories/entity_store_factory','models/collaborator'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/collaborator'),
  });
});

define('flux/stores/entity/dimension_store',['require','flux/factories/entity_store_factory','models/dimension'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/dimension'),
  });
});

define('flux/stores/entity/experiment_store',['require','flux/factories/entity_store_factory','models/experiment'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/experiment'),
  });
});

define('flux/stores/entity/goal_store',['require','flux/factories/entity_store_factory','models/goal'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/goal'),
  });
});

define('flux/stores/entity/integration_store',['require','flux/factories/entity_store_factory','models/integration'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/integration'),
  });
});

define('flux/stores/entity/project_integration_store',['require','flux/factories/entity_store_factory','models/project_integration'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/project_integration'),
  });
});

define('flux/stores/entity/project_store',['require','flux/factories/entity_store_factory','models/project'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/project'),
  });
});

/**
 * Variation model
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('models/section',['require','services/model_factory'],function(require) {
  var modelFactory = require('services/model_factory');

  return modelFactory.create({
    entity: 'sections',

    parent: {
      entity: 'experiments',
      key: 'experiment_id'
    },

    instance: function Section() {},

    fields: {
      id: null,
      experiment_id: null,
      title: null,
      variation_ids: [],
      created: null,
    },
  });
});

define('flux/stores/entity/section_store',['require','flux/factories/entity_store_factory','models/section'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/section'),
  });
});

/**
 * TargetingList model
 * @author Daniel O'Connor (daniel@optimizely.com)
 */
define('models/targeting_list',['require','services/model_factory'],function(require) {
  var modelFactory = require('services/model_factory');

  return modelFactory.create({
    entity: 'targeting_lists',

    parent: {
      entity: 'projects',
      key: 'project_id'
    },

    instance: function TargetingList() {},

    fields: {
      'id': null,
      'account_id': null,
      'project_id': null,
      'name': null,
      's3_url': null,
      'file_size_in_bytes': null,
      'format': null,
      'key_fields': null
    }
  });
});

define('flux/stores/entity/targeting_list_store',['require','flux/factories/entity_store_factory','models/targeting_list'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/targeting_list'),
  });
});

/**
 * Variation model
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('models/variation',['require','services/model_factory'],function(require) {
  var modelFactory = require('services/model_factory');

  return modelFactory.create({
    entity: 'variations',

    parent: {
      entity: 'experiments',
      key: 'experiment_id'
    },

    instance: function Variation() {},

    fields: {
      id: null,
      project_id: null,
      experiment_id: null,
      description: null,
      is_paused: null,
      js_component: null,
      section_id: null,
      variation_id: null,
      weight: null,
    },
  });
});

define('flux/stores/entity/variation_store',['require','flux/factories/entity_store_factory','models/variation'],function(require) {
  var entityStoreFactory = require('flux/factories/entity_store_factory');

  return entityStoreFactory.create({
    model: require('models/variation'),
  });
});

/**
 * Aggregates results
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/experiment_results_store',['require','flux/factories/store_factory','flux/constants/action_types'],function(require) {
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');

  return storeFactory.create({
    initialize: function() {
      this.__results = {};

      this.bindActions(
        actionTypes.EXPERIMENT_RESULTS_FETCH_SUCCESS, this.__saveResults,
        actionTypes.EXPERIMENT_VISITOR_COUNT_FETCH_SUCCESS, this.__saveVisitors
      );
    },

    /**
     * Gets experiment results by experiment id
     *
     * @param {number} id
     * @return {object}
     */
    get: function(id) {
      if (this.__results[id]) {
        return _.cloneDeep(this.__results[id]);
      }
    },

    /**
     * payload.results = [{cache_time: <Date>, id: <number>, visitor_count: <number>}, ...]
     * payload.timestamp
     */
    __saveVisitors: function(payload) {
      var results = payload.results;
      // data looks like:
      // [{"cache_time":"2014-11-18T22:31:14Z","by_variation":{"1019930313":5005,"1019930312":5006},"id":999820904,"visitor_count":10011}, ...]
      results.forEach(function(res) {
        var expId = res.id;
        if (!this.__results[expId]) {
          this.__results[expId] = {
            id: expId,
            variations: [],
          };
        }

        this.__results[expId]['retrieval_timestamp'] = payload.timestamp;
        this.__results[expId]['visitors'] = res.visitor_count;
      }.bind(this));
      if (results.length > 0) {
        this.emitChange();
      }
    },

    /**
     * payload.experiment_id
     * payload.timestamp
     * payload.results
     */
    __saveResults: function(payload) {
      // payload.results is a list of Variation Results which has an entry for every goal and variation on the experiment
      // to find the number of visitors filter by any goal id and reduce the number of visitors for each VariationResult
      var goalId = _.first(payload.results).goal_id;
      var visitors = _(payload.results)
        .filter(function(res) {
          return res.goal_id === goalId;
        })
        .reduce(function(total, variation) {
          return total + variation.visitors;
        }, 0);

      this.__results[payload.experiment_id] = {
        id: payload.experiment_id,
        visitors: visitors,
        variations: payload.results,
        retrieval_timestamp: payload.timestamp,
      };

      this.emitChange();
    },

  });
});

/**
 * Holds the information of the user account
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/account_store',['require','lodash','flux/factories/store_factory','flux/constants/action_types'],function(require) {
  var _ = require('lodash');
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');

  var DEFAULT_ACCOUNT_INFO = {
    accountId: null,
    activeProjects: [],
    backendApiToken: null,
    email: null,
    experimentsTotal: 0,
    firstName: null,
    lastName: null,
    maxProjects: -1,
    projectCount: 0,
    isSignedIn: false,
    isAdmin: false,
    isBetaCustomer: false,
    userAccounts: null
  };

  return storeFactory.create({
    initialize: function() {
      this.__accountInfo = _.cloneDeep(DEFAULT_ACCOUNT_INFO);

      this.bindActions(
        actionTypes.ACCOUNT_INFO_LOADED, this.__loadAccountInfo
      );
    },

    /**
     * Gets the account id
     * @return {number}
     */
    getId: function() {
      return this.__accountInfo.accountId;
    },

    /**
     * Gets the account email
     * @return {number}
     */
    getEmail: function() {
      return this.__accountInfo.email;
    },

    /**
     * Returns boolean whether the user is signed in
     * @return {boolean}
     */
    isSignedIn: function() {
      return this.__accountInfo.isSignedIn;
    },

    /**
     * Returns boolean whether the user is an admin
     * @return {boolean}
     */
    isAdmin: function() {
      return this.__accountInfo.isAdmin;
    },

    /**
     * Returns an array of user accounts (for multiple accounts feature)
     */
    getUserAccounts: function() {
      return _.clone(this.__accountInfo.userAccounts);
    },

    /**
     * Returns a complete copy of all account info.
     *
     * Be careful when using this method as it unnecessarily clones the whole thing
     * for dereferencing
     * @return {object}
     */
    getAccountInfo: function() {
      return _.cloneDeep(this.__accountInfo);
    },

    /**
     * Get the maximum number of projects allowed for this plan level
     * @return {number}
     */
    getMaxProjects: function() {
      return this.__accountInfo.maxProjects;
    },

    /**
     * Get the current number of projects used in this account
     * @return {number}
     */
    getProjectCount: function() {
      return this.__accountInfo.projectCount;
    },

    /**
     * Gets the backend API token for a account
     */
    getBackendApiToken: function() {
      return this.__accountInfo.backendApiToken;
    },

    /**
     * Caches the request
     * @param {object} payload
     */
    __loadAccountInfo: function(payload) {
      var account = _.cloneDeep(payload.accountInfo);
      var info = {}

      info.accountId = account.account_id;
      info.activeProjects = account.projects;
      info.backendApiToken = account.backend_api_token;
      info.email = account.email;
      info.experimentsTotal = account.experiments_total;
      info.firstName = account.first_name;
      info.lastName = account.last_name;
      info.maxProjects = account.max_projects;
      info.projectCount = account.project_count;
      info.isAdmin = account.is_admin;
      info.isBetaCustomer = account.beta_customer;
      info.isMasterAccount = account.is_master_account;
      info.planId = account.plan_id;
      info.userAccounts = account.user_accounts;
      info.isSignedIn = !!account.account_id;
      info.permissions = account.permissions;

      if (!_.isEqual(info, this.__accountInfo)) {
        // only emit change if the account info actual changed
        this.__accountInfo = info;
        this.emitChange();
      }
    },
  });
});

/**
 * Holds the state of the current project
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/current_project_store',['require','flux/factories/store_factory','flux/constants/action_types'],function(require) {
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');

  return storeFactory.create({
    initialize: function() {
      this.currentProjectId = null;

      this.bindActions(
        actionTypes.CHANGE_CURRENT_PROJECT_ID, this.__changeCurrentProject
      );
    },

    getId: function() {
      return this.currentProjectId;
    },

    __changeCurrentProject: function(payload) {
      if (this.currentProjectId !== payload.id) {
        this.currentProjectId = payload.id;
        this.emitChange();
      }
    },
  });
});

/**
 * Holds the state of what API requests have been
 * cached
 *
 * This provides a record of API requests made allowing apiActions
 * to not make redundant fetches
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/api_request_cache_store',['require','flux/factories/store_factory','flux/constants/action_types','utils/hasher'],function(require) {
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');
  var hash = require('utils/hasher').hash;

  return storeFactory.create({
    name: 'apiRequestCache',

    initialize: function() {
      this.requestCache = {};

      this.bindActions(
        actionTypes.API_ENTITY_FETCH_SUCCESS, this.__cacheRequest,
        actionTypes.FLUSH_API_ENTITY_STORE, this._resetEntities
      );
    },

    /**
     * Check if a request has been cached
     * @param {object} requestInfo with `method` and `requestArgs`
     * @return {boolean}
     */
    isRequestCached: function(requestInfo) {
      var entity = requestInfo.entity;
      var method = requestInfo.method;
      var requestHash  = hash(requestInfo);

      if (!this.requestCache[entity] || !this.requestCache[entity][method]) {
        return false;
      }

      return !!this.requestCache[entity][method][requestHash];
    },

    /**
     * Wipe out all cached requests for this entity
     * @param {object} payload
     */
    __resetEntities: function(payload) {
      delete this.requestCache[payload.entity];
      this.emitChange();
    },

    /**
     * Caches the request
     * @param {object} payload
     */
    __cacheRequest: function(payload) {
      if (!payload.requestInfo) {
        // requestInfo must be present to have enough info to cache request
        return;
      }
      var entity = payload.requestInfo.entity;
      var method = payload.requestInfo.method;
      var requestHash = hash(payload.requestInfo);

      if (!this.requestCache[entity]) {
        this.requestCache[entity] = {};
      }

      if (!this.requestCache[entity][method]) {
        this.requestCache[entity][method] = {};
      }

      this.requestCache[entity][method][requestHash] = true;
      this.emitChange();
    },
  });
});

/**
 * Holds the state of what API requests have been
 * cached
 *
 * This provides a record of API requests made allowing apiActions
 * to not make redundant fetches
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/api_request_deferreds_store',['require','flux/factories/store_factory','flux/constants/action_types','utils/hasher'],function(require) {
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');
  var hash = require('utils/hasher').hash;

  return storeFactory.create({
    initialize: function() {
      this.__requestDeferreds = {};

      this.bindActions(
        actionTypes.API_ENTITY_FETCH_START, this.__requestStarted,
        actionTypes.API_ENTITY_FETCH_SUCCESS, this.__requestFinished,
        actionTypes.API_ENTITY_FETCH_FAIL, this.__requestFinished
      );
    },

    /**
     * Check if a request has been cached
     * @param {string} entity
     * @param {object} filters
     * @return {boolean}
     */
    getRequestInProgress: function(requestInfo) {
      var requestHash = hash(requestInfo);

      if (!this.__requestDeferreds[requestHash]) {
        return null;
      }

      return this.__requestDeferreds[requestHash];
    },

    /**
     * Store reference to the deferred when a request starts
     *
     * payload.requestInfo
     * payload.deferred
     */
    __requestStarted: function(payload) {
      if (!payload.requestInfo) {
        return;
      }

      var requestInfo = payload.requestInfo;
      this.__requestDeferreds[hash(requestInfo)] = payload.deferred;
      this.emitChange();
    },

    /**
     * Store reference to the deferred when a request starts
     *
     * payload.requestInfo
     * payload.deferred
     */
    __requestFinished: function(payload) {
      if (!payload.requestInfo) {
        return;
      }

      var requestInfo = payload.requestInfo;
      if (this.__requestDeferreds[hash(requestInfo)]) {
        delete this.__requestDeferreds[hash(requestInfo)];
        this.emitChange();
      }
    },
  });
});

/**
 * Holds state about what tasks are currently loading
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/loading_store',['require','lodash','flux/factories/store_factory','flux/constants/action_types'],function(require) {
  var _ = require('lodash');
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');

  function getEntityLoadingId(entity, id) {
    return entity + '.' + id
  }

  return storeFactory.create({
    initialize: function() {
      this.__loading = {};
      this.__entitiesLoading = {};

      this.bindActions(
        actionTypes.LOADING_START, this.__startLoading,
        actionTypes.LOADING_FINISH, this.__stopLoading,

        actionTypes.ENTITY_LOADING_START, this.__startEntityLoading,
        actionTypes.ENTITY_LOADING_FINISH, this.__stopEntityLoading,

        actionTypes.API_ENTITY_PERSIST_START, this.__startEntityLoading,
        actionTypes.API_ENTITY_PERSIST_SUCCESS, this.__stopEntityLoading,
        actionTypes.API_ENTITY_PERSIST_FAIL, this.__stopEntityLoading,

        actionTypes.CLEAR_ALL_ENTITY_LOADING, this.__entityLoadingStopped
      );
    },

    /**
     * Checks whether some key is currently loading
     */
    isLoading: function(key) {
      return !!this.__loading[key];
    },

    /**
     * Checks if a certain type of entity is loading
     * Can check generically for a entity type
     * or entity type and id combination
     *
     * @param {string} entity
     * @param {number} id
     * @return {boolean}
     */
    isEntityLoading: function(entity, id) {
      if (!this.__entitiesLoading[entity]) {
        return false;
      }

      if (!id) {
        return _.some(this.__entitiesLoading[entity]);
      }

      return !!this.__entitiesLoading[entity][id]
    },

    /**
     * Clears all loading keys for an entity
     */
    __entityLoadingStopped: function(payload) {
      if (!this.__entitiesLoading[payload.entity] ||
          this.__entitiesLoading[payload.entity].length === 0) {
        return
      }

      this.__entitiesLoading[payload.entity] = {};
      this.emitChange();
    },

    /**
     * @param {object} payload
     */
    __startEntityLoading: function(payload) {
      if (payload.data && payload.data.id) {
        var entity = payload.entity;
        var id = payload.data.id;
        // only handle case of single entity being saved
        // since we must have ID
        if (!this.__entitiesLoading[entity]) {
          this.__entitiesLoading[entity] = {};
        }

        if (!this.__entitiesLoading[entity][id]) {
          this.__entitiesLoading[entity][id] = true;
          this.emitChange();
        }
      }
    },

    /**
     * @param {object} payload
     */
    __stopEntityLoading: function(payload) {
      if (payload.data && payload.data.id) {
        var entity = payload.entity;
        var id = payload.data.id;
        // only handle case of single entity being saved
        // since we must have ID
        if (!this.__entitiesLoading[entity] || !this.__entitiesLoading[entity][id]) {
          return;
        }
        delete this.__entitiesLoading[entity][id];
        this.emitChange();
      }
    },

    /**
     * Makes some section id as loading
     * @param {object} payload
     */
    __startLoading: function(payload) {
      if (!this.__loading[payload.id]) {
        this.__loading[payload.id] = true;
        this.emitChange();
      }
    },

    /**
     * Makes some section id as done loading
     * @param {object} payload
     */
    __stopLoading: function(payload) {
      if (this.__loading[payload.id]) {
        this.__loading[payload.id] = false;
        this.emitChange();
      }
    },
  });
});

/**
 * Holds the sort by state of all sortable tables
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/sortable_table_store',['require','lodash','env','flux/factories/store_factory','flux/constants/action_types','utils/sort'],function(require) {
  var _ = require('lodash');
  var env = require('env');
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');
  var sort = require('utils/sort');

  var ASC = sort.ASC;
  var DESC = sort.DESC;

  var DEFAULT_SORT_DIR = ASC;
  var DEFAULT_SORT_MAX = 2;

  /**
   * sort.functions provide basic sort functions for string, number, date, boolean, length
   * extend them with application specific sort functions
   */
  var SORT_FNS = _.extend({}, sort.functions, {
    // it so happens that experiment status can be sorted in alphabetical order
    experimentStatus: sort.reverse(sort.functions.string),
  });

  /**
   * Sort direction to use if one isn't specified the first time a field
   * is toggled
   */
  var defaultSortDirs = {
    string: ASC,
    number: DESC,
    length: DESC,
    date: DESC,
    boolean: DESC,
  };

  return storeFactory.create({
    initialize: function() {
      /**
       * map of tableIds => {
       *   sortMax: <number>,
       *   sortBy: <array<{
       *     field: <string>,
       *     type: <string>, // sort type enum
       *     dir: <sort.ASC|sort.DESC>, // sort dir enum
       *   }>>
       * }
       */
      this.__state = {};

      this.bindActions(
        actionTypes.SORT_TABLE, this.__sortTable,
        actionTypes.TOGGLE_SORT_TABLE_FIELD, this.__toggleField,
        actionTypes.RESET_TABLE_SORTING, this.__reset
      );
    },

    /**
     * Returns a single generated function that represents all the sort
     * rules for a specific table.  Returns undefined if there is no sorting needed.
     *
     * @param {string|number} tableId
     * @return {function|undefined}
     */
    getSortFn: function(tableId) {
      var sortData = this.__state[tableId];
      if (!sortData) {
        return;
      }

      var sortFns = sortData.sortBy.map(function(entry) {
        var baseSortFn = SORT_FNS[entry.type];
        // generate a sort function that sorts by the proper type
        // and looks at the proper field
        var sortFn = sort.field(SORT_FNS[entry.type], entry.field);
        if (entry.dir === ASC) {
          sortFn = sort.reverse(sortFn);
        }
        return sortFn;
      });

      return sort.combineComparators(sortFns);
    },

    /**
     * returns sort.ASC, sort.DESC or undefined
     * @param {string} tableId
     * @param {string} field
     * @return {string|undefined}
     */
    getFieldSortDir: function(tableId, field) {
      var table = this.__state[tableId];
      if (!table) {
        return;
      }

      var entry = _.find(table.sortBy, { field: field });
      if (entry) {
        return entry.dir;
      }
    },

    /**
     * Checks if a table is currently being sorted on
     * @param {string} tableId
     * @return {boolean}
     */
    isSorted: function(tableId) {
      var table = this.__state[tableId];
      return !!(table && table.sortBy && table.sortBy.length > 0);
    },

    /**
     * payload.tableId - identifier of the table
     * payload.field - field name of what to sort by
     * payload.type - corresponds to key in SORT_FNS
     */
    __toggleField: function(payload) {
      var tableId = payload.tableId;
      var field = payload.field;
      var type = payload.type;
      var dir = defaultSortDirs[type] || DEFAULT_SORT_DIR;

      var sortOptions = {
        tableId: tableId,
        field: field,
        type: type,
        dir: dir,
      };

      var table = this.__state[tableId];

      if (!table) {
        this.__sort(sortOptions);
        this.emitChange();
        return;
      }

      // find out if already sorting by this field
      var ind = _.findIndex(table.sortBy, { field: field });

      if (ind !== -1) {
        var currentDir = table.sortBy[ind].dir;
        sortOptions.dir = (ind === 0)
          // if at the top switch directions
          ? (currentDir === ASC) ? DESC : ASC
          // otherwise use the current dir and __sort will move to top
          : dir;
      }

      this.__sort(sortOptions);
      this.emitChange();
    },

    /**
     * payload.tableId - unique table identifier (ex: 'dashboard.experiments')
     * payload.sortMax - (optional default=2) the maximum number of fields to fallback on sorting
     * payload.sortBy - array of { field, type, dir }
     */
    __sortTable: function(payload) {
      payload.sortBy
        .map(function(entry) {
          var opts = _.extend({
            tableId: payload.tableId,
            sortMax: payload.sortMax,
          }, entry);
          if (!opts.dir) {
            opts.dir = defaultSortDirs[opts.type] || DEFAULT_SORT_DIR;
          }
          return opts;
        })
        .reverse()
        .forEach(this.__sort.bind(this))

      this.emitChange();
    },

    /**
     * payload.tableId - unique table identifier (ex: 'dashboard.experiments')
     * payload.field - name of field in object
     * payload.type - 'number', 'string', etc see 'utils/sort.js' functions
     * payload.dir - (optional default=sort.ASC) sort.ASC or sort.DESC
     * payload.sortMax - (optional default=2) the maximum number of fields to fallback on sorting
     * @param {object} payload
     * @return {boolean} did emitChange
     */
    __sort: function(payload) {
      var tableId = payload.tableId;
      var field = payload.field;
      var type = payload.type;
      var sortMax = payload.sortMax || DEFAULT_SORT_MAX;
      var dir = payload.dir || DEFAULT_SORT_DIR;

      var table = this.__state[tableId];
      if (!table) {
        table = {
          sortMax: sortMax,
          sortBy: [],
        };
        this.__state[tableId] = table;
      } else {
        // the weird case where the sort max changes after table initialize
        table.sortMax = sortMax;
      }

      if (!SORT_FNS[type]){
        console.warn("No sort function for type: " + type + ", using string sort");
        type = 'string';
      }

      // see if the field is already being sorted on
      var ind = _.findIndex(table.sortBy, { field: field });
      if (ind === 0) {
        if (dir === table.sortBy[0].dir) {
          // already sorting by field at top priority in specified directory, no change
          return false;
        }
        table.sortBy[0].dir = dir
      } else if (ind !== -1) {
        // move field to top of priority
        table.sortBy.unshift(table.sortBy.splice(ind, 1)[0]);
      } else {
        if (table.sortBy.length >= table.sortMax) {
          table.sortBy.pop();
        }
        // add field to beginning of sortBy array
        table.sortBy.unshift({
          field: field,
          type: type,
          dir: dir,
        });
      }

      return true;
    },

    /**
     * payload.tableId
     */
    __reset: function(payload) {
      delete this.__state[payload.tableId];
      this.emitChange();
    },
  });
});

/**
 * Holds the state of the selected tab in the dashboard
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/dashboard_store',['require','flux/factories/store_factory','flux/constants/action_types'],function(require) {
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');

  return storeFactory.create({
    initialize: function() {
      this.activeTab = null;
      this.activeSubtab = null;

      this.bindActions(
        actionTypes.DASHBOARD_SWITCH_MAIN_TAB, this.__switchMainTab,
        actionTypes.DASHBOARD_SWITCH_SUB_TAB, this.__switchSubTab
      );
    },

    /**
     * Gets the main active tab
     */
    getActiveMainTab: function() {
      return this.activeTab;
    },

    /**
     * Gets the active tab for a subtab section
     */
    getActiveSubTab: function() {
      return this.activeSubtab;
    },

    /**
     * Switches the main tab state
     * @param {object} payload
     */
    __switchMainTab: function(payload) {
      if (this.activeTab !== payload.tabId) {
        this.activeTab = payload.tabId;
        this.activeSubtab = null;
        this.emitChange();
      }
    },

    /**
     * Switches the Settings tab's subtab state
     * @param {object} payload
     */
    __switchSubTab: function(payload) {
      var tabId = payload.tabId;
      if (this.activeSubtab !== tabId) {
        this.activeSubtab = tabId;
        this.emitChange();
      }
    },
  });
});

/**
 * Helper utils for calculating the limit and offset for
 * a page of results
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('utils/api_page',['require','lodash'],function(require) {
  var _ = require('lodash');
  var getRelativePageFilters = function (filters, direction) {
    var newFilters = _.cloneDeep(filters);
    if (!newFilters.$limit) {
      throw new Error("getPageFilter functions must supply a filter that contains a $limit value");
    }

    var offset = newFilters.$offset || 0;
    newFilters.$offset = offset + (newFilters.$limit * direction);
    return newFilters;
  }

  function getNextPageFilters(filters) {
    return getRelativePageFilters(filters, 1);
  }

  function getPreviousPageFilters(filters) {
    return getRelativePageFilters(filters, -1);
  }

  function getSpecificPageFilters(filters, pageNum) {
    var newFilters = _.cloneDeep(filters);
    if (!newFilters.$limit) {
      throw new Error("getPageFilter functions must supply a filter that contains a $limit value");
    }

    newFilters.$offset = pageNum * newFilters.$limit;
    return newFilters;
  }

  return {
    getNextPageFilters: getNextPageFilters,
    getPreviousPageFilters: getPreviousPageFilters,
    getSpecificPageFilters: getSpecificPageFilters,
  };
});

/**
 * Holds the state of the filters of the activity view of the dashboard
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('flux/stores/dashboard/activity_filters_store',['require','flux/factories/store_factory','flux/constants/action_types','utils/api_page'],function(require) {
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');
  var apiPage = require('utils/api_page');
  var ACTIVITY_PAGE_LIMIT = 20;

  return storeFactory.create({
    __resultsLength: null,
    __filters: {
      $offset: 0,
      $order: "created:desc",
      $limit: ACTIVITY_PAGE_LIMIT,
      // TODO (asa): support activities other than those in the category
      // of experiment
      category: 'experiment',
    },

    initialize: function() {
      this.__defaultFilters = _.cloneDeep(this.__filters);

      this.bindActions(
        actionTypes.DASHBOARD_SET_NEXT_PAGE_ACTIVITY_FILTER, this.__setNextPageFilter,
        actionTypes.DASHBOARD_SET_ACTIVITY_PAGE_RESULTS_LENGTH, this.__setPageResultsLength,
        actionTypes.DASHBOARD_SELECT_ACTIVITY_FILTER, this.__selectActivityFilter,
        actionTypes.CHANGE_CURRENT_PROJECT_ID, this.__resetFilters
      );
    },

    /**
     * Return a copy of the filters object
     * @return {Object}
     */
    getFilters: function () {
      return _.cloneDeep(this.__filters);
    },

    /**
     * Return whether or not there are more activities to get.
     * @return {Boolean}
     */
    hasMoreActivities: function () {
      return this.__resultsLength === this.__filters.$limit;
    },

    /**
     * Return whether or not there are any activities for a given filter
     * @return {Boolean}
     */
    hasNoActivities: function () {
      return this.__resultsLength === 0 && this.__filters.$offset === 0;
    },

    /**
     * Add a filter specified by the key value pair
     * Changing the filter changes the api results, which means
     * we should reset the offset.
     * @param {String} key
     * @param {String|Number} value
     */
    __addFilter: function (key, value) {
      this.__filters[key] = String(value);
      this.__filters.$offset = 0;
      this.__resultsLength = null;
    },

    /**
     * Remove a filter from the filter object specified by key
     * Changing the filter changes the api results, which means
     * we should reset the offset.
     * @param {String} key
     */
    __removeFilter: function (key) {
      delete this.__filters[key];
      this.__filters.$offset = 0;
      this.__resultsLength = null;
    },

    /**
     * Set the filters to grab the next page of results
     * If no offset is provided, the next page is calculated
     * based on the current $offset and $limit
     * @param {object} payload
     */
    __setNextPageFilter: function(payload) {
      if (payload.offset) {
        this.__filters.$offset = payload.offset;
      } else {
        this.__filters = apiPage.getNextPageFilters(this.__filters);
      }
      this.emitChange();
    },

    /**
     * Set the size of the previous fetched page
     * @param {object} payload
     */
    __setPageResultsLength: function(payload) {
      this.__resultsLength = payload.length;
      this.emitChange();
    },

    /**
     * Set the state of the users selected filter
     * @param {object} payload
     */
    __selectActivityFilter: function(payload) {
      if (payload.filterValue) {
        this.__addFilter(payload.filterKey, payload.filterValue);
      } else {
        this.__removeFilter(payload.filterKey);
      }
      this.emitChange();
    },

    /**
     * Reset the filters when switching projects
     * @param {object} payload
     */
    __resetFilters: function(payload) {
      if (payload.id) {
        this.__filters = _.cloneDeep(this.__defaultFilters);
        this.__addFilter('project_id', payload.id);
      }
      this.emitChange();
    },
  })
});

/**
 * Holds the state of the selected table items for the dashboard
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/dashboard/labs_data_store',['require','lodash','flux/factories/store_factory','flux/constants/action_types','utils/enums'],function(require) {
  var _ = require('lodash');
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');
  var Features = require('utils/enums').Features;

  /**
   * Schema for labs data
   *
   * id: <integer>, // an id for reference when selected in the UI
   * name: <string>,
   * category: <string>,
   * sidebarComponent: <string>, // the component must be registered on the labs tab
   * permissionRequire: <Feature Enum>, // feature enum required to see the labs entry
   */
  var LABS_DATA = [
    {
      id: 1,
      name: 'List Targeting',
      category: 'Targeting',
      sidebarComponent: 'list-management-sidebar',
      permissionRequired: Features.LIST_TARGETING,
    },
    /**
     * Disable until executive summary can be ported over to new dashboard
    {
      id: 2,
      name: 'Executive Summary',
      category: 'Analytics',
      sidebarComponent: 'executive-summary-sidebar',
      permissionRequired: Features.EXECUTIVE_SUMMARY,
    },
    **/
  ];

  return storeFactory.create({
    initialize: function() {
      this.__state = {
        labsData: LABS_DATA,
      };
    },

    /**
     * Gets lab data entries that should be available given
     * a set of permissions
     * @param {array} permissions
     * @return {array}
     */
    getData: function(permissions) {
      return this.__state.labsData.filter(function(entry) {
        if (!entry.permissionRequired) {
          return true;
        }
        return _.contains(permissions, entry.permissionRequired);
      })
    },
  });
});

/**
 * Holds the state of the selected table items for the dashboard
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/dashboard/selected_items_store',['require','lodash','flux/factories/store_factory','flux/constants/action_types'],function(require) {
  var _ = require('lodash');
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');

  return storeFactory.create({
    initialize: function() {
      this.selectedItems = {
        experiments: [],
        audiences: [],
        activities: [],
        dimensions: [],
        integrations: [],
        collaborators: [],
        projects: [],
        labs: [],
      };

      this.bindActions(
        actionTypes.DASHBOARD_SELECT_TABLE_ITEM, this.__selectItem,
        actionTypes.DASHBOARD_DESELECT_TABLE_ITEM, this.__deselectItem
      );
    },

    isSelected: function(category, id) {
      return this.selectedItems[category].indexOf(id) !== -1;
    },

    getSelectedIds: function(category) {
      return _.clone(this.selectedItems[category]);
    },

    /**
     * Switches the main tab state
     * @param {object} payload
     */
    __selectItem: function(payload) {
      var category = payload.category;
      var id = payload.itemId;
      var multiple = payload.multiple;

      if (!this.selectedItems[category]) {
        this.selectedItems[category] = [];
      }

      if (!multiple && !_.isEqual([id], this.selectedItems[category])) {
        // this is a single select
        this.selectedItems[category] = [id];
        this.emitChange();
      }

      if (multiple && this.selectedItems[category].indexOf(id) === -1) {
        // selecting multiple
        this.selectedItems[category].push(id);
        this.emitChange();
      }
    },

    __deselectItem: function(payload) {
      var category = payload.category;
      var id = payload.itemId;

      var items = this.selectedItems[category];

      if (!items || items.length === 0) {
        return;
      }

      var ind = items.indexOf(id);
      if (ind !== -1) {
        items.splice(ind, 1);
        this.emitChange();
      }
    },
  });
});

/**
 * Holds the state of the selected table items for the dashboard
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/stores/dashboard/table_filters_store',['require','lodash','flux','flux/factories/store_factory','flux/constants/action_types','utils/enums'],function(require) {
  var _ = require('lodash');
  var flux = require('flux');
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');
  var statusType = require('utils/enums').ExperimentStatusType;

  var DEFAULT_EXPERIMENT_STATUS_FILTER = 'active';
  var EXPERIMENT_STATUS_FILTERS = {
    active: [
      statusType.RUNNING,
      statusType.PAUSED,
      statusType.NOT_STARTED,
    ],
    archived: [statusType.ARCHIVED],
    draft: [statusType.NOT_STARTED],
    paused: [statusType.PAUSED],
    running: [statusType.RUNNING],
  };

  var FILTER_DEFAULTS = {
    experiments: {
      statusString: DEFAULT_EXPERIMENT_STATUS_FILTER,
      status: EXPERIMENT_STATUS_FILTERS[DEFAULT_EXPERIMENT_STATUS_FILTER],
      string: null,
    },
    audiences: {
      string: null,
    },
    collaborators: {
      string: null,
    },
    dimensions: {
      string: null,
    }
  };

  return storeFactory.create({
    initialize: function() {
      this.tableFilters = _.cloneDeep(FILTER_DEFAULTS);

      this.bindActions(
        actionTypes.DASHBOARD_SET_TABLE_FILTERS, this.__setFilters,
        actionTypes.DASHBOARD_RESET_TABLE_FILTERS, this.__resetFilters
      );
    },

    /**
     * Get filter values for a specific category
     * @return {object}
     */
    getFilters: function(category) {
      if (!this.tableFilters[category]) {
        throw new Error("No table filters registered for " + category);
      }
      return _.cloneDeep(this.tableFilters[category]);
    },

    /**
     * Sets filters for a category, will leave existing filters in
     * if the payload.filters doesnt overwrite
     */
    __setFilters: function(payload) {
      var category = payload.category;

      var payloadFilters = this.__validateFilters(category, payload.filters);
      var currentFilters = this.tableFilters[category];
      var newFilters = _.extend(
        {},
        currentFilters,
        payloadFilters
      );

      if (!_.isEqual(currentFilters, newFilters)) {
        this.tableFilters[category] = newFilters;
        this.emitChange();
      }
    },

    /**
     * Validates the filters based on the filter category
     * Use default filters if the supplied filter is not valid.
     */
    __validateFilters: function(category, filters) {
      switch (category) {
        case 'experiments':
          filters.status = EXPERIMENT_STATUS_FILTERS[filters.statusString];
          if (!filters.status) {
            filters.statusString = DEFAULT_EXPERIMENT_STATUS_FILTER;
            filters.status = EXPERIMENT_STATUS_FILTERS[DEFAULT_EXPERIMENT_STATUS_FILTER];
          }
        default:
          break;
      }
      return filters;
    },

    /**
     * Reset filter values to defaults for a particular category
     */
    __resetFilters: function(payload) {
      var category = payload.category;

      this.tableFilters[category] = _.cloneDeep(FILTER_DEFAULTS[category]);
      this.emitChange();
    },
  });
});

/**
 * Holds experiment-level integration settings for current experiment
 * TODO(peng-wen): Change this into an entity store when ExperimentIntegration REST API is ready
 *
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('flux/stores/integration/current_experiment_integration_store',['require','flux/factories/store_factory','flux/constants/action_types'],function(require) {
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');

  return storeFactory.create({
    initialize: function() {
      this.settings = {};

      this.bindActions(
        actionTypes.UPDATE_EXPERIMENT_INTEGRATION_SETTINGS, this.__updateExperimentIntegrationSettings
      );
    },

    getSettings: function() {
      return this.settings;
    },

    __updateExperimentIntegrationSettings: function(payload) {
      if (payload.settings) {
        this.settings = payload.settings;
        this.emitChange();
      }
    }
  });
});

/**
 * Holds the platform of the current project
 */
define('flux/stores/mobile/mobile_platform_store',['require','flux/factories/store_factory','flux/constants/action_types','utils/enums'],function(require) {
  var storeFactory = require('flux/factories/store_factory');
  var actionTypes = require('flux/constants/action_types');
  var enums = require('utils/enums');

  return storeFactory.create({
    initialize: function() {
      this.__currentPlatform = null;

      this.bindActions(
        actionTypes.CHANGE_MOBILE_PLATFORM, this.__changeCurrentPlatform
      );
    },

    getPlatform: function() {
      return this.__currentPlatform;
    },

    getIsAndroid: function() {
      return this.__currentPlatform == enums.ProjectPlatforms.ANDROID;
    },

    getIsIOS: function() {
      return this.__currentPlatform == enums.ProjectPlatforms.IOS;
    },

    __changeCurrentPlatform: function(payload) {
      if (this.__currentPlatform !== payload.platform) {
        this.__currentPlatform = payload.platform;
        this.emitChange();
      }
    },
  });
});

/**
 * The base action group that all other action groups
 * extend
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/action_group',['require'],function(require) {
  /**
   * @constructor
   * @param {Flux} flux
   */
  function ActionGroup(flux) {
    this.flux = flux
  }

  ActionGroup.prototype.dispatch = function() {
    var args = Array.prototype.slice.call(arguments);
    this.flux.dispatch.apply(this.flux, arguments);
  }

  return ActionGroup;
})
;
/**
 * Flux action factory
 *
 * Used to create an object that binds flux actions to a specific
 * dispatcher.  This allows easier testing by being able to inject a
 * mocked dispatcher/app
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/factories/action_factory',['require','utils/inherits','flux/action_group'],function(require) {
  var inherits = require('utils/inherits');
  var BaseActionGroup = require('flux/action_group');

  /**
   * @param {object.<string: function>} actions
   * @return {Constructor}
   */
  function createActionGroup(actions) {
    function ActionGroup(flux) {
      // super call
      BaseActionGroup.call(this, flux);

      _.assign(this, actions);
    }

    inherits(ActionGroup, BaseActionGroup);

    return ActionGroup;
  }

  return {
    create: createActionGroup,
  };
});

/**
 * App actions
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/app_actions',['require','flux/constants/action_types','flux/factories/action_factory'],function(require) {
  var actionTypes = require('flux/constants/action_types');
  var actionFactory = require('flux/factories/action_factory');

  return actionFactory.create({
    /**
     * Dispatch to the proper stores to load the account data structure
     * @param {object} accountInfo
     */
    loadAccountInfo: function(accountInfo) {
      this.flux.dispatch(actionTypes.ACCOUNT_INFO_LOADED, {
        accountInfo: accountInfo,
      });
    }
  });
});

/**
 * Helper functions to create a canonical representation of
 * an API request
 *
 * Including the method: fetch, fetchAll, fetchPage
 * model.entity
 * model.parent (entity, parent)
 * requestParams: <object>
 *
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/utils/api_request_info',['require','exports','module'],function(require, exports, module) {

  /**
   * Creates a canonical requestInfo object that holds
   * information such as entity, method and args
   * @param {Model} model
   * @param {string} method
   * @param {object} args
   * @return {object}
   */
  exports.create = function(model, method, args) {
    return Object.freeze({
      entity: model.entity,
      method: method,
      requestArgs: args,
      modelHashCode: model.hashCode,
    });
  };
});

/**
 * API actions
 *
 * Helper functions to make request to the rest api
 *
 * TODO: This needs unit tests
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/api_actions',['require','lodash','flux/constants/action_types','flux/factories/action_factory','flux/utils/api_request_info'],function(require) {
  var _ = require('lodash');
  var actionTypes = require('flux/constants/action_types');
  var actionFactory = require('flux/factories/action_factory');
  var apiRequestInfo = require('flux/utils/api_request_info');


  /**
   * Dispatches action when an API fetch request starts
   * @private
   *
   * @param {object} requestInfo with `method` and `requestArgs`
   * @param {Deferred} deferred
   */
  function onFetchStart(requestInfo, deferred) {
    this.dispatch(actionTypes.API_ENTITY_FETCH_START, {
      entity: requestInfo.entity,
      requestInfo: requestInfo,
      deferred: deferred,
    });
  }

  /**
   * Dispatch an ENTITY_FETCH_SUCCESS event to the system
   * @private
   *
   * @param {object} requestInfo with `method` and `requestArgs`
   * @param {object|array} response
   */
  function onFetchSuccess(requestInfo, response) {
    this.dispatch(actionTypes.API_ENTITY_FETCH_SUCCESS, {
      entity: requestInfo.entity,
      data: response,
      requestInfo: requestInfo,
    });
  }

  /**
   * Dispatch an ENTITY_FETCH_FAIL event to the system
   * @private
   *
   * @param {object} requestInfo with `method` and `requestArgs`
   * @param {string} reason
   */
  function onFetchFail(requestInfo, reason) {
    this.dispatch(actionTypes.API_ENTITY_FETCH_FAIL, {
      entity: requestInfo.entity,
      reason: reason,
      requestInfo: requestInfo,
    });
  }

  /**
   * Dispatch an ENTITY_PERSIST_SUCCESS event to the system
   * @private
   *
   * @param {string} entity
   * @param {object|array} instance
   */
  function onPersistSuccess(entity, instance) {
    this.dispatch(actionTypes.API_ENTITY_PERSIST_SUCCESS, {
      entity: entity,
      data: instance,
    });
  }

  /**
   * Dispatch an ENTITY_PERSIST_FAIL event to the system
   * @private
   *
   * @param {string} entity
   * @param {object} data of the instance
   * @param {string} reason
   */
  function onPersistFail(entity, data, reason) {
    this.dispatch(actionTypes.API_ENTITY_PERSIST_FAIL, {
      entity: entity,
      reason: reason,
      data: data,
    });
  }

  /**
   * Dispatch an ENTITY_DELETED_SUCCESS event to the system
   * @private
   *
   * @param {string} entity
   * @param {number} id
   */
  function onDeleteSuccess(entity, id) {
    this.dispatch(actionTypes.API_ENTITY_DELETED_SUCCESS, {
      entity: entity,
      id: id,
    });
  }

  /**
   * Function that calls all model fetch* functions
   * with a cache wrapper
   * @param {Flux} flux
   * @param {Model} model
   * @param {string} method
   * @param {number|object} arg the single argument passed to fetch*
   *                            in the case of fetch() it can be just a number (id)
   * @param {boolean} force bypass of the cache layer and always fetch a result from API
   *
   * @return {Deferred}
   */
  function executeModelFetch(flux, model, method, arg, force) {
    var store = flux.store(model.entity);
    var apiRequestCache = flux.store('apiRequestCache');
    var apiRequestDeferreds = flux.store('apiRequestDeferreds');

    // mapping of model.fetch* methods to their corresponding store methods
    var fetchMethodMap = {
      'fetch': 'get',
      'fetchPage': 'getPage',
      'fetchAll': 'getAll',
    };

    var storeMethod = fetchMethodMap[method];
    if (!storeMethod) {
      throw new Error("Invalid fetch method " + method);
    }

    var requestParams = arg;
    // request params must be an object such that the api request cachej
    // can properly hash.  If it is a number assume it is an id and transform
    // to object
    if (_.isNumber(requestParams)) {
      requestParams = {
        id: requestParams
      };
    }
    var requestInfo = apiRequestInfo.create(model, method, requestParams);

    var onSuccess = onFetchSuccess.bind(flux, requestInfo);
    var onFail = onFetchFail.bind(flux, requestInfo);

    var requestInProgress = apiRequestDeferreds.getRequestInProgress(requestInfo);
    if (requestInProgress) {
      return requestInProgress;
    }

    // if the store doesnt exists, then there is no point in checking if the request
    // is cached. If force is true bypass cache
    if (force || !flux.store(model.entity)) {
      var deferred = model[method](arg);
      onFetchStart.call(flux, requestInfo, deferred);
      deferred.then(onSuccess, onFail);
      return deferred;
    }

    // if the request is cached dont make again
    if (apiRequestCache.isRequestCached(requestInfo)) {
      return $.Deferred().resolve(store[storeMethod](arg));
    }

    // if it isn't cached just do a model fetch*
    var deferred = model[method](arg)
    onFetchStart.call(flux, requestInfo, deferred);
    deferred.then(onSuccess, onFail);
    return deferred;
  }

  /**
   * Dispatch an ENTITY_DELETED_FAIL event to the system
   * @private
   *
   * @param {string} entity
   * @param {number} id
   * @param {string} reason
   */
  function onDeleteFail(entity, id, reason) {
    this.dispatch(actionTypes.API_ENTITY_DELETED_FAIL, {
      entity: entity,
      id: id,
      reason: reason,
    });
  }

  return actionFactory.create({
    /**
     * Makes an API request to delete entity and sends the proper result
     * event into the flux system
     * @param {Model} model
     * @param {object} instance
     */
    deleteEntity: function(model, instance) {
      var onSuccess = onDeleteSuccess.bind(this, model.entity, instance.id);
      var onFail = onDeleteFail.bind(this, model.entity, instance.id);
      return model.delete(instance).then(onSuccess, onFail);
    },

    /**
     * Persists an entity to the database
     * @param {Model} model
     * @param {object} data
     */
    persistEntity: function(model, data) {
      var onSuccess = onPersistSuccess.bind(this, model.entity);
      var onFail = onPersistFail.bind(this, model.entity, data);

      this.dispatch(actionTypes.API_ENTITY_PERSIST_START, {
        entity: model.entity,
        data: data
      });

      return model.save(data)
        .then(onSuccess, onFail)
        // clone the object so consumer doesn't get reference to the store's instance
        .pipe(_.cloneDeep);
    },

    /**
     * Does a Model.fetch() generically and wraps with request caching
     * and flux-specific deferred resolve/reject functionality
     * @param {Model} model
     * @param {number|object} fetchParams
     * @param {boolean} force a model fetch instead of using cache
     */
    fetch: function(model, fetchParams, force) {
      return executeModelFetch(this.flux, model, 'fetch', fetchParams, force);
    },

    /**
     * Does a Model.fetchPage() generically and wraps with request caching
     * and flux-specific deferred resolve/reject functionality
     * @param {Model} model
     * @param {object} filters
     * @param {boolean} force a model fetch instead of using cache
     */
    fetchPage: function(model, filters, force) {
      if (!filters.$limit) {
          throw new Error("fetchPage: must take a limit. Otherwise use fetchAll instead.");
      }
      return executeModelFetch(this.flux, model, 'fetchPage', filters, force);
    },

    /**
     * Generic fetchAll function, wraps Model.fetchAll with request caching
     * and flux-specific deferred resolve/reject functionality
     * @param {Model} model
     * @param {object|undefined} filters
     * @param {boolean} force a model fetch instead of using cache
     */
    fetchAll: function(model, filters, force) {
      return executeModelFetch(this.flux, model, 'fetchAll', filters, force);
    },

    flushStore: function(entity) {
      return this.dispatch(actionTypes.FLUSH_API_ENTITY_STORE, {
        entity: entity,
      });
    }
  });
});

/**
 * View Actions
 *
 * Helper functions to create actions that represent user interaction with the view
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/current_project_actions',['require','flux/constants/action_types','flux/factories/action_factory'],function(require) {
  var actionTypes = require('flux/constants/action_types');
  var actionFactory = require('flux/factories/action_factory');

  return actionFactory.create({
    /**
     * Change the current project context
     */
    setCurrentProjectId: function(projectId) {
      this.dispatch(actionTypes.CHANGE_CURRENT_PROJECT_ID, {
        id: projectId
      });
    },
  });
});

/**
 * Helper utility to build uri's programmatically
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('utils/uri',[],function() {
  /**
   * @constructor
   *
   * @param {string} base uri
   */
  function UriLocation(base) {
    this._base = base;
    this._params = {};
  }

  /**
   * Adds key/value or hash of params to the UriLocation object
   * @param {string|object} key - or hash of params
   * @param {val=} val - or undefined if a hash is provided as first argument
   */
  UriLocation.prototype.param = function(key, val) {
    if (typeof key === 'object') {
      $.each(key, function(k, v) {
        this._params[k] = v;
      }.bind(this));
    } else {
      this._params[key] = val;
    }
  };

  /**
   * Constructs and returns the uri string from the base and params
   * @return {string}
   */
  UriLocation.prototype.toString = function() {
    var uri = this._base;
    var added = false;
    var paramString = $.param(this._params);
    if (paramString) {
      uri += (uri.indexOf('?') !== -1) ? '&' : '?';
      uri += paramString;
    }
    return uri;
  };

  return {
    /**
     * Returns a UriLocation object for uri creation
     */
    create: function(base) {
      return new UriLocation(base);
    }
  };
});

/**
 * Module containing methods representing routes in the application
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/router',['lodash','utils/uri'],function() {
  var _ = require('lodash');
  var uri = require('utils/uri');

  var router = {};

  /**
   * Returns a url for the editor. If an experimentId is provided, we just direct to /edit
   * for that experimentId. Else, we append the necessary information for /edit to create the experiment.
   *
   * @param {object} editorParams
   * @return {string}
   */
  router.experimentEdit = function(editorParams) {
    var experimentId = editorParams.experimentId;

    if (experimentId) {
      var loc = uri.create('/edit');
      loc.param('experiment_id', experimentId);
      if (editorParams.platform) {
        loc.param('platform', editorParams.platform);
      }
      return loc.toString();
    } else {
      // This is the exact logic from optly.common.url.generateEditorUrl
      var name = editorParams.name ? $.trim(editorParams.name) : "";
      var url = editorParams.url ? $.trim(editorParams.url) : "";
      var projectId = editorParams.projectId ? $.trim(editorParams.projectId) : "";

      if (!url) {
        return "";
      }

      var parameters = {
        url: url
      };

      if (name) {
        parameters.name = name;
      }

      if (projectId) {
        parameters.project_id = projectId;
      }
      return $.param.querystring("/edit", parameters);
    }
  };

  /**
   * @param {number} experimentId
   * @return {string}
   */
  router.experimentResults = function(experimentId) {
    var loc = uri.create('/results');
    loc.param('experiment_id', experimentId);
    return loc.toString();
  };

  /**
   * @param {number=} projectId
   * @param {string=} view
   * @return {string}
   */
  router.dashboard = function(projectId, view) {
    var loc = uri.create('/dashboard');
    if (projectId) {
      loc.param('project_id', projectId);
    }
    if (view) {
      loc.param('view', view);
    }
    return loc.toString();
  };

  /**
   * @param {string=} continueTo URL to continue to after signin
   * @return {string}
   */
  router.signIn = function(continueTo) {
    var loc = uri.create('/signin');
    if (continueTo) {
      loc.param('continue_to', continueTo);
    }
    return loc.toString();
  };

  /**
   * Creates a dashboard link based the current project id, the subtab (ex: 'experiments')
   * the selected item id (can be null) and an object of query params (for filtering)
   *
   * @param {number} projectId
   * @param {string?} subTab defaults to 'experiments' if not provided
   * @param {number?} itemId the selected item id
   * @param {object?} params query params
   * @return {string}
   */
  router.dashboardTab = function(projectId, subTab, itemId, params) {
    subTab = subTab || 'experiments';
    var parts = ['/projects', projectId, subTab];
    var queryParams = [];
    if (itemId) {
      parts.push(itemId);
    }
    var url = parts.join('/');

    _.each(params, function(val, key) {
      queryParams.push(key + '=' + encodeURIComponent(val));
    });

    if (queryParams.length > 0) {
      url += '?' + queryParams.join('&');
    }

    return url;
  };

  return router;
});

/**
 * Computes what the dashboard url should be given the
 * selected tabs and items
 */
define('flux/getters/dashboard/dashboard_url',['services/router'],function() {
  var router = require('services/router');

  var DEFAULT_STATUS_STRING = 'active';
  // mapping of the second part of the url /projects/123/{secondPart}
  // to the category in the selected items store
  // if a key isn't listed than that tab doesnt support selecting items
  // eg: settings
  var subPartToEntity = {
    experiments: 'experiments',
    audiences: 'audiences',
    'change-history': 'activities',
    collaborators: 'collaborators',
    dimensions: 'dimensions',
    integrations: 'integrations',
  };

  return [
    'dashboard',
    'currentProject',
    'dashboard/selectedItems',
    'dashboard/tableFilters',
    'dashboard/activityFilters',
    function(dashboardStore, currentProjectStore, selectedItemStore, tableFilterStore, activityFiltersStore) {
      var url = '/';
      var queryParams = {};
      var selectedItemId;
      var projectId = currentProjectStore.getId();
      var mainTab = dashboardStore.getActiveMainTab();
      // depending on whether the maintab is projects use the mainTab or subTab as the second part
      // in the url.  This is because everything is actually a child of projects, main and sub tabs
      var subPart = (mainTab === 'projects')
        ? dashboardStore.getActiveSubTab()
        : mainTab;

      // add the selected table item id to the uri
      // ex: /projects/123/experiments/456 <- that
      var selectedItemsKey = subPartToEntity[subPart];
      if (selectedItemsKey) {
        var selectedIds = selectedItemStore.getSelectedIds(selectedItemsKey);
        if (selectedIds.length === 1) {
          // add the selected item to the URI
          selectedItemId = selectedIds[0];
        }
      }

      switch (subPart) {
        case 'experiments':
          var filters = tableFilterStore.getFilters('experiments');
          if (filters.string) {
            queryParams.search = filters.string;
          }
          if (filters.statusString && filters.statusString !== DEFAULT_STATUS_STRING) {
            queryParams.status = filters.statusString;
          }
          break;
        case 'audiences':
          var filters = tableFilterStore.getFilters('audiences');
          if (filters.string) {
            queryParams.search = filters.string;
          }
          if (filters.statusString && filters.statusString !== DEFAULT_STATUS_STRING) {
            queryParams.status = filters.statusString;
          }
          break;
        case 'dimensions':
          var filters = tableFilterStore.getFilters('dimensions');
          if (filters.string) {
            queryParams.search = filters.string;
          }
          break;
        case 'collaborators':
          var filters = tableFilterStore.getFilters('collaborators');
          if (filters.string) {
            queryParams.search = filters.string;
          }
          break;
        case 'change-history':
          var filters = activityFiltersStore.getFilters();
          if (filters.experiment_id) {
            queryParams.expId = filters.experiment_id;
          }
          break;
        default:
          break;
      }

      return router.dashboardTab(projectId, subPart, selectedItemId, queryParams);
    }
  ];
});

/**
 * Function getter to take dashboard/tableFilters + category
 * and return all the fields which can be used as filters
 * through the rest api
 *
 * @param {String} category of the filter ('experiments', 'audiences', etc.)
 */
define('flux/getters/dashboard/api_filters',['lodash','models/experiment','models/audience','models/collaborator','models/dimension'],function() {
  var lodash = require('lodash');
  var Experiment = require('models/experiment');
  var Audience = require('models/audience');
  var Collaborator = require('models/collaborator');
  var Dimension = require('models/dimension');

  var CATEGORY_TO_MODEL = {
    experiments: Experiment,
    audiences: Audience,
    collaborators: Collaborator,
    dimensions: Dimension,
  }

  return function (category) {
    return [
      'dashboard/tableFilters',
      'currentProject',
      function (tableFiltersStore, currentProjectStore) {
        var model = CATEGORY_TO_MODEL[category];
        var apiFilters = _.keys(model.fieldTypes);
        var allFilters = tableFiltersStore.getFilters(category);
        var byProject = {
          project_id: currentProjectStore.getId()
        };
        return _(allFilters)
                 .pick(apiFilters)
                 .assign(byProject)
                 .value();
      }
    ];
  }
});

/**
 * Helper methods to deal with window.history
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('utils/history',['require','exports','module'],function(require, exports, module) {
  /**
   * Helper function to use our conventions of push state
   * @param {string} path (uri)
   * @param {string} title page title
   */
  exports.replaceState = function(path, title) {
    window.history.replaceState({
      path: path,
    }, title, path);
  };

  /**
   * Helper function to use our conventions of push state
   * @param {string} path (uri)
   * @param {string} title page title
   */
  exports.pushState = function(path, title) {
    window.history.pushState({
      path: path,
    }, title, path);
  };
});

/**
 * Event tracking service
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('services/events',[],function() {

  var pageName = 'optimizely';

  /**
   * Tracks an event in Google Analytics and Mixpanel
   * @param {string} category
   * @param {string=} action
   * @param {string=} label
   * @param {number=} value
   */
   function track(category, action, label, value) {

    var eventString = '/' + category + (action ? '/' + action : '') + (label ? '/' + label : '');

    //console.log('Tracking event',eventString);

    // Google Analytics, old (pageview) and new (event) style
    try {
      window._gaq = window._gaq || [];
      window._gaq.push(['_trackEvent', category, action, label, value]);
      window._gaq.push(['_trackPageview', eventString]);
    } catch (e) {}

    // Mixpanel
    try {
      window.mpq = window.mpq || [];
      window.mpq.push(['track', eventString, {}]);
    } catch (e) {}

    // Optimizely
    try {
      window.optimizely = window.optimizely || [];
      window.optimizely.push(['trackEvent', eventString]);
    } catch (e) {}

    // Kissmetrics
    try {
      window._kmq.push(['record', eventString]);
    } catch (e) {}

    // Adroll
    try {
      window.adroll_segments = eventString;
      __adroll.render_pixel_code(adroll_adv_id, adroll_pix_id);
    } catch (e) {}

    // Marketo
    try {
      window['mktoMunchkinFunction']('visitWebPage', {
        url: '/event' + eventString
      });
    } catch (e) {}
  }

  /**
   * Setter for global page name
   *
   * @param string page Name of the page user is on
   */
  function setPageName (page) {
    pageName = page;
  }


  /**
   * Getter for global page name
   *
   * @return Name of the global page
   */
  function getPageName () {
    return pageName;
  }

  return {
    getPageName: getPageName,
    setPageName: setPageName,
    track: track
  };
});

/**
 * Dashboard actions
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/dashboard_actions',['require','lodash','flux/constants/action_types','flux/factories/action_factory','flux/getters/dashboard/dashboard_url','flux/getters/dashboard/api_filters','utils/history','services/events','models/experiment'],function(require) {
  var _ = require('lodash');
  var actionTypes = require('flux/constants/action_types');
  var actionFactory = require('flux/factories/action_factory');

  var getDashboardUrl = require('flux/getters/dashboard/dashboard_url');
  var apiFiltersGetter = require('flux/getters/dashboard/api_filters');
  var history = require('utils/history');
  var events = require('services/events');

  // models
  var Experiment = require('models/experiment');

  return actionFactory.create({
    /**
     * Helper method to evaluate the current dashboard url based on the store state
     * and do a history.pushState() with the new url
     */
    pushUrl: function(title) {
      var url = this.flux.evaluate(getDashboardUrl);
      history.pushState(url, title);
    },
    /**
     * Helper method to evaluate the current dashboard url based on the store state
     * and do a history.replaceState() with the new url
     */
    replaceUrl: function(title) {
      var url = this.flux.evaluate(getDashboardUrl);
      history.replaceState(url, title);
    },

    /**
     * Action to switch the main tab in the dashboard view
     * @param {string} tabId
     */
    switchMainTab: function(tabId) {
      this.dispatch(actionTypes.DASHBOARD_SWITCH_MAIN_TAB, {
        tabId: tabId
      });
      events.track('dashboard2', 'view-tab', tabId);
    },

    /**
     * Action to switch the subtab in the Settings tab
     * @param {string} tabId
     */
    switchSubtab: function(tabId) {
      this.dispatch(actionTypes.DASHBOARD_SWITCH_SUB_TAB, {
        tabId: tabId
      });
      events.track('dashboard2', 'view-subtab', tabId);
    },

    /**
     * Logic for toggling an experiment in a list, does select/deselect logic
     * based on whether the item is selected, how many items are selected and
     * if the shift key was used
     * @param {string} entity
     * @param {object} instance
     * @param {boolean} shiftKey
     */
    clickItem: function(entity, instance, shiftKey) {
      var selectedLength = this.flux.store('dashboard/selectedItems').getSelectedIds(entity).length;
      var isSelected = this.flux.store('dashboard/selectedItems').isSelected(entity, instance.id);

      if (isSelected) {
        if (shiftKey) {
          this.deselectItem(entity, instance);
        } else {
          this.selectItem(entity, instance);
        }
      } else {
        if (shiftKey) {
          this.selectItem(entity, instance, {
            multiple: true
          });
        } else {
          this.selectItem(entity, instance);
        }
      }
    },

    /**
     * When a user selects an item in the data table
     * @param {string} entity
     * @param {object} instance
     * @param {object} opts
     */
    selectItem: function(entity, instance, opts) {
      opts = opts || {};
      this.dispatch(actionTypes.DASHBOARD_SELECT_TABLE_ITEM, {
        category: entity,
        multiple: opts.multiple,
        itemId: instance.id
      });
      events.track('dashboard2', 'select-item', entity);
      if (opts.multiple) {
        events.track('dashboard2', 'multiselect-item', entity);
      }
    },

    /**
     * When a user deselects an item in the data table
     * @param {string} entity
     * @param {object} instance
     */
    deselectItem: function(entity, instance) {
      this.dispatch(actionTypes.DASHBOARD_DESELECT_TABLE_ITEM, {
        category: entity,
        itemId: instance.id
      });
    },

    /**
     * Fetch experiments with the latest filter set by the user
     */
    fetchExperiments: function(shouldFetchResults) {
      var apiFilters = this.flux.evaluate(apiFiltersGetter('experiments'));
      var def = this.flux.actions('experiments').fetchAll(apiFilters);

      this.flux.actions('loading').when('dashboard.experiments', def);
      if (shouldFetchResults) {
        def.then(function(exps) {
          this.flux.actions('experiments').fetchVisitorCounts(exps);
        }.bind(this));
      }

      return def;
    },

    /**
     * Sets the filter values for the experiment data table
     * @param {string} status to filter experiment
     */
    filterExperimentsByStatus: function(statusString) {
      this.dispatch(actionTypes.DASHBOARD_SET_TABLE_FILTERS, {
        category: 'experiments',
        filters: {
          statusString: statusString,
        }
      });
      events.track('dashboard2', 'filter-experiments-status', statusString);
    },

    /**
     * Sets the filter values for the experiment data table
     * @param {string} string to filter experiment name/description
     */
    filterExperimentsByString: function(string) {
      this.dispatch(actionTypes.DASHBOARD_SET_TABLE_FILTERS, {
        category: 'experiments',
        filters: {
          string: string,
        }
      });
      events.track('dashboard2', 'filter-experiments-string');
    },

    /**
     * Resets all table filters for the experiments tab
     */
    resetExperimentFilters: function() {
      this.dispatch(actionTypes.DASHBOARD_RESET_TABLE_FILTERS, {
        category: 'experiments'
      });
    },

    /**
     * Sets the filter values for the collaborators data table
     * @param {string} string to filter audience name/description
     */
    filterCollaboratorsByString: function(string) {
      this.dispatch(actionTypes.DASHBOARD_SET_TABLE_FILTERS, {
        category: 'collaborators',
        filters: {
          string: string
        }
      });
    },

    /**
     * Resets all table filters for the collaborators tab
     */
    resetCollaboratorFilters: function() {
      this.dispatch(actionTypes.DASHBOARD_RESET_TABLE_FILTERS, {
        category: 'collaborators'
      });
    },

    /**
     * Sets the filter values for the audience data table
     * @param {string} string to filter audience name/description
     */
    filterAudiencesByString: function(string) {
      this.dispatch(actionTypes.DASHBOARD_SET_TABLE_FILTERS, {
        category: 'audiences',
        filters: {
          string: string
        }
      });
      events.track('dashboard2', 'filter-audiences-string');
    },

    /**
     * Sets the filter values for the audiences data table
     * @param {string} status to filter audiences
     */
    filterAudiencesByStatus: function(statusString) {

      this.dispatch(actionTypes.DASHBOARD_SET_TABLE_FILTERS, {
        category: 'audiences',
        filters: {
          statusString: statusString,
          archived: statusString === 'archived'
        }
      });
      events.track('dashboard2', 'filter-audiences-status', statusString);
    },

    /**
     * Resets all table filters for the audiences tab
     */
    resetAudienceFilters: function() {
      this.dispatch(actionTypes.DASHBOARD_RESET_TABLE_FILTERS, {
        category: 'audiences'
      });
    },

    /**
     * Sets the filter values for the audience data table
     * @param {string} string to filter audience name/description
     */
    filterDimensionsByString: function(string) {
      this.dispatch(actionTypes.DASHBOARD_SET_TABLE_FILTERS, {
        category: 'dimensions',
        filters: {
          string: string
        }
      });
      events.track('dashboard2', 'filter-dimensions-string');
    },

    /**
     * Resets all table filters for the dimensions tab
     */
    resetDimensionFilters: function() {
      this.dispatch(actionTypes.DASHBOARD_RESET_TABLE_FILTERS, {
        category: 'dimensions'
      });
    },
  });
});

/**
 * Experiment Actvitiy model
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('models/activity/experiment_activity',['require','services/model_factory'],function(require) {
  var modelFactory = require('services/model_factory');

  return modelFactory.create({
    entity: 'activity',

    parent: {
      entity: 'experiments',
      key: 'experiment_id'
    },

    instance: function ExperimentActivity() {},
  });
});

/**
 * Dashboard actions
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('flux/actions/dashboard/activity_actions',['require','lodash','flux/constants/action_types','flux/factories/action_factory','models/activity/project_activity','models/activity/experiment_activity','services/events'],function(require) {
  var _ = require('lodash')
  var actionTypes = require('flux/constants/action_types');
  var actionFactory = require('flux/factories/action_factory');
  var ProjectActivity = require('models/activity/project_activity');
  var ExperimentActivity = require('models/activity/experiment_activity');
  var events = require('services/events');

  return actionFactory.create({
    /**
     * When a user requests to load more activity in the log
     * @param {Object} filters
     */
    getActivities: function(filters) {
      var loadingKey = 'dashboard.change-history';
      this.flux.actions('loading').start(loadingKey);
      this.flux.actions('api').fetchPage(ProjectActivity, filters).then(function (results) {
        this.flux.actions('loading').stop(loadingKey);
        this.dispatch(actionTypes.DASHBOARD_SET_ACTIVITY_PAGE_RESULTS_LENGTH, {
          length: results.length
        });
      }.bind(this));
    },

    /**
     * When a user selects a filter for the dashboard activity list
     * @param {String} key
     * @param {String|Number|null} value
     */
    selectActivityFilter: function(key, value) {
      this.dispatch(actionTypes.DASHBOARD_SELECT_ACTIVITY_FILTER, {
        filterKey: key,
        filterValue: value
      });
      events.track('dashboard2', 'filter-activities');
    },

    /**
     * Change the filters for the next page of results
     * @param {String} key
     * @param {String|Number|null} value
     */
    setNextPageFilters: function(offset) {
      this.dispatch(actionTypes.DASHBOARD_SET_NEXT_PAGE_ACTIVITY_FILTER, {
        offset: offset
      });
    },
  });
});

/**
 * Function getter to take currentProject + experiments + integrations + projectintegrations stores
 * and return all integrations for that project
 */
define('flux/getters/current_project/integrations',[],function() {
  return [
    'currentProject',
    'experiments',
    'integrations',
    'projectintegrations',
    function(currentProjectStore, experimentStore, integrationStore, projectIntegrationStore) {
      var currentProjectId = currentProjectStore.getId();

      if (!currentProjectId) {
        return [];
      }

      // only show enabled integrations with the `web` channel type
      // TODO(peng-wen): filter integrations by Account.project_platforms when mobile integrations are supported
      var integrations = integrationStore.getAll({
        enabled: true,
        channels: 'web'
      });

      // TODO(peng-wen): get() with filter still doesn't work for junction entity
      var projectIntegrations = projectIntegrationStore.getAll({
        project_id: currentProjectId
      });

      // create a map to facilitate lookup of projectintegrations by integration ID
      var integrationToProjectIntegrationMap = {};
      projectIntegrations.forEach(function(projectIntegration) {
        integrationToProjectIntegrationMap[projectIntegration.integration_id] = projectIntegration;
      });

      integrations = _.sortBy(integrations, function(integration) {
        // First sort on whether the integration is configurable at project-level (configurable < non-configurable),
        // then sort on the integration's master label (natural ordering)
        return (integration.settings_metadata.onOffableAtProjectLevel ? 0 : 1) + integration.master_label.toLowerCase();
      });

      return integrations.map(function(integration) {
        var projectIntegration = integrationToProjectIntegrationMap[integration.id];

        var usageCount = experimentStore.getAll({
          project_id: currentProjectId,
          enabled_integration_ids: integration.id
        }).length;

        return {
          categories: integration.categories,
          experimentLevelData: {
            fields: integration.settings_metadata.fields.filter(function(fieldConfig) {
              return fieldConfig.saveLocations && fieldConfig.saveLocations.indexOf('experiment') !== -1;
            }),
            generalHelp: integration.settings_metadata.generalHelp.experiment,
            onOffable: integration.settings_metadata.onOffableAtExperimentLevel,
            settingsHelp: integration.settings_metadata.settingsHelp.experiment
          },
          id: integration.id,
          logoUrl: integration.logo_url,
          masterLabel: integration.master_label,
          minPlanLevel: integration.min_plan,
          partnerDirectoryUrl: integration.partner_dir_url,
          projectLevelData: {
            description: integration.description,
            enabled: projectIntegration ? projectIntegration.enabled : false,
            fields: integration.settings_metadata.fields.filter(function(fieldConfig) {
              return fieldConfig.saveLocations && fieldConfig.saveLocations.indexOf('project') !== -1;
            }),
            generalHelp: integration.settings_metadata.generalHelp.project,
            onOffable: integration.settings_metadata.onOffableAtProjectLevel,
            settings: projectIntegration ? projectIntegration.settings : null,
            settingsHelp: integration.settings_metadata.settingsHelp.project,
            usageCount: usageCount
          }
        };
      });
    }
  ];
});

/**
 * Integration actions
 *
 * Helper functions to make request to the rest api
 *
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('flux/actions/integration_actions',['require','flux/factories/action_factory','flux/constants/action_types','flux','models/integration','models/project_integration','flux/getters/current_project/integrations'],function(require) {
  var actionFactory = require('flux/factories/action_factory');
  var actionTypes = require('flux/constants/action_types');
  var flux = require('flux');
  var Integration = require('models/integration');
  var ProjectIntegration = require('models/project_integration');
  var getCurrentProjectIntegrations = require('flux/getters/current_project/integrations');

  /**
   * Helper function to facilitate upserting a ProjectIntegration entity
   * @param {ProjectIntegration} projectIntegration An object containing ProjectIntegration entity field values
   * e.g.
   * {
   *   project_id: 123,
   *   integration_id: 'at_internet',
   *   enabled: true,
   *   settings: {
   *     at_internet_acct_no: '123',
   *     at_internet_log_server_url: 'https://www.atinternet.com/log',
   *     enable_for_new_experiments: 'on'
   *   }
   * }
   * @returns Deferred
   * @private
   */
  var _persistProjectIntegration = function(projectIntegration) {
    return flux.actions('api').persistEntity(ProjectIntegration, projectIntegration);
  };

  return actionFactory.create({
    /**
     * Fetch integration data required to render Integrations Dialog
     * @param projectId ID of the project to fetch data from
     */
    fetchIntegrationsDialogData: function(projectId) {
      flux.actions('currentProject').setCurrentProjectId(projectId);
      flux.actions('api').fetchAll(Integration);
      flux.actions('api').fetchAll(ProjectIntegration, {
        project_id: projectId
      });
    },

    /**
     * Fetch default-on integrations for new experiments
     * @param projectId ID of the project to fetch data from
     * @returns {Deferred}
     */
    fetchDefaultEnabledIntegrationsForNewExperiment: function(projectId) {
      if (!projectId) {
        return $.Deferred().resolve([]);
      }

      flux.actions('currentProject').setCurrentProjectId(projectId);
      var integrationDeferred = flux.actions('api').fetchAll(Integration);
      var projectIntegrationDeferred = flux.actions('api').fetchAll(ProjectIntegration, {
        project_id: projectId
      });

      return $.when(integrationDeferred, projectIntegrationDeferred).pipe(function() {
        var integrations = flux.evaluate(getCurrentProjectIntegrations);
        return integrations.filter(function(integration) {
          var settings = integration.projectLevelData.settings;
          return integration.projectLevelData.enabled &&
            settings && settings['enable_for_new_experiments'] === 'on';
        });
      });
    },

    /**
     * Update experiment-level integration settings for the current experiment
     * TODO(peng-wen): Remove this action after making ExperimentIntegration an entity store
     * @param settings an object containing experiment-level settings for the current experiment
     */
    updateSettingsForExperiment: function(settings) {
      this.dispatch(actionTypes.UPDATE_EXPERIMENT_INTEGRATION_SETTINGS, {
        settings: settings
      });
    },

    /**
     * Update integration settings for a project
     *
     * @param projectId ID of the project to update integration settings
     * @param integrationId ID of the integration whose settings will be updated
     * @param enabled whether this integration shall be enabled for the project or not
     * @param settings an object containing settings to be updated
     * @returns {Deferred}
     */
    updateSettingsForProject: function(projectId, integrationId, enabled, settings) {
      return _persistProjectIntegration({
        project_id: projectId,
        integration_id: integrationId,
        enabled: !!enabled,
        settings: settings || null
      });
    }
  });
});

/**
 * Loading actions
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/loading_actions',['require','lodash','flux/constants/action_types','flux/factories/action_factory'],function(require) {
  var _ = require('lodash');
  var actionTypes = require('flux/constants/action_types');
  var actionFactory = require('flux/factories/action_factory');

  /**
   * Returns a deferred that is resolved when either a single
   * deferred is resolved or array of deferreds
   *
   * @param {Deferred|array<Deferred>} def
   */
  function when(def) {
    return (_.isArray(def))
      ? $.when.apply($, def)
      : $.when(def);
  }

  return actionFactory.create({
    /**
     * Denotes loading starting for a specific loadingId
     * @param {string|number} id
     */
    start: function(id) {
      this.dispatch(actionTypes.LOADING_START, {
        id: id
      });
    },

    /**
     * Denotes loading finishing for a specific loadingId
     * @param {string|number} id
     */
    stop: function(id) {
      this.dispatch(actionTypes.LOADING_FINISH, {
        id: id
      });
    },

    /**
     * Watches a deferred and stops loading when the deferred is resolved
     *
     * @param {string} loadingId
     * @param {Deferred|array<Deferred>} def
     */
    when: function(loadingId, def) {
      this.start(loadingId);
      when(def).always(function() {
        this.stop(loadingId);
      }.bind(this))
    },

    /**
     * Helper function to declare an entity is being saved/updated
     *
     * If passed a Deferred as a third argument it will stop the loading
     * after the deferred is resolved.
     *
     * @param {string} entity
     * @param {object} instance
     * @param {Deferred|array<Deferred>} def
     */
    entityUpdated: function(entity, instance, def) {
      this.dispatch(actionTypes.ENTITY_LOADING_START, {
        entity: entity,
        data: instance
      });
      when(def).always(function() {
        this.dispatch(actionTypes.ENTITY_LOADING_FINISH, {
          entity: entity,
          data: instance
        });
      }.bind(this));
    },

    /**
     * Brute force mark all entities as done loading 
     *
     * @param {string} entity
     */
    setEntityLoaded: function(entity) {
      this.dispatch(actionTypes.CLEAR_ALL_ENTITY_LOADING, {
        entity: entity
      });
    },
  });
});

/**
 * Permissions actions
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/permission_actions',['require','utils/enums','flux/factories/action_factory','lodash'],function(require) {
  var Features = require('utils/enums').Features;
  var actionFactory = require('flux/factories/action_factory');
  var _ = require('lodash');

  var hasProjectPermission = function(project, feature) {
    return _.contains(project.project_permissions, feature);
  };

  return actionFactory.create({
    hasProjectPermission: hasProjectPermission,

    // Projects
    canEditProject: function(project) {
      return hasProjectPermission(project, Features.EDIT_PROJECT);
    },

    canCreateAndroidProject: function(project, account) {
      return hasProjectPermission(project, Features.CREATE_ANDROID_PROJECT);
    },

    canCreateProject: function(project, account) {
      return hasProjectPermission(project, Features.CREATE_PROJECT) && account.getProjectCount() < account.getMaxProjects();
    },

    // Collaborators
    canUseCollaborators: function(project) {
      return hasProjectPermission(project, Features.ADD_USER);
    },

    canViewCollaborators: function(project) {
      return hasProjectPermission(project, Features.VIEW_COLLABORATORS);
    },

    canAddCollaborator: function(project) {
      return hasProjectPermission(project, Features.INVITE);
    },

    canEditCollaborator: function(project) {
      return hasProjectPermission(project, Features.USER_PERMISSIONS);
    },

    canRemoveCollaboratorFromAccount: function(project) {
      return hasProjectPermission(project, Features.DELETE_USER);
    },

    // Experiments
    canCreateExperiment: function(project) {
      return hasProjectPermission(project, Features.CREATE_EXPERIMENT);
    },

    canDeleteExperiment: function(project) {
      return hasProjectPermission(project, Features.DELETE_EXPERIMENT);
    },

    canArchiveExperiment: function(project) {
      return hasProjectPermission(project, Features.ARCHIVE_EXPERIMENT);
    },

    canUnarchiveExperiment: function(project) {
      return hasProjectPermission(project, Features.ARCHIVE_EXPERIMENT);
    },

    canStartExperiment: function(project) {
      return hasProjectPermission(project, Features.START_EXPERIMENT);
    },

    canPauseExperiment: function(project) {
      return hasProjectPermission(project, Features.PAUSE_EXPERIMENT);
    },

    canEditExperiment: function(project, experiment) {
      if (experiment.status == 'Running') {
        return hasProjectPermission(project, Features.MODIFY_RUNNING_EXPERIMENT);
      } else {
        return hasProjectPermission(project, Features.MODIFY_PAUSED_EXPERIMENT);
      }
    },

    // Audiences
    canCreateAudience: function(project) {
      return hasProjectPermission(project, Features.CREATE_AUDIENCE);
    },

    canArchiveAudience: function(project) {
      return hasProjectPermission(project, Features.MODIFY_AUDIENCE);
    },

    canEditAudience: function(project, experiments) {
      var hasRunningExperiments = experiments.some(function(exp) {
        return exp.status == 'Running';
      });
      if (hasRunningExperiments) {
        return hasProjectPermission(project, Features.MODIFY_RUNNING_EXPERIMENT);
      } else {
        return hasProjectPermission(project, Features.MODIFY_PAUSED_EXPERIMENT);
      }
    },

    canUseSegmentation: function(project) {
      return hasProjectPermission(project, Features.CUSTOM_SEGMENTS);
    },

    // Dimensions
    canCreateDimension: function(project) {
      return this.canUseDimensions(project) && hasProjectPermission(project, Features.CREATE_DIMENSION);
    },

    canEditDimension: function(project) {
      return this.canUseDimensions(project) && hasProjectPermission(project, Features.MODIFY_DIMENSION);
    },

    canDeleteDimension: function(project) {
      return this.canUseDimensions(project) && hasProjectPermission(project, Features.DELETE_DIMENSION);
    },

    canUseDimensions: function(project) {
      return hasProjectPermission(project, Features.CUSTOM_SEGMENTS);
    },

    // History
    canUseChangeHistory: function(project) {
      return hasProjectPermission(project, Features.ACTIVITY_LOG);
    },

    // Integrations
    canEditIntegrationForProject: function(project) {
      return hasProjectPermission(project, Features.EDIT_INTEGRATION);
    },

    canUseIntegration: function(project, integrationId) {
      return hasProjectPermission(project, integrationId + '_integration');
    },

    // Auto traffic allocation feature
    canUseBandits: function(project) {
      return hasProjectPermission(project, Features.BANDITS);
    },

    // Multi Channel experiments & platform switcher
    canUseMultiChannel: function(project) {
      return hasProjectPermission(project, Features.MULTICHANNEL_EXPERIMENTS);
    },

    // Can view statistical significance setting.
    canViewStatisticalSignificance: function(project) {
      return hasProjectPermission(project, Features.SEQUENTIAL_STATISTICS);
    },

    // CEO Dashboard
    canSeeExecutiveSummary: function(project) {
      return hasProjectPermission(project, Features.EXECUTIVE_SUMMARY);
    },

    // List Targeting (dialog)
    canUseListTargeting: function(project) {
      return hasProjectPermission(project, Features.LIST_TARGETING);
    },
  });
});

/**
 * App actions
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/sortable_table_actions',['require','flux/constants/action_types','flux/factories/action_factory','utils/sort'],function(require) {
  var actionTypes = require('flux/constants/action_types');
  var actionFactory = require('flux/factories/action_factory');
  var sort = require('utils/sort');

  return actionFactory.create({
    /**
     * options.tableId - unique table identifier (ex: 'dashboard.experiments')
     * options.sortMax - (optional default=2) the maximum number of fields to fallback on sorting
     * options.sortBy - array of { field, type, dir }
     */
    sortTable: function(options) {
      if (!options.tableId || !options.sortBy) {
        throw new Error("Must supply tableId and sortBy when sorting");
      }

      this.dispatch(actionTypes.SORT_TABLE, options);
    },

    /**
     * Toggles sorting by a certain field
     *
     * options.tableId - unique table identifier (ex: 'dashboard.experiments')
     * options.field - name of field in object
     * options.dir - sort.ASC or sort.DESC
     * options.sortMax - the maximum number of fields to fallback on sorting
     */
    toggleField: function(options) {
      if (!options.tableId || !options.field) {
        throw new Error("Must supply tableId and field when sorting");
      }

      this.dispatch(actionTypes.TOGGLE_SORT_TABLE_FIELD, options);
    },

    /**
     * Destroys the sorting entry for a particular table
     * @param {string} tableId
     */
    resetTable: function(tableId) {
      this.dispatch(actionTypes.RESET_TABLE_SORTING, {
        tableId: tableId
      });
    },
  });
});

/**
 * The base action group that all other action groups
 * extend
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/entity_action_group',['require','flux/action_group','utils/inherits'],function(require) {
  var ActionGroup = require('flux/action_group');
  var inherits = require('utils/inherits');

  /**
   * @constructor
   * @param {Flux} flux
   */
  function EntityActionGroup(flux) {
    ActionGroup.call(this, flux);
  }

  inherits(EntityActionGroup, ActionGroup);

  /**
   * Fetch an entity by id or set of filters
   *
   * @param {number|object} filters
   * @param {boolean?} force fetch and bypass cache
   * @return {Deferred}
   */
  EntityActionGroup.prototype.fetch = function(filters, force) {
    return this.flux.actions('api').fetch(this.model, filters, force);
  };

  /**
   * Fetch paged results for an entity
   *
   * @param {object} filters
   * @param {boolean?} force fetch and bypass cache
   * @return {Deferred}
   */
  EntityActionGroup.prototype.fetchPage = function(filters, force) {
    return this.flux.actions('api').fetchPage(this.model, filters, force);
  };

  /**
   * Fetch all results for an entity matching some filters
   *
   * @param {object?} filters
   * @param {boolean?} force fetch and bypass cache
   * @return {Deferred}
   */
  EntityActionGroup.prototype.fetchAll = function(filters, force) {
    return this.flux.actions('api').fetchAll(this.model, filters, force);
  };

  /**
   * Fetch all results for an entity matching some filters
   *
   * @param {object} changes
   * @return {Deferred}
   */
  EntityActionGroup.prototype.save = function(changes) {
    return this.flux.actions('api').persistEntity(this.model, changes);
  };

  /**
   * Fetch all results for an entity matching some filters
   *
   * @param {object} instance
   * @return {Deferred}
   */
  EntityActionGroup.prototype.delete = function(instance) {
    return this.flux.actions('api').deleteEntity(this.model, instance);
  };

  /**
   * Flushes the cache of the corresponding entity store
   */
  EntityActionGroup.prototype.flushStore = function() {
    this.flux.actions('api').flushStore(this.model.entity);
  };

  return EntityActionGroup;
})
;
/**
 * Factory for creating flux datastores that are based off of
 * rest entities
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/factories/entity_action_factory',['require','lodash','flux/entity_action_group','utils/inherits'],function(require) {
  var _ = require('lodash');
  var BaseEntityActionGroup = require('flux/entity_action_group');
  var inherits = require('utils/inherits');


  /**
   * Creates an EntityActionGroup class
   * config.model is requiredo
   *
   * config will override methods on the EntityActionGroup base class
   *
   * @return {EntityActionGroup}
   */
  function createEntityActionGroup(config) {
    if (!config.model) {
      throw new Error("Must supply `model` when creating Entity ActionGroup");
    }
    /**
     * @constructor
     * @param {Flux} flux
     */
    function EntityActionGroup(flux) {
      BaseEntityActionGroup.call(this, flux);

      _.assign(this, config);
    }

    inherits(EntityActionGroup, BaseEntityActionGroup);

    return EntityActionGroup;
  }

  return {
    create: createEntityActionGroup,
  };
});

/**
 * Custom Dimensions service
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/dimension',['models/dimension','models/dimension'],function() {
  var Dimension = require('models/dimension');
  var Project = require('models/dimension');

  var TOTAL_REPORTING_SLOTS = 10;

  /**
   * Fetches all custom dimensions for a project
   *
   * @param {Integer} number
   * @return {Deferred}
   */
  function fetchDimensionsForProject(projectId) {
    return Dimension.fetchAll({
      project_id: projectId
    });
  }

  /**
   * Fetch dimensions, add to segmentation audiences, and subtract from total slots allowed
   *
   * @param {Integer} projectId
   * @param {Array.<Audience>} audiences
   *
   * @return {Deferred}
   */
  function fetchAvailableReportingSlotsCount(projectId, audiences) {
    var deferred = $.Deferred();
    var segmentationAudiences = audiences.filter(function(audience) {
      return audience.segmentation;
    });
    this.fetchDimensionsForProject(projectId).then(function(dimensions) {
      var availableSlots = calculateAvailableReportingSlots(
        segmentationAudiences.length,
        dimensions.length
      );
      deferred.resolve(availableSlots);
    });

    return deferred;
  }

  /**
   * Logic for the calculation of available reporting slots
   */
  function calculateAvailableReportingSlots(reportableAudiencesCount, dimensionsCount) {
    return TOTAL_REPORTING_SLOTS - reportableAudiencesCount - dimensionsCount;
  }

  return {
    TOTAL_REPORTING_SLOTS: TOTAL_REPORTING_SLOTS,
    fetchDimensionsForProject: fetchDimensionsForProject,
    fetchAvailableReportingSlotsCount: fetchAvailableReportingSlotsCount,
    calculateAvailableReportingSlots: calculateAvailableReportingSlots
  };
});

/**
 * Gets the current number of audiences that are used for segmentation
 */
define('flux/getters/current_project/reportable_audiences_count',[],function() {
  return [
    'currentProject',
    'audiences',
    function(currentProject, audiences) {
      var projId = currentProject.getId();
      if (!projId) {
        return 0;
      }
      return audiences.getAll({
        project_id: projId,
        segmentation: true
      }).length;
    }
  ]
})
;
/**
 * Function getter to take currentProject + dimensions store
 * and return all dimensions for that project
 */
define('flux/getters/current_project/dimensions',[],function() {
  return [
    'currentProject',
    'dimensions',
    function (currentProject, dimensions) {
      var currentProjectId = currentProject.getId()
      if (!currentProjectId) {
        return [];
      }

      return dimensions.getAll({
        project_id: currentProjectId
      });
    }
  ];
});

/**
 * Audience actions
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/audience_actions',['require','lodash','flux/factories/entity_action_factory','models/audience','services/dimension','services/dimension','services/events','flux/getters/current_project/reportable_audiences_count','flux/getters/current_project/dimensions'],function(require) {
  var _ = require('lodash');
  var entityActionFactory = require('flux/factories/entity_action_factory');
  var Audience = require('models/audience');
  var TOTAL_REPORTING_SLOTS = require('services/dimension').TOTAL_REPORTING_SLOTS;
  var calculateOpenSlots = require('services/dimension').calculateAvailableReportingSlots;
  var events = require('services/events');

  var getReportableAudiencesCount = require('flux/getters/current_project/reportable_audiences_count');
  var getCurrentProjectDimensions = require('flux/getters/current_project/dimensions');

  return entityActionFactory.create({
    model: Audience,

    /**
     * Archives an audience
     * @param {Audience} audience
     * @return {Deferred}
     */
    archive: function(audience) {
      events.track('dashboard2', 'archive-audience');
      return this.save({
        id: audience.id,
        archived: true
      });
    },

    /**
     * Unarchives an audience
     * @param {Audience} audience
     * @return {Deferred}
     */
    unarchive: function(audience) {
      events.track('dashboard2', 'unarchive-audience');
      return this.save({
        id: audience.id,
        archived: false
      });
    },

    /**
     * Fetches the available reporting slots by calculating dimensions + reportable audiences
     * @param {object} project
     * @return {Deferred}
     */
    fetchAvailableReportingSlots: function(project) {
      var flux = this.flux;
      var currentProjId = project.id;

      var dimensions = this.flux.actions('dimensions').fetchAll({
        project_id: currentProjId
      });

      var reportableAudiences = this.fetchAll({
        project_id: currentProjId,
        segmentation: true
      });

      return $.when(dimensions, reportableAudiences)
        .pipe(function(dims, auds) {
          var audienceCount = auds.length;
          var dimensionCount = dims.length;
          return calculateOpenSlots(audienceCount, dimensionCount);
        });
    },

  });
});

/**
 * This module exists so the global `window` can be mocked
 * in testing
 */
define('window',[],function() {
  return window;
});

/**
 * Auth service, all application level auth functionality should go in here
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/auth',['flux','window'],function() {
  var flux = require('flux');
  var $window = require('window');

  /**
   * Logs the user out and redirects to homepage
   * Don't return jqXHR object here since it always redirects
   */
  function logout() {
    $.ajax('/account/signout').done(function() {
      $window.location = '/';
    });
  }

  /**
   * Makes ajax request to switch accounts
   * @param {Integer} accountId
   * @return {Deferred}
   */
  function switchAccount(accountId) {
    return $.ajax({
      url: '/account/switch',
      type: 'GET',
      data: {
        'account_id': accountId
      }
    });
  }

  /**
   * Returns the userAccount that is associated the current account
   * @return {Object}
   */
  function getCurrentUserAccount() {
    return _.find(flux.store('account').getUserAccounts(), {
      current_account: true
    });
  }

  function getCurrentUserAccountName() {
    var account = getCurrentUserAccount();
    if (!account) {
      throw new Error("No account associated with current user")
    }

    if (account.account_name) {
      return account.account_name;
    }
    else {
      return tr("{0}'s Account", account.email);
    }
  }

  return {
    logout: logout,
    switchAccount: switchAccount,
    getCurrentUserAccount: getCurrentUserAccount,
    getCurrentUserAccountName: getCurrentUserAccountName
  };
});

/**
 * Account service
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/account',['services/auth','app'],function() {
  var auth = require('services/auth');
  var app = require('app');

  /**
   * Gets the users for an account
   * Note this is an old endpoint and should be replaced with the REST API
   *
   * @return {Deferred}
   */
  function getUsers() {
    return $.ajax({
      url: '/api/users.json',
      type: 'GET'
    }).pipe(function(users) {
      return users.users;
    });
  }

  /**
   * Makes ajax request to change account name
   * @param {String} accountName
   * @return {Deferred}
   */
  function changeAccountName(accountName) {
    return $.ajax({
      url: '/account/change_account_name',
      type: 'POST',
      data: {
        'account_name': accountName
      }
    }).then(function() {
      var userAccount = auth.getCurrentUserAccount();
      userAccount.account_name = accountName;
      app.$broadcast('userAccountNameChanged', accountName);
    });
  }

  return {
    getUsers: getUsers,
    changeAccountName: changeAccountName,
  };
});

/**
 * Collaborator actions
 *
 * Helper functions to make request to the rest api
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/collaborator_actions',['require','lodash','flux','flux/constants/action_types','flux/factories/entity_action_factory','models/collaborator','services/account'],function(require) {
  var _ = require('lodash');
  var flux = require('flux');
  var actionTypes = require('flux/constants/action_types');
  var entityActionFactory = require('flux/factories/entity_action_factory');
  var Collaborator = require('models/collaborator');
  var account = require('services/account');

  return entityActionFactory.create({
    model: Collaborator,

    /**
     * Creates a new collab. We flush the datastore since this collaborator may be
     * duplicated locally as a User/Project Creator.
     * @param {object} changes
     * @return {Deferred}
     */
    create: function(data, currentProject){
      return this.save(data).pipe(function(result) {
        this.__refreshCollaborators(currentProject.id);
        return result;
      }.bind(this));
    },
    /**
     * Does a patch of a collaborator with id and changes
     * @param {object} changes
     * @return {Deferred}
     */
    save: function(changes) {
      return this.flux.actions('api')
        .persistEntity(Collaborator, changes)
        .then(function(result) {
          if (result.id !== changes.id) {
            // saving collabs in the API will delete the entity
            // and return a new one, emulate that behavior in the frontend
            var payload = {
              entity: Collaborator.entity,
              id: changes.id
            };
            this.flux.dispatch(
              actionTypes.API_ENTITY_DELETED_SUCCESS,
              payload
            );
          }
        }.bind(this));
    },
    /**
     * Deletes a collaborator. We flush the datastore since this collaborator may be
     * recreated on the server as a User/Project Creator.
     * @param {object} instance
     * @param {object} currentProject
     * @return {Deferred}
     */
    delete: function(instance, currentProject) {
      var collab = this.flux.actions('api').deleteEntity(
        Collaborator,
        instance
      );
      return collab.pipe(function(result) {
        this.__refreshCollaborators(currentProject.id);
        return result;
      }.bind(this));
    },

    /**
     * Special action to remove collaborator from all projects
     * Flush the store after since other projects will also be affected
     * @param {Object} instance
     * @return {Deferred}
     */
    deleteFromAccount: function(instance, currentProject) {
      var id = instance.id;
      var accountId = this.flux.store('account').getId();
      return $.ajax({
        url: '/api/v1/accounts/' + accountId + '/users/' + instance.user_id,
        type: 'DELETE'
      }).done(function(result) {
        this.__refreshCollaborators(currentProject.id);
        return result;
      }.bind(this));
    },

    /**
     * Flushes the collaborators store and fetches a fresh set
     * @param {number} projectid
     * @return {Deferred}
     */
    __refreshCollaborators: function(projectId) {
      this.flushStore();
      // force fetchAll
      return this.fetchAll({
        project_id: projectId
      }, true);
    }

  });
});

/**
 * Dimension actions
 *
 * Helper functions to make request to the rest api
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('flux/actions/dimension_actions',['require','flux/factories/entity_action_factory','models/dimension'],function(require) {
  var entityActionFactory = require('flux/factories/entity_action_factory');

  return entityActionFactory.create({
    model: require('models/dimension'),
  });
});

/**
 * Date/Time utils
 */
define('utils/date',['require','exports','module'],function(require, exports, module) {
  /**
   * Pads a number to 2 digits (leading zero)
   */
  function pad(number) {
    var r = String(number);
    if ( r.length === 1 ) {
      r = '0' + r;
    }
    return r;
  }

  /**
   * Takes a date string and returns an ISO-8601 like string without
   * milliseconds
   * @param {string} dateString
   */
  exports.truncateMilliseconds = function(dateString) {
    var date = new Date(dateString);

    return date.getUTCFullYear()
      + '-' + pad(date.getUTCMonth() + 1 )
      + '-' + pad(date.getUTCDate() )
      + 'T' + pad(date.getUTCHours() )
      + ':' + pad(date.getUTCMinutes() )
      + ':' + pad(date.getUTCSeconds() )
      + 'Z';
  }
});

/**
 * Wrapper around bundle/backend/api.js
 *
 * @author Jordan Garcia
 */
define('services/backend_api',['require','exports','module','env','flux'],function(require, exports, module) {
  var env = require('env');
  var flux = require('flux');

  /**
   * @param {string?} instance the string identifier of the instance (new backend vs mongo).  This is
   *                           defined at the experiment level by experiment.backend_api_host
   * @return {optly.backend.Api}
   */
  module.exports = {
    create: function(instance){
      var accountId = flux.store('account').getId();
      var backendApiToken = flux.store('account').getBackendApiToken();
      var apiPrefix = env.BACKEND_API_HOST;

      return new optly.backend.Api(apiPrefix, accountId, backendApiToken, instance);
    }
  }
});

/**
 * Experiment actions
 *
 * Helper functions to make request to the rest api
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/experiment_actions',['require','lodash','utils/date','flux/factories/entity_action_factory','services/backend_api','flux/constants/action_types','utils/enums','models/experiment','models/audience','models/goal','models/variation','services/events'],function(require) {
  var _ = require('lodash');
  var dateUtils = require('utils/date');
  var entityActionFactory = require('flux/factories/entity_action_factory');
  var backendApi = require('services/backend_api');
  var actionTypes = require('flux/constants/action_types');
  var ExperimentStatusType = require('utils/enums').ExperimentStatusType;
  var Experiment = require('models/experiment');
  var Audience = require('models/audience');
  var Goal = require('models/goal');

  var Variation = require('models/variation');
  var events = require('services/events');

  return entityActionFactory.create({
    model: Experiment,

    /**
     * Starts an experiment
     * @param {Experiment} experiment
     * @return {Deferred}
     */
    start: function(experiment) {
      events.track('dashboard2', 'start-experiment');
      return this.save({
        id: experiment.id,
        status: 'Running',
      });
    },

    /**
     * Pauses an experiment
     * @param {Experiment} experiment
     * @return {Deferred}
     */
    pause: function(experiment) {
      events.track('dashboard2', 'pause-experiment');
      return this.save({
        id: experiment.id,
        status: 'Paused',
      });
    },

    /**
     * Deletes (soft) an experiment
     * @param {Experiment} experiment
     * @return {Deferred}
     */
    delete: function(experiment) {
      // TODO(jordan): delete method and use deleteSelectedExperiments in dashboard actions 
      events.track('dashboard2', 'delete-experiment');
      return this.flux.actions('api').deleteEntity(Experiment, experiment);
    },

    /**
     * Duplicates an experiment to a different project
     * @param {Experiment} experiment
     * @param {number} projectId to duplicate to
     * @return {Deferred}
     */
    duplicate: function(experiment, projectId) {
      events.track('dashboard2', 'duplicate-experiment');
      var data = {
        'experiment_id': experiment.id,
        'new_project_id': projectId
      };

      return $.ajax("/experiment/duplicate", {
        data: data,
        type: "POST"
      })
      .done(function(newExperiment) {
        this.flux.actions('api').fetch(Experiment, newExperiment.experiment_id);
        
        // refresh goals to get up-to-date experiment_ids
        this.flux.actions('api').fetchAll(Goal, {
          project_id: projectId,
        }, true);

        var hasNewAudiences = _.some(newExperiment.destination_audiences, 'is_new');
        if (hasNewAudiences) {
          this.flux.actions('api').fetchAll(Audience, {
            project_id: projectId,
          }, true);
        }
      }.bind(this));
    },

    /**
     * Archives an experiment
     * @param {Experiment} experiment
     * @return {Deferred}
     */
    archive: function(experiment) {
      events.track('dashboard2', 'archive-experiment');
      return this.save({
        id: experiment.id,
        status: 'Archived',
      });
    },

    /**
     * Unarchives an experiment
     * @param {Experiment} experiment
     * @return {Deferred}
     */
    unarchive: function(experiment) {
      return this.save({
        id: experiment.id,
        status: 'Paused'
      });
    },

    /**
     * Updates a variation's weight, it does not automatically
     * sync to the server
     * @param {number} variationId
     * @param {number} weight
     * @return {Deferred}
     */
    updateVariationWeight: function(variationId, weight) {
      return this.flux.actions('api').persistEntity(Variation, {
        id: variationId,
        weight: weight
      });
    },

    /**
     * Fetch the visitor counts directly from the backend API
     * @param {array<Experiment>} experiments
     * @return {Deferred}
     */
    fetchVisitorCounts: function(experiments) {
      var experimentStatusesToFetch = [
        ExperimentStatusType.ARCHIVED,
        ExperimentStatusType.PAUSED,
        ExperimentStatusType.RUNNING,
      ];
      var experimentsToFetch = experiments.filter(function(exp) {
        return _.contains(experimentStatusesToFetch, exp.status);
      }).map(function(exp) {
        // TODO this map step is necessary to fetch visitor counts from the new backend
        // once https://github.com/optimizely/backend/pull/516 is merged this can be removed
        return _.extend({}, exp, {
          // the backend api requires a certain format for start times
          earliest: dateUtils.truncateMilliseconds(exp.earliest)
        });
      });
      // makeVisitorRequests can make multiple requests to different backends (mongo vs NBE)
      // thus it returns an array of deferreds
      var deferreds = backendApi.create().makeVisitorRequests(experimentsToFetch);
      deferreds.forEach(function(def) {
        def.then(function(response) {
          // response.experiments looks like:
          // [{"cache_time":"2014-11-18T22:31:14Z","by_variation":{"1019930313":5005,"1019930312":5006},"id":999820904,"visitor_count":10011}, ...]
          this.dispatch(actionTypes.EXPERIMENT_VISITOR_COUNT_FETCH_SUCCESS, {
            results: response.experiments,
            // this is not the cached timestamp, but the timestamp of when the API request was made
            timestamp: Date.now()
          });
        }.bind(this));
      }.bind(this));

      return $.when.apply($, deferreds);
    },

    /**
     * Fetches the results for an experiment by making a request
     * to the Reper backend
     * @param {Experiemnt} experiment
     * @return {Deferred}
     */
    fetchResults: function(experiment) {
      Experiment.results(experiment).then(function(results) {
        this.dispatch(actionTypes.EXPERIMENT_RESULTS_FETCH_SUCCESS, {
          experiment_id: experiment.id,
          timestamp: Date.now(),
          results: results
        });
      }.bind(this));
    },
  });
});

/**
 * Goal actions
 *
 * Helper functions to make request to the rest api
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('flux/actions/goal_actions',['require','flux/factories/entity_action_factory','models/goal'],function(require) {
  var entityActionFactory = require('flux/factories/entity_action_factory');

  return entityActionFactory.create({
    model: require('models/goal')
  });
});

/**
 * Project actions
 *
 * Helper functions to make requests to the rest api
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/actions/project_actions',['require','utils/enums','models/project','flux/factories/entity_action_factory'],function(require) {
  var enums = require('utils/enums');
  var Project = require('models/project');
  var entityActionFactory = require('flux/factories/entity_action_factory');

  return entityActionFactory.create({
    model: Project,

    /**
    * Archives a project
    * @param {Project} project
    */
    archive: function(project) {
      return this.save({
        id: project.id,
        project_status: enums.ProjectStatusType.ARCHIVED
      });
    },

    /**
    * Unarchives a project
    * @param {Project} project
    */
    unarchive: function(project) {
      return this.save({
        id: project.id,
        project_status: enums.ProjectStatusType.ACTIVE
      });
    },
  });
});

/**
 * Mobile Actions
 *
 * Helper functions related to mobile config
 *
 */
define('flux/actions/mobile_actions',['require','flux/constants/action_types','flux/factories/action_factory'],function(require) {
  var actionTypes = require('flux/constants/action_types');
  var actionFactory = require('flux/factories/action_factory');

  return actionFactory.create({
    /**
     * Change the current mobile platform
     */
    setMobilePlatform: function(mobilePlatform) {
      this.dispatch(actionTypes.CHANGE_MOBILE_PLATFORM, {
        platform: mobilePlatform
      });
    },
  });
});

/**
 * Flux app configuration
 *
 * Enumeration of all actions/stores for the flux app
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('flux/config',['require','flux/stores/entity/activity_store','flux/stores/entity/audience_store','flux/stores/entity/collaborators_store','flux/stores/entity/dimension_store','flux/stores/entity/experiment_store','flux/stores/entity/goal_store','flux/stores/entity/integration_store','flux/stores/entity/project_integration_store','flux/stores/entity/project_store','flux/stores/entity/section_store','flux/stores/entity/targeting_list_store','flux/stores/entity/variation_store','flux/stores/experiment_results_store','flux/stores/account_store','flux/stores/current_project_store','flux/stores/api_request_cache_store','flux/stores/api_request_deferreds_store','flux/stores/loading_store','flux/stores/sortable_table_store','flux/stores/dashboard_store','flux/stores/dashboard/activity_filters_store','flux/stores/dashboard/labs_data_store','flux/stores/dashboard/selected_items_store','flux/stores/dashboard/table_filters_store','flux/stores/integration/current_experiment_integration_store','flux/stores/mobile/mobile_platform_store','flux/actions/app_actions','flux/actions/api_actions','flux/actions/current_project_actions','flux/actions/dashboard_actions','flux/actions/dashboard/activity_actions','flux/actions/integration_actions','flux/actions/loading_actions','flux/actions/permission_actions','flux/actions/sortable_table_actions','flux/actions/audience_actions','flux/actions/collaborator_actions','flux/actions/dimension_actions','flux/actions/experiment_actions','flux/actions/goal_actions','flux/actions/project_actions','flux/actions/mobile_actions'],function(require) {
  var stores = {
    // model stores
    // IMPORTANT: When registering an entity store you must register the id
    // as the entity name, this is defined in the model.entity
    'activity': require('flux/stores/entity/activity_store'),
    'audiences': require('flux/stores/entity/audience_store'),
    'collaborators': require('flux/stores/entity/collaborators_store'),
    'dimensions': require('flux/stores/entity/dimension_store'),
    'experiments': require('flux/stores/entity/experiment_store'),
    'goals': require('flux/stores/entity/goal_store'),
    'integrations': require('flux/stores/entity/integration_store'),
    'projectintegrations': require('flux/stores/entity/project_integration_store'),
    'projects': require('flux/stores/entity/project_store'),
    'sections': require('flux/stores/entity/section_store'),
    'targeting_lists': require('flux/stores/entity/targeting_list_store'),
    'variations': require('flux/stores/entity/variation_store'),

    'experimentResults': require('flux/stores/experiment_results_store'),

    // App state stores
    'account': require('flux/stores/account_store'),
    'currentProject': require('flux/stores/current_project_store'),

    // Misc Stores
    'apiRequestCache': require('flux/stores/api_request_cache_store'),
    'apiRequestDeferreds': require('flux/stores/api_request_deferreds_store'),

    // UI State stores
    'loading': require('flux/stores/loading_store'),
    'sortableTable': require('flux/stores/sortable_table_store'),

    // Dashboard stores
    'dashboard': require('flux/stores/dashboard_store'),
    'dashboard/activityFilters': require('flux/stores/dashboard/activity_filters_store'),
    'dashboard/labsData': require('flux/stores/dashboard/labs_data_store'),
    'dashboard/selectedItems': require('flux/stores/dashboard/selected_items_store'),
    'dashboard/tableFilters': require('flux/stores/dashboard/table_filters_store'),

    // Integration stores
    'integration/currentExperimentIntegrations': require('flux/stores/integration/current_experiment_integration_store'),

    // Mobile stores
    'mobile/mobilePlatform' : require('flux/stores/mobile/mobile_platform_store'),

  };

  var actions = {
    'app': require('flux/actions/app_actions'),
    'api': require('flux/actions/api_actions'),
    'currentProject': require('flux/actions/current_project_actions'),
    'dashboard': require('flux/actions/dashboard_actions'),
    'dashboard/activity': require('flux/actions/dashboard/activity_actions'),
    'integration': require('flux/actions/integration_actions'),
    'loading': require('flux/actions/loading_actions'),
    'permissions': require('flux/actions/permission_actions'),
    'sortableTable': require('flux/actions/sortable_table_actions'),

    // API entity actions, these extend the entityActionFactory (flux/factories/entity_action_factory.js)
    // the naming of these actions should match their corresponding store and the model.entity
    'audiences': require('flux/actions/audience_actions'),
    'collaborators': require('flux/actions/collaborator_actions'),
    'dimensions': require('flux/actions/dimension_actions'),
    'experiments': require('flux/actions/experiment_actions'),
    'goals': require('flux/actions/goal_actions'),
    'projects': require('flux/actions/project_actions'),

    // Mobile actions
    'mobile': require('flux/actions/mobile_actions')
  };

  return {
    actions: actions,
    stores: stores,
  };
});

/**
 * ConditionGroup model
 *
 *
 * Condition data structure:
 *   {
 *    name: <string>,
 *    value: <string|number>,
 *    match_type: <value>,
 *    type: <string>
 *   }
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('models/condition_group',['require'],function(require) {
  /**
   * Whitelist of condition properties we care about
   */
  var CONDITION_PROPS = ['name', 'value', 'match_type', 'type'];
  /**
   * @constructor
   *
   * Note: methods cannot go on the prototype since Vue will override it when it attaches
   * the EventEmitter
   *
   * @param {string} type
   */
  function ConditionGroup(type) {
    var self = this;

    /**
     * Hack since we can't check instanceof
     */
    this.IS_GROUP = true;

    /**
     * @var {string} <'and'|'or'>
     */
    this.type = type;

    /**
     * @var {boolean}
     */
    this.negate = false;

    /**
     * @var {Array.<Condition|ConditionGroup>}
     */
    this.conditions = [];

    /**
     * @param {Condition|ConditionGroup} condition
     */
    this.removeCondition = function(condition) {
      var ind = self.conditions.indexOf(condition);
      if (ind !== -1) {
        self.conditions.splice(ind, 1);
      }
    };

    /**
     * Recursively removes empty child condition groups
     */
    this.deleteEmptyConditions = function() {
      var dirty = false;

      self.conditions.forEach(function(val, ind) {
        if (val.IS_GROUP) {
          if (val.conditions.length === 0) {
            self.conditions.splice(ind, 1);
            dirty = true;
          }
          else {
            var result = val.deleteEmptyConditions();
            if (!dirty) {
              // if the current iteration wasn't di
              // mark as dirty if the a child condition group was marked dirty
              dirty = result;
            }
          }
        }
      });

      // once all the conditoins are recursively cleared try to clear outer level
      if (dirty) {
        self.deleteEmptyConditions();
      }

      return dirty;
    };

    /**
    * Serialize to JS object
    *
    * Data structure:
    * [
    *   'and',
    *   [
    *     'or',
    *     [
    *       'or',
    *       {
    *         name: ''
    *         value: 'value1',
    *         match_type: null,
    *         type: 'ad_campaign'
    *       },
    *       {
    *         name: ''
    *         value: 'value2',
    *         match_type: null,
    *         type: 'ad_campaign'
    *       },
    *     ],
    *   ],
    *   [
    *     'not',
    *     [
    *       'or':
    *       {
    *         name: ''
    *         value: 'value2',
    *         match_type: null,
    *         type: 'ad_campaign'
    *       },
    *     ]
    *   ]
    * ]
    *
    * @return {Object}
    */
    this.serialize = function() {
      if (!this.type && this.conditions.length > 0) {
        throw new Error("Type cannot be undefined to call serialize()");
      }
      if (!this.type) {
        return [];
      }

      var serialized = [self.type];

      // conditions is an array of ConditionGroups or condition literals (never a mix)
      self.conditions.forEach(function(condition) {
        if (condition.IS_GROUP) {
          // condition is a ConditionGroup
          serialized.push(condition.serialize())
        }
        else {
          // condition is a condition literal,
          var cleanedCondition = {};
          // whitelist properties so Vue related things like '$index' dont get included
          CONDITION_PROPS.forEach(function(prop) {
            if (condition.hasOwnProperty(prop)) {
              cleanedCondition[prop] = condition[prop]
            }
          });

          serialized.push(cleanedCondition);
        }
      });

      if (self.negate) {
        serialized = ['not', serialized];
      }

      return serialized;
    };

    /**
    * Load JS object of same structure as this.serialize()
    *
    * @param {Object} data
    */
    this.load = function(data) {
      var RE_AND_OR = /^and|or$/
      // remove existing conditions
      self.conditions = [];

      if (data.length === 0) {
        return;
      }

      var current = data;
      // handle the ['not', ['or' ...]] case
      if (current[0] === 'not') {
        self.negate = true;

        if (current.length > 2) {
          throw new Error("'not' is unary operator, cannot have multiple conditions or condition groups");
        }
        var condition = current[1];

        // recursively load the condition data ['not', ['or', ...]] or ['not
        // in the case where current[1] is another conidtion group: ['not', ['or', { cond1 }]]
        if ($.isArray(condition)) {
          self.load(condition);
        }
        else if ($.isPlainObject(condition)) {
          // current[1] is a condition literal, must transform to ['or', { cond }]
          self.load(['or', condition])
        }
        else {
          throw new Error("Expecting Array or Object, got: " + condition);
        }
      } else {
        // current[0] now HAS to point the logical type ('and'|'or')
        if (!RE_AND_OR.test(current[0])) {
          throw new Error("Expecting and|or, got: " + current[0]);
        }
        self.type = current[0];

        current.slice(1).forEach(function(condition) {
          if ($.isArray(condition)) {
            // create and load a new condition group
            var newConditionGroup = new ConditionGroup();
            newConditionGroup.load(condition);
            self.conditions.push(newConditionGroup);
          }
          else if ($.isPlainObject(condition)) {
            // handle condition literal of form:
            // { name: <string>, match_type: <string>, value: <string|number>, type: <string> }
            var conditionToAppend = {};
            CONDITION_PROPS.forEach(function(key) {
              if (condition.hasOwnProperty(key)) {
                conditionToAppend[key] = condition[key];
              }
            });
            self.conditions.push(conditionToAppend);
          }
          else {
            throw new Error("Expecting Array or Object, got: " + condition);
          }
        });
      }

    };
  }

  return ConditionGroup;
});

/**
 * Condition Group Component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/condition_group',['require'],function(require) {
  return {
    replace: true,

    data: {
      /**
       * @var {ConditionGroup}
       */
      conditionGroup: null,
      /**
       * @var {String}
       */
      conditionType: null,
      /**
       * For custom dimensions the name is meaningful
       * @var {String}
       */
      customDimensionName: null
    },

    computed: {
      /**
       * Use computed negate so 'true' and 'false' can be converted to their boolean values
       */
      negate: {
        $get: function() {
          return (this.conditionGroup.negate) ? 'true' : 'false';
        },
        $set: function(val) {
          this.conditionGroup.negate = (val === 'false') ? false : true;
        }
      }
    },

    methods: {
      /**
       * Check if a field is required in the dimensions configuration
       * @param {String} field
       */
      isRequired: function(field) {
        return this.dimension['fields'][field]['required'];
      },
      /**
       * Return true if any condition has the inputted match_type
       * @param {String} matchType
       * @return {Boolean}
       */
      hasMatchType: function(matchType) {
        return _.any(this.conditionGroup.conditions, function(condition) {
          return condition.match_type === matchType;
        });
      },
      /**
       * Return the placeholder text for the specific match type
       * @param {String} matchType
       * @return {String}
       */
      placeholderText: function (valueString, matchType) {
        var text = '';
        switch (matchType) {
          case 'exact':
            text = valueString;
            break;
          case 'substring':
            text = valueString + '(substring)';
            break;
          case 'regex':
            text = valueString + '(regular expression)';
            break;
        }
        return text;
      },
      /**
       * Helper method to get the current index of a condition
       *
       * Cannot use the $index property of the loop because it does not get
       * updated when conditions are removed
       *
       * @param {ConditionGroup|Condition} condition
       * @return {number}
       */
      conditionIndex: function(condition) {
        return this.conditionGroup.conditions.indexOf(condition);
      },
      /**
       * Add an empty condition to the conditionGroup
       */
      addEmptyCondition: function() {
        var condition = {
          type: this.conditionType
        };
        if (this.customDimensionName) {
          condition.name = this.customDimensionName;
        }
        this.conditionGroup.conditions.push(condition);
      },
      /**
       * Removes condition from the group
       * @param {ConditionGroup|Condition} condition
       */
      removeCondition: function(condition) {
        this.conditionGroup.removeCondition(condition)

        // trigger to ancestor VMs that the last condition was removed
        if (this.conditionGroup.conditions.length === 0) {
          this.removeConditionGroup();
        }
      },
      removeConditionGroup: function() {
        this.conditionGroup.conditions = [];
        this.$dispatch('conditionRemoved');
      }
    },

    ready: function() {
      if (this.conditionType === 'custom_dimension') {
        // extract the name from the first condition object in the conditionGroup
        // For custom dimensions all names are the same
        this.customDimensionName = this.conditionGroup.conditions[0].name;
      }
    }
  };
});

/**
 * Geotargeting Conditon Group Component
 * extends `condition-group` component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/geotargeting/geotargeting_condition_group',['require'],function(require) {
  return {
    replace: true,

    data: {
      /**
       * @var {ConditionGroup}
       */
      conditionGroup: null
    },

    computed: {
      /**
       * Use computed negate so 'true' and 'false' can be converted to their boolean values
       */
      negate: {
        $get: function() {
          return (this.conditionGroup.negate) ? 'true' : 'false';
        },
        $set: function(val) {
          this.conditionGroup.negate = (val === 'false') ? false : true;
        }
      },

      /**
       * Returns whether or not the condition group has any conditions
       * @return {Boolean}
       */
      hasNoConditions: function() {
        return (this.conditionGroup.conditions.length === 0);
      }
    },

    methods: {
      /**
       * Helper method to get the current index of a condition
       *
       * Cannot use the $index property of the loop because it does not get
       * updated when conditions are removed
       *
       * @param {ConditionGroup|Condition} condition
       * @return {number}
       */
      conditionIndex: function(condition) {
        return this.conditionGroup.conditions.indexOf(condition);
      },

      /**
       * Destroy the codnition group by dispatching an event
       * to parent component
       */
      destroyConditionGroup: function() {
        this.$dispatch('conditionRemoved');
      },

      /**
       * Removes condition from the group
       * @param {ConditionGroup|Condition} condition
       */
      removeCondition: function(condition) {
        this.conditionGroup.removeCondition(condition)
      },
    },

    ready: function() {
      // normal condition groups are instantiated with an empty condition in this.conditionGroup.conditions[0]
      // we dont want that for geotargeting, remove it
      if (
          this.conditionGroup.conditions.length === 1 &&
          !this.conditionGroup.conditions[0].value
      ) {
        this.conditionGroup.conditions = [];
      }

      this.$on('geotargetingLocationSelected', function(data) {
        this.conditionGroup.conditions.push({
          type: this.conditionType,
          value: data.location
        });
        // broadcast to geotargeting autocomplete to clear the input
        this.$broadcast('geotargetingAutocompleteClear');
      }.bind(this));
    }
  };
});

/**
 * Third Party Targeting Conditions service
 *
 * Provides information on third party targeting conditions.
 */

define('services/third_party_targeting_conditions',['require','exports','module','lodash'],function(require, exports, module) {
  // TODO(jon): Figure out how to test this...
  var _ = require('lodash');
  var THIRD_PARTY_CONDITIONS_METADATA = module.config()['conditions_metadata'] || {};

  /**
   * Retrieve provider / integration ID and condition name from condition full name.
   *
   * @param conditionFullName Full name of a third-party condition using the format: `<provider_id>.<condition_name>`
   * @returns {{ '{{' }}providerId: <string>, conditionName: <string>{{ '}}' }}
   * @private
   */
  var _getProviderIdAndConditionNameFromConditionFullName = function(conditionFullName) {
    var conditionFullNameParts = conditionFullName.split('.');
    return {
      providerId: conditionFullNameParts[0],
      conditionName: conditionFullNameParts[1]
    }
  } ;

  /**
   * Get the fully qualified name of a third-party condition.
   *
   * @param providerId ID of the provider / integration
   * @param conditionName Name of a third-party condition, see integrations/demandbase/config.yaml for an example
   * @returns {string}
   * @private
   */
  var _getConditionFullName = function(providerId, conditionName) {
    return providerId + '.' + conditionName;
  };

  /**
   * Get config metadata for a third-party dimension.
   *
   * @param conditionFullName Full name of a third-party condition using the format: `<provider_id>.<condition_name>`
   * @returns {{ '{{' }}displayName?: <string>, inputType?: <string>, values?: <string>{{ '}}' }}
   */
  function getConditionConfig(conditionFullName) {
    var conditionFullNameParts = _getProviderIdAndConditionNameFromConditionFullName(conditionFullName);
    var providerId = conditionFullNameParts.providerId;
    var conditionName = conditionFullNameParts.conditionName;
    var providerMetadata = THIRD_PARTY_CONDITIONS_METADATA[providerId];

    if (!providerMetadata) {
      return {};
    }

    var field =  _.find(providerMetadata.supported_fields, {
      name: conditionName
    });

    return field ? {
      providerMasterLabel: providerMetadata.master_label,
      displayName: field.display_name,
      inputType: field.input_type,
      values: field.values
    } : {};
  }

  /**
   * Get the metadata needed to render the Third-Party conditions tab in audience builder
   *
   * @returns {{ '{{' }}{{ '}}' }}
   */
  function getThirdPartyConditionsTabMetadata() {
    var thirdPartyConditionsTabMetadata = {};

    _.forEach(THIRD_PARTY_CONDITIONS_METADATA, function(metadata, integrationId) {
      thirdPartyConditionsTabMetadata[integrationId] = {
        masterLabel: metadata.master_label,
        providerId: integrationId,
        conditions: metadata.supported_fields.map(function(fieldConfig) {
          return {
            displayName: fieldConfig.display_name,
            helpText: fieldConfig.help_text,
            name: _getConditionFullName(integrationId, fieldConfig.name)
          };
        })
      };
    });

    return thirdPartyConditionsTabMetadata;
  }

  return {
    getConditionConfig: getConditionConfig,
    getThirdPartyConditionsTabMetadata: getThirdPartyConditionsTabMetadata
  }
});

/**
 * @license RequireJS text 2.0.12 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text',['module'], function (module) {
    

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.12',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file.indexOf('\uFEFF') === 0) {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});


define('text!components/third_party_targeting/third_party_targeting_condition_field.html',[],function () { return '{# Note(ali): Text field should go first in order to use v-show #}\n\n<input v-show="config.inputType === \'text\'" type="text" v-model="condition.value" class="condition__value" />\n\n<select v-show="config.inputType === \'select\'" v-model="condition.value" class="condition__value">\n  <option v-repeat="value: config.values" v-attr="selected: value.value === condition.value" value="[[ value.value ]]">[[ value.text ]]</option>\n</select>\n\n<span v-show="config.inputType === \'range\'" >\n  <input type="text" v-model="rangeFromWrapper" class="quarter condition__value" /> [[ config.unit ]] and <input type="text" v-model="rangeToWrapper" class="quarter condition__value" /> [[ config.unit ]]\n</span>\n\n<input v-if="config.inputType === \'boolean\'" type="hidden" v-model="condition.value" class="condition__value" />\n';});

/**
 * Third Party Condition Field Component
 * Responsible for rendering the configuration UI for a specific third-party condition
 *
 * TODO(peng-wen): provide a dedicated condition field component for each input type
 */
define('components/third_party_targeting/third_party_targeting_condition_field',['require','text!components/third_party_targeting/third_party_targeting_condition_field.html','services/third_party_targeting_conditions'],function(require) {
  var tmpl = require('text!components/third_party_targeting/third_party_targeting_condition_field.html');
  var thirdPartyTargetingConditions = require('services/third_party_targeting_conditions');

  /**
   * Get condition value for the `range` input type based on values from `from` and `to` input elements.
   *
   * @param from the beginning value of the range
   * @param to the ending value of the range
   * @returns {string}
   * @private
   */
  var _getRangeConditionValue = function(from, to) {
    if (!(from && to)) {
      return '';
    }

    return from + ':' + to;
  };

  /**
   * Get the upper and lower limits from a range field's condition value.
   *
   * @param conditionValue value of a condition using the `range` input type
   * @returns {*}
   * @private
   */
  var _getRangeLimitsFromConditionValue = function(conditionValue) {
    if (!conditionValue) {
      return {};
    }

    var limits = conditionValue.split(':');

    return {
      from: limits[0],
      to: limits[1]
    };
  };

  return {
    replace: true,

    template: tmpl,

    data: {
      config: {},
      // Used by `range` input type only
      rangeFrom: '',
      rangeTo: ''
    },

    computed: {
      // Used by `range` input type only
      rangeFromWrapper: {
        $get: function() {
          return this.rangeFrom;
        },
        $set: function(value) {
          this.rangeFrom = value;
          this.condition.value = _getRangeConditionValue(this.rangeFrom, this.rangeTo);
        }
      },
      rangeToWrapper: {
        $get: function() {
          return this.rangeTo;
        },
        $set: function(value) {
          this.rangeTo = value;
          this.condition.value = _getRangeConditionValue(this.rangeFrom, this.rangeTo);
        }
      }
    },

    ready: function() {
      this.config = thirdPartyTargetingConditions.getConditionConfig(this.condition.name);

      // Set initial value for condition depending upon the input type
      if (this.config.inputType === 'select' && !_.find(this.config.values, {value: this.condition.value})) {
        this.condition.value = this.config.values[0].value;
      } else if (this.config.inputType === 'boolean') {
        this.condition.value = "true";
      } else if (this.config.inputType === 'range') {
        var limits = _getRangeLimitsFromConditionValue(this.condition.value);
        this.rangeFromWrapper = limits.from;
        this.rangeToWrapper = limits.to;
      }
    }
  }
});

/**
 * Third Party Targeting Condition Group Component
 * This component extends components/condition_group to provide specific logic to render a third-party condition
 *
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('components/third_party_targeting/third_party_targeting_condition_group',['require','services/third_party_targeting_conditions','components/condition_group','components/third_party_targeting/third_party_targeting_condition_field'],function(require) {
  var thirdPartyTargetingConditions = require('services/third_party_targeting_conditions');
  var baseComponent = require('components/condition_group');

  return $.extend(true, {}, baseComponent, {
    components: {
      'third-party-condition-field': require('components/third_party_targeting/third_party_targeting_condition_field')
    },

    data: {
      conditionConfig: {},
      conditionGroup: {},
      conditionName: ''
    },

    methods: {
      /**
       * Add an empty third-party condition to the conditionGroup
       */
      addEmptyCondition: function() {
        this.conditionGroup.conditions.push({
          type: this.conditionType,
          name: this.conditionName
        });
      }
    },

    ready: function() {
      this.conditionName = this.conditionGroup.conditions[0].name;
      this.conditionConfig = thirdPartyTargetingConditions.getConditionConfig(this.conditionName);
    }
  });
});

/**
 * Targeting Conditions service
 *
 * Creates a registry of components for each targeting condition type
 * based off the dimensions.yaml file passed into the requirejs module.config()
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/targeting_conditions',['require','exports','module','components/condition_group','components/geotargeting/geotargeting_condition_group','components/third_party_targeting/third_party_targeting_condition_group'],function(require, exports, module) {
  /**
   * The conditions that are available to use in the and_or_targeting component
   * See src/www/models/dimensions.yaml for structure
   * @var {Object}
   */
  var dimensions = module.config()['dimensions'] || {};
  /**
   * The base component to extend for every condition group
   */
  var baseComponent = require('components/condition_group');
  /**
   * A mapping of condition_types => baseComponents
   * if the condition_type should not use the standard baseComponent
   * @param {Object}
   */
  var baseComponentExceptions = {
    'location': require('components/geotargeting/geotargeting_condition_group'),
    'third_party_dimension': require('components/third_party_targeting/third_party_targeting_condition_group')
  };

  // registry of sub components
  var conditionComponents = {};
  /**
   * @var {Object} mapping of condition types to component ids
   */
  var componentMap = {};

  /**
   * Iterate over the 'dimensions' data from the RequireJS config for this module and create two things:
   *
   * 1.  A mapping of components only defined on thie ViewModel for each supported
   * condition type.  All of these components extend the base `condition-group` component
   * but have their own templates
   *
   * 2.  A mapping of conditionTypes (ex: 'ad_campaign', 'browser') to their component id
   */
  _.forEach(dimensions, function(dimension, conditionType) {
    var componentName = 'conditions/' + conditionType;
    var template = '#condition-template-' + conditionType;
    var componentToExtend = (baseComponentExceptions[conditionType]) 
      ? baseComponentExceptions[conditionType]
      : baseComponent;

    conditionComponents[componentName] = $.extend(true, {}, componentToExtend, {
      template: template,
      data: {
        conditionType: conditionType,
        dimension: dimension
      }
    });

    componentMap[conditionType] = componentName;
  });

  /**
   * Gets the field definition for a dimensionType/field
   * @param {String} dimensionType
   * @param {String} field
   * @return { {
 *     required: <Boolean>
 *     values: <Array.<{ value: <String>, text: <String> }>>
   * {{ '}}' }}
   */
  function getFieldDefinition(dimensionType, field) {
    if (!dimensions[dimensionType]) {
      throw new Error("Invalid dimension type: " + dimensionType);
    }
    if (!dimensions[dimensionType].fields[field]) {
      throw new Error("Invalid field: " + field);
    }

    return dimensions[dimensionType].fields[field];
  }

  /**
   * Checks if a particular value is a valid value for a condition type's field
   *
   * Ex: dimensionType='visitor' and field='value' and value='hey' => invalid
   *
   * @param {String} dimensionType
   * @param {String} field
   * @param {String} value
   * @return {Boolean}
   */
  function isValidFieldValue(dimensionType, field, value) {
    var fieldDef;
    try {
      fieldDef = getFieldDefinition(dimensionType, field);
    } catch (e) {
      return false;
    }

    if (fieldDef.required && !value) {
      // if the field is required and value is fasly
      return false;
    } else if (!fieldDef.required) {
      return true;
    }

    if (fieldDef.values) {
      var acceptableValues = fieldDef.values.map(function(def) {
        return def.value;
      });

      if (acceptableValues.indexOf(value) === -1) {
        return false;
      }
    }
    return true;
  }

  return {
    getComponentId: function(conditionType) {
      return componentMap[conditionType];
    },
    /**
     * @var { { <componentId> : <componentDefinition } }
     */
    conditionComponents: conditionComponents,
    isValidFieldValue: isValidFieldValue
  };
});

/**
 * Condition service
 *
 * Functionality revolving around condition data
 *
 * Condition data structure:
 *   {
 *    name: <string>,
 *    value: <string|number>,
 *    match_type: <value>
 *   }
 *
 * ConditionGroup data structure
 *   [
 *    <'or'|'and'>,
 *    <Condition|ConditionGroup>, // recursive
 *    <Condition|ConditionGroup>,
 *    <Condition|ConditionGroup>
 *   ]
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/condition',['require','lodash','models/condition_group','services/targeting_conditions'],function(require) {
  var _ = require('lodash');
  var ConditionGroup = require('models/condition_group');
  var targetingConditions = require('services/targeting_conditions');

  /**
   * Validates whether a condition is too complex to be
   * displayed in the UI
   *
   * Must conform to the structure 
   * [
   *  'and',
   *  [
   *    'or',
   *    [
   *      'not',
   *      [
   *        'or',
   *        {
   *          match_type: ...
   *          value: ...
   *          name: ...
   *        }
   *      ]
   *    ]
   *  ]
   * ]
   *
   * @param {ConditionGroup}
   * @return {Boolean}
   */
  function isUIDisplayableCondition(conditionGroup) {
    if (!conditionGroup.IS_GROUP) {
      // root level conditionGroup must be a ConditionGroup
      return false;
    }
    if (conditionGroup.negate) {
      // cannot negate root level condition
      return false;
    }
    if (conditionGroup.type === 'or') {
      // root ConditionGroup must be 'and' type
      return false;
    }
    if (conditionGroup.conditions.length === 0) {
      // conditionGroup is unitialized
      return true;
    }
    if (conditionGroupDepth(conditionGroup) !== 3) {
      return false;
    }

    // all children of the root condition group must be condition groups of type 'or'
    // and not negated
    var validSecondLevelGroups = conditionGroup.conditions.every(function(group) {
      return (group.IS_GROUP && !group.negate && group.type === 'or');
    });
    if (!validSecondLevelGroups) {
      return false;
    }

    // all grandchildren nodes must be condition groups of the type or
    var validThirdLevelGroups = true;
    conditionGroup.conditions.forEach(function(child) {
      child.conditions.forEach(function(grandchild) {
        if (
          // must be a group
          !grandchild.IS_GROUP ||
          // must be logical type 'or'
          grandchild.type !== 'or' ||
          // all grandchild.conditions must be the same type
          !getConditionType(grandchild)
        ) {
          validThirdLevelGroups = false;
        }
      });
    });
    if (!validThirdLevelGroups) {
      return false;
    }

    return true;
  }

  /**
   * Attempts to transform a ConditionGroup that is not UI-displayable
   * into a logical equivalent group that IS UI-displayable
   *
   * Note: Does not modify the inputted condition group
   *
   * Returns null if the condition group cannot be transformed into a UI-displayable group
   *
   * @param {ConditionGroup} conditionGroup
   * @return {ConditionGroup|null}
   */
  function transformToUIValidConditionGroup(serializedConditions) {
    var conditionGroup = new ConditionGroup();
    try {
      conditionGroup.load(serializedConditions);
    } catch(e) {
      // invalid serializedConditions cannot even load into ConditionGroup object
      return null;
    }

    if (isUIDisplayableCondition(conditionGroup)) {
      return conditionGroup;
    }

    // load the serialized data into a new conditionGroup
    var serializedData = conditionGroup.serialize();
    var conditionGroup = new ConditionGroup();
    conditionGroup.load(serializedData);

    // if ['or', {cond1}, {cond2}, {cond3}] and all are the same type
    // This is a special case where the output should be ['and', ['or', ['or', {cond1}, {cond2}, {cond3}]]]
    conditionGroup = handleSingleProperLeafConditionGroup(conditionGroup);

    // attempt to recognize this pattern and immediately transform into ['and', ['or', ['or', {cond1}, {cond2}, {cond3}]]]
    if (isUIDisplayableCondition(conditionGroup)) {
      return conditionGroup;
    }

    // top level condition group must be 'and' for UI
    if (conditionGroup.type === 'or') {
      conditionGroup = wrapGroup(conditionGroup, 'and');
    }

    if (conditionGroupDepth(conditionGroup) > 3) {
      // cannot transform if depth > 3
      return null;
    }

    // attempt to traverse improper condition groups and convert condition literals
    // Traverse all leaf condition groups (any group with a condition literal as a child)
    // wrap the condition literals in an 'or' condition group => ['or', cond]
    traverseLeafGroups(conditionGroup, function(group, depth) {
      if (depth < 3) {
        // wrap any condition literals of group in ['or', cond]
        wrapConditionsInGroup(group, 'or');
      }
    });
    // By this point there should be no more improper leaf ConditionGroups
    if (isUIDisplayableCondition(conditionGroup)) {
      return conditionGroup;
    }

    // try to normalize the depth to 3 by padding every singular ['or', cond] with ['or', ['or', cond]]
    var succeeded = true;
    try {
      traverseProperLeafGroups(conditionGroup, function(group, depth) {
        if (depth === 2) {
          var ind = conditionGroup.conditions.indexOf(group);
          if (ind === -1) {
            throw new Error("Could find index of " + group.serialize() + " in " + conditionGroup.serialize());
          }
          var newGroup = new ConditionGroup('or');
          newGroup.conditions = [group];

          conditionGroup.conditions.splice(ind, 1, newGroup);
        }
      });
    } catch(e) {
      succeeded = false;
    }

    if (!succeeded) {
      // there was an error trying to transform into a 3-level deep condition group
      return null;
    }

    if (isUIDisplayableCondition(conditionGroup)) {
      return conditionGroup;
    }

    return null;
  }

  /**
   * Takes a condition object literal 
   * {
   *   type: 'visitor',
   *   name: '',
   *   value: ''
   * }
   * and removes name and value properties, since name is not a valid field
   * and value isn't a valid value
   *
   * @param {ConditionGroup} conditionGroup
   */
  function cleanInvalidConditionFields(conditionGroup) {
    traverseProperLeafGroups(conditionGroup, function(group) {
      group.conditions.forEach(function(condition) {
        _.each(condition, function(value, field) {
          // ignore the type property on condition literals
          if (field === 'type') {
            return;
          }
          if (!targetingConditions.isValidFieldValue(condition.type, field, value)) {
            delete condition[field];
          }
        });
      });
    });
  }

  /**
   * Derives the conditionType from conditionGroup.conditions
   * All conditions must be condition literals and of the same type or
   * null is returned
   *
   * @param {ConditionGroup} group
   * @return {String|null}
   */
  function getConditionType(group) {
    if (group.conditions.length === 0) {
      return null;
    }
    var hasAllConditions = group.conditions.every(function(condition) {
      return !condition.IS_GROUP;
    });
    if (!hasAllConditions) {
      return null;
    }
    // group.conditions[0] must be a condition literal
    var type = group.conditions[0].type;

    var hasSameType = group.conditions.every(function(condition) {
      return condition.type === type;
    });

    if (!hasSameType) {
      return null;
    }

    return type;
  }

  /**
   * if ['or', {cond1}, {cond2}, {cond3}] and all are the same type
   * This is a special case where the output should be ['and', ['or', ['or', {cond1}, {cond2}, {cond3}]]]
   *
   * @private
   * @param {ConditionGroup} group
   * @return {ConditionGroup}
   */
  function handleSingleProperLeafConditionGroup(group) {
    if (group.type !== 'or') {
      // only handle the or case
      return group;
    }

    if (!isProperLeafConditionGroup(group)) {
      // group must only have condition literals as children
      return group;
    }

    var type = group.conditions[0].type;
    var allSameType = group.conditions.every(function(cond) {
      return cond.type === type;
    });

    if (!allSameType) {
      // all conditions must be the same type
      return group;
    }

    // at this point we can do a shortcut transform to ['and', ['or', ['or', conds...]]]
    var rootGroup = new ConditionGroup('and');
    rootGroup.conditions = [wrapGroup(group, 'or')];
    return rootGroup;
  }

  /**
   * Transforms:
   * [
   *  'and',
   *  {
   *    type: 'type1',
   *    value: 'value1'
   *  },
   *  {
   *    type: 'type2',
   *    value: 'value2'
   *  },
   *  {
   *    type: 'type1',
   *    value: 'value3'
   *  },
   * ]
   * into
   * [
   *  'and',
   *  [
   *    'or',
   *    {
   *      type: 'type1',
   *      value: 'value1'
   *    }
   *  ],
   *  [
   *    'or',
   *    {
   *      type: 'type2',
   *      value: 'value2'
   *    }
   *  ]
   *  [
   *    'or',
   *    {
   *      type: 'type1',
   *      value: 'value3'
   *    }
   *  ]
   * ]
   *
   * Also moves the negation to the leaf ConditionGroup
   * Ex:
   * [
   *   'not',
   *   [
   *     'or',
   *     { cond1 },
   *     { cond2 }
   *   ]
   * ]
   * INTO
   * [
   *   'or',
   *   [
   *     'not',
   *     [
   *       'or',
   *       { cond1 }
   *     ]
   *   ],
   *   [
   *     'not',
   *     [
   *       'or',
   *       { cond2 }
   *     ]
   *   ]
   * ]
   *
   * Wraps every condition literal in a ConditionGroup of type 'or'
   * Does not combine like types
   * @private
   * @param {ConditionGroup} group
   * @param {String} type
   */
  function wrapConditionsInGroup(group, type) {
    // if the groups conditions are mutated
    var mutated = false;
    // create the childConditionMap
    group.conditions.forEach(function(cond, ind) {
      // replace a raw condition literal with ['or', cond]
      if (!cond.IS_GROUP) {
        mutated = true;
        var groupToInsert = new ConditionGroup(type);
        groupToInsert.conditions = [cond];
        groupToInsert.negate = group.negate;
        group.conditions.splice(ind, 1, groupToInsert);
      }
    });

    if (mutated) {
      // Since the negation is moved to the leaf ConditionGroup
      group.negate = false;
    }
  }

  /**
   * Wraps a single condition group in another condition group of a certain type
   * ['or', cond1, cond2] => ['and', ['or', cond1, cond2]]
   *
   * @private
   * @param {ConditionGroup} group
   * @param {String} type
   * @return {ConditionGroup}
   */
  function wrapGroup(group, type) {
    var wrapper = new ConditionGroup(type);
    wrapper.conditions = [group];
    return wrapper;
  }

  /**
   * Does a traversal of all proper leaf conditionGroups and executes fn(group, depth)
   *
   * @private
   * @param {ConditionGroup} conditionGroup
   * @param {Function} fn
   */
  function traverseProperLeafGroups(conditionGroup, fn, depth) {
    if (!depth) {
      depth = 1;
    } else {
      depth++;
    }
    if (isProperLeafConditionGroup(conditionGroup)) {
      fn(conditionGroup, depth);
    } else {
      conditionGroup.conditions.forEach(function(condition) {
        if (condition.IS_GROUP) {
          traverseProperLeafGroups(condition, fn, depth);
        }
      });
    }
  }

  /**
   * Does a traversal of all leaf conditionGroups and executes fn(group, depth)
   *
   * @private
   * @param {ConditionGroup} conditionGroup
   * @param {Function} fn
   */
  function traverseLeafGroups(conditionGroup, fn, depth) {
    if (!depth) {
      depth = 1;
    } else {
      depth++;
    }
    if (isImproperLeafConditionGroup(conditionGroup) ||
        isProperLeafConditionGroup(conditionGroup)
    ) {
      fn(conditionGroup, depth);
    } else {
      conditionGroup.conditions.forEach(function(condition) {
        if (condition.IS_GROUP) {
          traverseLeafGroups(condition, fn, depth);
        }
      });
    }
  }

  /**
   * Checks if a conditionGroup.conditions are all condition literals
   *
   * @private
   * @param {ConditionGroup} conditionGroup
   * @return {Boolean}
   */
  function isProperLeafConditionGroup(conditionGroup) {
    return conditionGroup.conditions.length > 0 && conditionGroup.conditions.every(function(condition) {
      return !condition.IS_GROUP;
    });
  }

  /**
   * An improper leaf group is a ConditionGroup that has at least one condition literal
   * as a child condition
   *
   * @private
   * @param {ConditionGroup} conditionGroup
   * @return {Boolean}
   */
  function isImproperLeafConditionGroup(conditionGroup) {
    if (isProperLeafConditionGroup(conditionGroup)) {
      return false;
    }
    var someConditions = conditionGroup.conditions.some(function(condition) {
      return !condition.IS_GROUP;
    });
    var someConditionGroups = conditionGroup.conditions.some(function(condition) {
      return condition.IS_GROUP;
    });
    return (someConditions && someConditionGroups);
  }

  /**
   * Gets the depth of the condition group
   * The amount of nesting between the root conditionGroup and the lowest
   * condition literal
   *
   * Assumes that the depth consistent amongst all children nodes
   *
   * @private
   * @param {ConditionGroup} conditionGroup
   * @param {Integer=} depth
   * @return {Integer}
   */
  function conditionGroupDepth(conditionGroup, depth) {
    if (!depth) {
      depth = 1;
    } else {
      depth++;
    }
    if (conditionGroup.conditions.length === 0 || $.isPlainObject(conditionGroup.conditions[0])) {
      return depth;
    } else {
      return conditionGroupDepth(conditionGroup.conditions[0], depth);
    }
  }

  /**
   * Returns whether the conditions array has any condition literals
   *
   * @param {Array} conditions
   * @return {Boolean}
   */
  function isEmpty(conditions) {
    var isEmpty = true;

    var conditionGroup = new ConditionGroup();
    conditionGroup.load(conditions);

    traverseProperLeafGroups(conditionGroup, function(group) {
      isEmpty = false;
    });

    return isEmpty;
  }

  return {
    getConditionType: getConditionType,
    cleanInvalidConditionFields: cleanInvalidConditionFields,
    transformToUIValidConditionGroup: transformToUIValidConditionGroup,
    isUIDisplayableCondition: isUIDisplayableCondition,
    isEmpty: isEmpty
  };
});

/**
 * And/Or Targeting Controller
 *
 * Controls the serializing/deserializing of audinece conditions
 * and the interaction between switching from the and_or_targeting ui
 * and the code editor mode
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/and_or_targeting',['require','services/condition','services/dimension'],function(require) {
  var conditionService = require('services/condition');
  var dimensionService = require('services/dimension');

  return {
    template: '#and-or-targeting-template',

    data: {
      conditions: null,
      /**
       * @requiredInitialData
       *
       * @var {Integer}
       */
      projectId: null,
      /**
       * @var {Array.<Dimension>} Custom Dimensions for the particular project
       */
      customDimensions: [],
      /**
       * @var {String.<ui|code>} the current view mode
       */
      mode: null,
      /**
       * Array of collected deferreds after broadcasting 'validateConditions'
       * @var {Array}
       */
      _deferredValidationResponses: []
    },

    computed: {
      /**
       * @return {Boolean}
       */
      isCodeMode: function() {
        return this.mode === 'code';
      },
      /**
       * @return {Boolean}
       */
      isUIMode: function() {
        return this.mode === 'ui';
      }
    },

    methods: {
      /**
       * Handles the initial loading of the serialized conditions when the component is
       * initialized
       * @param {Array} val
       */
      handleInitialConditions: function(val) {
        var transformedForUI = conditionService.transformToUIValidConditionGroup(val);
        if (transformedForUI) {
          this.conditions = transformedForUI.serialize();
          this._switchToUIMode();
        } else {
          // import the raw condition to send to code editor
          this.conditions = val;
          this._switchToCodeMode();
        }
      },
      /**
       * Gets the serialized conditions, if the condition JSON was created in code mode
       * it will export the JSON directly (without loading into UI)
       *
       * @return {Array}
       */
      getSerializedConditions: function() {
        if (this.isCodeMode) {
          return this.$.codeEditor.getSerializedConditions();
        } else {
          return this.$.uiEditor.getSerializedConditions();
        }
      },
      /**
       * Main method used to switch in and out of code mode
       */
      toggleCodeMode: function() {
        if (this.isCodeMode) {
          var conditions = this.$.codeEditor.getSerializedConditions();
          if (!conditions) {
            // conditions return false, cannot export to UI
            return;
          }
          // attempt to transform the parsed code into a UI-displayable condition group
          var transformedForUI = conditionService.transformToUIValidConditionGroup(conditions);
          // returns null if not ui-displayable
          if (!transformedForUI) {
            this.$.codeEditor.isUIDisplayable = false;
            return;
          }

          // if it was successfully transformed
          this.$.codeEditor.isUIDisplayable = true;
          // clean out invalid fields and values that the user may have enteredd and reserialize
          conditionService.cleanInvalidConditionFields(transformedForUI)
          this.conditions = transformedForUI.serialize();
          this._switchToUIMode();
        } else {
          // remove any empty conditions (that are invalid) in the UI so they arent serialized
          this.$.uiEditor.cleanupConditions();
          this.conditions = this.$.uiEditor.getSerializedConditions();
          this._switchToCodeMode();
        }
      },
      /**
       * Tells child condition-group components to validate and returns a Deferred
       * of whether or not all condition groups are valid
       *
       * @return {Deferred}
       */
      validate: function() {
        var deferred = $.Deferred();
        this._deferredValidationResponses = [];
        this.$broadcast('validateConditions');

        // get the serialized conditions from either the uiEditor or codeEditor
        var conditions = this.getSerializedConditions();

        // check the invalidCode flag and push the error
        if (this.isCodeMode && this.$.codeEditor.invalidCode) {
          this._deferredValidationResponses.push({
            valid: false,
            message: tr('You must enter valid JSON code')
          });
        } else if (conditionService.isEmpty(conditions)){
          // if the code is valid but the conditions are empty
          this._deferredValidationResponses.push({
            valid: false,
            message: tr('You must supply at least one condition')
          });
        }

        // by this time we assume this._deferredValidationResponses is
        // populated all the responses from the child components
        $.when.apply($, this._deferredValidationResponses).then(function() {
          /**
           * @var {Array.<{ valid: Boolean, message?: String }>}
           */
          var args = [].slice.call(arguments);
          var isValid = true;
          var errors = [];
          // if any responses are invalid reject the project
          args.forEach(function(rslt) {
            if (!rslt.valid) {
              isValid = false;
              if (rslt.message) {
                errors.push(rslt.message);
              }
            }
          });

          (isValid) ? deferred.resolve() : deferred.reject(errors);
        });

        return deferred;
      },
      /**
       * switches mode to 'code', does not actually load the conditions into code
       */
      _switchToCodeMode: function() {
        this.mode = 'code';
      },
      /**
       * switches mode to 'ui', does not export the code to the conditionGroup
       */
      _switchToUIMode: function() {
        this.mode = 'ui';
      },
      /**
       * Fetches custom dimensions for projects and loads them into the $data
       *
       * @param {Integer} projectId
       */
      _loadCustomDimensions: function(projectId) {
        dimensionService.fetchDimensionsForProject(projectId)
        .then(function(dimensions) {
          this.customDimensions = dimensions;
        }.bind(this));
      }
    },

    ready: function() {
      // load serialized conditions if passed in as `initialConditions`
      this.handleInitialConditions(this.initialConditions || []);
      this._loadCustomDimensions(this.projectId);

      // collect the children component's validation responses
      this.$on('validateConditionsResponse', function(deferred) {
        this._deferredValidationResponses.push(deferred);
      });
    }
  };
});

/**
 * And Or Targeting Code Editor Component
 *
 * Responsible for loading serialized conditions into a JSON code editor
 * Does basic "is valid json" validation when trying to get the serialized conditions
 *
 * Meant to be used as a child component of and-or-targeting
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/and_or_targeting_code_editor',['require'],function(require) {
  return {
    data: {
      /**
       * @var {String} synced to the code mode editor
       */
      code: '',
      /**
       * Whether the user supplied code is valid JSON
       * @var {Boolean}
       */
      invalidCode: false,
      /**
       * Whether the conditions UI displayable
       * @var {Boolean}
       */
      isUIDisplayable: true
    },

    computed: {
      /**
       * @return {Boolean}
       */
      showInvalidCodeMsg: function() {
        return this.invalidCode;
      },
      /**
       * @return {Boolean}
       */
      showNotUIDisplayableMsg: function() {
        // do not show the not ui-displayable message if the json is invalid
        return !this.isUIDisplayable && !this.invalidCode;
      },
    },

    methods: {
      /**
       * Attempts to parse and return the json code in the editor
       * @return {Array}
       */
      getSerializedConditions: function() {
        this.invalidCode = false;

        if (this.code.trim() === '') {
          return [];
        }

        var parsed;
        try {
          parsed = JSON.parse(this.code);
        } catch(e) {
          this.invalidCode = true;
          this.isUIDisplayable = false;
          return false;
        }

        return parsed;
      },
      /**
       * Stringifies the psased in serialized conditions
       * @param {Array|undefined} val
       */
      setSerializedConditions: function(val) {
        this.code = JSON.stringify(val, null, '  ');
      },
    },

    ready: function() {
      if (this.serializedConditions) {
        this.setSerializedConditions(this.serializedConditions);
      }
    }
  };
});

/**
 * Simple wrapper for page.permissions. See optly.Permissions for methods.
 *
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('services/permissions',[],function() {
    if (optly && optly.page) {
    return optly.page.permissions;
  } else {
    return {};
  }
  

  // until we combine the old optly.page.permissions and
  // this permissions service, stub out the permission functions
  });

/**
 * And Or Targeting UI Component
 *
 * Responsible for driving the UI that powers the drag and drop
 * creation of and or targeting conditions
 *
 * Meant to be used as a child component of and-or-targeting
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/and_or_targeting_ui',['require','services/router','services/condition','models/condition_group','services/permissions','services/targeting_conditions','services/third_party_targeting_conditions'],function(require) {
  var router = require('services/router');
  var conditionService = require('services/condition');
  var ConditionGroup = require('models/condition_group');
  var permissions = require('services/permissions');
  var targetingConditions = require('services/targeting_conditions');
  var thirdPartyTargetingConditions = require('services/third_party_targeting_conditions');

  return {
    // condition components for the types of conditions this targeting supports
    components: targetingConditions.conditionComponents,

    data: {
      /**
       * @var {ConditionGroup} the root ConditionGroup node
       */
      rootConditionGroup: null,
      /**
       * Permission flag for custom dimensions
       * @var {Boolean}
       */
      canUseCustomDimensions: false,
      /**
       * @var {Array.<Dimension>} Custom Dimensions for the particular project
       */
      customDimensions: [],
      /**
       * @var {String.<ui|custom>} whether showing custom or default dimensions in sidebar
       */
      sidebarMode: 'default',
      /**
       *  @var {String} ID of the third party conditions provider whose conditions are currently shown
       */
      selectedProviderId: null,
      /**
       * @var {Object} metadata for all third party conditions, grouped by the third party provider
       */
      thirdPartyConditionMetadataPerProvider: {}
    },

    methods: {
      /**
       * @return {Array}
       */
      getSerializedConditions: function() {
        return this.rootConditionGroup.serialize();
      },
      /**
       * Loads serialized conditions in the rootConditionGroup
       * @param {Array|undefined} val
       */
      setSerializedConditions: function(val) {
        this.rootConditionGroup.load(val);
      },
      /**
       * Checks if there are any conditions in the rootConditionGroup
       * @return {boolean}
       */
      hasRootConditions: function() {
        return this.rootConditionGroup.conditions.length > 0;
      },
      /**
       * Shortcut method to arr.indexOf
       * @return {number}
       */
      conditionIndex: function(arr, item) {
        return arr.indexOf(item);
      },
      /**
       * @param {ConditionGroup} conditionGroup
       * @return {string} component identifier for conditionGroup
       */
      componentForCondition: function(conditionGroup) {
        var conditionType = conditionService.getConditionType(conditionGroup);
        var componentId = targetingConditions.getComponentId(conditionType);
        if (!conditionType || !componentId) {
          throw new Error("Invalid condition type: " + conditionType);
        }
        return componentId;
      },
      /**
       * Add a condition type to the root conditions, nests two 'or' conditions group
       * @param { { type: <string>, name?: <string> } } dimension
       */
      addRootConditionGroup: function(dimension) {
        var baseConditionGroup = new ConditionGroup('or');
        var conditionGroup = new ConditionGroup('or');
        // add a blank condition of conditionType
        // clone so the condition-group component doesn't modify the original
        conditionGroup.conditions.push(_.clone(dimension));

        baseConditionGroup.conditions.push(conditionGroup);
        // add the new conditionGroup to the root ConditionGroup
        this.rootConditionGroup.conditions.push(baseConditionGroup);
      },
      /**
       * Adds an or condition to the current conditionGroup (in VM context of v-repeat)
       *
       * @param { { type: <string>, name?: <string> } } dimension
       */
      addOrCondition: function(dimension) {
        var condition = new ConditionGroup('or');
        // add a blank condition of conditionType
        // clone so the condition-group component doesn't modify the original
        condition.conditions.push(_.clone(dimension));
        this.conditionGroup.conditions.push(condition);
      },
      /**
       * Returns the URL for dashboard dimensions view
       * @return {String}
       */
      dashboardDimensionsUrl: function() {
        return router.dashboard(this.projectId, 'DIMENSIONS');
      },
      /**
       * Removes empty condition groups from rootConditionGroup recursively
       */
      cleanupConditions: function() {
        this.rootConditionGroup.deleteEmptyConditions();
      },
      /**
       * Returns whether or not the UI should display the third party integrations tab
       *
       * @return {boolean} whether or not the UI should display the third party integrations tab
       */
      shouldShowThirdPartyTab: function() {
        return _.size(this.thirdPartyConditionMetadataPerProvider) > 0;
      },
      /**
       * Toggles as shown or hidden the conditions from the given provider, and hides other third party conditions.
       *
       * @param {String} unique ID of the third party conditions provider
       */
      toggleSelectedProvider: function(providerId) {
        this.selectedProviderId = this.selectedProviderId === providerId ? null : providerId;
      }
    },

    created: function() {
      this.rootConditionGroup = new ConditionGroup('and');

      this.canUseCustomDimensions = permissions.canUseCustomSegments();

      this.thirdPartyConditionMetadataPerProvider = thirdPartyTargetingConditions.getThirdPartyConditionsTabMetadata();
    },

    ready: function() {
      if (this.serializedConditions) {
        this.setSerializedConditions(this.serializedConditions);
      }

      this.$on('conditionRemoved', this.cleanupConditions.bind(this));
    }
  };
});

/**
 * Audience Service
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/audience',['models/audience','models/condition_group','services/condition'],function() {
  var Audience = require('models/audience');
  var ConditionGroup = require('models/condition_group');
  var conditionService = require('services/condition');

  /**
   * Fetch all audiences belonging to an experiment
   * @param {Model} experiment
   * @param {Deferred}
   */
  function fetchAudiencesById(audienceIds) {
    var deferred = $.Deferred();

    var experimentAudienceDeferreds = _.map(audienceIds, function(audienceId) {
      return Audience.fetch(audienceId);
    });

    $.when.apply($, experimentAudienceDeferreds).then(function() {
      var audiences = [].slice.call(arguments);
      deferred.resolve(audiences);
    }, deferred.reject);

    return deferred;
  }

  /**
   * Fetches all audiences where user_touched == true
   *
   * @param {Integer} projectId
   * @return {Deferred}
   */
  function fetchSavedAudiences(projectId) {
    return Audience.fetchAll({
      project_id: projectId,
      user_touched: true
    });
  }

  /**
   * API Audiences have no conditions
   * @param {Model} audience
   * @return {Boolean}
   */
  function isAPIAudience(audience) {
    if (!audience.id) {
      return false;
    }
    return conditionService.isEmpty(audience.conditions);
  }

  return {
    fetchSavedAudiences: fetchSavedAudiences,
    fetchAudiencesById: fetchAudiencesById,
    isAPIAudience: isAPIAudience,
  };
});

/**
 * Handles ajax error in .fail() handler
 * and prevents the default error handling
 * at page level
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('utils/handle_ajax_error',['require'],function(require) {
  /**
   * Parses out the error message from a failed jqXHR object
   * @param {jqXHR} jqXHR
   * @return {String}
   */
  function parseErrorResponse(jqXHR) {
    var response = JSON.parse(jqXHR.responseText);
    var msg;
    if (response.error) {
      msg = response.error;
    }
    else if (response.errors) {
      msg = response.errors.join('; ');
    } else if (response.message) {
      msg = response.message;
    } else {
      throw new Error("Unable to parse json error responseText");
    }

    return msg;
  }

  /**
   * Function that is passed to an ajax .fail() or .then(fn, handleAajxError(...))
   * When this function is invoked it prevents the default error handling from happening
   * at the page level
   *
   * This is useful for components that would like like to handle non-200 responses
   * in their own way and prevent the default error dialog from appearing.
   *
   * @param {Function} errorHandler
   */
  return function handleAjaxError(errorHandler) {
    // The fail handler passed to .fail()
    // for some reason jQuery 1.7 calls apply with args = [jqXHR, textStatus, error]
    return function onFail(jqXHR) {
      // destructure args
      var msg;
      var handlerReturn;
      try {
        msg = parseErrorResponse(jqXHR);
        // pass the handler the parsed error message
        handlerReturn = errorHandler.call(this, msg);
        // if the errorHandler function explicitly returns false, dont supress error
        if (handlerReturn === false) {
          jsXHR.optlyErrorHandled = false;
        } else {
          jqXHR.optlyErrorHandled = true;
        }
      } catch(e) {}
    }
  }
});

/**
 * Audience Editor component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/audience_editor',['require','exports','module','lodash','models/audience','models/experiment','services/permissions','services/audience','services/router','utils/handle_ajax_error','flux'],function(require, exports, module) {
  var _ = require('lodash');
  var Audience = require('models/audience');
  var Experiment = require('models/experiment');
  var permissionSvc = require('services/permissions');
  var audienceSvc = require('services/audience');
  var router = require('services/router');
  var handleAjaxError = require('utils/handle_ajax_error');
  var flux = require('flux');

  return {
    template: '#audience-editor-template',

    data: {
      // deferred resolved on save
      _onSave: null,
      audience: {},
      error: null,
      /**
       * The current experiment in context.  If this component is instantiated from the dashboard
       * then there is no currentExperiment
       */
      currentExperiment: null,
      experiments: [],
      isAPIOnly: false,
      isLoading: true,
      isNew: true,
      isSaving: false,
      openReportingSlots: 0,
      originalAudience: {},
      // expose the componentType so it can be passed down to the and-or-targeting component
      closeEvent: 'hideDialog'
    },

    computed: {
      /**
       * Format this.error to show each error on newline if an array
       * @return {Array|null}
       */
      displayErrors: function() {
        var errors = null;
        if (_.isString(this.error) && this.error) {
          errors = [this.error];
        } else if (_.isArray(this.error)){
          errors = this.error;
        }
        return (errors) ? errors.join("<br />") : errors;
      },
      /**
       * Compute the number of open slots, if the audience was saved as-is (relevant when audience.segmentation
       * changes while dialog is open)
       * @returns {number}
       */
      openReportingSlotsIfSaved: function() {
        var currentSlots = this.openReportingSlots;

        if (this.originalAudience.segmentation && !this.audience.segmentation) {
          // segmentation was enabled, but is not now
          currentSlots++;
        } else if (!this.originalAudience.segmentation && this.audience.segmentation) {
          // segmentation was NOT enabled, but is now
          currentSlots--;
        }

        return currentSlots;
      },
      /**
       * Whether the segmentation status can be toggled
       * Return true if all slots are used and segmentation is off
       * @returns {boolean}
       */
      cannotEnableReporting: function() {
        var canEnable = true;
        if (this.openReportingSlotsIfSaved <= 0) {
          // if open slots is 0, we can only turn it off
          canEnable = this.audience.segmentation;
        }
        return !canEnable;
      },
      /**
       * Should show save warning alerting user about audience being used in other experiments
       * @return {Boolean}
       */
      shouldShowSaveWarning: function() {
        var numberExperimentsUsedIn = this.experiments.length;
        if (this.currentExperiment) {
          // in the context of another experiment
          var experimentIds = this.experiments.map(function(experiment) {
            return experiment.id;
          });
          if (experimentIds.indexOf(this.currentExperiment.id) !== -1) {
            numberExperimentsUsedIn--;
          }
        }

        return (numberExperimentsUsedIn > 0);
      },
      /**
       * Does the user have permission to make Audiences segmentation enabled?
       * @returns {boolean}
       */
      canMakeAudiencesReportable: function() {
        return permissionSvc.canUseCustomSegments();
      },
      /**
       * Experiment ID for currentExperiment
       * @returns {?number}
       */
      experimentId: function() {
        if (!this.currentExperiment) {
          return null;
        }
        return this.currentExperiment.id;
      },
      title: function() {
        return this.isNew ? tr('Create new audience') : tr('Edit audience') ;
      },
      cancelText: function() {
        return this.currentExperiment ? tr('Back') : tr('Cancel');
      },
      saveText: function() {
        return this.currentExperiment ? tr('Save') : tr('Save Audience');
      }
    },

    methods: {
      close: function() {
        this.$dispatch(this.closeEvent);
      },
      experimentEdit: function(experimentId) {
        return router.experimentEdit({
          experimentId: experimentId
        });
      },
      /**
       * Submit handler that notifies all child components to validate
       * and then waits for their response to either save or show an error
       *
       * @param {Event} event
       */
      handleSubmit: function(event) {
        // Prevent default submit from happening
        event.preventDefault();

        if (!this.isAPIOnly) {
          // conditionsComponent isn't present in API only audiences
          this.$.conditionsComponent.validate().then(
            function() {
              this.save();
            }.bind(this),
            function(errors) {
              this.error = errors;
            }.bind(this)
          );
        } else {
          this.save();
        }
      },
      /**
       * Save the Audience as configured using the API
       */
      save: function() {
        var isCodeMode = false;
        // conditionsComponent isn't present in API only audiences
        if (!this.isAPIOnly) {
          isCodeMode = this.$.conditionsComponent.isCodeMode;
          this.audience.conditions = this.$.conditionsComponent.getSerializedConditions();
        }

        this.isSaving = true;

        // Use flux apiActions.persistEntity here so that all components receive the updated entity
        flux.actions('api').persistEntity(Audience, this.audience).done(function(savedAudience) {
          // if _onSave deferred is present, resolve it
          if (this._onSave) {
            // resolve with a new instance of the audience
            this._onSave.resolve(savedAudience);
          }

          if (this.isNew) {
            this.$dispatch('audience-editor:audienceCreated', savedAudience);
          }

          this.$dispatch(this.closeEvent);
        }.bind(this))
        .fail(handleAjaxError(function(reason) {
          if (isCodeMode) {
            this.error = 'Invalid ' + reason;
          } else {
            this.error = reason;
          }
        }.bind(this)))
        .always(function() {
          this.isSaving = false;
        }.bind(this));
      }
    },

    ready: function() {
      if (!this.audience.project_id){
        throw new Error('data.audience must be passed with project_id to the audience-editor component');
      }

      // dereference audience
      this.audience = Audience.create(this.audience);
      // make a copy of the audience for backup
      this.originalAudience = Audience.create(this.audience);

      // at this point the this.audience is fully loaded
      this.isLoading = false;

      if (this.audience.id) {
        this.isNew = false;
        this.isAPIOnly = audienceSvc.isAPIAudience(this.audience);
        // Fetch related experiments for pre-existing audiences
        Experiment.fetchAll({
          project_id: this.audience.project_id,
          audiences: this.audience.id
        }).then(function(experiments) {
          this.experiments = experiments;
          if (this.currentExperiment) {
            if (_.indexOf(_.pluck(this.experiments, 'id'), this.currentExperiment.id) === -1) {
              this.experiments.unshift(this.currentExperiment);
            }
          }
        }.bind(this));
      }
    }
  };
});

/**
 * Code Mirror Component
 *
 * @author Sam Jackson (sam@optimizely.com)
 *
 */
define('components/code_mirror',['require','exports','module'],function(require, module, exports) {
  var PREFIX = 'codeMirror:';

  return {
    data: {
      _editor: null,

      // TODO -- make these extensible
      _defaultEditorOptions: {
        // Custom written option to show errors in gutters
        annotations: true,
        // Add Ctrl-Enter to the keymap so it will fire the keyHandled event when pressed
        extraKeys: {
          'Ctrl-Enter': function () {},
          'Ctrl-Space': 'autocomplete'
        },
        fixedGutter: true,
        // Required for annotations to work
        gutters: ["CodeMirror-lint-markers"],
        lineNumbers: true,
        lineWrapping: true,
        matchBrackets: true,
        mode: "javascript",
        tabSize: 2
      },
      _code: '',
      isDirty: false
    },
    computed: {
      editorCode: function () {
        return this._editor && this._editor.getValue ? this._editor.getValue() : '';
      },
      code: {

        // Re-instantiate editor when we set new code to keep things simple --
        // this guarantees that the editor is instantiated and the right size
        // when we reset the code
        $set: function (value) {
          this._code = value;
          this.createEditor();
          this.setEditorValue(this._code);
        },
        $get: function () {
          return this._code;
        }
      }
    },
    methods: {

      /**
       * For some reason, CodeMirror will appear as blank when you set the editor value to a long string.
       * The text will appear when a user interacts with the editable area, however that's not ideal.
       * Using scrollTo immediately after setting the value fixes the problem.
       *
       * See https://github.com/optimizely/optimizely/pull/3431
       *
       * @private
       */
      _fixLongTextRendering: function () {
        this._editor.scrollTo(null, 10000);
      },

      /**
       * Handle CodeMirror event fired when a change is made to the code. Set the dirty flag
       * and notify the parent component.
       *
       * @param editor
       * @param change
       */
      _handleEditorCodeChange: function (editor, change) {
        this.isDirty = this.editorCode !== this.code;
        this.$dispatch(PREFIX + 'ChangeHandled', change);
      },

      /**
       * Handle CodeMirror event when a key is pressed
       *
       * @param editor
       * @param name
       * @param event
       */
      _handleEditorKeyEvent: function(editor, name, event) {
        this.$dispatch(PREFIX + 'KeyHandled', name, event);
      },

      /**
       * Add an annotation to the code based on error object of the format:
       *
       * {
       *   columnNumber: number,
       *   errorMessage: {string},
       *   lineNumber: {number}
       * }
       *
       */
      addAnnotation: function (error) {
        if (this._editor.addAnnotation) {
          if (error.lineNumber > 0 && error.lineNumber <= this._editor.lineCount()) {
            this._editor.addAnnotation(error.errorMessage, 'error', error.lineNumber, error.columnNumber);
          }
        }
      },

      /**
       * Instantiate the editor from a textarea found in the markup
       *
       */
      createEditor: function () {
        this.destroyEditor();
        this._editor = CodeMirror.fromTextArea(this.$el, this._defaultEditorOptions);
        this._editor.on('keyHandled', this._handleEditorKeyEvent.bind(this));
        this._editor.on('change', this._handleEditorCodeChange.bind(this));
      },

      /**
       * Revert the editor back to a textarea
       *
       */
      destroyEditor: function () {
        if (this._editor) {
          this._editor.toTextArea();
          this._editor = null;
        }
      },

      /**
       * Retrieve the code on the requested line number
       *
       * @param lineNumber {number}
       * @returns {string|undefined}
       */
      getLine: function (lineNumber) {
        return this._editor.getLine(lineNumber);
      },

      /**
       * Trigger linter if it is enabled
       *
       */
      lintCode: function () {
        if (this._editor.lint) {
          this._editor.lint();
        }
      },

      /**
       * There are issues with the drawer screwing up sizing and location of the editor cursor
       * when the value changes. This is a convenience method that gets around those issues.
       *
       */
      rebuildEditor: function () {
        var code = this.editorCode;
        this.createEditor();
        this.setEditorValue(code);
      },

      /**
       * This should be called whenever the CodeMirror container resizes
       *
       */
      refresh: function () {
        this._editor.refresh();
      },

      /**
       * Set the value of the code in editable area of the editor
       *
       * @param code
       */
      setEditorValue: function (code) {
        this._editor.setValue(code);
        this._fixLongTextRendering();
        this.lintCode();
      },

      /**
       * Set the value of the code in the editor using the code property's setter,
       * which performs some operations that setEditorValue does not
       *
       * @param {string} code
       * @param {Object} editorOptions
       */
      setCode: function(code, editorOptions) {
        // eventually we want to have a utility method such as underscore's _extend to
        // copy over values and override them
        if (editorOptions && editorOptions.mode) {
          this.$data._defaultEditorOptions.mode = editorOptions.mode;
        }
        this.code = code;
      },

      /**
       * Sets the isDirty property
       *
       * @param {boolean} isDirty
       */
      setDirtyFlag: function(isDirty) {
        // coerce value into a boolean
        this.isDirty = !!isDirty;
      }
    },

    /**
     * Remove CodeMirror instance from DOM before we destroy the component
     *
     */
    beforeDestroy: function () {
      this.destroyEditor();
    },

    created: function () {
      this.createEditor();
      this.$on('editCodeDrawer:OpenComplete', this.rebuildEditor.bind(this));
      this.$on('editCodeDrawer:Resize', this.refresh.bind(this));
      this.$on(PREFIX + 'addAnnotation', this.addAnnotation.bind(this));
      this.$on(PREFIX + 'lintCode', this.lintCode.bind(this));
      this.$on(PREFIX + 'rebuildEditor', this.rebuildEditor.bind(this));
      this.$on(PREFIX + 'refreshEditor', this.refresh.bind(this));
      this.$on(PREFIX + 'setCode', this.setCode.bind(this));
      this.$on(PREFIX + 'setDirtyFlag', this.setDirtyFlag.bind(this));
    }
  };
});

/**
 * A "Copy to Clipboard" component, powered by ZeroClipboard. Add this
 * to an element with:
 *
 * - `data-clipboard-target="someID"` and add `id="someID" to the DOM
 *    element whose text/value should be copied.
 * - Alternatively, add `data-clipboard-text="Copy Me!"` to the element
 *   to copy the contents of the string.
 *
 * You may optionally provide a temporary success message
 * with `data-clipboard-successText=""`
 *
 * The 'isLoaded' flag tells us if flash is loaded since ZeroClipboard
 * relies on flash being present. This flag can be used to hide the
 * copy button if flash is not loaded using the v-show directive.
 *
 * Example:
 *
 * <pre id="code">This will be copied.</pre>
 *
 * <button data-clipboard-target="code"
 *         data-clipboard-successText="Copied!"
 *         v-component="copier"
 *         v-show="isLoaded">
 *   Copy to Clipboard
 * </button>
 *
 * @author Daniel O'Connor (daniel@optimizely.com)
 */

define('components/copier',['require','exports','module','app'],function(require, module, exports) {

  var app = require('app');

  /**
   * The number of milliseconds a success message is displayed.
   * @var {Number}
   */
  var SUCCESS_TEXT_DELAY = 2300;

  return {
    data: {
      isLoaded: false
    },
    methods: {
      /**
       * Gets the copy success text fron a data
       * attribute.
       *
       * @param {HTMLElement} button
       * @return {String|undefined}
       */
      _getSuccessText: function(button) {
        var successText = button.getAttribute('data-clipboard-successText');

        return successText;
      },
      /**
       * Fires on `aftercopy` event and sets a success
       * message, if desired.
       *
       * @param {Event} event
       */
      _onAfterCopy: function(event) {
        var button = event.target;
        var successText = this._getSuccessText(button);

        if (successText) {
          var self = this;
          var originalText = button.innerText;
          var originalWidth = button.offsetWidth;

          // Add a success message
          this._setText(button, successText);

          // Revert to the original message
          setTimeout(function() {
            self._setText(button, originalText, originalWidth);
          }, SUCCESS_TEXT_DELAY);
        } else {
          app.$broadcast('notify', {
            message: tr('Copied to clipboard.'),
          });
        }
      },
      /**
       * Temporaraily change the text of a button, revert, and
       * maintain the original width if `successText` increases
       * the width of the button.
       *
       * @param {HTMLElement} button
       * @param {String} successText
       * @param {Number} width
       */
      _setText: function(button, successText, width) {
        var originalWidth = button.offsetWidth;

        button.innerText = successText;

        // Reset the width
        button.style.width = 'auto';

        if (width) {
          // Set a custom defined width
          button.style.width = width + 'px';
        } else if (button.offsetWidth < originalWidth) {
          // New width is smaller than previous. Maintain
          // the original width.
          button.style.width = originalWidth + 'px';
        }
      }
    },
    ready: function() {
      var self = this;

      // http://zeroclipboard.org/
      ZeroClipboard.config({
        activeClass: 'lego-button--active',
        forceHandCursor: true,
        hoverClass: 'lego-button--hover',
        swfPath: '/static/swf/ZeroClipboard.swf'
      });

      var client = new ZeroClipboard(this.$el);

      client.on('ready', function(readyEvent) {
        self.isLoaded = true;
        client.on('aftercopy', function(event) {
          self._onAfterCopy(event);
        });
      });
    }
  };
});


define('text!components/dashboard/projects/projects_tab.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n  <!-- Sub Tabs -->\n  <div class="lego-tabs lego-tabs--small lego-tabs--sub push-half--top" v-tabs="subTabs">\n    <ul class="lego-tabs-nav soft-double--left">\n      <li class="lego-tabs-nav__item"\n        v-on="click: switchSubtab(\'experiments\')"\n        v-class="tab-active: activeSubtab === \'experiments\'">\n        Experiments\n      </li>\n      <li class="lego-tabs-nav__item"\n        v-on="click: switchSubtab(\'audiences\')"\n        v-class="tab-active: activeSubtab === \'audiences\'"\n        v-if="shouldSeeAudiences">\n        Audiences\n      </li>\n      <li class="lego-tabs-nav__item"\n        v-on="click: switchSubtab(\'dimensions\')"\n        v-class="tab-active: activeSubtab === \'dimensions\'"\n        v-if="shouldSeeDimensions">\n        Dimensions\n      </li>\n      <li class="lego-tabs-nav__item"\n        v-on="click: switchSubtab(\'change-history\')"\n        v-class="tab-active: activeSubtab === \'change-history\'">\n        Change History\n      </li>\n    </ul>\n  </div>\n  <div v-view="activeSubtab"></div>\n</div>\n';});


define('text!services/project_code_ios.txt',[],function () { return '[Optimizely startOptimizelyWithAPIToken:\n@"%s"\nlaunchOptions:launchOptions];';});


define('text!services/project_config_android.txt',[],function () { return '{\n  "apiKey": "%s",\n  "enableEditGesture": true,\n  "enableVerboseLogging": true\n}\n';});


define('text!services/project_code_android.txt',[],function () { return 'Optimizely.startOptimizely(R.raw.optimizely, getApplication());\n';});

/**
 * Project Service
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/project',['require','text!services/project_code_ios.txt','text!services/project_config_android.txt','text!services/project_code_android.txt','utils/enums','lodash'],function(require) {
  var REPORTING_SLOTS_PER_PROJECT = 10;
  var WEB_SNIPPET_TEMPLATE = "<script src=\"//cdn.optimizely.com/js/%s.js\"></script>";
  var WEB_SNIPPET_SRC_TEMPLATE = "cdn.optimizely.com/js/%s.js";
  var IOS_SNIPPET_TEMPLATE = require('text!services/project_code_ios.txt');
  var ANDROID_CONFIG_TEMPLATE = require('text!services/project_config_android.txt');
  var ANDROID_SNIPPET_TEMPLATE = require('text!services/project_code_android.txt');
  var MOBILE_BASE_ENDPOINT = '/mobile';

  var enums = require('utils/enums');

  var _ = require('lodash');

  /**
   * Gets the number of open reporting slots for a specific project
   * calculated by the projects audiences and dimensions
   *
   * @param {Array.<Object>} audiences
   * @param {Array.<Object>} dimensions
   * @return {Integer}
   */
  function getOpenReportingSlots(audiences, dimensions) {
    var segmentationAudiences = audiences.filter(function(aud) {
      return aud.segmentation;
    });
    var usedSlots = segmentationAudiences.length + dimensions.length;
    return REPORTING_SLOTS_PER_PROJECT - usedSlots;
  }


  /**
   * Generates the snippet code for a web project
   * @param {Integer} projectId
   */
  function webProjectCode(projectId) {
    return sprintf(WEB_SNIPPET_TEMPLATE, projectId);
  }

  /**
   * Generates the install code for an iOS project
   * @param {String} socketToken
   */
  function iOSProjectCode(socketToken) {
    return sprintf(IOS_SNIPPET_TEMPLATE, socketToken);
  }

  /**
   * Generates the install code for an Android project
   * @param {String} socketToken
   */
  function androidProjectCode(socketToken) {
    return ANDROID_SNIPPET_TEMPLATE;
  }

  /**
   * Generates the configuration JSON for an Android project
   * @param {String} socketToken
   */
  function androidProjectConfig(socketToken) {
    return sprintf(ANDROID_CONFIG_TEMPLATE, socketToken);
  }

  /**
   * Generates the project code for a project, depending on platform
   * @param {Object} project
   * @param {String} platform
   * @return {String} Code for the passed in platform or error string
   */
  function projectCode(project, platform) {
    var code = '';
    switch(platform) {
      case enums.ProjectPlatformType.WEB:
        code = webProjectCode(project.id);
        break;
      case enums.ProjectPlatformType.IOS:
        code = iOSProjectCode(project.socket_token);
        break;
      case enums.ProjectPlatformType.ANDROID:
        code = androidProjectCode(project.socket_token);
        break;
      default:
        code = tr('Unsupported Platform');
    }
    return code;
  }

  /**
   * Fetches a project via the legacy API.
   * @param {Integer} projectId
   */
  function fetchProject(projectId) {
    return $.ajax({
        url: '/api/projects/' + projectId + '/',
        type: 'GET'
    }).pipe(function(response) {
      return response.project;
    });
  }

  /**
   * Returns true if this is a web project
   * @param {Object} project
   */
  function isWebProject(project) {
    return _.contains(project.project_platforms, enums.ProjectPlatforms.WEB);
  }

  /**
   * Returns true if this is a mobile project
   * @param {Object} project
   */
  function isMobileProject(project) {
    return isiOSProject(project) || isAndroidProject(project);
  }

  /**
   * Returns true if this is an iOS project
   * @param {Object} project
   */
  function isiOSProject(project) {
    return _.contains(project.project_platforms, enums.ProjectPlatforms.IOS);
  }

  /**
   * Returns true if this is an Android project
   * @param {Object} project
   */
  function isAndroidProject(project) {
    return _.contains(project.project_platforms, enums.ProjectPlatforms.ANDROID);
  }

  /**
   * Triggers a handler to email project code to a developer
   * Only works with web projects due to Marketo implementation
   * @param {String} email
   * @param {Object} project
   */
  function sendProjectCode(email, project) {
    var snippetSrc = sprintf(WEB_SNIPPET_SRC_TEMPLATE, project.id);
    $.ajax({
      url: '/project/send_code',
      type: 'POST',
      data: {
        email: email,
        snippetSrc: snippetSrc
      }
    });
  }

  /**
   * Save a project name to a mobile project
   * @param {String} name The name of the project
   * @param {String} platform `ios` or `android`
   * @param {String} nextStep `install` or `email`
   * @returns {Object} A jQuery deferred object
   */
  function addProjectName(name, platform, nextStep) {
    return $.ajax({
      url : MOBILE_BASE_ENDPOINT + '/add-project-name',
      type: 'POST',
      data: {
        project_name: name,
        project_platform: platform,
        next_step: nextStep
      }
    });
  }

  /**
   * Since this is often used while polling, we ask Optimizely to ignore errors so you should handle them yourself.
   * @param projectId
   */
  function checkSDKInstalled(projectId) {
    return $.ajax({
       url: MOBILE_BASE_ENDPOINT + '/is-installed?project_id=' + projectId,
       type: 'GET',
       optimizelyCancelRetryLimit: 0,
       optimizelyIgnoreErrors: true
    });
  }

  /**
   * Send the sdk installation instructions for the current project to the given emails
   * @param {Integer} project id that we should send the install instructions for
   * @param {Array} emails List of emails to send the instructions to
   * @param {String} string representing the custom message from sender
   */
  function emailSDKInstructions(projectId, emails, customMessage) {
    return $.ajax({
      url: MOBILE_BASE_ENDPOINT + '/send-email',
      type: 'POST',
      data: {
        project_id: projectId,
        emails: emails,
        message_body: customMessage
      }
    });
  }

  /**
   * See a project has experiments that are not archived.
   * @param {Integer} projectId
   */
  function hasExperiments(projectId) {
    return $.ajax("/api/experiments.json", {
      data: {
        project_ids: projectId,
        status: enums.ExperimentStatusType.RUNNING + ',' +
                enums.ExperimentStatusType.PAUSED + ',' +
                enums.ExperimentStatusType.NOT_STARTED
      },
      optimizelyRetryLimit: 3
    });
  }

  return {
    addProjectName: addProjectName,
    checkSDKInstalled: checkSDKInstalled,
    emailSDKInstructions: emailSDKInstructions,
    fetchProject: fetchProject,
    getOpenReportingSlots: getOpenReportingSlots,
    hasExperiments: hasExperiments,
    iOSProjectCode: iOSProjectCode,
    isAndroidProject: isAndroidProject,
    isiOSProject: isiOSProject,
    isMobileProject: isMobileProject,
    isWebProject: isWebProject,
    projectCode: projectCode,
    sendProjectCode: sendProjectCode,
    iOSProjectCode: iOSProjectCode,
    androidProjectCode: androidProjectCode,
    webProjectCode: webProjectCode,
    androidProjectConfig: androidProjectConfig
  };
});

/**
 * Function getter to take currentProject + projects store
 * and return the singular currentProject
 */
define('flux/getters/current_project',[],function() {
  return [
    'currentProject',
    'projects',
    function (currentProjectStore, projectStore) {
      var id = currentProjectStore.getId();
      if (!id) {
        return {};
      }
      return projectStore.get(id) || {};
    }
  ];
});


define('text!components/dashboard/projects/experiments/experiments_tab.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group">\n  <div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n    <div class="lego-pane lego-fence--soft">\n\n      <!-- Toolbar -->\n      <ul class="flex push-double--ends" data-ui-component="dashboard-toolbar"\n          v-if="hasExperiments">\n        <li class="push-triple--right">\n          <div class="lego-button-group">\n            <div class="lego-dropdown-group" v-dropdown>\n              <button class="lego-button" type="button" data-toggle-dropdown>\n                <span v-text="filters.statusString | capitalize"></span>\n                <span class="lego-arrow-inline--down"></span>\n              </button>\n              <ul class="lego-dropdown">\n                <li class="lego-dropdown__item">\n                <a href="javascript:void(0)" class="lego-dropdown__block-link" v-on="click: setStatusFilter(\'active\')" data-hide-dropdown>\n                    Active\n                  </a>\n                </li>\n                <li class="lego-dropdown__item">\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link" v-on="click: setStatusFilter(\'running\')" data-hide-dropdown>\n                    <span class="push-half--left">Running</span>\n                  </a>\n                </li>\n                <li class="lego-dropdown__item">\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link" v-on="click: setStatusFilter(\'paused\')" data-hide-dropdown>\n                    <span class="push-half--left">Paused</span>\n                  </a>\n                </li>\n                <li class="lego-dropdown__item">\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link" v-on="click: setStatusFilter(\'draft\')" data-hide-dropdown>\n                    <span class="push-half--left">Draft</span>\n                  </a>\n                </li>\n                <li class="lego-dropdown__item">\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link" v-on="click: setStatusFilter(\'archived\')" data-hide-dropdown>\n                    Archived\n                  </a>\n                </li>\n              </ul>\n            </div>\n            <input type="text" class="lego-text-input lego-text-input--search width-200" placeholder="Filter by Name"\n              v-on="keyup: setStringFilter($event)"\n            v-value="filters.string" />\n          </div>\n        </li>\n        <li class="push--right">\n          <div class="lego-button-group" v-if="!inArchive">\n            <button class="lego-button lego-button--secondary"\n              v-lego-disabled="!(canStartExperiment && canStartChecked)"\n              v-on="click: startExperiments(selectedExperiments)"\n              v-poptip data-dir="top" data-content="Start"\n              data-test-section="experiment-start-button">\n              <svg class="lego-icon"><use xlink:href="#play"></use></svg>\n            </button>\n            <button class="lego-button lego-button--secondary"\n              v-lego-disabled="disabled: !(canPauseExperiment && canPauseChecked)"\n              v-on="click: pauseExperiments(selectedExperiments)"\n              v-poptip data-dir="top" data-content="Pause"\n              data-test-section="experiment-pause-button">\n              <svg class="lego-icon"><use xlink:href="#pause"></use></svg>\n            </button>\n          </div>\n        </li>\n        <li class="push--right">\n          <div class="lego-button-group">\n            <div class="lego-dropdown-group" v-dropdown\n              data-test-section="duplicate-dropdown">\n              <button class="lego-button lego-button--secondary"\n                v-lego-disabled="!(canCreateExperiment && canDuplicateChecked)"\n                v-poptip data-dir="top" data-content="Duplicate"\n                data-toggle-dropdown>\n                <svg class="lego-icon"><use xlink:href="#duplicate"></use></svg>\n                <span class="lego-arrow-inline--down"></span>\n              </button>\n              <ul class="lego-dropdown">\n                <li class="lego-dropdown__item">\n                  <div class="soft-half--ends">\n                    <input type="text"\n                      class="lego-text-input lego-text-input--search"\n                      placeholder="Filter Projects by Name"\n                      v-model="projectFilter">\n                  </div>\n                </li>\n                <li class="lego-dropdown__item">\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link"\n                    v-on="click: duplicateExperiment(selectedExperiments[0], currentProject)"\n                    data-hide-dropdown>\n                    <b>[[ currentProject.project_name ]]</b>\n                  </a>\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link"\n                    v-repeat="project: duplicationTargetProjects | filterBy projectFilter in \'project_name\' | orderBy \'project_name\'"\n                    v-on="click: duplicateExperiment(selectedExperiments[0], project)"\n                    data-hide-dropdown>\n                    [[ project.project_name ]]\n                  </a>\n                </li>\n              </ul>\n            </div>\n            <button class="lego-button lego-button--secondary"\n              v-lego-disabled="disabled: !(canArchiveExperiment && canArchiveChecked)"\n              v-on="click: archiveExperiments(selectedExperiments)"\n              v-poptip data-dir="top" data-content="Archive"\n              data-test-section="experiment-archive-button"\n              v-if="!inArchive">\n              <svg class="lego-icon"><use xlink:href="#archive"></use></svg>\n            </button>\n            <button class="lego-button lego-button--secondary"\n              v-lego-disabled="disabled: !(canArchiveExperiment && canUnarchiveChecked)"\n              v-on="click: unarchiveExperiments(selectedExperiments)"\n              data-test-section="experiment-unarchive-button"\n              v-if="inArchive">\n              Unarchive\n            </button>\n          </div>\n        </li>\n        <li class="anchor--right">\n          <button class="lego-button lego-button--highlight"\n            v-lego-disabled="!canCreateExperiment"\n            v-if="currentProject"\n            v-on="click: showCreateExperiment(currentProject.id)">New Experiment\n          </button>\n        </li>\n      </ul>\n    </div>\n\n    <div class="lego-pane lego-pane--flex-1 lego-pane--scroll-y" v-loading="dashboard.experiments">\n      <table class="lego-table lego-table--dashboard" id="dashboard-experiments"\n        v-if="shownExperiments.length > 0"\n        v-show="hasExperiments">\n        <thead>\n          <tr>\n            <th class="nowrap" v-component="sortable-th" field="description">\n              Name\n            </th>\n            <th class="nowrap cell-collapse" v-component="sortable-th" field="status" type="experimentStatus">\n              Status\n            </th>\n            <th class="numerical nowrap" v-component="sortable-th" field="visitors" type="number">\n              Visitors\n            </th>\n            <th class="numerical nowrap" v-component="sortable-th" field="goals" type="length">\n              Goals\n            </th>\n            <th class="numerical nowrap" v-component="sortable-th" field="last_modified" type="date">\n              Modified\n            </th>\n            <th class="numerical nowrap" v-component="sortable-th" field="created" type="date">\n              Created\n            </th>\n          </tr>\n        </thead>\n        <tbody v-prevent-shift-selection>\n          <tr v-repeat="experiment: shownExperiments"\n            v-component="experiment-table-row">\n          </tr>\n        </tbody>\n      </table>\n\n      <div v-if="hasExperiments && shownExperiments.length === 0 && hasFilters" class="lego-fence--soft">\n        No experiments match your filters. Try <a href="javascript:void(0)" v-on="click: clearFilters">clearing them</a> to see all your experiments.\n      </div>\n\n      <div v-if="!hasExperiments" \n         v-component="dashboard/empty" v-with="project: currentProject"></div>\n    </div>\n\n  </div>\n  <div class="lego-pane lego-data-sidebar lego-pane--flex"\n    v-component="experiment-sidebar">\n  </div>\n</div>\n';});

/**
 * Provide a promise-based interface similar to window.confirm but with options for the dialog.
 *
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('services/confirm',['require','app'],function(require) {
  var app = require('app');

  /**
   * Spawn a confirmDialog, and return a promise that is resolved when the confirm is accepted.
   * @param {{ '{{' }}title: (string|undefined),
   *          isWarning: (boolean|undefined),
   *          message: (string|undefined),
   *          confirmText: (string|undefined),
   *          cancelText: (string|undefined){{ '}}' }} componentData
   * @returns {Deferred}
   */
  return {
    confirm: function(componentData) {
      var onConfirm = $.Deferred();

      var data = _.extend({}, componentData, {
        _confirmDeferred: onConfirm
      });

      // show the confirm dialog
      app.$broadcast('showConfirmDialog', {
        component: 'dialogs/confirm',
        data: data
      });

      return onConfirm;
    }
  };
});

/**
 * Gets all projects for your account
 */
define('flux/getters/projects',[],function() {
  return [
    'account',
    'projects',
    function(accountStore, projectStore) {
      return projectStore.getAll({
        account_id: accountStore.getId(),
      });
    }
  ]
})
;
/**
 * Function getter to take currentProject + experiments store
 * and return all experiments for that project
 */
define('flux/getters/current_project/experiments',[],function() {
  return [
    'currentProject',
    'experiments',
    function (currentProject, experiments) {
      var currentProjectId = currentProject.getId()
      if (currentProjectId) {
        return experiments.getAll({
          project_id: currentProjectId
        });
      } else {
        return [];
      }
    }
  ];
});

/**
 * Gets all experiments to be shown on the dashboard by taking into account
 * the current project experiments and the active filters on the dashboard
 */
define('flux/getters/dashboard/filtered_experiments',['utils/enums','flux/getters/current_project/experiments'],function() {
  var ExperimentStatusType = require('utils/enums').ExperimentStatusType;
  var getCurrentProjectExperiments = require('flux/getters/current_project/experiments');

  /**
   * This has to match the id attribute of the table being sorted
   */
  var tableId = 'dashboard-experiments';

  return [
    getCurrentProjectExperiments,
    'experimentResults',
    'goals',
    'sortableTable',
    'dashboard/tableFilters',
    /**
     * This function composes the current experiments with their results, goals and does any
     * sort of filtering / sorting based on the state of the dashboard UI
     */
    function (experiments, experimentResultsStore, goalStore, sortableTableStore, filterStore) {
      var sortFn = sortableTableStore.getSortFn(tableId);
      var filtered = experiments;

      var filters = filterStore.getFilters('experiments');
      var filterString = filters.string;
      var status = filters.status;

      if (status.length > 0) {
        filtered = experiments.filter(function(exp) {
          return _.contains(status, exp.status);
        })
      }

      if (filterString) {
        filterString = filterString.toLowerCase();
        filtered = filtered.filter(function(exp) {
          var id = exp.id.toString();
          var desc = exp.details.toLowerCase();
          var title = exp.description.toLowerCase();
          return _.contains(desc, filterString)
              || _.contains(title, filterString)
              || _.contains(id, filterString);
        });
      }

      var filtered = filtered.map(function(exp) {
        var visitorCount;

        exp.goals = goalStore.getAll({
          experiment_ids: exp.id
        });

        if (exp.status === ExperimentStatusType.NOT_STARTED) {
          visitorCount = -1;
        }
        var results = experimentResultsStore.get(exp.id);
        if (!results) {
          visitorCount = -1;
        } else {
          visitorCount = results.visitors;
        }

        exp.visitors = visitorCount;

        return exp;
      });

      if (sortFn) {
        filtered.sort(sortFn);
      }

      return filtered;
    }
  ];
});

/**
 * Gets the selected experiment for the sidebar on the dashboard
 */
define('flux/getters/dashboard/selected_experiments',['flux/getters/dashboard/filtered_experiments'],function() {
  var getDashboardFilteredExperiments = require('flux/getters/dashboard/filtered_experiments');

  return [
    'dashboard/selectedItems',
    getDashboardFilteredExperiments,
    function (selectedItems, experiments) {
      var selectedIds = selectedItems.getSelectedIds('experiments');
      return _(selectedIds)
        .map(function(id) {
          return _.find(experiments, { id: id });
        })
        .filter()
        .value();
    }
  ];
});

/**
 * Gets all active projects for your account
 */
var enums = require('utils/enums');

define('flux/getters/active_projects',[],function() {
  return [
    'account',
    'projects',
    function(accountStore, projectStore) {
      return projectStore.getAll({
        account_id: accountStore.getId(),
        project_status: enums.ProjectStatusType.ACTIVE,
      });
    }
  ]
})
;
/**
 * Get possible project targets for entity duplication.
 */

define('flux/getters/duplication_target_projects',['flux/getters/active_projects','flux/getters/current_project'],function() {
  var getActiveProjects = require('flux/getters/active_projects');
  var getCurrentProject = require('flux/getters/current_project');
  
  return [
    getActiveProjects,
    getCurrentProject,
    function(activeProjects, currentProject) {
      return activeProjects.filter(function(proj) {
        // filter out the current project
        if (proj.id === currentProject.id) {
          return false;
        }
        var currentPlatform = currentProject.project_platforms[0];
        return proj.project_platforms.indexOf(currentPlatform) !== -1;
      });
    },
  ];
});


define('text!components/dashboard/projects/experiments/experiment_table_row.html',[],function () { return '<tr v-on="click: clickExperiment($event, experiment)"\n  v-class="lego-table-row--active: isSelected"\n  v-loading-entity="experiment.id" entity="experiments" spinner-size="small"\n  data-table-row-id="[[ experiment.id ]]">\n\n  <td class="cell-truncate">\n    <div class="cell-truncate__text">\n      <span v-repeat="tag: tags" class="lego-tag">[[ tag ]] </a>\n    </div>\n    <div class="cell-truncate__title">[[ experiment.description ]]</div>\n  </td>\n\n  <td>\n    <span class="[[ experiment.status | statusClass ]]">\n      [[ experiment.status | statusRemap ]]\n    </span>\n  </td>\n\n  <td class="numerical">\n    <span v-if="experiment.visitors === -1">\n      --\n    </span>\n\n    <span v-if="experiment.visitors !== -1">\n      [[ experiment.visitors | number-with-commas ]]\n    </span>\n  </td>\n\n  <td class="numerical">\n    <div>[[ experiment.goals.length ]]</div>\n  </td>\n\n  <td class="numerical">\n    <div class="nowrap"> [[ experiment.last_modified | shortdate ]] </div>\n  </td>\n\n  <td class="numerical">\n    <div class="nowrap"> [[ experiment.created | shortdate ]] </div>\n  </td>\n</tr>\n';});

/**
 * Utils for regular expressions
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('utils/regex',['require','exports','module'],function(require, exports, module) {

  /**
   * Finds all matching URLs. From https://github.com/component/regexps/blob/master/index.js#L3
   */
  exports.urls = /(?:(?:ht|f)tp(?:s?)\:\/\/|~\/|\/)?(?:\w+:\w+@)?((?:(?:[-\w\d{1-3}]+\.)+(?:com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|edu|co\.uk|ac\.uk|it|fr|tv|museum|asia|local|travel|[a-z]{2}))|((\b25[0-5]\b|\b[2][0-4][0-9]\b|\b[0-1]?[0-9]?[0-9]\b)(\.(\b25[0-5]\b|\b[2][0-4][0-9]\b|\b[0-1]?[0-9]?[0-9]\b)){3}))(?::[\d]{1,5})?(?:(?:(?:\/(?:[-\w~!$+|.,=]|%[a-f\d]{2})+)+|\/)+|\?|#)?(?:(?:\?(?:[-\w~!$+|.,*:]|%[a-f\d{2}])+=?(?:[-\w~!$+|.,*:=]|%[a-f\d]{2})*)(?:&(?:[-\w~!$+|.,*:]|%[a-f\d{2}])+=?(?:[-\w~!$+|.,*:=]|%[a-f\d]{2})*)*)*(?:#(?:[-\w~!$ |\/.,*:;=]|%[a-f\d]{2})*)?/ig;

  exports.hashtags = /#\w*/g;

  exports.email = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  

});

/**
 * Experiment Table Row on Dashboard
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/projects/experiments/experiment_table_row',['require','text!components/dashboard/projects/experiments/experiment_table_row.html','flux','utils/regex','services/events','utils/enums'],function(require) {
  var tmpl = require('text!components/dashboard/projects/experiments/experiment_table_row.html');
  var flux = require('flux');
  var regex = require('utils/regex');
  var events = require('services/events');
  var ExperimentStatusType = require('utils/enums').ExperimentStatusType;

  var EMPTY_VISITOR_COUNT_PLACE_HOLDER = '--';

  return {
    filters: {
      statusClass: function(status) {
        if (status == 'Running') {
          return 'good-news';
        } else {
          return 'muted';
        }
      },

      statusRemap: function(status) {
        if (status == 'Not started') {
          return 'Draft';
        } else {
          return status;
        }
      }
    },

    template: tmpl,

    replace: true,

    data: {
      experiment: {},
      isSelected: false,
    },

    computed: {
      tags: function() {
        var description = this.experiment.details;
        if (!description) {
          return [];
        }
        return description.match(regex.hashtags); // Find all words starting with hashtags
      }
    },

    methods: {
      /**
       * @param {Event} event
       * @param {Object} experiment
       */
      clickExperiment: function(event, experiment) {
        flux.actions('dashboard').clickItem('experiments', experiment, event.shiftKey);
        flux.actions('dashboard').replaceUrl();
      },

    },

    ready: function() {
      flux.bindVueValues(this, {
        isSelected: ['dashboard/selectedItems', function(selectedItems) {
          return selectedItems.isSelected('experiments', this.experiment.id);
        }.bind(this)],
      });
    },

    beforeDestroy: function() {
      if (this.isSelected) {
        flux.actions('dashboard').deselectItem('experiments', this.experiment);
      }
    },
  };
});


define('text!components/dashboard/projects/experiments/experiment_sidebar.html',[],function () { return '<ul class="accordion" v-accordion data-test-section="experiment-sidebar">\n  <li class="accordion__item accordion__item--active" v-class="accordion__item--empty : !experiment && selectedExperiments.length != 1 && hasExperiments">\n    <a class="accordion__link" href="#">Experiment Details</a>      \n    <div class="accordion__content-wrap" v-if="!hasExperiments">\n      <div class="accordion__content" v-show="isWebProject">\n        <h3>Implementing Optimizely</h3>\n        <p>Visit the <a href="/projects/[[ currentProject.id ]]/settings" v-push-state>settings page</a> for implementation instructions.</p>\n\n        <h3>Getting Started</h3>\n        <ul class="lego-list lego-list--bullet"> \n          <li><a href="https://help.optimizely.com/hc/en-us/articles/200040095-Implementing-the-Optimizely-Snippet" target="_blank">Implementing the Optimizely Snippet</a></li>\n          <li><a href="https://help.optimizely.com/hc/en-us/articles/200159574-Get-Started-on-Web-Optimization" target="_blank">Get started with web Optimization</a></li>\n          <li><a href="https://help.optimizely.com/hc/en-us/articles/200293489-10-Common-Experiments-and-how-to-build-them-" target="_blank">10 Common Experiments and How to Build Them</a></li>\n          <li><a href="https://help.optimizely.com/hc/en-us/articles/200587730-From-Novice-to-Testing-Hero-Your-Optimizely-Journey" target="_blank">From Novice to Testing Hero</a></li>\n          <li><a href="https://help.optimizely.com/hc/en-us/articles/200904580-Frequently-Asked-Questions" target="_blank">Frequently Ask Questions</a></li>\n          <li><a href="https://help.optimizely.com/hc/en-us/articles/201697344-Help-Videos" target="_blank">Help Videos</a></li>\n        </ul>\n      </div>\n      <div class="accordion__content" v-show="isiOSProject">\n        <h3>Getting Started</h3>\n        <h6 class="push-double--top">Plan Your Testing Strategy</h6>\n        <ul class="lego-list lego-list--bullet"> \n          <li><a href="https://help.optimizely.com/hc/en-us/articles/201940160?utm_medium=product&utm_source=mobile&utm_campaign=dashboard_empty_002" target="_blank">Optimization Essentials</a>: Learn how to move the metrics that matter</li>\n          <li><a href="https://help.optimizely.com/hc/en-us/articles/202248294?utm_medium=product&utm_source=mobile&utm_campaign=dashboard_empty_003" target="_blank">Mobile Testing Ideas</a>: Try these low-effort, high-impact experiment ideas</li>\n        </ul>\n        <h6 class="push-double--top">Get Help with SDK Installation</h6>\n        <ul class="lego-list lego-list--bullet">\n          <li><a href="http://developers.optimizely.com/ios/" target="_blank">Developer Docs</a>: Quick-start guide, custom configurations, and advanced features</li>\n          <li><a href="http://developers.optimizely.com/ios/help/html/Classes/Optimizely.html" target="_blank">SDK Reference Docs</a>: Learn about the Optimizely SDK interface</li>\n        </ul>\n        <h6 class="push-double--top">Get Ready, Get Set, Test!</h6>\n        <ul class="lego-list lego-list--bullet">\n          <li><a href="https://help.optimizely.com/hc/en-us/articles/202296994?utm_medium=product&utm_source=mobile&utm_campaign=dashboard_empty_001#steps" target="_blank">Getting Started</a>: Five simple steps to creating your first experiment</li>\n        </ul>\n      </div>\n    </div>\n    <div class="accordion__content-wrap" v-if="!experiment && selectedExperiments.length == 0 && hasExperiments">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large"><use xlink:href="#experiments"></use></svg>\n          <div>Select or create an experiment.</div>\n        </div>\n      </div>\n    </div>\n    <div class="accordion__content-wrap" v-if="!experiment && selectedExperiments.length > 1">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large"><use xlink:href="#experiments"></use></svg>\n          <div>[[ selectedExperiments.length ]] experiments selected.</div>\n        </div>\n      </div>\n    </div>\n    <div class="accordion__content-wrap" v-if="experiment">\n      <div class="accordion__content" v-loading-entity="experiment.id" entity="experiments">\n        <ul class="lego-sections">\n          <li class="lego-sections__item flex">\n            <div class="lego-button-row--left">\n              <a href="[[ editUrl(experiment.id) ]]" class="lego-button lego-button--brand" v-experiment-edit-link="experiment.id" v-if="canEditExperiment && !isArchived">\n                Editor\n              </a>\n              <a href="[[ resultsUrl(experiment.id) ]]" class="lego-button lego-button--brand" target="_blank" v-if="canGetResults">\n                Results\n              </a>\n            </div>\n            <button\n              class="lego-button anchor--right"\n              v-if="canPreview"\n              v-on="click: openPreview(experiment)"\n              data-test-section="experiment-preview-button">\n              Preview\n            </button>\n          </li>\n          <li class="lego-sections__item">\n            <h3 v-component="editable"\n                v-with="id: \'description\',\n                        content: experiment.description,\n                        permission: canEditExperiment">\n            </h3>\n          </li>\n          <li class="lego-sections__item">\n            <label class="lego-label lego-label--rule">\n              <div class="flex">\n                <div class="flex-1">Description</div>\n                <a href="javascript:void(0)" class="anchor--right"\n                  v-on="click: editProperty(\'details\')"\n                  v-if="canEditExperiment">Edit Text</a>\n              </div>\n            </label>\n            <p v-component="editable"\n               v-with="id: \'details\',\n                       style: \'multiline\',\n                       content: experiment.details,\n                       display: experiment.details | format-description"\n               v-on="click: handleHashtagClick($event)">\n            </p>\n            <p v-if="!experiment.details">\n              <i class="milli muted">You can add your hypothesis and notes here. Use #hashtags to organize your experiments.</i>\n            </p>\n          </li>\n          <li class="lego-sections__item" v-loading="dashboard.traffic-allocation" spinner-size="small">\n            <label class="lego-label lego-label--rule">\n              <div class="flex">\n                <div class="flex-1">Traffic Allocation: [[ experiment.percentage_included | traffic-allocation-percentage ]]</div>\n                <a href="javascript:void(0)" class="anchor--right"\n                  v-if="canEditExperiment"\n                  v-on="click: editTrafficAllocation(experiment)">Edit</a>\n              </div>\n            </label>\n            <ul class="lego-list--bullet lego-list--spaced">\n              <li v-repeat="variation: variations">\n                <div class="float--right">[[ variation.weight | traffic-allocation-percentage ]]</div>\n                <div class="push--right">[[ variation.description ]]</div>\n              </li>\n            </ul>\n          </li>\n          <li class="lego-sections__item" data-test-section="experiment-sidebar-goals">\n            <label class="lego-label lego-label--rule">\n              <div class="flex">\n                <div class="flex-1">Goals</div>\n                <a href="javascript:void(0)"\n                  class="anchor--right"\n                  v-if="canEditExperiment"\n                  v-on="click: showGoalsDialog(experiment)">Edit</a>\n              </div>\n            </label>\n            <ul class="lego-list--bullet lego-list--spaced">\n              <li v-repeat="goal: goals">[[ goal.title ]] \n                <span class="tagger" v-if="experiment.primary_goal_id === goal.id">(primary)</span>\n              </li>\n            </ul>\n          </li>\n          <li class="lego-sections__item" v-if="shouldSeeAudiences">\n            <label class="lego-label lego-label--rule">\n              <div class="flex">\n                <div class="flex-1">Audiences</div>\n                <a href="javascript:void(0)" class="anchor--right"\n                  v-on="click: showExperimentAudiences(experiment)"\n                  v-if="canEditExperiment">Edit</a>\n              </div>\n            </label>\n            <ul class="lego-list--bullet lego-list--spaced">\n              <li v-repeat="audience: audiences">[[ audience.name ]]</li>\n              <li v-if="audiences.length === 0">Everyone</li>\n            </ul>\n          </li>\n          <li class="lego-sections__item" v-if="shouldSeeUrlTargeting">\n            <label class="lego-label lego-label--rule">\n              <div class="flex">\n                <div class="flex-1">URL Targeting</div>\n                <a href="javascript:void(0)" class="anchor--right"\n                  v-if="canEditExperiment"\n                  v-class="link--disabled: experiment.experiment_type === \'multipage\'"\n                  v-on="click: showUrlTargetingDialog(experiment)">Edit</a>\n              </div>\n            </label>\n            <p v-if="excludeUrlConditions.length">Include</p>\n            <ul class="lego-list--bullet lego-list--spaced">\n              <li class="word-break" v-repeat="cond: includeUrlConditions">\n                [[ cond.value ]] <span class="tagger">([[cond.match_type]] match)</span>\n              </li>\n            </ul>\n\n            <p v-if="excludeUrlConditions.length">Exclude</p>\n            <ul class="lego-list--bullet lego-list--spaced">\n              <li class="word-break" v-repeat="cond: excludeUrlConditions">\n                [[ cond.value ]] <span class="tagger">([[cond.match_type]] match)</span>\n              </li>\n            </ul>\n          </li>\n          <li class="lego-sections__item text--right">\n            <div class="lego-button-row--right">\n              <a class="lego-button" data-dir="top" data-content="Change History" v-poptip\n                 href="/projects/[[ currentProject.id ]]/change-history" v-push-state>\n                <svg class="lego-icon"><use xlink:href="#history"></use></svg>\n              </a>\n              <button class="lego-button" data-dir="top" data-content="Delete" v-poptip\n                      v-on="click: deleteExperiment(experiment)" v-if="canDeleteExperiment">\n                <svg class="lego-icon"><use xlink:href="#trash"></use></svg>\n              </button>\n            </div>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </li>\n  <li class="accordion__item">\n    <a class="accordion__link" href="#">Help</a>\n    <div class="accordion__content-wrap">\n      <div class="accordion__content">\n        <h3>Managing Experiments</h3>\n\n        <p>The Experiments overview dashboard allows you to see all of your experiments for this project. Create your first experiment by clicking New Experiment or see vital information about your current experiments.</p>\n\n        <p><b>Overview:</b> At a glance, youll see each active experiment in your project and its status (running, paused, or draft). Pay attention to the Primary column: thats where youll see how your primary goal is performing.</b>\n\n        <p><b>Filter Experiments:</b> If you have many experiments, use the filters to show only certain statuses or names. You can also find archived experiments here.</p>\n        <p><img src="/static/img/dashboard/Filter.png"></p>\n\n        <p><b>See Details:</b> Click any experiment to see more details right here, in this panel. Jump to the Editor or the Results page, or click the Edit buttons to change experiment settings (Traffic Allocation, Goals, Audiences, URL Targeting) without opening the Editor.</p>\n\n        <p><b>Start/Pause/Archive:</b> When you click an experiment, you can also start or pause it. Or archive old experiments that youre not currently using.</p>\n        <p><img src="/static/img/dashboard/StartPauseArchive.png"></p>\n\n        <p><b>Pro tips:</b>\n        <ul class="lego-list lego-list--bullet"> \n          <li>Use hashtags in your experiment descriptions to easily track and categorize experiments</li>\n          <li>Hold shift to select more than one experiment. This is useful for making batch changes to multiple experiments</li>\n          <li>To change your primary goal, click "Edit" next to the goals section in the experiment details and drag and drop a new goal to the top</li>\n        </ul>\n\n      </div>\n    </div>\n  </li>\n</ul>\n';});

/**
 * Service holding functionality related to experiments
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/experiment',['require','lodash','models/experiment','services/project','utils/enums'],function(require) {
  var _ = require('lodash');
  var Experiment = require('models/experiment');
  var projectService = require('services/project');
  var enums = require('utils/enums');

  // Only allow editing goals in the first 4 weeks
  var MAX_EDITABLE_GOALS_AGE_MILLISECONDS = 4 * 7 * 24 * 60 * 60 * 1000;

  /**
   * Load all Google Universal Analytics slots that are in use by all active
   * experiments.
   * @param  {number} project_id
   * @return {Promise}
   */
  function listUniversalAnalyticsSlotsInUse(project_id) {
    var deferred = $.Deferred();
    // TODO (HALEY): Replace mobile_slots with _slots (line below) once web and mobile are merged
    // $.ajax("project/list_universal_analytics_slots?project_id=" + project_id)
    $.ajax("/project/list_universal_analytics_mobile_slots?project_id=" + project_id)
      .done(function(data) {
        deferred.resolve(data.slots_map);
       })
      .fail(deferred.reject);

    return deferred.promise();
  }

  /**
   * Load recent experiments for an account
   * @param {number} limit
   * @return {Deferred}
   */
  function loadRecent(limit) {
    var deferred = $.Deferred();

    $.ajax("/experiment/load_recent", {
      data: {
        max_experiments: limit
      },
      optimizelyRetryLimit: 3
    }).done(function(data) {
      deferred.resolve(data.experiments);
    }).fail(deferred.reject);

    return deferred.promise();
  }

  /**
   * Updates an experiment's properties and saves via the API
   *
   * @param {Integer} experimentId
   * @param {Object} data
   * @return {Deferred}
   */
  function updateExperiment(experimentId, data) {
    var experimentData = _.extend({
      id: experimentId,
    }, data);

    return Experiment.save(experimentData);
  }

  /**
   * Creates a new iOS experiment
   *
   * @param name Name of the experiment
   * @param project_id Id of the experiment's parent project
   * @param type ANDROID or IOS Experiment types
   * @returns {Deferred}
   */
  function createMobileExperiment(name, project_id, type) {
    return $.ajax({
      type: "POST",
      url: '/experiment/create',
      // Clear error so caller can handle the error instead of relying on the error handler in bundle/page.js
      error: goog.nullFunction,
      data: {
        experiment_title: name,
        project_id: project_id,
        experiment_type: 'ab',
        percentage_included: 10000,
        platform: type,
        sections: JSON.stringify([{
          variations : [{
            id: null,
            title: 'Original',
            is_paused: false,
            weight: 50,
            code: '',
            variation_platforms: [{
              id: null,
              assets: {},
              views: {},
              variables: {},
              type: type
            }]
          },
          {
            id: null,
            title: 'Variation #1',
            is_paused: false,
            weight: 50,
            code: '',
            variation_platforms: [{
              id: null,
              assets: '{}',
              views: '{}',
              variables: '{}',
              type: type
            }]
          }]
        }])
      }
    });
  }

  /**
   * Logic to determine if an experiment status
   * @param {Experiment} experiment
   * @return {boolean}
   */
  function canWebPreview(experiment, project) {
    var status = enums.ExperimentStatusType;
    var blacklist = [
      status.ARCHIVED,
      status.DELETED,
      status.ERROR,
    ];

    return (
      !_.contains(blacklist, experiment.status) &&
      projectService.isWebProject(project)
    );
  }

  /**
   * Equivalent to can_modify_goals in models/experiment.py
   */
  function canModifyGoals(experiment) {
    var earliest = experiment.earliest;
    var age = new Date() - new Date(earliest);
    return age < MAX_EDITABLE_GOALS_AGE_MILLISECONDS;
  }

  return {
    createMobileExperiment: createMobileExperiment,
    listUniversalAnalyticsSlotsInUse: listUniversalAnalyticsSlotsInUse,
    loadRecent: loadRecent,
    updateExperiment: updateExperiment,
    canWebPreview: canWebPreview,
    canModifyGoals: canModifyGoals,
  };
});

/**
 * Goal Service
 *
 * @author Neha Singla (neha@optimizely.com)
 */
define('services/goal',['require','models/experiment','models/goal','lodash'],function(require) {
  var Experiment = require('models/experiment');
  var Goal = require('models/goal');
  var _ = require('lodash');

  var TypeString = {
    CLICK: "CLICK",
    CUSTOM_EVENT: "CUSTOM_EVENT",
    ENGAGEMENT: "ENGAGEMENT",
    PAGEVIEW: "PAGEVIEW",
    REVENUE: "REVENUE",
    MOBILE_TAP_EVENT_TYPE: "MOBILE_TAP_EVENT_TYPE",
    MOBILE_VIEW_EVENT_TYPE: "MOBILE_VIEW_EVENT_TYPE"
  };

  var TypeCode = {
    CLICK: 0,
    CUSTOM_EVENT: 1,
    ENGAGEMENT: 2,
    PAGEVIEW: 3,
    REVENUE: 4,
    MOBILE_TAP_EVENT_TYPE: 5,
    MOBILE_VIEW_EVENT_TYPE: 6
  };

  var TypeCodeToString = {};
  TypeCodeToString[TypeCode.CLICK] = TypeString.CLICK;
  TypeCodeToString[TypeCode.CUSTOM_EVENT] = TypeString.CUSTOM_EVENT;
  TypeCodeToString[TypeCode.ENGAGEMENT] = TypeString.ENGAGEMENT;
  TypeCodeToString[TypeCode.PAGEVIEW] = TypeString.PAGEVIEW;
  TypeCodeToString[TypeCode.REVENUE] = TypeString.REVENUE;
  TypeCodeToString[TypeCode.MOBILE_TAP_EVENT_TYPE] = TypeString.MOBILE_TAP_EVENT_TYPE;
  TypeCodeToString[TypeCode.MOBILE_VIEW_EVENT_TYPE] = TypeString.MOBILE_VIEW_EVENT_TYPE;

  var TypeStringToCode = {};
  TypeStringToCode[TypeString.CLICK] = TypeCode.CLICK;
  TypeStringToCode[TypeString.CUSTOM_EVENT] = TypeCode.CUSTOM_EVENT;
  TypeStringToCode[TypeString.ENGAGEMENT] = TypeCode.ENGAGEMENT;
  TypeStringToCode[TypeString.PAGEVIEW] = TypeCode.PAGEVIEW;
  TypeStringToCode[TypeString.REVENUE] = TypeCode.REVENUE;
  TypeStringToCode[TypeString.MOBILE_TAP_EVENT_TYPE] = TypeCode.MOBILE_TAP_EVENT_TYPE;
  TypeStringToCode[TypeString.MOBILE_VIEW_EVENT_TYPE] = TypeCode.MOBILE_VIEW_EVENT_TYPE;

  /**
   * Generate the ordered list of goals for an experiment
   * @param {Object} experiment
   * @param {Object} goals belonging to the experiment above
   * @return {String}
   */
  function generateOrderedGoals(experiment, goals) {
    // order the goals according to the initially supplied goal order
    // if it exists
    if (experiment.display_goal_order_lst) {
      goals = goals.sort(function (a, b) {
        return experiment.display_goal_order_lst.indexOf(a.id) - experiment.display_goal_order_lst.indexOf(b.id);
      });
    }

    // Ensure that the primary goal is at the top of the list by removing it and adding it to
    // the front of the list
    if (experiment.primary_goal_id) {
      var primaryGoal = _.remove(goals, function (goal) {
        return goal.id === experiment.primary_goal_id;
      })[0];

      if (primaryGoal) {
        goals.unshift(primaryGoal);
      }
    }
    return goals;
  }

  /**
   * Generate a description for a goal
   * @param {Model} goal
   * @return {String}
   */
  function generateGoalDescription(goal){
    switch (goal.goal_type) {
      case optly.goals.TypeCode.CLICK:
        return "<t>The percentage of visitors who clicked on a tracked element.</t>";
      case optly.goals.TypeCode.CUSTOM_EVENT:
        return sprintf("<t>The percentage of visitors who triggered %s (custom event).</t>", sanitizeHTML(goal.event));
      case optly.goals.TypeCode.ENGAGEMENT:
        return "<t>The percentage of visitors who clicked on any part of the experiment page.</t>";
      case optly.goals.TypeCode.REVENUE:
        return "<t>The revenue earned per visitor after visiting an experiment page." +
          "<a class='help-button' href='https://help.optimizely.com/hc/en-us/articles/200039865' target='_blank'></a></t>";
      case optly.goals.TypeCode.PAGEVIEW:
        // very rarely (it's an error condition), there are pageview goals with no urls
        if (goal.urls === undefined) {
          return '<t>This goal is not set up to track views on any page. Please modify the goal or take a look at ' +
            '<a href="https://help.optimizely.com/hc/en-us/articles/200090069">Setting Up Goals</a> if you need help.</t>';
        }

        var urls = [];
        for (var i = 0; i < goal.urls.length; i++) {
          var type = "";
          switch (goal.url_match_types[i]) {
            case optly.goals.PageviewGoalUrlConditionTypeCode.EXACT:
              type = "<t>(exact match)</t>"; break;
            case optly.goals.PageviewGoalUrlConditionTypeCode.REGEX:
              type = "<t>(regular expression match)</t>"; break;
            case optly.goals.PageviewGoalUrlConditionTypeCode.SIMPLE:
              type = "<t>(simple match)</t>"; break;
            case optly.goals.PageviewGoalUrlConditionTypeCode.SUBSTRING:
              type = "<t>(substring match)</t>"; break;
          }
          urls.push(sanitizeHTML(goal.urls[i]) + " " + type);
        }
        return sprintf("<t>The percentage of visitors who visited %s.</t>", urls.join(", or "));
      case optly.goals.TypeCode.MOBILE_TAP_EVENT_TYPE:
        return "<t>The percentage of visitors who tapped a specific element in the app.</t>";
      case optly.goals.TypeCode.MOBILE_VIEW_EVENT_TYPE:
        return "<t>The percentage of visitors who visited a view in the app.</t>";
      default:
        return "";
    }
  }

  return {
    generateOrderedGoals: generateOrderedGoals,
    generateGoalDescription: generateGoalDescription,
    TypeCodeToString: TypeCodeToString,
    TypeStringToCode: TypeStringToCode,
    TypeCode: TypeCode
  }
});


/**
 * Traffic Allocation Service
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/traffic_allocation',['require','exports','module','lodash'],function(require, exports, module) {
  var _ = require('lodash');

  /**
   * Creates the section data structure required by the
   * traffic allocation dialog.  All data passed to this function
   * is plain API response javascript objects
   *
   * Returns:
   *  { // All traffic allocation data
   *    isMVT: <is the experiment MVT>,
   *    includePoints: <the point value (out of 10000) of all visitors included>,
   *    autoAllocated: <should use bandit?>,
   *    sections: [
   *      {
   *        title: <section title>,
   *        variations: [
   *          {
   *            title: <variation title>
   *            weight: <variation weight (in points)>
   *          }
   *        ],
   *      }
   *    ]
   *  }
   *
   * @param {Experiment} experiment
   * @param {array<Variation>} variations
   * @param {array<Section>} sections
   * @return {object}
   */
  function createTrafficAllocationData(experiment, variations, sections) {
    var isMVT = experiment.is_multivariate;
    if (!isMVT) {
      sections = [];
      var sectionVariations = variations.map(function(variation) {
        return {
          id: variation.id,
          title: variation.description,
          weight: variation.weight,
        };
      });
      // if the experiment isn't MVT then it doesn't have any sections, create a single
      // section and add all variation to it.
      sections.push({
        // fake the title
        title: 'Section #1',
        variations: sectionVariations
      });
    } else {
      var sections = sections.map(function(section) {
        // map over the sections variation ids and return
        // the proper variation data structure
        var sectionVariations = _(section.variation_ids)
          .map(function(id) {
            var variation = _.find(variations, {
              id: id
            });
            if (!variation) {
              // code defensively here since we are mapping ids => objects
              // our data could be bad
              console.warn("Could not find variation with id" + id);
              return null;
            }

            return {
              id: id,
              title: variation.description,
              weight: variation.weight
            };
          })
          .filter()
          .value();

        return {
          title: section.title,
          variations: sectionVariations,
        };
      });
    }

    return {
      isMVT: experiment.is_multivariate,
      includePoints: experiment.percentage_included,
      sections: sections,
      // TODO(jordan): use the real value of this if it ever gets into REST api
      autoAllocated: false,
    }
  }

  return {
    createTrafficAllocationData: createTrafficAllocationData,
  };
});

/**
 * Utils for the editable component
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('utils/editable',['require','exports','module'],function(require, exports, module) {

  /*
   * Register function to run when the user saves the editable property. 
   * saveFn will be called in the context of the ViewModel you pass in, with value as the argument.
   * Example use: editable.onSaved(this, 'experiment.description', this.saveDescription);
   * 
   * @param {object}
   * @param {string}
   * @param {Function}
   */
  exports.onSaved = function(vm, id, saveFn) {
    vm.$on('editable-saved', function(savedId, value, oldValue) {
      if (id === savedId) {
        saveFn.call(vm, value, oldValue);
      }
    });
  }

  /*
   * Triggers edit mode on a child editable component with the identifier ID.
   * @param {string}
   */
  exports.triggerEdit = function(vm, id) {
    vm.$broadcast('editable-edit', id);
  }

});

/**
 * Wrap the optly.guardian.Guardian for generating
 * preview links
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('utils/guardian',['require','exports','module'],function(require, exports, module) {
  /**
   * Wrapper function around optly.guardian.Guardian.prototype.open
   */
  exports.gotoPreview = function(experiment, project) {
    var guardian = new optly.guardian.Guardian();
    guardian.toggle(optly.guardian.GuardLinkType.HOSTED_WITH_LIVE_REDIRECT);
    // this is required to start an async process that the preview page relies on
    guardian.verify(experiment.project_id, project.code_revision);
    guardian.open(
      optly.guardian.GuardType.PREVIEW,
      experiment.edit_url,
      experiment.edit_user_agent,
      experiment.project_id,
      experiment.id,
      experiment.section_ids,
      [1] // force variation #1
    );
  };
});

/**
 * Experiment Sidebar Component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/projects/experiments/experiment_sidebar',['require','lodash','text!components/dashboard/projects/experiments/experiment_sidebar.html','app','flux','services/router','services/experiment','services/confirm','services/goal','models/variation','models/section','services/traffic_allocation','utils/editable','services/project','services/events','utils/guardian','flux/getters/current_project','flux/getters/current_project/experiments','flux/getters/dashboard/selected_experiments'],function(require) {
  var _ = require('lodash');
  var tmpl = require('text!components/dashboard/projects/experiments/experiment_sidebar.html');
  var app = require('app');
  var flux = require('flux');
  var router = require('services/router');

  var experimentService = require('services/experiment');
  var confirm = require('services/confirm');
  var goalService = require('services/goal');
  var Variation = require('models/variation');
  var Section = require('models/section');
  var trafficAllocationService = require('services/traffic_allocation');
  var editable = require('utils/editable');
  var projectService = require('services/project');
  var events = require('services/events');
  var guardian = require('utils/guardian');

  // Flux getters
  var getCurrentProject = require('flux/getters/current_project');
  var getCurrentProjectExperiments = require('flux/getters/current_project/experiments');
  var getDashboardSelectedExperiments = require('flux/getters/dashboard/selected_experiments');

  /**
   * Wrapper around getDashboardSelectedExperiments to return null when there
   * are 0 or 2 or more experiments selected
   */
  var getSingleSelectedExperiment = [
    getDashboardSelectedExperiments,
    function(experiments) {
      if (experiments.length !== 1) {
        return null;
      }
      return experiments[0];
    }
  ];

  /**
   * Gets all variations for the currently selected experiment
   */
  var getSelectedExperimentVariations = [
    getSingleSelectedExperiment,
    'variations',
    function(experiment, variationStore) {
      if (!experiment) {
        return [];
      }
      var values = _(experiment.variation_ids)
        .map(variationStore.get)
        .filter()
        .value();

      return values
    }
  ];

  /**
   * Ordered goals for the currently selected single experiment
   */
  var getExperimentGoals = [
    getSingleSelectedExperiment,
    'goals',
    function(experiment, goalStore) {
      if (!experiment) {
        return [];
      }

      var goals = goalStore.getAll({
        experiment_ids: experiment.id
      });

      return goalService.generateOrderedGoals(experiment, goals);
    }
  ];

  /**
   * Audiences for the currently selected single experiment
   */
  var getExperimentAudiences = [
    getSingleSelectedExperiment,
    'audiences',
    function(experiment, audienceStore) {
      if (!experiment) {
        return [];
      }

      return _(experiment.audience_ids)
        .map(audienceStore.get)
        .filter()
        .value();
    }
  ];

  return {
    template: tmpl,

    data: {
      editingDescription: false,
    },

    computed: {
      canPreview: function() {
        if (!this.experiment || !this.experiment.project_id) {
          return false;
        }
        var project = flux.store('projects').get(this.experiment.project_id);
        return experimentService.canWebPreview(this.experiment, project);
      },

      canGetResults: function() {
        if (!this.experiment || !this.experiment.project_id) {
          return false;
        }
        return this.experiment.status != 'Not started';
      },

      /**
       * Can delete an experiment
       * @return {boolean}
       */
      canDeleteExperiment: function() {
        return flux.actions('permissions').canDeleteExperiment(this.currentProject)
      },

      shouldSeeAudiences: function() {
        return projectService.isWebProject(this.currentProject);
      },

      shouldSeeUrlTargeting: function() {
        return projectService.isWebProject(this.currentProject);
      },

      isWebProject: function() {
        return projectService.isWebProject(this.currentProject);
      },

      isiOSProject: function() {
        return projectService.isiOSProject(this.currentProject);
      },

      isArchived: function() {
        if (!this.experiment) {
          return false;
        }
        return this.experiment.status == 'Archived';
      }
    },

    methods: {
      /**
       * Shows the experiment audiences dialog
       * @param {Object} experiment
       */
      showExperimentAudiences: function(experiment) {
        events.track('dashboard2', 'edit-experiment', 'audiences');

        // make a copy avoid mutation by reference
        var onSave = $.Deferred();

        // handle the experiment-audiences save
        onSave.then(function(results) {
          if (results.isDirty) {
            events.track('dashboard2', 'save-experiment', 'audiences');
            // send the view action since the experiment has been updated
            flux.actions('experiments').save({
              id: experiment.id,
              audience_ids: results.experimentAudienceIds
            }).then(function() {
              app.$broadcast('notify', {
                message: tr("The experiment <b>{0}</b> has been saved.", experiment.description),
              });
            });
          }
        });

        app.$broadcast('showDialog', {
          component: 'dialogs/experiment-audiences',
          data: {
            _onSave: onSave,
            experiment: experiment
          },
        });
      },

      /**
       * Shows the goals dialog
       * @param {Object} experiment
       */
      showGoalsDialog: function(experiment) {
        events.track('dashboard2', 'edit-experiment', 'goals');
        var onSave = $.Deferred();
        onSave.then(function (data) {
          var saveDefs = [];
          if (data.goals) {
            saveDefs = data.goals.map(function(goal) {
              return flux.actions('goals').save(goal);
            });
          }

          if (data.goalOrder) {
            saveDefs.push(flux.actions('experiments').save({
              id: experiment.id,
              display_goal_order_lst: data.goalOrder,
              primary_goal_id: data.goalOrder[0],
            }));
          }

          if (saveDefs.length > 0) {
            flux.actions('loading').entityUpdated('experiments', experiment, saveDefs);

            $.when.apply($, saveDefs).then(function() {
              app.$broadcast('notify', {
                message: tr("The experiment <b>{0}</b> has been saved.", experiment.description),
              });
            });
          }
        });

        var projectGoals = flux.store('goals').getAll({
           project_id: experiment.project_id
        });

        app.$broadcast('showDialog', {
          component: 'dialogs/experiment-goals',
          data: {
            _experiment: experiment,
            _goals: projectGoals,
            _goalsDialogDeferred: onSave
          }
        });
      },
      /**
       * Shows the traffic allocation dialog
       * @param {Object} experiment
       */
      editTrafficAllocation: function(experiment) {
        events.track('dashboard2', 'edit-experiment', 'traffic');
        var byExperiment = {
          experiment_id: experiment.id
        };
        var variationsDef = flux.actions('api').fetchAll(Variation, byExperiment);
        var sectionsDef = flux.actions('api').fetchAll(Section, byExperiment);
        // resolved when trafficAllocation dialog saves
        var savedDef = $.Deferred();

        $.when(variationsDef, sectionsDef).then(function(variations, sections) {
          var trafficAllocationData = trafficAllocationService.createTrafficAllocationData(
            experiment,
            variations,
            sections
          );

          /**
           * Result schema
           * result.autoAllocated
           * result.includePoints
           * result.sections
           */
          savedDef.then(function(result) {
            events.track('dashboard2', 'save-experiment', 'traffic');
            // flatten the section variations
            var allVariations = result.sections.reduce(function(accum, section) {
              return accum.concat(section.variations)
            }, []);

            var deferredSaves = []

            // if the include percentage changes update the experiment editor
            if (experiment.percentage_included !== result.includePoints) {
              deferredSaves.push(flux.actions('experiments').save({
                id: experiment.id,
                percentage_included: result.includePoints
              }));
            }

            // go through all section variations and check which ones were updated
            allVariations.forEach(function(variation) {
              var original = _.find(variations, {
                id: variation.id
              });
              if (variation.weight !== original.weight) {
                deferredSaves.push(flux.actions('experiments').updateVariationWeight(
                  variation.id,
                  variation.weight
                ));
              }
            });

            flux.actions('loading').entityUpdated('experiments', experiment, deferredSaves);

            $.when.apply($, deferredSaves).then(function() {
              app.$broadcast('notify', {
                message: tr("The experiment <b>{0}</b> has been saved.", experiment.description),
              });
            });
          });

          app.$broadcast('showDialog', {
            component: 'dialogs/traffic-allocation',
            data: _.extend({
              _saveDeferred: savedDef,
              enableAutoAllocation: this.canUseBandits,
            }, trafficAllocationData)
          });
        }.bind(this));
      },
      /**
       * Shows the confirmation to delete an experiment
       * @param {Experiment} experiment
       */
      deleteExperiment: function(experiment) {
        confirm.confirm({
          title: 'Delete Experiment',
          isWarning: true,
          message: tr('Are you sure you want to delete the experiment <b>{0}</b>?\n The experiment and its results will be permanently deleted. This action cannot be undone.', experiment.description),
        }).then(function() {
          var def = flux.actions('experiments').delete(experiment);

          flux.actions('loading').entityUpdated('experiments', experiment, def);
          def.then(function() {
            app.$broadcast('notify', {
              message: tr('The experiment <b>{0}</b> has been deleted', experiment.description),
              type: 'warning'
            });
          })
        });
      },
      /**
       * Edit page url
       * @param {number) experimentId
       * @return {String}
       */
      editUrl: function(experimentId) {
        return router.experimentEdit({
          experimentId: experimentId
        });
      },
      /**
       * Programmatically opens the preview page for an
       * experiment
       * @param {Experiment} experiment
       */
      openPreview: function(experiment) {
        events.track('dashboard2', 'preview-experiment');
        var project = flux.store('projects').get(experiment.project_id);
        guardian.gotoPreview(experiment, project);
      },
      /**
       * results page url
       * @param {number} experimentId
       * @return {String}
       */
      resultsUrl: function(experimentId) {
        return router.experimentResults(experimentId);
      },
      /**
       * Shows the url targeting dialog
       * (NOTE: editing multipage experiments is currently not supported)
       * @param {Object} experiment
       */
      showUrlTargetingDialog: function(experiment) {
        events.track('dashboard2', 'edit-experiment', 'url-targeting');
        if (experiment.experiment_type !== 'multipage') {
          var onSave = $.Deferred();

          // create a page object defined by url_conditions
          var pages = [];
          var page = {includeUrls: [], excludeUrls: []};
          experiment.url_conditions.forEach(function (condition) {
            var match = condition.value;
            var type = condition.match_type;
            var urlCondition = {
              match: match,
              type: type
            };

            if (condition.negate) {
              page.excludeUrls.push(urlCondition);
            } else {
              page.includeUrls.push(urlCondition);
            }
          });
          pages.push(page);

          // handle the experiment url targeting save
          onSave.then(function(pages) {
            events.track('dashboard2', 'save-experiment', 'url-targeting');
            if (pages) {
              // On save, transform the pages object back to url_conditions format
              var url_conditions = [];
              function addCondition (negate, condition) {
                return {
                  match_type: condition.type,
                  value: condition.match,
                  negate: negate
                }
              };

              pages.forEach(function (page) {
                if (page.includeUrls) {
                  var includes = page.includeUrls.map(_.partial(addCondition, false));
                  url_conditions = url_conditions.concat(includes);
                }

                if (page.excludeUrls) {
                  var excludes = page.excludeUrls.map(_.partial(addCondition, true));
                  url_conditions = url_conditions.concat(excludes);
                }
              });

              // send the view action since the experiment has been updated
              var saveDef = flux.actions('experiments').save({
                id: experiment.id,
                url_conditions: url_conditions
              }).then(function() {
                app.$broadcast('notify', {
                  message: tr("The experiment <b>{0}</b> has been saved.", experiment.description),
                });
              });
            }
          });

          // launch the url targeting dialog
          app.$broadcast('showDialog', {
            component: 'dialogs/url-targeting',
            data: {
              _urlTargetingDeferred: onSave,
              _submitText: tr('Save'),
              _pages: pages
            },
          });
        }
      },
      /**
       * Persists the specified experiment property
       * @param {String} property
       * @param {String} value
       * @param {String} oldValue
       */
      saveProperty: function(property, value, oldValue) {
        var toSave = {
          id: this.experiment.id
        };
        toSave[property] = value;
        return flux.actions('experiments').save(toSave)
          .fail(function() {
            // On fail, revert to the old value
            this.experiment[property] = oldValue;
          }.bind(this));
      },

      saveDescription: function(value, oldValue) {
        if (!value.length) {
          this.experiment.description = oldValue;
          app.$broadcast('notify', {
            type: 'error',
            message: tr("Empty experiment names are not allowed."),
          });
        } else {
          this.saveProperty('description', value, oldValue).then(function() {
            app.$broadcast('notify', {
              message: tr("The experiment <b>{0}</b> has been renamed.", value),
            });
          });
          events.track('dashboard2', 'edit-experiment', 'name');
        }        
      },

      saveDetails: function(value, oldValue) {
        this.saveProperty('details', value, oldValue).then(function() {
          app.$broadcast('notify', {
            message: tr("The experiment <b>{0}</b> has been saved.", this.experiment.description),
          });
        }.bind(this));
        events.track('dashboard2', 'edit-experiment', 'description');
      },

      editProperty: function(property) {
        editable.triggerEdit(this, property);
      },

      handleHashtagClick: function(event) {
        if ($(event.target).is('.hashtag')) {
          events.track('dashboard2', 'filter-experiments-hashtag', 'from-sidebar');
          flux.actions('dashboard').filterExperimentsByString(event.target.textContent);
          return;
        }
      },
    },
    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        experiment: getSingleSelectedExperiment,
        selectedExperiments: getDashboardSelectedExperiments,
        goals: getExperimentGoals,
        audiences: getExperimentAudiences,
        variations: getSelectedExperimentVariations,
        canUseBandits: [getCurrentProject, flux.actions('permissions').canUseBandits],
        canEditExperiment: [
          getSingleSelectedExperiment,
          getCurrentProject,
          function(experiment, project) {
            return experiment && flux.actions('permissions').canEditExperiment(project, experiment);
          }
        ],
        includeUrlConditions: [getSingleSelectedExperiment, function(experiment) {
          return experiment && _.where(experiment.url_conditions, {'negate': false});
        }],
        excludeUrlConditions: [getSingleSelectedExperiment, function(experiment) {
          return experiment && _.where(experiment.url_conditions, {'negate': true});
        }],
        hasExperiments: [getCurrentProjectExperiments, function(experiments) {
          return experiments.length > 0;
        }]
      });

      this.$watch('experiment', function(exp) {
        if (exp) {
          var byExperiment = {
            experiment_id: exp.id
          };
          // ensure the variation data is loaded
          flux.actions('api').fetchAll(Variation, byExperiment)
          flux.actions('api').fetchAll(Section, byExperiment)
        }
      });

      editable.onSaved(this, 'description', this.saveDescription);
      editable.onSaved(this, 'details', this.saveDetails);
    },
  }
});

/**
 * Experiment tab integration tests
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/projects/experiments/experiments_tab',['require','app','vue','flux','lodash','text!components/dashboard/projects/experiments/experiments_tab.html','services/confirm','services/events','utils/sort','flux/getters/projects','flux/getters/current_project','flux/getters/current_project/experiments','flux/getters/dashboard/filtered_experiments','flux/getters/dashboard/selected_experiments','flux/getters/duplication_target_projects','components/dashboard/projects/experiments/experiment_table_row','components/dashboard/projects/experiments/experiment_sidebar'],function(require) {
  var app = require('app');
  var Vue = require('vue');
  var flux = require('flux');
  var lodash = require('lodash');
  var tmpl = require('text!components/dashboard/projects/experiments/experiments_tab.html');
  var confirm = require('services/confirm');
  var events = require('services/events');
  var sort = require('utils/sort');

  var getProjects = require('flux/getters/projects');
  var getCurrentProject = require('flux/getters/current_project');
  var getCurrentProjectExperiments = require('flux/getters/current_project/experiments');
  var getDashboardFilteredExperiments = require('flux/getters/dashboard/filtered_experiments');
  var getDashboardSelectedExperiments = require('flux/getters/dashboard/selected_experiments');
  var getDuplicationTargetProjects = require('flux/getters/duplication_target_projects');

  return {
    components: {
      'experiment-table-row': require('components/dashboard/projects/experiments/experiment_table_row'),
      'experiment-sidebar': require('components/dashboard/projects/experiments/experiment_sidebar'),
    },

    template: tmpl,

    replace: true,

    computed: {

      /**
       * Checks whether any filters are applied
       * @return {boolean}
       */
      hasFilters: function() {
        return this.filters.string || this.filters.statusString != 'active';
      },

      /**
       * Are we in the archive?
       * @return {boolean}
       */
      inArchive: function() {
        return this.filters.statusString == 'archived';
      },

      /**
       * Can all checked experiments be started
       * @return {boolean}
       */
      canStartChecked: function() {
        if (this.selectedExperiments.length === 0) {
          return false;
        }
        return this.selectedExperiments.every(function(exp) {
          return exp.status !== 'Running';
        });
      },
      /**
       * Can all checked experiments be paused
       * @return {boolean}
       */
      canPauseChecked: function() {
        if (this.selectedExperiments.length === 0) {
          return false;
        }
        return this.selectedExperiments.every(function(exp) {
          return exp.status === 'Running';
        });
      },
      /**
       * Can all checked experiments be archived
       * @return {boolean}
       */
      canArchiveChecked: function() {
        if (this.selectedExperiments.length === 0) {
          return false;
        }
        return this.selectedExperiments.every(function(exp) {
          return exp.status !== 'Archived';
        });
      },
      /**
       * Can all checked experiments be unarchived
       * @return {boolean}
       */
      canUnarchiveChecked: function() {
        if (this.selectedExperiments.length === 0) {
          return false;
        }
        return this.selectedExperiments.every(function(exp) {
          return exp.status == 'Archived';
        });
      },
      /**
       * Can checked experiment be duplicated
       * @return {boolean}
       */
      canDuplicateChecked: function() {
        return this.selectedExperiments.length === 1;
      },

      /**
      * Can create a new experiment
      * @return {boolean}
      */
      canCreateExperiment: function() {
        return flux.actions('permissions').canCreateExperiment(this.currentProject);
      },

      /**
      * Can archive an experiment
      * @return {boolean}
      */
      canArchiveExperiment: function() {
        return flux.actions('permissions').canArchiveExperiment(this.currentProject)
      },

      /**
      * Can unarchive an experiment
      * @return {boolean}
      */
      canUnarchiveExperiment: function() {
        return flux.actions('permissions').canUnarchiveExperiment(this.currentProject)
      },

      /**
      * Can start an experiment
      * @return {boolean}
      */
      canStartExperiment: function() {
        return flux.actions('permissions').canStartExperiment(this.currentProject)
      },

      /**
      * Can stop an experiment
      * @return {boolean}
      */
      canPauseExperiment: function() {
        return flux.actions('permissions').canPauseExperiment(this.currentProject)
      },

    },

    methods: {
      /**
       * Batch start experiments
       * @param {array.<Experiment>} experiments
       */
      startExperiments: function(experiments) {
        if (!experiments.length) {
          return;
        }
        var deferredSaves = experiments.map(function(experiment) {
          return flux.actions('experiments').start(experiment);
        });

        var notificationMessage = experiments.length > 1
          ? tr("{0} experiments have been started.", experiments.length)
          : tr("The experiment <b>{0}</b> has been started.", experiments[0].description);

        $.when.apply($, deferredSaves).then(function() {
          app.$broadcast('notify', {
            message: notificationMessage,
          });
        });
        if (experiments.length > 1) {
          events.track('dashboard2', 'batch-start-experiments', null, experiments.length);
        }
      },
      /**
       * Batch pause experiments
       * @param {array.<Experiment>} experiments
       */
      pauseExperiments: function(experiments) {
        if (!experiments.length) {
          return;
        }

        var deferredSaves = experiments.map(function(experiment) {
          return flux.actions('experiments').pause(experiment);
        });

        var notificationMessage = experiments.length > 1
          ? tr("{0} experiments have been paused.", experiments.length)
          : tr("The experiment <b>{0}</b> has been paused.", experiments[0].description);

        $.when.apply($, deferredSaves).then(function() {
          app.$broadcast('notify', {
            message: notificationMessage,
          });
        });

        if (experiments.length > 1) {
          events.track('dashboard2', 'batch-pause-experiments', null, experiments.length);
        }
      },
      /**
       * Duplicate an experiment
       * @param {Experiment} experiment
       * @param {Project} project
       */
      duplicateExperiment: function(experiment, project) {
        events.track('dashboard2', 'duplicate-experiment');

        var dupeDef = flux.actions('experiments').duplicate(experiment, project.id);
        flux.actions('loading').entityUpdated('experiments', experiment, dupeDef);

        dupeDef.then(function(newExp) {
          if (project.id === this.currentProject.id) {
            app.$broadcast('notify', {
              message: tr("You have successfully <b>duplicated</b> experiment <b>'{0}'</b>.", experiment.description),
            });
          } else {
            var hasNewAudiences = _.some(newExp.destination_audiences, 'is_new');
            var hasNewGoals = _.some(newExp.destination_project_goals, 'is_new');
            if (hasNewAudiences || hasNewGoals) {
              app.$broadcast('showDialog', {
                component: 'dialogs/duplicate-experiment',
                data: {
                  destinationAudiences: newExp.destination_audiences || [],
                  destinationGoals: newExp.destination_project_goals || [],
                  projectName: project.project_name,
                }
              });
            } else {
              app.$broadcast('notify', {
                message: tr("You have successfully <b>duplicated</b> experiment <b>'{0}'</b> to project <b>'{1}'</b>.", experiment.description, project.project_name),
              });
            }
          }
        }.bind(this));
      },
      /**
       * Batch archive experiments
       * @param {array.<Experiment>} experiments
       */
      archiveExperiments: function(experiments) {
        if (!experiments.length) {
          return;
        }

        var message;
        if (experiments.length == 1 && experiments[0].status == 'Running') {
          message = tr('This experiment is currently running. Archiving a running experiment will pause it. Are you sure you want to archive it?');
        } else if (experiments.length == 1) {
          message = tr('Are you sure you want to archive this experiment?');
        } else {
          message = tr('Are you sure you want to archive {0} experiments? Any running experiments will be paused first.', experiments.length);
        }

        confirm.confirm({
          title: tr('Archive'),
          message: message,
        }).then(function() {
          var deferredSaves = experiments.map(function(experiment) {
            return flux.actions('experiments').archive(experiment);
          });
          var notificationMessage = experiments.length > 1
            ? tr("{0} experiments have been archived.", experiments.length)
            : tr("The experiment <b>{0}</b> has been archived.", experiments[0].description);

          $.when.apply($, deferredSaves).then(function() {
            app.$broadcast('notify', {
              message: notificationMessage,
            });
            if (experiments.length > 1) {
              events.track('dashboard2', 'batch-archive-experiments', null, experiments.length);
            }
          });
        });
      },

      /**
       * Batch unarchive experiments
       * @param {array.<Experiment>} experiments
       */
      unarchiveExperiments: function(experiments) {
        if (!experiments.length) {
          return;
        }

        var deferredSaves = experiments.map(function(experiment) {
          return flux.actions('experiments').unarchive(experiment);
        });

        var notificationMessage = experiments.length > 1
          ? tr("{0} experiments have been unarchived.", experiments.length)
          : tr("The experiment <b>{0}</b> has been unarchived.", experiments[0].description);

        $.when.apply($, deferredSaves).then(function() {
          app.$broadcast('notify', {
            message: notificationMessage,
          });
          if (experiments.length > 1) {
            events.track('dashboard2', 'batch-unarchive-experiments', null, experiments.length);
          }
        });

      },

      /**
       * @param {String} status
       */
      setStatusFilter: function(status) {
        flux.actions('dashboard').filterExperimentsByStatus(status);
        flux.actions('dashboard').fetchExperiments();
        flux.actions('dashboard').replaceUrl();
      },
      /**
       * @param {Event} event to filter name/descripton
       */
      setStringFilter: _.debounce(function(event) {
        var value = event.target.value;
        flux.actions('dashboard').filterExperimentsByString(value);
        Vue.nextTick(function() {
          // wait until next tick to replace the url this allows
          // any filtered experiments to be deselected
          flux.actions('dashboard').replaceUrl();
        });
      }, 200),

      clearFilters: function() {
        flux.actions('dashboard').resetExperimentFilters();
        flux.actions('dashboard').filterExperimentsByStatus('active');
        Vue.nextTick(function() {
          // wait until next tick to replace the url this allows
          // any filtered experiments to be deselected
          flux.actions('dashboard').replaceUrl();
        });
      },
      /**
       * Shows the create experiment dialog
       * @param {Integer} projectId
       */
      showCreateExperiment: function(projectId) {
        events.track('dashboard2', 'create-experiment');
        app.$broadcast('showDialog', {
          component: 'dialogs/create-experiment',
          data: {
            project_id: projectId
          }
        });
      },
    },

    created: function() {
      flux.bindVueValues(this, {
        projects: getProjects,
        currentProject: getCurrentProject,
        shownExperiments: getDashboardFilteredExperiments,
        selectedExperiments: getDashboardSelectedExperiments,
        filters: ['dashboard/tableFilters', function(filterStore) {
          return filterStore.getFilters('experiments');
        }],
        hasExperiments: [getCurrentProjectExperiments, function(experiments) {
          return experiments.length > 0;
        }],
        duplicationTargetProjects: getDuplicationTargetProjects,
      });

      if (!this.filters.statusString) {
        flux.actions('dashboard').filterExperimentsByStatus('active');
      }

      var tableId = 'dashboard-experiments';
      if (!flux.store('sortableTable').isSorted(tableId)) {
        // default sorting
        flux.actions('sortableTable').sortTable({
          tableId: tableId,
          sortBy: [
            { field: 'status', type: 'experimentStatus' },
            { field: 'created', type: 'date' },
          ]
        });
      }
    },
  };
});


define('text!components/dashboard/projects/audiences/audiences_tab.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group">\n  <div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n    <div class="lego-pane lego-fence--soft">\n\n      <!-- Toolbar -->\n      <ul class="flex push-double--ends">\n        <li class="push-triple--right">\n          <div class="lego-button-group">\n            <div class="lego-dropdown-group" v-dropdown>\n              <button class="lego-button" type="button" data-toggle-dropdown>\n                <span v-text="filters.statusString | capitalize"></span>\n                <span class="lego-arrow-inline--down"></span>\n              </button>\n              <ul class="lego-dropdown">\n                <li class="lego-dropdown__item">\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link" v-on="click: setStatusFilter(\'active\')" data-hide-dropdown>\n                    Active\n                  </a>\n                </li>\n                <li class="lego-dropdown__item">\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link" v-on="click: setStatusFilter(\'archived\')" data-hide-dropdown>\n                    Archived\n                  </a>\n                </li>\n              </ul>\n            </div>\n            <input type="text" class="lego-text-input lego-text-input--search width-200" placeholder="Filter by Name"\n              v-on="keyup: setStringFilter($event)"\n              v-value="filters.string" />\n          </div>\n        </li>\n        <li class="push--right">\n          <div class="lego-button-group">\n            <div class="lego-dropdown-group" v-dropdown\n              data-test-section="duplicate-dropdown">\n              <button class="lego-button lego-button--secondary"\n                v-lego-disabled="!(canCreateAudience && canDuplicateChecked)"\n                v-poptip data-dir="top" data-content="Duplicate"\n                data-toggle-dropdown>\n                <svg class="lego-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#duplicate"></use></svg>\n                <span class="lego-arrow-inline--down"></span>\n              </button>\n              <ul class="lego-dropdown">\n                <li class="lego-dropdown__item">\n                  <div class="soft-half--ends">\n                    <input type="text"\n                      class="lego-text-input lego-text-input--search"\n                      placeholder="Filter Projects by Name"\n                      v-model="projectFilter">\n                  </div>\n                </li>\n                <li class="lego-dropdown__item">\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link"\n                    v-on="click: duplicateAudience(selectedAudiences[0], currentProject)"\n                    data-hide-dropdown>\n                    <b>[[ currentProject.project_name ]]</b>\n                  </a>\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link"\n                    v-repeat="project: duplicationTargetProjects | filterBy projectFilter in \'project_name\' | orderBy \'project_name\'"\n                    v-on="click: duplicateAudience(selectedAudiences[0], project)"\n                    data-hide-dropdown>\n                    [[ project.project_name ]]\n                  </a>\n                </li>\n              </ul>\n            </div>\n            <button class="lego-button lego-button--secondary"\n              v-lego-disabled="!(canArchiveAudience && canArchiveChecked)"\n              v-on="click: archiveAudiences(selectedAudiences)"\n              v-poptip data-dir="top" data-content="Archive"\n              v-if="!filters.archived">\n              <svg class="lego-icon"><use xlink:href="#archive"></use></svg>\n            </button>\n            <button class="lego-button lego-button--secondary"\n              v-lego-disabled="!(canArchiveAudience && selectedAudiences.length > 0)"\n              v-on="click: unarchiveAudiences(selectedAudiences)"\n              v-if="filters.archived">\n              Unarchive\n            </button>\n          </div>\n        </li>\n        <li class="anchor--right">\n          <button class="lego-button lego-button--highlight" v-on="click: createAudience" v-lego-disabled="!canCreateAudience">New Audience</button>\n        </li>\n      </ul>\n      <p class="push-double--bottom" v-if="canUseSegmentation" v-loading-hide="dashboard.audiences.reportableCount">\n        You\'re currently using [[ reportableAudiencesCount ]] [[ reportableAudiencesCount | pluralize audience ]] and [[ dimensionsCount ]] <a href="/projects/[[ currentProject.id ]]/dimensions" v-push-state>visitor [[ dimensionsCount | pluralize dimension ]]</a> for segmentation, so you can turn segmentation on for <b>[[ availableReportableAudiences ]]</b> more [[ availableReportableAudiences | pluralize audience ]].\n      </p>\n    </div>\n\n    <div class="lego-pane lego-pane--flex-1 lego-pane--scroll-y" v-loading="dashboard.audiences">\n      <table class="lego-table lego-table--dashboard" id="dashboard-audiences"\n        v-if="shownAudiences.length > 0">\n        <thead>\n          <tr>\n            <th class="nowrap" v-component="sortable-th" field="name">Name</th>\n            <th class="nowrap" v-component="sortable-th" field="segmentation" type="boolean">Segmentation</th>\n            <th class="nowrap" v-component="sortable-th" field="experiments" type="number">Experiments</th>\n            <th class="nowrap" v-component="sortable-th" field="last_modified" type="date">Modified</th>\n            <th class="nowrap" v-component="sortable-th" field="created" type="date">Created</th>\n          </tr>\n        </thead>\n        <tbody v-prevent-shift-selection>\n          <tr v-repeat="audience: shownAudiences"\n            v-component="audience-table-row">\n          </tr>\n        </tbody>\n      </table>\n      <div v-if="shownAudiences.length === 0 && hasFilters" class="lego-fence--soft">\n        No audiences match your filters. Try <a href="javascript:void(0)" v-on="click: clearFilters">clearing them</a> to see all your audiences.\n      </div>\n    </div>\n  </div>\n  <div class="lego-pane lego-data-sidebar lego-pane--flex"\n    v-component="audience-sidebar">\n  </div>\n</div>\n';});

/**
 * Function getter to take currentProject + audiences store
 * and return all audiences for that project
 */
define('flux/getters/current_project/audiences',[],function() {
  return [
    'currentProject',
    'audiences',
    function (currentProject, audiences) {
      var currentProjectId = currentProject.getId()
      if (currentProjectId) {
        return audiences.getAll({
          project_id: currentProjectId
        });
      } else {
        return [];
      }
    }
  ];
});

/**
 * Function getter to take currentProject + experiments store
 * and return all experiments for that project
 */
define('flux/getters/dashboard/filtered_audiences',['flux/getters/current_project/audiences'],function() {
  var getCurrentProjectAudiences = require('flux/getters/current_project/audiences');

  /**
   * This has to match the id attribute of the table being sorted
   */
  var tableId = 'dashboard-audiences';

  return [
    getCurrentProjectAudiences,
    'sortableTable',
    'experiments',
    'dashboard/tableFilters',
    function (audiences, sortableTableStore, experimentStore, filterStore) {
      var sortFn = sortableTableStore.getSortFn(tableId);
      var archived = filterStore.getFilters('audiences').archived;
      var filtered = audiences.filter(function(aud) {
        return aud.archived == archived && aud.user_touched;
      });
      var filterString = filterStore.getFilters('audiences').string;

      if (filterString) {
        filterString = filterString.toLowerCase();
        filtered = audiences.filter(function(aud) {
          var id = aud.id;
          var name = aud.name;
          var desc = aud.description || '';
          return (
            name.toLowerCase().indexOf(filterString) !== -1 ||
            desc.toLowerCase().indexOf(filterString) !== -1 ||
            id.toString().indexOf(filterString) !== -1
          );
        });
      }

      // map and populate the audience experiments
      filtered = filtered.map(function(audience) {
        audience.experiments = experimentStore.getAll({
          audience_ids: audience.id,
        });
        return audience;
      });

      if (sortFn) {
        filtered.sort(sortFn);
      }

      return filtered;
    }
  ];
});

/**
 * Gets the selected audience for the sidebar on the dashboard
 */
define('flux/getters/dashboard/selected_audiences',['lodash','flux/getters/dashboard/filtered_audiences'],function() {
  var _ = require('lodash');
  var getDashboardFilteredAudiences = require('flux/getters/dashboard/filtered_audiences');

  return [
    'dashboard/selectedItems',
    getDashboardFilteredAudiences,
    function (selectedItems, audiences) {
      var selectedAudienceIds = selectedItems.getSelectedIds('audiences');

      return _(selectedAudienceIds)
        .map(function(id) {
          return _.find(audiences, { id: id });
        })
        .filter()
        .value()
    }
  ];
});


define('text!components/dashboard/projects/audiences/audience_sidebar.html',[],function () { return '<ul class="accordion" v-accordion data-test-section="audience-sidebar">\n  <li class="accordion__item accordion__item--active"  v-class="accordion__item--empty : !audience && selectedAudiences.length != 1">\n    <a class="accordion__link" href="#">Audience Data</a>\n    <div class="accordion__content-wrap" v-if="!audience && selectedAudiences.length == 0">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large"><use xlink:href="#audiences"></use></svg>\n          <div>Select or create an audience.</div>\n        </div>\n      </div>\n    </div>\n    <div class="accordion__content-wrap" v-if="!audience && selectedAudiences.length > 1">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large"><use xlink:href="#audiences"></use></svg>\n          <div>[[ selectedAudiences.length ]] audiences selected.</div>\n        </div>\n      </div>\n    </div>\n    <div class="accordion__content-wrap" v-if="audience">\n      <div class="accordion__content" v-loading-entity="audience.id" entity="audiences">\n\n        <ul class="lego-sections">\n          <li class="lego-sections__item">\n            <button class="lego-button lego-button--brand"\n             v-on="click: editAudience(audience)"\n             v-if="canEditAudience">\n              Edit\n            </button>\n          </li>\n          <li class="lego-sections__item">\n            <h3 v-component="editable"\n                v-with="id: \'audience.name\',\n                        content: audience.name,\n                        permission: canEditAudience">\n            </h3>\n          </li>\n          <li class="lego-sections__item">\n            <label class="lego-label lego-label--rule">\n              <div class="flex">\n                <div class="flex-1">Description</div>\n                <a href="javascript:void(0)" class="anchor--right"\n                  v-on="click: editProperty(\'audience.description\')"\n                  v-if="canEditAudience">Edit Text</a>\n              </div>\n            </label>\n            <p v-component="editable"\n               v-with="id: \'audience.description\',\n                            style: \'multiline\',\n                            content: audience.description,\n                            display: audience.description | format-description"\n               v-on="click: handleHashtagClick($event)">\n            </p>\n            <p v-if="!audience.description">\n              <i class="milli muted">You can add more details about your audience here. Use #hashtags to organize your audiences.</i>\n            </p>\n          </li>\n          <li class="lego-sections__item">\n            <h6>Experiments</h6>\n            <ul class="lego-block-list lego-block-list--flush">\n              <li v-repeat="exp: experiments">\n                [[ exp.description ]]\n              </li>\n              <li v-if="experiments.length === 0">\n                No experiments using this audience.\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </li>\n\n  <li class="accordion__item">\n    <a class="accordion__link" href="#">Help</a>\n    <div class="accordion__content-wrap">\n      <div class="accordion__content">\n        <h3>What are Audiences?</h3>\n        <p>An Audience is a group of visitors that shares the same characteristics. Audiences let you show different content to different groups of visitors. You create Audiences by choosing certain characteristics that the visitor should (or shouldnt) match. Once created, an Audience can be reused in other experiments. <a href="https://help.optimizely.com/hc/en-us/articles/200039685#creating" target="_blank">Learn more</a>.</p>\n\n        <h3>Which visitors should I target?</h3>\n        <p>\n        <ul class="lego-list lego-list--bullet">\n          <li>Mobile traffic (using browser or device) - <a href="https://help.optimizely.com/hc/en-us/articles/201876450#browsers" target="_blank">Learn more</a></li>\n          <li>Logged-in visitors (using cookies) -  <a href="https://help.optimizely.com/hc/en-us/articles/201876450#cookies" target="_blank">Learn more</a></li>\n          <li>Campaign traffic (using query parameters or ad campaigns) - <a href="https://help.optimizely.com/hc/en-us/articles/201876450#query_parameters" target="_blank">Learn more</a></li>\n          <li>Referral traffic or search traffic (using traffic source) - <a href="https://help.optimizely.com/hc/en-us/articles/201876450#referrer" target="_blank">Learn more</a></li>\n          <li>New or returning visitors - <a href="https://help.optimizely.com/hc/en-us/articles/201876450#new_returning" target="_blank">Learn more</a></li>\n          <li>Just yourself and select others, for QA (using cookies) - <a href="https://help.optimizely.com/hc/en-us/articles/200293784" target="_blank">Learn more</a></li>\n          <li>Build custom audiences by combining conditions - <a href="https://help.optimizely.com/hc/en-us/articles/200039685#adding_conditions" target="_blank">Learn more</a></li>\n        </ul>\n        </p>\n\n        <h3>What is Segmentation?</h3>\n        <p>Turn on segmentation for an Audience to filter experiment results by that specific audience. Use segmentation to find out what content works best for different audiences -- it may be different from your overall results. - <a href="https://help.optimizely.com/hc/en-us/articles/200039935#segmenting" target="_blank">Learn more</a></p>\n      </div>\n    </div>\n  </li>\n</ul>\n\n';});

/**
 * Experiment Sidebar Component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/projects/audiences/audience_sidebar',['require','text!components/dashboard/projects/audiences/audience_sidebar.html','app','flux','services/router','utils/editable','services/events','flux/getters/current_project','flux/getters/dashboard/selected_audiences'],function(require) {
  var tmpl = require('text!components/dashboard/projects/audiences/audience_sidebar.html');
  var app = require('app');
  var flux = require('flux');
  var router = require('services/router');
  var editable = require('utils/editable');
  var events = require('services/events');

  var getCurrentProject = require('flux/getters/current_project');
  var getDashboardSelectedAudiences = require('flux/getters/dashboard/selected_audiences');
  var getSingleSelectedAudience = [
    getDashboardSelectedAudiences,
    function(audiences) {
      if (audiences.length === 1) {
        return audiences[0];
      }
      return null;
    }
  ];

  var getAudienceExperiments = [
    getSingleSelectedAudience,
    'experiments',
    function(audience, experimentStore) {
      if (!audience) {
        return [];
      }

      return experimentStore.getAll({
        audience_ids: audience.id
      });
    }
  ];

  return {
    template: tmpl,

    methods: {
      /**
       * Shows the audience editor dialog
       * @param {Audience} audience
       */
      editAudience: function(audience) {

        var onSave = $.Deferred();
        onSave.then(function(results) {
          events.track('dashboard2', 'edit-audience', 'dialog');
          app.$broadcast('notify', {
            message: tr("The audience <b>{0}</b> has been saved.", audience.name),
          });
        });
        flux.actions('audiences')
          .fetchAvailableReportingSlots(this.currentProject)
          .then(function(count) {
            app.$broadcast('showDialog', {
              component: 'audience-editor',
              data: {
                audience: audience,
                openReportingSlots: count,
                _onSave: onSave
              }
            });
          })
      },

      saveProperty: function(property, value, oldValue) {
        var changes = {};
        changes[property] = value;
        changes.id = this.audience.id;
        return flux.actions('audiences').save(changes)
          .fail(function() {
            // On fail, revert to the old value
            this.audience[property] = oldValue;
          }.bind(this));
      },

      saveDescription: function(value, oldValue) {
        this.saveProperty('description', value, oldValue).then(function() {
          app.$broadcast('notify', {
            message: tr("The audience <b>{0}</b> has been saved.", this.audience.name),
          });
        }.bind(this));
        events.track('dashboard2', 'edit-audience', 'description');
      },

      saveName: function(value, oldValue) {
        if (!value.length) {
          this.audience.name = oldValue;
          app.$broadcast('notify', {
            type: 'error',
            message: tr("Empty audience names are not allowed."),
          });
        } else {
          this.saveProperty('name', value, oldValue).then(function() {
            app.$broadcast('notify', {
              message: tr("The audience <b>{0}</b> has been renamed.", this.audience.name),
            });
          }.bind(this));
          events.track('dashboard2', 'edit-audience', 'name');
        }
      },

      editProperty: function(property) {
        editable.triggerEdit(this, property);
      },

      handleHashtagClick: function(event) {
        events.track('dashboard2', 'filter-audiences-hashtag', 'from-sidebar');
        if ($(event.target).is('.hashtag')) {
          flux.actions('dashboard').filterAudiencesByString(event.target.textContent);
          return;
        }
      },

    },

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        audience: getSingleSelectedAudience,
        experiments: getAudienceExperiments,
        selectedAudiences: getDashboardSelectedAudiences,
        canEditAudience: [
          getCurrentProject,
          getAudienceExperiments,
          function(project, experiments) {
            return project && flux.actions('permissions').canEditAudience(project, experiments);
          }
        ]
      });

      editable.onSaved(this, 'audience.description', this.saveDescription);
      editable.onSaved(this, 'audience.name', this.saveName);
    },
  }
});


define('text!components/dashboard/projects/audiences/audience_table_row.html',[],function () { return '<tr v-on="click: clickAudience($event, audience)"\n    v-class="lego-table-row--active: isSelected"\n    v-loading-entity="audience.id" entity="audiences" spinner-size="small"\n    data-table-row-id="[[ audience.id ]]">\n  <td class="cell-truncate">\n    <div class="cell-truncate__text">\n      <span v-repeat="tag: tags" class="lego-tag">[[ tag ]] </span>\n    </div>\n    <div class="cell-truncate__title">[[ audience.name ]]</div>\n  </td>\n  <td>\n    <div v-class="muted: !audience.segmentation,\n                  good-news: audience.segmentation">\n       [[ segmentationStatus ]]\n     </div>\n  </td>\n  <td>\n    [[ audience.experiments.length ]]\n  </td>\n  <td>\n    <span class="nowrap">[[ audience.last_modified | shortdate ]]</span>\n  </td>\n  <td>\n    <span class="nowrap">[[ audience.created | shortdate ]]</span>\n  </td>\n</tr>\n';});

/**
 * Audience Table Row on Dashboard
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/projects/audiences/audience_table_row',['require','text!components/dashboard/projects/audiences/audience_table_row.html','flux','utils/regex','services/events'],function(require) {
  var tmpl = require('text!components/dashboard/projects/audiences/audience_table_row.html');
  var flux = require('flux');
  var regex = require('utils/regex');
  var events = require('services/events');

  // define flux getters for this component
  /**
   * Takes in the current audience for this component and returns a flux getter
   * that gets whether the current audience is selected
   * @param {object} audience
   * @return {array}
   */
  var getIsSelected = function(audience) {
    return ['dashboard/selectedItems', function(selectedItems) {
      return selectedItems.isSelected('audiences', audience.id);
    }]
  };

  return {
    template: tmpl,

    replace: true,

    data: {
      isSelected: false,
      audience: {},
    },

    computed: {
      segmentationStatus: function() {
        return this.audience.segmentation
          ? tr('ON')
          : tr('OFF');
      },

      tags: function() {
        var description = this.audience.description;
        var tags = description.match(regex.hashtags); // Find all words starting with hashtags
        return tags;
      },
    },

    methods: {
      /**
       * @param {Event} event
       * @param {Object} audience
       */
      clickAudience: function(event, audience) {
        flux.actions('dashboard').clickItem('audiences', audience, event.shiftKey);
        flux.actions('dashboard').replaceUrl();
      },
    },

    ready: function() {
      flux.bindVueValues(this, {
        isSelected: getIsSelected(this.audience),
      });
    },

    beforeDestroy: function() {
      if (this.isSelected) {
        flux.actions('dashboard').deselectItem('audiences', this.audience);
      }
    },

  };
});

/**
 * Audiences tab view component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/projects/audiences/audiences_tab',['require','app','text!components/dashboard/projects/audiences/audiences_tab.html','flux','models/audience','services/confirm','services/events','services/dimension','services/dimension','flux/getters/current_project','flux/getters/current_project/dimensions','flux/getters/dashboard/filtered_audiences','flux/getters/dashboard/selected_audiences','flux/getters/duplication_target_projects','flux/getters/current_project/reportable_audiences_count','components/dashboard/projects/audiences/audience_sidebar','components/dashboard/projects/audiences/audience_table_row'],function(require) {
  var app = require('app');
  var tmpl = require('text!components/dashboard/projects/audiences/audiences_tab.html');
  var flux = require('flux');
  var Audience = require('models/audience');
  var confirm = require('services/confirm');
  var events = require('services/events');
  var calculateOpenSlots = require('services/dimension').calculateAvailableReportingSlots;
  var TOTAL_REPORTING_SLOTS = require('services/dimension').TOTAL_REPORTING_SLOTS;

  var getCurrentProject = require('flux/getters/current_project');
  var getCurrentProjectDimensions = require('flux/getters/current_project/dimensions');
  var getDashboardFilteredAudiences = require('flux/getters/dashboard/filtered_audiences');
  var getDashboardSelectedAudiences = require('flux/getters/dashboard/selected_audiences');
  var getDuplicationTargetProjects = require('flux/getters/duplication_target_projects');
  var getReportableAudiencesCount = require('flux/getters/current_project/reportable_audiences_count');

  return {
    components: {
      'audience-sidebar': require('components/dashboard/projects/audiences/audience_sidebar'),
      'audience-table-row': require('components/dashboard/projects/audiences/audience_table_row'),
    },

    template: tmpl,

    replace: true,

    computed: {
      /*
      * Checks permissions to create a new audience
      * @return {boolean}
      */
      canCreateAudience: function() {
        return flux.actions('permissions').canCreateAudience(this.currentProject);
      },

      canArchiveAudience: function() {
        return flux.actions('permissions').canArchiveAudience(this.currentProject);
      },

      /**
       * Can all checked audiences be archived
       * @return {boolean}
       */
      canArchiveChecked: function() {
        if (this.selectedAudiences.length === 0) {
          return false;
        }
        return this.selectedAudiences.every(function(aud) {
          return !aud.segmentation;
        });
      },

      /**
      * Can checked audience be duplicated
      * @return {boolean}
      */
      canDuplicateChecked: function() {
        return this.selectedAudiences.length === 1;
      },

      canUseSegmentation: function() {
        return flux.actions('permissions').canUseSegmentation(this.currentProject);
      },

      availableReportableAudiences: function() {
        // use dimension service function to calculate
        return calculateOpenSlots(this.reportableAudiencesCount, this.dimensionsCount);
      },

      /**
       * Checks whether any filters are applied
       * @return {boolean}
       */
      hasFilters: function() {
        return this.filters.string || this.filters.statusString != 'active';
      },
    },

    methods: {
      /**
       * @param {Event} event to filter name/descripton
       */
      setStringFilter: _.debounce(function(event) {
        var value = event.target.value;
        flux.actions('dashboard').filterAudiencesByString(value);
        Vue.nextTick(function() {
          // wait until next tick to replace the url this allows
          // any filtered experiments to be deselected
          flux.actions('dashboard').replaceUrl();
        });
      }, 200),

      /**
       * @param {String} status
       */
      setStatusFilter: function(status) {
        flux.actions('dashboard').filterAudiencesByStatus(status);
        flux.actions('dashboard').replaceUrl();
      },

      /**
       * Opens the create audience dialog
       */
      createAudience: function() {
        events.track('dashboard2','create-audience');
        var projectId = flux.store('currentProject').currentProjectId;
        var newAudience = Audience.create({
          project_id: projectId,
        });
        app.$broadcast('showDialog', {
          component: 'audience-editor',
          data: {
            audience: newAudience,
            openReportingSlots: this.availableReportableAudiences
          }
        });
      },

      /**
       * Duplicate an audience
       * @param {Audience} audience
       * @param {Project} project to duplicate to
       */
      duplicateAudience: function(audience, project) {
        events.track('dashboard2', 'duplicate-audience');

        var notificationMessage = project.id === this.currentProject.id
          ? tr("You have successfully <b>duplicated</b> audience <b>'{0}'</b>.", audience.name)
          : tr("You have successfully <b>duplicated</b> audience <b>'{0}'</b> to project <b>'{1}'</b>.", audience.name, project.project_name);
        var onSave = $.Deferred();

        onSave.then(function() {
          app.$broadcast('notify', {
            message: notificationMessage,
          });
        });

        var newAudience = _.omit(audience, 'id');
        newAudience.project_id = project.id;

        flux.actions('audiences').fetchAvailableReportingSlots(project)
          .then(function(count) {
            app.$broadcast('showDialog', {
              component: 'audience-editor',
              data: {
                audience: newAudience,
                openReportingSlots: count,
                _onSave: onSave,
                shouldShowDupeWarning: project.id === this.currentProject.id,
              }
            });
          }.bind(this));
      },
      
      /**
       * Batch archive audiences
       * @param {array.<Audience>} audiences
       */
      archiveAudiences: function(audiences) {
        if (!audiences.length) {
          return;
        }

        var message = audiences.length > 1
          ? tr("Are you sure you want to archive {0} audiences? Existing experiments using these audiences won't be affected, but you will not be able to add them to new experiments.", audiences.length)
          : tr("Are you sure you want to archive the audience <b>{0}</b>? Existing experiments using this audiences won't be affected, but you will not be able to add it to new experiments.", audiences[0].name);

        confirm.confirm({
          title: tr('Archive'),
          message: message,
        }).then(function() {
          var deferredSaves = audiences.map(function(audience) {
            return flux.actions('audiences').archive(audience);        
          });
          var notificationMessage = audiences.length > 1
            ? tr("{0} audiences have been archived.", audiences.length)
            : tr("The audience <b>{0}</b> has been archived.", audiences[0].name);

          $.when.apply($, deferredSaves).then(function() {
            app.$broadcast('notify', {
              message: notificationMessage,
            });
            if (audiences.length > 1) {
              events.track('dashboard2', 'batch-archive-audiences', null, audiences.length);
            }
          });
        });
      },

      /**
       * Batch unarchive audiences
       * @param {array.<Audience>} audiences
       */
      unarchiveAudiences: function(audiences) {
        if (!audiences.length) {
          return;
        }

        var deferredSaves = audiences.map(function(audience) {
          return flux.actions('audiences').unarchive(audience);        
        });

        var notificationMessage = audiences.length > 1
          ? tr("{0} audiences have been unarchived.", audiences.length)
          : tr("The audience <b>{0}</b> has been unarchived.", audiences[0].name);

        $.when.apply($, deferredSaves).then(function() {
          app.$broadcast('notify', {
            message: notificationMessage,
          });
          if (audiences.length > 1) {
            events.track('dashboard2', 'batch-unarchive-audiences', null, audiences.length);
          }
        });

      },

      clearFilters: function() {
        flux.actions('dashboard').resetAudienceFilters();
        flux.actions('dashboard').filterAudiencesByStatus('active');
        Vue.nextTick(function() {
          // wait until next tick to replace the url this allows
          // any filtered experiments to be deselected
          flux.actions('dashboard').replaceUrl();
        });
      },

    },

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        shownAudiences: getDashboardFilteredAudiences,
        selectedAudiences: getDashboardSelectedAudiences,
        dimensionsCount: [getCurrentProjectDimensions, function(dimensions) {
          return dimensions.length;
        }],
        reportableAudiencesCount: getReportableAudiencesCount,

        filters: ['dashboard/tableFilters', function(filterStore) {
          return filterStore.getFilters('audiences');
        }],
        duplicationTargetProjects: getDuplicationTargetProjects,
      });

      if (!this.filters.statusString) {
        flux.actions('dashboard').filterAudiencesByStatus('active');
      }

      var tableId = 'dashboard-audiences';
      if (!flux.store('sortableTable').isSorted(tableId)) {
        // default sorting
        flux.actions('sortableTable').sortTable({
          tableId: tableId,
          sortBy: [{ field: 'name', type: 'string' }],
        });
      }
    },
  };
});


define('text!components/dashboard/projects/change_history/change_history_tab.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group">\n  <div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n\n\n    <div class="lego-pane lego-fence--soft">\n      <div class="lego-attention push-double--top" v-if="!canUseChangeHistory">\n        <p>Change history is only available for Enterprise customers. Change history lets you see a detailed record of changes made to your experiments. Please <a href="/pricing" target="_blank">upgrade or contact sales to use this feature</a>.</p>\n        <p>If you\'ve already upgraded, reload this page and you\'ll be able to use change history!</p>\n      </div>\n\n      <!-- Toolbar -->\n      <ul class="flex push-double--ends" v-if="canUseChangeHistory">\n        <li class="push-triple--right">\n          <div class="lego-dropdown-group" v-dropdown="">\n            <button class="lego-button" data-toggle-dropdown="">\n              [[ experimentFilter ]] <span class="lego-arrow-inline--down"></span>\n            </button>\n            <ul class="lego-dropdown">\n              <li class="lego-dropdown__item">\n                <div class="soft-half--ends">\n                  <input type="text"\n                     class="lego-text-input lego-text-input--search"\n                     placeholder="Filter by Name"\n                     v-model="experimentDropDownFilter">\n                </div>\n              </li>\n              <!-- TODO (asa): Change this into an experiments drop down component -->\n              <li class="lego-dropdown__item">\n                <div class="lego-dropdown__block-link"\n                  v-on="click: selectExperimentFilter()"\n                  data-hide-dropdown>\n                  All Experiments\n                </div>\n              </li>\n              <li class="lego-dropdown__item "\n                  v-repeat="experiment: experiments | filterBy experimentDropDownFilter in \'description\' | orderBy \'description\'">\n                <div class="lego-dropdown__block-link"\n                  v-on="click: selectExperimentFilter(experiment)"\n                  data-hide-dropdown>\n                  [[ experiment.description ]]\n                </div>\n              </li>\n            </ul>\n          </div>\n        </li>\n      </ul>\n    </div>\n\n    <!-- History Table -->\n    <div class="lego-pane lego-pane--flex-1 lego-pane--scroll-y" v-if="canUseChangeHistory" v-loading="dashboard.change-history">\n      <table class="lego-table lego-table--dashboard push-double--bottom" v-repeat="dateKey: groupedActivities.keys">\n        <thead>\n          <tr>\n            <th colspan="2" style="text-align:left;">[[ dateKey ]]</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-repeat="activity: groupedActivities[dateKey]"\n            v-component="change-history-table-row">\n          </tr>\n        </tbody>\n      </table>\n      <div class="text--center" data-test-section="activity-show-more" v-loading-hide="dashboard.change-history">\n        <a v-if="hasMoreActivities" href="javascript:void(0)" v-on="click: getMoreActivities">\n          Show More Activities\n        </a>\n        <p class="push-double--top">\n          <p v-if="!hasMoreActivities && !hasNoActivities">No More Activities</p>\n          <p v-if="!hasMoreActivities && hasNoActivities">No Activities</p>\n        </p>\n      </div>\n    </div>\n  </div>\n  <div class="lego-pane lego-data-sidebar lego-pane--flex"\n    v-component="change-history-sidebar">\n  </div>\n</div>\n';});

/**
 * Filter to format a date string into a human readable date.
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('filters/format_date',[],function() {
  return function(dateString) {
    var date = new Date(dateString);
    var dateTime = date.getTime();
    var dayOfWeek = DAYS[date.getDay()];
    var day = date.getDate();
    var month = MONTHS[date.getMonth()];
    var year = date.getFullYear();

    var dayInMilliseconds = 24*60*60*1000;
    var todaysStartTime = (new Date()).setHours(0,0,0,0);
    var yesterdaysStartTime = todaysStartTime - dayInMilliseconds;

    var recency = "";
    if (dateTime > todaysStartTime) {
      recency = "Today, ";
    } else if (dateTime > yesterdaysStartTime) {
      recency = "Yesterday, ";
    }

    return sprintf("%s%s, %s %d, %d", recency, dayOfWeek, month, day, year);
  };
});


define('text!components/dashboard/projects/change_history/change_history_sidebar.html',[],function () { return '<ul class="accordion" v-accordion data-test-section="activity-sidebar">\n  <li class="accordion__item accordion__item--active"\n      v-class="accordion__item--empty : !activity">\n    <a class="accordion__link" href="#">Change Details</a>\n\n    <div class="accordion__content-wrap" v-if="!activity">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large">\n            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#history"></use>\n          </svg>\n          <div>Select a change for details</div>\n        </div>\n      </div>\n    </div>\n    <div class="accordion__content-wrap" v-if="activity">\n      <div class="accordion__content muted-background">\n        <div class="lego-button-row--center">\n          <div v-show="experiment">\n            <a class="lego-button push--bottom button--full"\n              href="[[ computedExperimentLink ]]"\n              data-test-section="activity-sidebar-experiment-link"\n              v-push-state>\n              Go To Experiment\n            </a>\n          </div>\n        </div>\n    </div>\n  </li>\n  <li class="accordion__item">\n    <a class="accordion__link" href="#">Help</a>\n    <div class="accordion__content-wrap">\n      <div class="accordion__content">\n        <h3>What Is Change History?</h3>\n        <p>Optimizely keeps track of changes that are made to experiments and lists them in the Change History.</p>\n\n        <p>Use Change History when you work with collaborators on a project. Youre able to see what the change was, who made the change, when the change was made, and the URL the change affects.</p>\n\n        <p>Find out more in our Knowledge Base - <a href="https://help.optimizely.com/hc/en-us/articles/200040745#change_history" target="_blank">Learn more</a></p>\n      </div>\n    </div>\n  </li>\n</ul>\n\n\n\n';});

/**
 * Gets the selected activity for the sidebar on the dashboard
 */
define('flux/getters/dashboard/selected_activity',[],function() {
  return [
    'dashboard/selectedItems',
    'activity',
    function (selectedItems, activities) {
      var selectedIds = selectedItems.getSelectedIds('activities');
      if (selectedIds.length === 1) {
        return activities.get(selectedIds[0]);
      }
    }
  ];
});

/**
 * Helper utils for calculating url for a specified entity
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('utils/entity_to_url',['require','lodash','flux'],function(require) {
  var _ = require('lodash');
  var flux = require('flux');

  function getCollaboratorUrl(projectId, collaboratorId) {
    collaboratorId = collaboratorId || '';
    return '/projects/' + projectId + '/collaborators/' + collaboratorId;
  };

  function getExperimentUrl(projectId, experimentId, experimentStatus) {
    experimentId = experimentId || '';
    var url = '/projects/' + projectId + '/experiments/' + experimentId;
    if (experimentStatus) {
      url += '/?status=' + experimentStatus.toLowerCase();
    }
    return url;
  };

  function getAudienceUrl(projectId, audienceId) {
    audienceId = audienceId || '';
    return '/projects/' + projectId + '/audiences/' + audienceId;
  };

  return {
    getCollaboratorUrl: getCollaboratorUrl,
    getExperimentUrl: getExperimentUrl,
    getAudienceUrl: getAudienceUrl,
  };
});

/**
 * History Sidebar Component
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/dashboard/projects/change_history/change_history_sidebar',['require','text!components/dashboard/projects/change_history/change_history_sidebar.html','app','flux','services/router','services/events','flux/getters/dashboard/selected_activity','flux/getters/current_project','utils/entity_to_url'],function(require) {
  var tmpl = require('text!components/dashboard/projects/change_history/change_history_sidebar.html');
  var app = require('app');
  var flux = require('flux');
  var router = require('services/router');
  var events = require('services/events');

  var getDashboardSelectedActivity = require('flux/getters/dashboard/selected_activity');
  var getCurrentProject = require('flux/getters/current_project');
  var getExperimentUrl = require('utils/entity_to_url').getExperimentUrl;

  return {
    template: tmpl,

    computed: {
      /*
       * Make a computed based off of 'experimentLink' so
       * vue can bind to it and listen to changes
       */
      computedExperimentLink: function () {
        return this.experimentLink;
      }
    },

    created: function () {
      this.activity = null;
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,

        activity: getDashboardSelectedActivity,

        experimentLink: [
          getDashboardSelectedActivity,
          getCurrentProject,
          function (activity, project) {
            if (activity && project) {
              var experiment = flux.store('experiments').get(activity.experiment_id);
              var experimentStatus = experiment ? experiment.status : '';
              return getExperimentUrl(project.id, activity.experiment_id, experimentStatus);
            }
          }
        ],

        experiment: [
          'experiments',
          getDashboardSelectedActivity,
          function (experimentsStore, activity) {
            var experiment = null;
            if (activity) {
              experiment = experimentsStore.get(parseInt(activity.experiment_id));
            }
            return experiment;
          }
        ]
      });
    },
  }
});


define('text!components/dashboard/projects/change_history/change_history_table_row.html',[],function () { return '<tr v-class="lego-table-row--active: isSelected"\n  v-on="click: selectActivity(activity)"\n  data-table-row-id="[[ activity.id ]]">\n  <td>\n    <div class="lego-grid lego-grid--gutter--narrow">\n      <div class="lego-grid__cell width-1-10">\n        <div class="nowrap">[[activity.created | format-time ]]</div>\n      </div>\n      <div class="lego-grid__cell width-9-10">\n        <p v-show="!activity.email"\n           v-class="text--inline: !activity.email">\n          Optimizely scheduler\n        </p>\n        <a v-show="activity.email"\n           v-attr="href: collaboratorLink"\n           v-push-state>\n           <strong>[[activity.email]]</strong>\n        </a>\n        [[activity | activity-string]]\n        <p v-show="!experimentName"\n           v-class="text--inline: !experimentName">\n           (ID: [[activity.experiment_id]])\n        </p>\n        <a v-show="experimentName"\n           v-attr="href: experimentLink"\n           v-push-state>\n           <strong>[[ experimentName ]]</strong>\n        </a>\n      </div>\n    </div>\n  </td>\n</tr>\n';});

define('filters/activity_string',['require'],function(require) {

  /**
   * Takes as input the variables for an activity and outputs the formatted english string for the activity
   * @return {Object} activity
   * @return {String}
   */
  return function(activity) {
    var activityString = activity.event;
    switch (activity.event) {
      case "save":
        activityString = "<t>saved the Experiment</t>";
        break;
      case "create":
        activityString = "<t>created the Experiment</t>";
        break;
      case "start":
        activityString = "<t>started the Experiment</t>";
        break;
      case "pause":
        activityString = "<t>paused the Experiment</t>";
        break;
      case "delete":
        activityString = "<t>deleted the Experiment</t>";
        break;
      case "archive":
        activityString = "<t>archived the Experiment</t>";
        break;
      case "unarchive":
        activityString = "<t>unarchived the Experiment</t>";
        break;
      case "new goal":
        activityString = "<t>added a new goal to the Experiment</t>";
        break;
      case "add saved goal":
        activityString = "<t>added a saved goal to the Experiment</t>";
        break;
      case "remove goal":
        activityString = "<t>removed a goal from the Experiment</t>";
        break;
      case "update":
        activityString = "<t>updated the Experiment</t>";
        break;
      default:
        if (activity.event.indexOf("Scheduled changed") !== -1) {
          activityString = "<t>changed the schedule for the Experiment</t>";
          break;
        }
        activityString = activity.event;
        break;
    }

    return activityString;
  };
});

/**
 * History Table Row on Dashboard
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/dashboard/projects/change_history/change_history_table_row',['require','text!components/dashboard/projects/change_history/change_history_table_row.html','filters/activity_string','flux','utils/entity_to_url','utils/entity_to_url','flux/getters/current_project'],function(require) {
  var tmpl = require('text!components/dashboard/projects/change_history/change_history_table_row.html');
  var activityString = require('filters/activity_string');
  var flux = require('flux');
  var getExperimentUrl = require('utils/entity_to_url').getExperimentUrl;
  var getCollaboratorUrl = require('utils/entity_to_url').getCollaboratorUrl;
  var getCurrentProject = require('flux/getters/current_project');

  return {
    template: tmpl,

    replace: true,

    data: {
      isSelected: false
    },

    computed: {
      experimentName: function () {
        var experimentName = null;
        var experiment = flux.store('experiments').get(this.activity.experiment_id);
        if (experiment) {
          experimentName = experiment.description;
        }
        return experimentName;
      },
    },

    methods: {
      /**
       * Selects the activity
       * @param {Object} activity
       */
      selectActivity: function (activity) {
        console.log(activity);
        flux.actions('dashboard').clickItem('activities', activity);
        flux.actions('dashboard').replaceUrl();
      },
    },

    created: function() {
      flux.bindVueValues(this, {
        isSelected: ['dashboard/selectedItems', function(selectedItems) {
          return selectedItems.isSelected('activities', this.activity.id);
        }.bind(this)],

        experimentLink: [getCurrentProject, function (project) {
          if (this.activity && project) {
            var experiment = flux.store('experiments').get(this.activity.experiment_id);
            var experimentStatus = experiment ? experiment.status : '';
            return getExperimentUrl(project.id, this.activity.experiment_id, experimentStatus);
          }
        }.bind(this)],

        collaboratorLink: [getCurrentProject, function (project) {
          if (this.activity && project) {
            var collaborator = flux.store('collaborators').getAll({
              user_id: this.activity.email
            })[0] || {};
            return getCollaboratorUrl(project.id, collaborator.id);
          }
        }.bind(this)]
      });
    },
  };
});

/**
 * History tab view component
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/dashboard/projects/change_history/change_history_tab',['require','lodash','flux','text!components/dashboard/projects/change_history/change_history_tab.html','filters/format_date','utils/api_page','services/events','flux/getters/current_project','flux/getters/current_project/experiments','components/dashboard/projects/change_history/change_history_sidebar','components/dashboard/projects/change_history/change_history_table_row'],function(require) {
  var _ = require('lodash');
  var flux = require('flux');
  var tmpl = require('text!components/dashboard/projects/change_history/change_history_tab.html');
  var formatDateWithDay = require('filters/format_date');
  var apiPage = require('utils/api_page');
  var events = require('services/events');

  var getCurrentProject = require('flux/getters/current_project');
  var getCurrentProjectExperiments = require('flux/getters/current_project/experiments');
  var DEFAULT_EXPERIMENT_SELECTION = 'All Experiments';
  var DEFAULT_EVENT_SELECTION = 'All Events';
  var DEFAULT_COLLABORATOR_SELECTION = 'All Collaborators';

  return {
    components: {
      'change-history-sidebar': require('components/dashboard/projects/change_history/change_history_sidebar'),
      'change-history-table-row': require('components/dashboard/projects/change_history/change_history_table_row'),
    },

    template: tmpl,

    replace: true,

    created: function ()  {
      this.experimentDropDownFilter = '';
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,

        experiments: getCurrentProjectExperiments,

        filters: ['dashboard/activityFilters', function (activityFilterStore) {
          return activityFilterStore.getFilters();
        }],

        hasMoreActivities: ['dashboard/activityFilters', function (activityFilterStore) {
          return activityFilterStore.hasMoreActivities();
        }],

        hasNoActivities: ['dashboard/activityFilters', function (activityFilterStore) {
          return activityFilterStore.hasNoActivities();
        }],

        activities: [
          'activity',
          'dashboard/activityFilters',
          function (activityStore, activityFilterStore) {
            var filters = activityFilterStore.getFilters();
            return activityStore.getAll(filters);
          }
        ],

        groupedActivities: [
          'activity',
          'dashboard/activityFilters',
          function (activityStore, activityFilterStore) {
            var filters = activityFilterStore.getFilters();
            var activities = activityStore.getAll(filters);
            var changesByDay = {
              keys: []
            };
            if (activities) {
              activities.forEach(function (change) {
                var dateKey = formatDateWithDay(change.created);
                if (changesByDay[dateKey]) {
                  changesByDay[dateKey].push(change);
                } else {
                  changesByDay[dateKey] = [change];
                  changesByDay.keys.push(dateKey);
                }
              });
            }
            return changesByDay;
          }
        ]
      });
    },

    computed: {
      /*
      * Determines what to display in the experiment filter drop down button
      */
      experimentFilter: function () {
        this.experiments;
        this.filters;
        if (this.experiments && this.filters) {
          var experiment_id = this.filters.experiment_id;
          var experimentsFilter = _.find(this.experiments, { id : parseInt(experiment_id) });
          if (experimentsFilter) {
            return experimentsFilter['description'];
          }
        }
        return DEFAULT_EXPERIMENT_SELECTION;
      },

      /*
      * Determines what to display in the event filter drop down button (TODO: add event filter button)
      */
      eventFilter: function () {
        this.filters;
        if (this.filters) {
          return this.filters['event'];
        }
        return DEFAULT_EVENT_SELECTION;
      },

      /*
      * Determines what to display in the collaborator filter drop down button (TODO: add collaborator filter button)
      */
      collaboratorFilter: function () {
        this.filters;
        if (this.filters) {
          return this.filters['email'];
        }
        return DEFAULT_EMAIL_SELECTION;
      },

      /*
      * Checks permissions to use change history
      * @return {boolean}
      */
      canUseChangeHistory: function() {
        return flux.actions('permissions').canUseChangeHistory(this.currentProject);
      }
    },

    methods: {
      /**
       * When a user selects a project from the projects list "filter"
       * @param {Number} projectId
       */
      selectProjectFilter: function (projectId) {
        flux.actions('dashboard/activity').selectActivityFilter('project_id', projectId);
        flux.actions('dashboard/activity').getActivities(flux.store('dashboard/activityFilters').getFilters());
      },

      /**
       * If the user selects All Experiments, set the
       * selected experiment to null.
       * @param {Object} experiment
       */
      selectExperimentFilter: function (experiment) {
        var experimentId = experiment ? experiment.id : null;
        flux.actions('dashboard/activity').selectActivityFilter('experiment_id', experimentId);
        flux.actions('dashboard/activity').getActivities(flux.store('dashboard/activityFilters').getFilters());
        flux.actions('dashboard').replaceUrl();
      },

      /**
       * When a user selects an experiment from the experiments list filter
       * TODO (asa): Add collaborator filter
       * @param {String} email
       */
      selectEmailFilter: function (email) {
        flux.actions('dashboard/activity').selectActivityFilter('email', email);
        flux.actions('dashboard/activity').getActivities(flux.store('dashboard/activityFilters').getFilters());
      },

      /**
       * When a user selects an event from the event list filter
       * @param {String} event
       */
      selectEventFilter: function (event) {
        flux.actions('dashboard/activity').selectActivityFilter('event', event);
        flux.actions('dashboard/activity').getActivities(flux.store('dashboard/activityFilters').getFilters());
      },

      /**
       * Loads the next page of activities
       */
      getMoreActivities: function () {
        flux.actions('dashboard/activity').setNextPageFilters(this.activities.length);
        flux.actions('dashboard/activity').getActivities(flux.store('dashboard/activityFilters').getFilters());
        events.track('dashboard2', 'more-activities');
      },
    },
  };
});


define('text!components/dashboard/projects/dimensions/dimensions_tab.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group">\n  <div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n    <div class="lego-pane lego-fence--soft">\n\n      <div class="lego-attention push-double--top" v-if="!canUseDimensions">\n        <p>Visitor dimensions are only available for Enterprise customers. Dimensions let you track extra information about your visitors and use it for targeting experiments or segmenting your results. Please <a href="/pricing" target="_blank">upgrade or contact sales to use this feature</a>.</p>\n        <p>If you\'ve already upgraded, reload this page and you\'ll be able to use dimensions!</p>\n      </div>\n\n      <!-- Toolbar -->\n      <ul class="flex push-double--ends" data-ui-component="dashboard-toolbar" v-if="canUseDimensions">\n        <li class="push-triple--right">\n          <input type="text" class="lego-text-input lego-text-input--search width-250" placeholder="Filter by Name"\n            v-on="keyup: setStringFilter($event)"\n            v-value="filterString" />\n        </li>\n        <li class="push--right">\n          <div class="lego-button-group">\n            <div class="lego-dropdown-group" v-dropdown\n              data-test-section="duplicate-dropdown">\n              <button class="lego-button lego-button--secondary"\n                v-lego-disabled="!(canCreateDimension && canDuplicateChecked)"\n                v-poptip data-dir="top" data-content="Duplicate"\n                data-toggle-dropdown>\n                <svg class="lego-icon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#duplicate"></use></svg>\n                <span class="lego-arrow-inline--down"></span>\n              </button>\n              <ul class="lego-dropdown">\n                <li class="lego-dropdown__item">\n                  <div class="soft-half--ends">\n                    <input type="text"\n                      class="lego-text-input lego-text-input--search"\n                      placeholder="Filter Projects by Name"\n                      v-model="projectFilter">\n                  </div>\n                </li>\n                <li class="lego-dropdown__item">\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link"\n                    v-on="click: duplicateDimension(checkedDimensions[0], currentProject)"\n                    data-hide-dropdown>\n                    <b>[[ currentProject.project_name ]]</b>\n                  </a>\n                  <a href="javascript:void(0)" class="lego-dropdown__block-link"\n                    v-repeat="project: duplicationTargetProjects | filterBy projectFilter in \'project_name\' | orderBy \'project_name\'"\n                    v-on="click: duplicateDimension(checkedDimensions[0], project)"\n                    data-hide-dropdown>\n                    [[ project.project_name ]]\n                  </a>\n                </li>\n              </ul>\n            </div>\n          </div>\n        </li>\n        <li class="anchor--right">\n          <button class="lego-button lego-button--highlight"\n            v-on="click: showCreateDimension()"\n            v-if="canCreateDimension">New Dimension\n          </button>\n        </li>\n      </ul>\n      <p class="push-double--bottom" v-if="canUseDimensions">\n        You\'re currently using [[ reportableAudiencesCount ]] <a href="/projects/[[ currentProject.id ]]/audiences" v-push-state>[[ reportableAudiencesCount | pluralize audience ]]</a> and [[ dimensions.length ]] visitor [[ dimensions.length | pluralize dimension ]] for segmentation, so you can turn segmentation on for <b>[[ availableReportableAudiences ]]</b> more [[ availableReportableAudiences | pluralize dimension ]].\n      </p>\n    </div>\n\n    <div class="lego-pane lego-pane--flex-1 lego-pane--scroll-y" v-if="canUseDimensions">\n      <table class="lego-table lego-table--dashboard" id="dashboard-dimensions"\n             v-if="shownDimensions.length > 0">\n        <thead>\n          <tr>\n            <th class="nowrap" v-component="sortable-th" field="name">Name</th>\n            <th class="nowrap" v-component="sortable-th" field="id" type="number">ID</th>\n            <th class="nowrap" v-component="sortable-th" field="client_api_name">API Name</th>\n            <th class="nowrap" v-component="sortable-th" field="last_modified" type="date">Modified</th>\n          </tr>\n        </thead>\n        <tbody v-prevent-shift-selection>\n          <tr v-repeat="dimension: shownDimensions"\n            v-component="dimension-table-row">\n          </tr>\n        </tbody>\n      </table>\n      <div v-if="shownDimensions.length === 0 && hasFilters" class="lego-fence--soft">\n        No dimensions match your filters. Try <a href="javascript:void(0)" v-on="click: clearFilters">clearing them</a> to see all your dimensions.\n      </div>\n    </div>\n  </div>\n  <div class="lego-pane lego-data-sidebar lego-pane--flex"\n    v-component="dimension-sidebar">\n  </div>\n</div>\n';});

/**
 * Function getter to take currentProject + experiments store
 * and return all experiments for that project
 */
define('flux/getters/dashboard/filtered_dimensions',['flux/getters/current_project/dimensions'],function() {
  var getCurrentProjectDimensions = require('flux/getters/current_project/dimensions');

  var tableId = 'dashboard-dimensions';

  return [
    getCurrentProjectDimensions,
    'sortableTable',
    'dashboard/tableFilters',
    function (dimensions, sortableTableStore, filterStore) {
      var sortFn = sortableTableStore.getSortFn(tableId);
      var filtered = dimensions;
      var filterString = filterStore.getFilters('dimensions').string;

      if (filterString) {
        filterString = filterString.toLowerCase();
        filtered = dimensions.filter(function(dim) {
          var name = dim.name;
          var api_name = dim.client_api_name || '';
          var desc = dim.description || '';
          var id = dim.id;
          return (
            name.toLowerCase().indexOf(filterString) !== -1 ||
            desc.toLowerCase().indexOf(filterString) !== -1 ||
            api_name.toLowerCase().indexOf(filterString) !== -1 ||
            id.toString().indexOf(filterString) !== -1
          );
        });
      }

      if (sortFn) {
        filtered.sort(sortFn);
      }

      return filtered;
    }
  ];
});


define('text!components/dashboard/projects/dimensions/dimension_table_row.html',[],function () { return '<tr v-on="click: clickDimension($event, dimension)"\n    v-loading-entity="dimension.id" entity="dimensions" spinner-size="small"\n    v-class="lego-table-row--active: isSelected"\n    data-table-row-id="[[ dimension.id ]]">\n  <td class="cell-truncate">\n    <div class="cell-truncate__text">\n      <span v-repeat="tag: tags" class="lego-tag">[[ tag ]] </span>\n    </div>\n    <div class="cell-truncate__title">[[ dimension.name ]]</div>\n  </td>\n  <td>\n    [[ dimension.id ]]\n  </td>\n  <td>\n    [[ dimension.client_api_name ]]\n  </td>\n  <td>\n    [[ dimension.last_modified | shortdate ]]\n  </td>\n</tr>\n';});

/**
 * Dimension table row
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/dashboard/projects/dimensions/dimension_table_row',['require','text!components/dashboard/projects/dimensions/dimension_table_row.html','flux','utils/regex','services/events'],function(require) {
  var tmpl = require('text!components/dashboard/projects/dimensions/dimension_table_row.html');
  var flux = require('flux');
  var regex = require('utils/regex');
  var events = require('services/events');

  return {
    template: tmpl,

    replace: true,

    data: {
      isSelected: false,
      dimension: {},
    },

    computed: {
      tags: function() {
        var description = this.dimension.description;
        var tags = description.match(regex.hashtags); // Find all words starting with hashtags
        return tags;
      }
    },

    methods: {
      /**
       * @param {Event} event
       * @param {Object} dimension
       */
      clickDimension: function(event, dimension) {
        flux.actions('dashboard').clickItem('dimensions', dimension, event.shiftKey);
        flux.actions('dashboard').replaceUrl();
      },
    },

    ready: function() {
      var dimension = this.dimension;
      flux.bindVueValues(this, {
        isSelected: ['dashboard/selectedItems', function(selectedItems) {
          return selectedItems.isSelected('dimensions', dimension.id);
        }.bind(this)]
      })
    },
  };
});


define('text!components/dashboard/projects/dimensions/dimension_sidebar.html',[],function () { return '<ul class="accordion" v-accordion data-test-section="dimension-sidebar">\n  <li class="accordion__item accordion__item--active"  v-class="accordion__item--empty : !dimension && selectedDimensions.length != 1">\n    <a class="accordion__link" href="#">Dimension Details</a>\n    <div class="accordion__content-wrap" v-if="!dimension && selectedDimensions.length == 0">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large"><use xlink:href="#dimensions"></use></svg>\n          <div>Select or create a dimension.</div>\n        </div>\n      </div>\n    </div>\n    <div class="accordion__content-wrap" v-if="!dimension && selectedDimensions.length > 1">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large"><use xlink:href="#experiments"></use></svg>\n          <div>[[ selectedDimensions.length ]] dimensions selected.</div>\n        </div>\n      </div>\n    </div>\n\n    <div class="accordion__content-wrap" v-if="dimension">\n      <div class="accordion__content" v-loading-entity="dimension.id" entity="dimensions">\n        <ul class="lego-sections">\n        <li class="lego-sections__item">\n          <button class="lego-button lego-button--brand" v-on="click: editDimension(dimension)" v-if="canEditDimension">\n            Edit\n          </button>\n        </li>\n        <li class="lego-sections__item">\n          <h3 v-component="editable"\n              v-with="id: \'dimension.name\',\n                      permission: canEditDimension,\n                      content: dimension.name">\n          </h3>\n        </li>\n        <li class="lego-sections__item">\n          <label class="lego-label lego-label--rule">\n            <div class="flex">\n              <div class="flex-1">Description</div>\n              <a href="javascript:void(0)" class="anchor--right"\n                v-if="canEditDimension" v-on="click: editProperty(\'dimension.description\')">Edit Text</a>\n            </div>\n          </label>\n          <p v-component="editable"\n             v-with="id: \'dimension.description\',\n                     style: \'multiline\',\n                     content: dimension.description,\n                     display: dimension.description | format-description"\n             v-on="click: handleHashtagClick($event)">\n          </p>\n          <p v-if="!dimension.description">\n            <i class="milli muted">You can add more details about your dimension here. Use #hashtags to organize your dimensions.</i>\n          </p>\n        </li>\n        <li class="lego-sections__item">\n          <label class="lego-label">JavaScript Snippet</label>\n          <div class="lego-button-group">\n            <input id="snippet" type="text" value="optimizely.push([\'setDimensionValue\', [[ apiIdentifier ]], \'yourValue\']);" class="lego-text-input">\n            <button class="lego-button" data-dir="bottom-center"\n              data-clipboard-target="snippet"\n              v-component="copier">\n              <i class="fa fa-clipboard"></i>\n            </button>\n          </div>\n          <div class="lego-form-note">Use this code to set a string value for this dimension.</div>\n        </li>\n        <li class="lego-sections__item text--right">\n          <div class="lego-button-row--right">\n            <button class="lego-button" data-dir="top" data-content="Delete" v-poptip\n                    v-on="click: deleteDimension(dimension)" v-if="canDeleteDimension">\n              <svg class="lego-icon"><use xlink:href="#trash"></use></svg>\n            </button>\n          </div>\n        </li>\n        </ul>\n      </div>\n    </div>\n  </li>\n  <li class="accordion__item">\n    <a class="accordion__link" href="#">Help</a>\n    <div class="accordion__content-wrap">\n      <div class="accordion__content">\n        <h3>What are Dimensions?</h3>\n        <p>Optimizely collects visitor information like browser, source type, mobile vs. non-mobile, and ad campaign. Optimizely can also collect custom information about your visitors through the JavaScript API. These pieces of information are called Dimensions.</p>\n\n        <p>Use Dimensions to segment your experiment results and discover how different groups of visitors behave. Then, based on those results, you can turn your Dimensions into Audiences to target future experiments to more specific visitors.</p>\n\n        <p>Find out more in our Knowledge Base -  <a href="https://help.optimizely.com/hc/en-us/articles/200040865#custom_dimensions" target="_blank">Learn more</a></p>\n\n        <h3>What data should I use to create Dimensions?</h3>\n        <ul class="lego-list lego-list--bullet">\n          <li>Plan types or tiers</li>\n          <li>Customers vs. prospects</li>\n          <li>First-time or returning purchasers</li>\n          <li>Purchasers with a certain AOV</li>\n          <li>Visitors who gave certain types of feedback - <a href="https://help.optimizely.com/hc/en-us/articles/202984760" target="_blank">Learn more</a></li>\n          <li>Demographic info from your Data Management Platform - <a href="https://help.optimizely.com/hc/en-us/articles/201334090" target="_blank">Learn more</a></li>\n        </ul>\n      </div>\n    </div>\n  </li>\n</ul>\n';});

/**
 * Gets the selected dimensions for the dashboard
 */
define('flux/getters/dashboard/selected_dimensions',['lodash','flux/getters/dashboard/filtered_dimensions'],function() {
  var _ = require('lodash');
  var getDashboardFilteredDimensions = require('flux/getters/dashboard/filtered_dimensions');

  return [
    'dashboard/selectedItems',
    getDashboardFilteredDimensions,
    function (selectedItems, dimensions) {
      var selectedDimensionIds = selectedItems.getSelectedIds('dimensions');
      return _(selectedDimensionIds)
        .map(function(id) {
          return _.find(dimensions, { id: id });
        })
        .filter()
        .value()
    }
  ];
});

/**
 * Dimension Sidebar Component
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/dashboard/projects/dimensions/dimension_sidebar',['require','text!components/dashboard/projects/dimensions/dimension_sidebar.html','app','flux','models/dimension','utils/editable','services/confirm','services/events','flux/getters/current_project','flux/getters/dashboard/selected_dimensions'],function(require) {
  var tmpl = require('text!components/dashboard/projects/dimensions/dimension_sidebar.html');
  var app = require('app');
  var flux = require('flux');
  var Dimension = require('models/dimension');
  var editable = require('utils/editable');
  var confirm = require('services/confirm');
  var events = require('services/events');

  var getCurrentProject = require('flux/getters/current_project');
  var getDashboardSelectedDimensions = require('flux/getters/dashboard/selected_dimensions');

  var getSingleSelectedDimension = [
    getDashboardSelectedDimensions,
    function(dimensions) {
      if (dimensions.length === 1) {
        return dimensions[0];
      }
      return null;
    }
  ];

  return {
    template: tmpl,

    computed: {
      apiIdentifier: function() {
        if (this.dimension) {
          if (this.dimension.client_api_name) {
            return sprintf('\'%s\'', this.dimension.client_api_name);
          } else {
            return this.dimension.id;
          }
        }
      },
    },

    methods: {
      /**
       * Delete the given dimension
       * @param {Dimension} dimension
       */
      deleteDimension: function(dimension) {
        var msg = tr('Are you sure you want to delete the dimension <b>{0}</b>?\n Any audiences using this dimension will stop getting traffic, and results associated with this dimension will be permanently deleted. This action cannot be undone.', dimension.name);
        confirm.confirm({
          title: 'Delete Dimension',
          isWarning: true,
          message: msg,
        }).then(function() {
          flux.actions('dimensions').delete(dimension).then(function() {
            app.$broadcast('notify', {
              message: tr("The dimension <b>{0}</b> has been deleted.", dimension.name),
              type: 'warning'
            });
            events.track('dashboard2', 'delete-dimension');
          });
        });
      },
      /**
       * Shows the dimension editor dialog
       * @param {Dimension} dimension
       */
      editDimension: function(dimension) {
        var onSave = $.Deferred();
        onSave.then(function(results) {
          app.$broadcast('notify', {
            message: tr("The dimension <b>{0}</b> has been saved.", dimension.name),
          });
          events.track('dashboard2', 'edit-dimension', 'dialog');
        });

        app.$broadcast('showDialog', {
          component: 'dialogs/dimension-editor',
          data: {
            dimension: dimension,
            _onSave: onSave
          }
        });
      },

      saveProperty: function(property, value, oldValue) {
        var changes = {};
        changes[property] = value;
        return flux.actions('dimensions').save(this.dimension.id, changes)
          .fail(function() {
            // On fail, revert to the old value
            this.dimension[property] = oldValue;
          }.bind(this));
      },

      saveDescription: function(value, oldValue) {
        this.saveProperty('description', value).then(function() {
          app.$broadcast('notify', {
            message: tr("The dimension <b>{0}</b> has been saved.", this.dimension.name),
          });
        }.bind(this));
        events.track('dashboard2', 'edit-dimension', 'description');
      },

      saveName: function(value, oldValue) {
        if (!value.length) {
          this.dimension.name = oldValue;
          app.$broadcast('notify', {
            type: 'error',
            message: tr("Empty dimension names are not allowed."),
          });
        } else {
          this.saveProperty('name', value, oldValue).then(function() {
            app.$broadcast('notify', {
              message: tr("The dimension <b>{0}</b> has been renamed.", this.dimension.name),
            });
          }.bind(this));
          events.track('dashboard2', 'edit-dimension', 'name');
        }
      },

      editProperty: function(property) {
        editable.triggerEdit(this, property);
      },

      handleHashtagClick: function(event) {
        events.track('dashboard2', 'filter-dimensions-hashtag', 'from-sidebar');
        if ($(event.target).is('.hashtag')) {
          flux.actions('dashboard').filterDimensionsByString(event.target.textContent);
          return;
        }
      },
    },

    created: function() {
      this.dimension = {};

      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        dimension: getSingleSelectedDimension,
        selectedDimensions: getDashboardSelectedDimensions,

        canEditDimension: [getCurrentProject, function(project) {
          return project && flux.actions('permissions').canEditDimension(project);
        }],

        canDeleteDimension: [getCurrentProject, function(project) {
          return project && flux.actions('permissions').canDeleteDimension(project);
        }],
      })

      editable.onSaved(this, 'dimension.description', this.saveDescription);
      editable.onSaved(this, 'dimension.name', this.saveName);
    },
  }
});

/**
 * Dimensions tab view component
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/dashboard/projects/dimensions/dimensions_tab',['require','app','flux','text!components/dashboard/projects/dimensions/dimensions_tab.html','models/dimension','services/dimension','services/dimension','services/events','utils/enums','flux/getters/current_project','flux/getters/current_project/dimensions','flux/getters/dashboard/filtered_dimensions','flux/getters/duplication_target_projects','flux/getters/current_project/reportable_audiences_count','components/dashboard/projects/dimensions/dimension_table_row','components/dashboard/projects/dimensions/dimension_sidebar'],function(require) {
  var app = require('app');
  var flux = require('flux');
  var tmpl = require('text!components/dashboard/projects/dimensions/dimensions_tab.html');
  var Dimension = require('models/dimension');
  var calculateOpenSlots = require('services/dimension').calculateAvailableReportingSlots;
  var TOTAL_REPORTING_SLOTS = require('services/dimension').TOTAL_REPORTING_SLOTS;
  var events = require('services/events');
  var enums = require('utils/enums');

  var getCurrentProject = require('flux/getters/current_project');
  var getCurrentProjectDimensions = require('flux/getters/current_project/dimensions');
  var getDashboardFilteredDimensions = require('flux/getters/dashboard/filtered_dimensions');
  var getDuplicationTargetProjects = require('flux/getters/duplication_target_projects');
  var getReportableAudiencesCount = require('flux/getters/current_project/reportable_audiences_count');

  var COMPONENTS = {
    'dimension-table-row': require('components/dashboard/projects/dimensions/dimension_table_row'),
    'dimension-sidebar': require('components/dashboard/projects/dimensions/dimension_sidebar'),
  };

  return {
    components: COMPONENTS,

    template: tmpl,

    replace: true,

    computed: {
      /** 
      * Available audience segmentation slots
      * @return {number}
      */
      availableReportableAudiences: function() {
        return calculateOpenSlots(this.reportableAudiencesCount, this.dimensionsCount);
      },
      /**
       * Currently checked dimensions
       * @return {array.<Dimension>}
       */
      checkedDimensions: function() {
        var getDimension = flux.store('dimensions').get.bind(flux);
        // TODO: only compute dimensions that aren't filtered
        return this.selectedDimensionIds.map(getDimension);
      },

      /**
       * Can all checked dimensions be duplicated
       * @return {boolean}
       */
      canDuplicateChecked: function() {
        // TODO: implement permissions
        if (this.checkedDimensions.length === 1) {
          return true;
        }
        return false;
      },

      /*
      * Checks permissions to create a new dimension
      * @return {boolean}
      */
      canCreateDimension: function() {
        var project = this.currentProject;
        return project && flux.actions('permissions').canCreateDimension(project);
      },

      /*
      * Checks permissions to use the dimensions feature
      * @return {boolean}
      */
      canUseDimensions: function() {
        var project = this.currentProject;
        return flux.actions('permissions').canUseDimensions(project);
      },

      /**
       * Checks whether any filters are applied
       * @return {boolean}
       */
      hasFilters: function() {
        return this.filterString;
      },
    },

    methods: {
      /**
       * @param {Event} event to filter name/descripton
       */
      setStringFilter: _.debounce(function(event) {
        var value = event.target.value;
        flux.actions('dashboard').filterDimensionsByString(value);
        Vue.nextTick(function() {
          // wait until next tick to replace the url this allows
          // any filtered experiments to be deselected
          flux.actions('dashboard').replaceUrl();
        });
      }, 200),

      clearFilters: function() {
        flux.actions('dashboard').resetDimensionFilters();
        Vue.nextTick(function() {
          // wait until next tick to replace the url this allows
          // any filtered experiments to be deselected
          flux.actions('dashboard').replaceUrl();
        });
      },

      showCreateDimension: function() {
        events.track('dashboard2', 'create-dimension');
        var projectId = this.currentProject.id;
        var newDimension = Dimension.create({
          project_id: projectId,
        });
        app.$broadcast('showDialog', {
          component: 'dialogs/dimension-editor',
          data: {
            dimension: newDimension,
          },
        });
      },

      /**
       * Duplicate a dimension
       * @param {Dimension} dimension
       * @param {Project} project to duplicate to
       */
      duplicateDimension: function(dimension, project) {
        events.track('dashboard2', 'duplicate-dimension');

        var onSave = $.Deferred();
        var notificationMessage = project.id === this.currentProject.id
          ? tr("You have successfully <b>duplicated</b> dimension <b>'{0}'</b>.", dimension.name)
          : tr("You have successfully <b>duplicated</b> dimension <b>'{0}'</b> to project <b>'{1}'</b>.", dimension.name, project.project_name);

        onSave.then(function(dim) {
          app.$broadcast('notify', {
            message: notificationMessage,
          });
        });

        var newDimension = _.omit(dimension, 'id');
        newDimension.project_id = project.id;

        flux.actions('audiences').fetchAvailableReportingSlots(project)
          .then(function(count) {
            if (count > 0) {
              app.$broadcast('showDialog', {
                component: 'dialogs/dimension-editor',
                data: {
                  dimension: newDimension,
                  _onSave: onSave,
                },
              });
            } else {
              app.$broadcast('warning', {
                message: tr("Dimension could not be duplicated because you're already segmenting by {0} audiences or dimensions. Delete another dimension or turn off segmentation for an audience to make room.", TOTAL_REPORTING_SLOTS),
              });
            }
          })
      },
    },

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,

        dimensions: getCurrentProjectDimensions,

        selectedDimensionIds: ['dashboard/selectedItems', function(selectedItems) {
          return selectedItems.getSelectedIds('dimensions');
        }],

        shownDimensions: getDashboardFilteredDimensions,

        filterString: ['dashboard/tableFilters', function(tableFiltersStore) {
          return tableFiltersStore.getFilters('dimensions').string;
        }],

        dimensionsCount: [getCurrentProjectDimensions, function(dimensions) {
          return dimensions.length
        }],

        reportableAudiencesCount: getReportableAudiencesCount,
        
        duplicationTargetProjects: getDuplicationTargetProjects,
      });

      var tableId = 'dashboard-dimensions';
      if (!flux.store('sortableTable').isSorted(tableId)) {
        // default sorting
        flux.actions('sortableTable').sortTable({
          tableId: tableId,
          sortBy: [{ field: 'name', type: 'string' }],
        });
      }
    },
  };
});

/**
 * Projects Main Tab Component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/projects/projects_tab',['require','flux','text!components/dashboard/projects/projects_tab.html','services/project','services/events','utils/page','services/router','flux/getters/current_project','components/dashboard/projects/experiments/experiments_tab','components/dashboard/projects/audiences/audiences_tab','components/dashboard/projects/change_history/change_history_tab','components/dashboard/projects/dimensions/dimensions_tab'],function(require) {
  var flux = require('flux');
  var tmpl = require('text!components/dashboard/projects/projects_tab.html');
  var projectService = require('services/project');
  var events = require('services/events');
  var page = require('utils/page');
  var router = require('services/router');

  var getCurrentProject = require('flux/getters/current_project');

  var COMPONENTS = {
    'experiments': require('components/dashboard/projects/experiments/experiments_tab'),
    'audiences': require('components/dashboard/projects/audiences/audiences_tab'),
    'change-history': require('components/dashboard/projects/change_history/change_history_tab'),
    'dimensions': require('components/dashboard/projects/dimensions/dimensions_tab'),
  };

  return {
    components: COMPONENTS,

    template: tmpl,

    replace: true,

    methods: {
      /**
       * Switches the active subtab and sets up the tab contents component
       * @param {String} tab
       */
      switchSubtab: function(tab) {
        events.track('dashboard2','switch-subtab', tab);
        if (this.activeSubtab !== tab) {
          page(router.dashboardTab(this.currentProject.id, tab));
        }
      },
    },

    computed: {
      shouldSeeAudiences: function() {
        return projectService.isWebProject(this.currentProject);
      },
      shouldSeeDimensions: function() {
        return projectService.isWebProject(this.currentProject);
      },
    },

    created: function() {
      if (!flux.store('dashboard').getActiveSubTab()) {
        flux.actions('dashboard').switchSubtab('experiments');
      }
      // replace the url to account for default tab selection
      flux.actions('dashboard').replaceUrl();

      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        activeSubtab: ['dashboard', function(dashboard) {
          return dashboard.getActiveSubTab();
        }]
      });
    },
  };
});

/**
 * Analytics Integrations Vue Component
 */
define('components/dialogs/analytics_integrations',['require','lodash','app','services/confirm','utils/enums','services/experiment'],function(require) {
  var _                 = require('lodash');
  var app               = require('app');
  var confirm           = require('services/confirm');
  var enums             = require('utils/enums');
  var experimentService = require('services/experiment');

  // This is used by the Universal Analytics integration.
  // Non-premium accounts are limited to 20 custom dimension slots.
  // Generate an array of MAX_NUM_UA_SLOTS numbers to use as selectable options
  var MAX_NUM_UA_SLOTS = 20;
  var numUASlots = _.range(1, MAX_NUM_UA_SLOTS+1);

  return {
    template: '#analytics-integrations-dialog',
    replace: true,
    data: {
      atInternetDetailsDiffer  : true,
      atInternetInputDisabled  : false,
      atInternetIntegration    : true,
      atInternetAcctNo         : '',
      atInternetLogServerURL   : '',
      atInternetTag            : {
                                  acctNo      : null,
                                  logServerURL: null
                                 },
      atInternetTagFound       : true,
      chartbeatWhitelist       : false,
      chartbeatIntegration     : false,
      deviceSdkVersion         : null,
      existingSlots            : [],
      experimentId             : null,
      gaCustomTracker          : '',
      gaIntegration            : false,
      gaSlotNumber             : -1,
      kissmetrics              : false,
      mixpanel                 : false,
      numUASlots               : numUASlots,
      projectId                : null,
      // Show no sections by default since we don't
      // know what platform a user is using
      showContainer            : [],
      sitecatalyst             : '',
      sitecatalystVar          : -1,
      sitecatalystProp         : -1,
      sitecatalystVarCheckbox  : true,
      sitecatalystPropCheckbox : true,
      universalAnalyticsTracker: '',
      universalAnalyticsSlot   : -1,
      universalAnalytics       : false,
      universalAnalyticsIsSupported: true
    },
    computed: {
      isWebProject: function () {
        return _.contains(this.project_platforms, enums.ProjectPlatformType.WEB);
      },
      isiOSProject: function () {
        return _.contains(this.project_platforms, enums.ProjectPlatformType.IOS);
      },
      isAndroidProject: function() {
        return _.contains(this.project_platforms, enums.ProjectPlatformType.ANDROID);
      },
      shouldShowATInternet: function () {
        return this.shouldShowFeature(enums.Features.AT_INTERNET_INTEGRATION);
      },
      shouldShowChartbeat: function () {
        return this.shouldShowFeature(enums.Features.CHARTBEAT_INTEGRATION);
      },
      shouldShowKISSMetrics: function () {
        return this.shouldShowFeature(enums.Features.KISSMETRICS_INTEGRATION);
      },
      shouldShowMixpanel: function () {
        return this.shouldShowFeature(enums.Features.MIXPANEL_INTEGRATION);
      },
      shouldShowUA: function () {
        return this.shouldShowFeature(enums.Features.UNIVERSAL_ANALYTICS_INTEGRATION);
      },
      shouldShowGA: function () {
        return this.shouldShowFeature(enums.Features.GOOGLE_ANALYTICS_INTEGRATION);
      }
    },
    methods: {
      /**
       * Helper function to check whether a feature/integration should be shown to the user, based on
       * the features to show being passed in by the instantiator.
       *
       * @param feature The integration to consider.
       * @returns {boolean}
       */
      shouldShowFeature: function(feature) {
        return this.showContainer.indexOf(feature) > -1;
      },
      /**
       * This is used for Universal Analytics.
       * Selected custom dimension slot is:
       * - Invalid (False) if selected custom dimension is already in use
       *   by another experiment
       */
      _hasValidSlot: function () {
        // Null is the only invalid tracker name. If it is null, then
        // an existing custom dimension slot can potentially be overwritten by the following logic:
        // 1. No conflicts are detected because null is not an existing tracker.
        // 2. Null tracker will be coerced to "" in GAE, which could be an existing tracker already with the same slot in use.
        // However, tracker should never be null due to prior initialization with default values.
        if (this.universalAnalyticsTracker !== null) {
          // Each tracker has only MAX_NUM_UA_SLOTS available to use.
          // Each slot can have only one experimentId.
          var slotsToExperimentIdsDictForTracker = this.existingSlots[this.universalAnalyticsTracker];
          if (slotsToExperimentIdsDictForTracker) {
            var storedExperimentId = slotsToExperimentIdsDictForTracker[this.universalAnalyticsSlot];
            // There is a conflict if a different experiment ID is already using the current slot.
            if (storedExperimentId && parseInt(storedExperimentId, 10) !== parseInt(this.experimentId, 10)) {
              return false;
            }
          }
        }
        return true;
      },
      /**
       * Update Experiment object and hide dialog when 'submit' button is clicked.
       */
      applyChanges: function (event) {
        if (this.universalAnalytics && !this._hasValidSlot()) {
          var warning = tr('The Universal Analytics custom dimension number is the same as one already being used. Are you sure you wish to use this slot number?<br><br> Click OK to save, Cancel to abort saving.');
          confirm.confirm({
            isWarning: true,
            title: tr('Overwrite Custom Dimension?'),
            message: warning,
            confirmAction: tr('Overwrite')
          }).then(function() {
            // Update values if user confirms
            var occupying_experiment_id = this.existingSlots[this.universalAnalyticsTracker][this.universalAnalyticsSlot];
            // Update the experiment that was just overwritten to turn
            // off the UA integration.
            // If this AJAX call fails, it's caught by the generic AJAX error handler
            // Question for code review: I exposed the universal_analytics property
            // in the new API. Is that okay? @neha @dogan
            experimentService.updateExperiment(occupying_experiment_id, {
              universal_analytics: 'disabled' // This is stored as either 'enabled' or 'disabled'...
            }).done((function() {
              this._saveAndClose();
            }).bind(this));
          }.bind(this));
        } else {
          this._saveAndClose();
        }
      },
      /**
       * Broadcasts changes to the experiment's analytics and closes the dialog.
       * Probably shouldn't be called by anything other than this.applyChanges
       * @private
       */
      _saveAndClose: function() {
        var newValues = {
          // Cast values to remain consistent with Experiment model in GAE.
          universalAnalyticsTracker: String(this.universalAnalyticsTracker),
          universalAnalyticsSlot: parseInt(this.universalAnalyticsSlot, 10),
          universalAnalytics: Boolean(this.universalAnalytics)
        };
        app.$broadcast('integrations-dialog:updateLocalExperiment', newValues);
        this.$dispatch('hideDialog');
      },
      /**
       * This is used for Universal Analytics.
       * Makes an async call to retrieve all of the custom dimension slots in use across
       * all experiments in a project.
       */
      _loadUASlotsInUse: function () {
        experimentService.listUniversalAnalyticsSlotsInUse(this.projectId)
          .done(function(slots) {
            // Slots has schema {universalAnalyticsTracker : {universalAnalyticsSlot : experimentId, ...}, ...}
            this.existingSlots = slots;
          }.bind(this));
      }
    },
    ready: function() {
        // Universal Analytics section
        this._loadUASlotsInUse();
    }
  };
});


define('text!components/dialogs/audiences_disabled.html',[],function () { return '<div class="dialog--narrow">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      Audiences Disabled\n    </div>\n  </div>\n  <div class="dialog__body">\n    <p>\n      This experiment uses segments or new/returning visitors in its targeting conditions,\n      so the experiment can\'t be migrated to audiences and audiences are disabled.\n    </p>\n    <p>\n      To enable audiences, remove the segments or select "all" visitors and refresh the page.\n    </p>\n    <p>\n      Create a new audience and add the targeting conditions back as dimensions to maintain\n      the same experiment with audiences enabled.\n    </p>\n  </div>\n  <div class="dialog__footer">\n    <button type="button" class="button secondary-button" v-hide-dialog>Close</button>\n  </div>\n</div>\n';});

/**
 * Component to show the audiences disabled dialog
 *
 * @author Daniel O'Connor (daniel@optimizely.com)
 */
define('components/dialogs/audiences_disabled',['require','app','text!components/dialogs/audiences_disabled.html'],function(require) {
  var app = require('app');
  var tmpl = require('text!components/dialogs/audiences_disabled.html');

  return {
    template: tmpl,
  };
});


define('text!components/dialogs/change_account_name.html',[],function () { return ' <form class="standard dialog--narrow"\n v-on="submit: changeAccountName($event, name)">\n   \n   <div class="dialog__header">\n   \t<div class="dialog__title">\n   \t\tChange Account Name\n   \t</div>\n   </div>\n   \n   <div class="dialog__body">\n   \t<label>\n   \t\t<input type="text" v-model="name"/>\n   \t</label>\n   \t\n   </div>\n   \n   <div class="dialog__footer">\n   \t<button id="account-name-change-button" type="submit" class="primary-button">Change Account name</button>\n   \t<button class="secondary-button" type="button" v-hide-dialog>Cancel</button>\n   </div>\n \n</form>';});

/**
  * Change Account Name Form Component
  *
  */
define('components/dialogs/change_account_name',['require','app','text!components/dialogs/change_account_name.html','services/auth','services/account'],function(require) {
  var app = require('app');
  var tmpl = require('text!components/dialogs/change_account_name.html');
  var auth = require('services/auth');
  var account = require('services/account');

  return {
    template: tmpl,

    created: function() {
      this.name = auth.getCurrentUserAccountName();
    },

    methods: {

      /**
       * Changes the current account's account_name
       * @param {String} event
       * @param {String} accountName
       */
      changeAccountName: function(event, accountName) {
        event.preventDefault();
        account.changeAccountName(accountName);
        app.$broadcast('hideDialog');
      },
    }
  };

});


define('text!components/dialogs/changed_code.html',[],function () { return '<form class="standard dialog--wide">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      Changed Variations\n     </div>\n  </div>\n   \n  <div class="dialog__body">\n    <div class="changed-code" v-repeat="variation: changed_code">\n      <h4 id="variation-name"> [[ variationName(variation) ]] ([[ variationEventDescription(variation) ]]) </h4>\n        <table width="100%">\n          <tr>\n            <td>\n              <div v-repeat="line: variation.diff">\n                <div class="changed-code--[[ line.type ]]">[[ line.diff ]]</div>\n              </div>\n            </td>\n           </tr>\n        </table>\n    </div>\n  </div> \n  <div class="dialog__footer">\n    <button class="secondary-button" type="button" v-hide-dialog>Cancel</button>\n  </div>\n\n</form>\n\n\n\n\n';});

/**
 * Changes model
 *
 * @author Jennifer Hu (jennifer.hu@optimizely.com)
 */
define('models/change_set',['require','services/model_factory','models/field_types'],function(require) {
  var modelFactory = require('services/model_factory');
  var fieldTypes = require('models/field_types');

  return modelFactory.create({
    entity: 'changes',

    fields: {
      id: null,
      changes: []
    },
  });
});

/**
  * Changed Code Dialog Component
  *
  */
define('components/dialogs/changed_code',['require','text!components/dialogs/changed_code.html','services/experiment','models/change_set'],function(require) {
  var tmpl = require('text!components/dialogs/changed_code.html');
  var experiment = require('services/experiment');
  var ChangeSet = require('models/change_set');

  return {
    template: tmpl,

    data: {
      changeset_id: null,
      changed_code: []
    },

    methods: {
      _loadChangedCode: function() {
        ChangeSet.fetch(this.changeset_id)
          .done(function(data) {
            this.changed_code = data.diffs;
          }.bind(this));
      },

      variationName: function(variation) {
        if (variation.section_name) {
          return variation.variation_name + " - " + variation.section_name
        }
        return variation.variation_name
      },

      variationEventDescription: function(variation) {
        switch (variation.event) {
          case 'create':
            return tr('created variation');
          case 'update':
            return tr('updated variation');
          case 'delete':
            return tr('deleted variation');
          default:
            return variation.event;
        }
      }
    },

    ready: function() {
      this._loadChangedCode();
    }
  };
});


define('text!components/dialogs/confirm.html',[],function () { return '<div class="dialog--narrow">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      [[ title ]]\n    </div>\n  </div>\n  <div class="dialog__body">\n    [[[ message ]]]\n  </div>\n  <div class="dialog__footer">\n    <button type="submit" class="button button-danger"\n      v-class="button-danger: isWarning,\n               button-primary: !isWarning"\n      v-on="click: accept">[[ confirmText ]]</button>\n    <button type="button" class="button secondary-button" v-hide-dialog>[[ cancelText ]]</button>\n  </div>\n</div>\n';});

/**
 * Component to show a confirm dialog
 * Intended to be used with services/confirm
 *
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('components/dialogs/confirm',['require','text!components/dialogs/confirm.html'],function(require) {
  var tmpl = require('text!components/dialogs/confirm.html');

  return {
    template: tmpl,

    data: {
      isWarning: false,
      title: tr('Please confirm your action'),
      message: tr('Are you sure?'),
      confirmText: tr('Confirm'),
      cancelText: tr('Cancel'),
      /**
       * @var {Deferred} fulilled on accept, rejected on close/hideDialog
       */
      _confirmDeferred: null,
      _hasAccepted: false
    },

    afterDestroy: function() {
      if (this._confirmDeferred && !this._hasAccepted) {
        this._confirmDeferred.reject();
      }
    },

    methods: {
      accept: function(event) {
        event.preventDefault();
        if (this._confirmDeferred) {
          this._confirmDeferred.resolve();
          this._hasAccepted = true;
        }
        this.$dispatch('hideDialog');
      }
    }
  };
});

/**
 * Create an alert dialog with the given parameters (similar to window.alert)
 *
 * Usage:
 *
 * var alert = require('services/alert');
 * alert.error({title: 'My title'}).then(function() {
 *   console.log('Alert closed!');
 * });
 *
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('services/alert',['require','app'],function(require) {
  var app = require('app');

  /**
   * Spawn a dialogs/alert component; return a deferred that will be resolved when the dialog closes.
   *
   * @param componentData Data to pass to the dialogs/alert component
   * @returns {$.Deferred}
   */
  var alert = function(componentData) {
    var onClose = $.Deferred();

    var data = _.extend({}, componentData, {
      _onClose: onClose
    });

    app.$broadcast('showDialog', {
      component: 'dialogs/alert',
      data: data
    });

    return onClose;
  };

  /**
   * Like alert, but set isError to true first
   *
   * @param componentData
   * @returns {$.Deferred}
   */
  var error = function(componentData) {
    return alert(_.extend({}, componentData, {
      isError: true
    }));
  };

  return {
    alert: alert,
    error: error
  };
});


define('text!components/dialogs/create_experiment.html',[],function () { return '<form class="create-experiment-form standard dialog--narrow" v-on="submit: createExperiment" v-loading="dialogs.create-experiment">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      Create Experiment\n    </div>\n    <p v-show="project_id">\n        Your new experiment will appear under "DRAFTS" until you start it.\n        Then it will appear under "ACTIVE".\n    </p>\n    <p v-show="!project_id">\n        Enter a URL below to get started on a new experiment!\n    </p>\n  </div>\n\n  <div class="dialog__body">\n    <label>\n        <span v-show="isWebProject">Experiment Name (optional)</span>\n        <span v-show="isiOSProject">Experiment Name</span>\n        <span for="name" class="error" v-text="name_error"></span>\n        <input type="text" name="name" v-model="name" v-class="error: name_error" v-attr="required: isiOSProject" v-on="invalid: invalidInput"/>\n    </label>\n    <label v-show="isWebProject">\n        <span>Experiment URL</span>\n        <span for="url" class="error" v-text="url_error"></span>\n        <input type="text" name="url" v-model="url" maxlength="500" v-class="error: url_error" v-attr="required: isWebProject" v-on="invalid: invalidInput"/>\n    </label>\n    <p class="message error">[[ajax_error]]</p>\n  </div>\n\n  <div class="dialog__footer">\n    <button id="experiment-create-button" type="submit" class="primary-button" v-attr="disabled: buttonsDisabled">Create experiment</button>\n    <button class="secondary-button" type="button" v-attr="disabled: buttonsDisabled" v-hide-dialog>Cancel</button>\n  </div>\n</form>\n';});

/**
 * Experiment Create Form Component
 *
 */
define('components/dialogs/create_experiment',['require','window','services/alert','services/router','utils/enums','services/events','services/experiment','text!components/dialogs/create_experiment.html','flux','models/project'],function(require) {
  var $window = require('window');
  var alert = require('services/alert');
  var router = require('services/router');
  var enums = require('utils/enums');
  var events = require('services/events');
  var experimentService = require('services/experiment');
  var tmpl = require('text!components/dialogs/create_experiment.html');
  var flux = require('flux');
  var Project = require('models/project');

  return {
    template: tmpl,
    replace: true,
    data: {
      buttonsDisabled: false,
      project_id: null,
      project_platforms: [],
      name: '', // form data
      name_error: null,
      url: '', // form data
      url_error: null,
      ajax_error: null
    },
    computed: {
      primaryPlatform: function() {
        return this.project_platforms[0];
      },
      isWebProject: function() {
        return _.contains(this.project_platforms, enums.ProjectPlatformType.WEB);
      },
      isiOSProject: function() {
        return _.contains(this.project_platforms, enums.ProjectPlatformType.IOS);
      },
      isAndroidProject: function() {
        return _.contains(this.project_platforms, enums.ProjectPlatformType.ANDROID);
      },
      isMobileProject: function() {
        return this.isiOSProject || this.isAndroidProject;
      }
    },
    methods: {
      /**
       * Creates a new experiment based on the current data model
       *
       * @param event The jQuery event that occurred. Needed to preventDefault
       */
      createExperiment: function(event) {
        event.preventDefault();
        this.buttonsDisabled = true;

        if (this.primaryPlatform === enums.ProjectPlatformType.WEB) {
          this._createWebExperiment();
        } else if (this.primaryPlatform === enums.ProjectPlatformType.IOS ||
                   this.primaryPlatform === enums.ProjectPlatformType.ANDROID) {
          this._createMobileExperiment();
        } else {
          throw new Error('Cannot create an experiment for a project with an unknown platform type');
        }
      },
      /**
       * For handling the 'invalid' DOM event.
       *
       * @param event
       */
      invalidInput: function(event) {
        event.preventDefault();

        // The only time this triggers is if input is empty and is 'required'. Each project type
        // currently only has one field that's required, so base logic on that
        if (this.isMobileProject) {
          this.name_error = 'This field is required';
        } else {
          this.url_error = 'This field is required';
        }
        this.buttonsDisabled = false;
      },
      _createWebExperiment: function() {
        // Redirect to editor
        $window.location = router.experimentEdit(
          {
            'url': this.url,
            'name': this.name,
            'projectId': this.project_id
          });
      },
      _createMobileExperiment: function() {
        var self = this;

        experimentService.createMobileExperiment(self.name, self.project_id, self.primaryPlatform)
          .done(function(data) {

            // Track the create experiment event
            events.track(events.getPageName(), 'create-mobile-experiment');

            // On success, redirect to the editor for this experiment
            $window.location = router.experimentEdit({
              experimentId: data.experiment_id,
              platform: self.primaryPlatform
            });
          }).fail(function(jqXHR) {
            self.buttonsDisabled = false;

            var errorMessage;
            var errorId;
            if (jqXHR && jqXHR.responseText) {
              try {
                var responseJSON = $.parseJSON(jqXHR.responseText);
                if (responseJSON.error) {
                  errorMessage = responseJSON.error;
                }
                if (responseJSON.id) {
                  errorId = responseJSON.id;
                }
              } catch(e) {}
            }

            if (errorMessage) {
              self.ajax_error = errorMessage;
            } else {
              self.$dispatch('hideDialog');
              alert.error({
                errorId: errorId
              });
            }
          });
      }
    },
     created: function() {
      if (!this.project_id) {
        throw new Error('create-experiment component must be passed a project_id');
      }

      var loadingProject = flux.actions('api').fetch(Project, this.project_id).then(function(proj) {
        if (this.primaryPlatform) {
          if (!_.contains(proj.project_platforms, this.primaryPlatform)) {
            throw new Error("Project does not have specified primaryPlatform");
          }
        } else {
          this.project_platforms = proj.project_platforms;
        }
      }.bind(this));

      flux.actions('loading').when('dialogs.create-experiment', loadingProject);
    },
  };
});


define('text!components/dialogs/duplicate_experiment.html',[],function () { return '<div class="lego-dialog">\n  <div class="lego-dialog__header">\n    <div class="lego-dialog__title">Duplicate Experiment</div>\n  </div>\n  <div class="lego-dialog__body">\n    <p>These audiences and goals associated with this experiment have also been duplicated into \'[[ projectName ]]\'.</p>\n    <table class="lego-table" v-if="destinationAudiences.length > 0">\n      <thead>\n        <tr>\n          <th>Audience in old project</th>\n          <th>Audience in new project</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr v-repeat="audience: destinationAudiences">\n          <td>[[ audience.source_name ]]</td>\n          <td>[[ audience.destination_name]]\n            <span v-if="audience.could_not_make_reportable"></span>\n            <span v-if="audience.is_new">*</span>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n    <p class="micro" v-if="hasNewAudiences">\n      * newly created audience\n    </p>\n    <p class="micro" v-if="hasAudiencesThatCouldNotBeMadeReportable">\n       This audience could not be made available for reporting because you\'ve used all of your available reporting slots.\n    </p>\n    \n    <hr class="lego-rule" v-if="destinationAudiences.length > 0 && destinationGoals.length > 0" />\n\n    <table class="lego-table" v-if="destinationGoals.length > 0">\n      <thead>\n        <tr>\n          <th>Goal in old project</th>\n          <th>Goal in new project</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr v-repeat="goal: destinationGoals">\n          <td>[[ goal.old_title ]]</td>\n          <td>[[ goal.new_title ]]\n            <span v-if="goal.is_new">*</span>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n    <p class="micro" v-if="hasNewGoals">\n      * newly created goal\n    </p>\n  </div>\n\n  <div class="lego-dialog__footer lego-button-row--right">\n    <button class="lego-button" v-hide-dialog>Close</button>\n  </div>\n</div>\n';});

/**
 * Duplicate experiment entity migration dialog
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/dialogs/duplicate_experiment',['require','exports','module','flux','models/project','text!components/dialogs/duplicate_experiment.html'],function(require, exports, module) {
  var flux = require('flux');
  var Project = require('models/project');
  var tmpl = require('text!components/dialogs/duplicate_experiment.html');

  return {
    template: tmpl,

    computed: {
      hasAudiencesThatCouldNotBeMadeReportable: function() {
        return _.some(this.destinationAudiences, 'could_not_make_reportable');
      },
      hasNewAudiences: function() {
        return _.some(this.destinationAudiences, 'is_new');
      },
      hasNewGoals: function() {
        return _.some(this.destinationGoals, 'is_new');
      },
    },

    data: {
      destinationAudiences: [],
      destinationGoals: [],
      projectName: '',
    },
  };
});


define('text!components/dialogs/create_project.html',[],function () { return '<form class="standard dialog--wide"\n      v-on="submit: save">\n\n  <div class="dialog__header">\n    <div class="dialog__title">\n      Create Project\n    </div>\n  </div>\n\n    <div class="dialog__body">\n      <div class="label" style="margin-top: 2em;">Project Type</div>\n      <div class="selector selector-project-type">\n        <div class="selector-option"\n             v-on="click: selectedPlatform = \'web\'"\n             v-class="selected: selectedPlatform === \'web\'">\n          <div class="selector-option-graphic selector-graphic-first"></div>\n          <h4 class="selector-option-headline">Web Project</h4>\n          <p>Test and optimize web sites.</p>\n        </div>\n        <div class="selector-option"\n             v-on="click: selectedPlatform = \'ios\'"\n             v-class="selected: selectedPlatform === \'ios\'">\n          <div class="selector-option-graphic selector-graphic-middle"></div>\n          <h4 class="selector-option-headline">iOS Project</h4>\n          <p>Test and optimize native iOS apps.</p>\n        </div>\n        <div class="selector-option"\n             v-if="canCreateAndroidProject"\n             v-on="click: selectedPlatform = \'android\'"\n             v-class="selected: selectedPlatform === \'android\'">\n          <div class="selector-option-graphic selector-graphic-last"></div>\n          <h4 class="selector-option-headline">Android Project</h4>\n          <p>Test and optimize Android apps.</p>\n        </div>\n      </div>\n\n      <label for="project-name" v-text="projectNoun + \' Name\'"></label>\n      <input type="text" id="project-name" name="project-name"\n        placeholder="[[ \'My New \' + projectNoun ]]"\n        v-model="project.project_name">\n      <div class="push-double--top">\n        <p>\n          Each project has a unique <strong>Project Code</strong> which must be included on every web page or app running experiments or tracking goals.\n        </p>\n      </div>\n\n      <p class="last">\n        For more information, see\n        <a href="https://help.optimizely.com/hc/en-us/articles/200040745" target="_blank">Managing Projects</a>.\n      </p>\n\n    </div>\n    <div class="dialog__footer">\n      <div class="buttons">\n        <button class="lego-button lego-button--highlight" type="submit"\n          v-lego-disabled="!selectedPlatform || !project.project_name">Create project</button>\n        <button class="lego-button lego-button--secondary" type="button" v-hide-dialog>Cancel</button>\n      </div>\n    </div>\n  </div>\n</form>\n';});

/**
 * Create Project dialog component
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/dialogs/create_project',['require','exports','module','lodash','utils/enums','flux','text!components/dialogs/create_project.html','models/project'],function(require, exports, module) {
  var _ = require('lodash');
  var enums = require('utils/enums');
  var flux = require('flux');
  var tmpl = require('text!components/dialogs/create_project.html');

  var Project = require('models/project');

  return {
    template: tmpl,

    data: {
      _onSave: null,
      project: {},
      selectedPlatform: null,
    },

    computed: {
      canCreateAndroidProject: function() {
        var account = flux.store('account');
        var currentProject = flux.store('projects').get(account.getId());

        return flux.actions('permissions').canCreateAndroidProject(currentProject, account);
      },

      projectNoun: function() {
        var noun = tr('Project');
        if (_.contains(enums.ProjectPlatformsMobile, this.selectedPlatform)) {
          noun = tr('App');
        }
        return noun;
      }
    },

    methods: {
      save: function(event) {
        event.preventDefault();

        this.project.project_platforms = [this.selectedPlatform];
        trackEvent('/project/create/' + this.selectedPlatform);
        flux.actions('api').persistEntity(Project, this.project).done(function(savedProject) {
          // if _onSave deferred is present, resolve it
          if (this._onSave) {
            // resolve with a new instance of the project
            this._onSave.resolve(savedProject);
          }
          this.$dispatch('hideDialog');
        }.bind(this))
      }
    },

    ready: function() {
      var accountId = flux.store('account').getId();
      // create a new project
      this.project = Project.create({
        account_id: accountId,
      });
    },
  };
});


define('text!components/dialogs/dimension_editor.html',[],function () { return '<form class="dimension-editor-form standard dialog--narrow"\n  v-on="submit: save">\n\n  <div class="dialog__header">\n    <div class="dialog__title" v-text="title"></div>\n    <p>\n    Dimensions can be used to track extra data about visitors. You can use dimensions to filter your results or define new audiences for targeting. <a href="https://help.optimizely.com/hc/en-us/articles/200040865#custom_dimensions" target="_blank">Learn more</a>.\n    </p>\n\n  </div>\n\n  <div class="dialog__body">\n    <div class="horizontal-form clearfix">\n      <div class="control-group">\n        <label for="dimension-name">Dimension Name</label>\n        <div class="controls">\n          <input id="dimension-name" required type="text"\n                 v-model="dimension.name" />\n        </div>\n      </div>\n      <div class="control-group">\n        <label for="dimension-description">Dimension Description (optional)</label>\n        <div class="controls">\n          <textarea id="dimension-description" v-model="dimension.description"></textarea>\n        </div>\n      </div>\n      <div class="control-group" v-if="!isNew">\n        <label for="dimension-id">Dimension ID</label>\n        <div class="controls">\n          <span id="dimension-id" v-text="dimension.id"></span>\n        </div>\n      </div>\n      <div class="control-group">\n        <label for="dimension-api-name">Dimension API Name (optional)</label>\n        <div class="controls">\n          <input id="dimension-api-name" type="text"\n                 v-model="dimension.client_api_name" />\n        </div>\n      </div>\n\n      <p class="alert-box alert-box-error"\n        v-if="displayErrors"\n        v-html="displayErrors">\n      </p>\n    </div>\n  </div>\n\n  <div class="dialog__footer">\n    <button id="dimension-create-button" type="submit" class="lego-button lego-button--highlight"\n            v-lego-disabled="isSaving">Save</button>\n    <button class="lego-button lego-button--secondary" type="button"\n            v-lego-disabled="isSaving" v-hide-dialog>Cancel</button>\n  </div>\n\n</form>\n';});

/**
 * Dimension Editor component
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/dialogs/dimension_editor',['require','exports','module','lodash','utils/handle_ajax_error','models/dimension','flux','text!components/dialogs/dimension_editor.html'],function(require, exports, module) {
  var _ = require('lodash');
  var handleAjaxError = require('utils/handle_ajax_error');
  var Dimension = require('models/dimension');
  var flux = require('flux');
  var tmpl = require('text!components/dialogs/dimension_editor.html');

  return {
    template: tmpl,

    data: {
      _onSave: null,
      dimension: {},
      error: null,
      isNew: true,
      isSaving: false,
      originalDimension: {}
    },

    computed: {
      /**
       * Format this.error to show each error on newline if an array
       * @return {Array|null}
       */
      displayErrors: function() {
        var errors = null;
        if (_.isString(this.error) && this.error) {
          errors = [this.error];
        } else if (_.isArray(this.error)) {
          errors = this.error;
        }
        return (errors) ? errors.join("<br />") : errors;
      },
      title: function() {
        return this.isNew ? tr('Create Visitor Dimension') : tr('Edit Visitor Dimension');
      }
    },

    methods: {
      save: function(event) {
        event.preventDefault();

        this.isSaving = true;

        // Use flux apiActions.persistEntity here so that all components receive the updated entity
        flux.actions('api').persistEntity(Dimension, this.dimension).done(function(savedDimension) {
          // if _onSave deferred is present, resolve it
          if (this._onSave) {
            // resolve with a new instance of the dimension
            this._onSave.resolve(savedDimension);
          }

          this.$dispatch('hideDialog');
        }.bind(this))
        .fail(handleAjaxError(function(reason) {
          this.error = reason;
        }.bind(this)))
        .always(function() {
          this.isSaving = false;
        }.bind(this));
      }
    },

    ready: function() {
      // dereference dimension
      this.dimension = Dimension.create(this.dimension);

      if (this.dimension.id) {
        this.isNew = false;
      }
    }
  };
});


define('text!components/dialogs/get_feedback.html',[],function () { return '<div id="getfeedback-dialog" class="dialog__header">\n  <div class="dialog__title">\n    Feedback\n  </div>\n</div>\n<div class="feedback-iframe">\n  <iframe src="https://optimizely.getfeedback.com/r/LFGiuWTu?gf_bottom_bar_color=F8F8F8&accountId=[[ accountId ]]&email=[[ email ]]&page=[[ page ]]" frameborder="0"></iframe>\n</div>\n';});

/**
 * get-feedback component
 *
 * @author Byron Jones (byron@optimizely.com)
 */

define('components/dialogs/get_feedback',['require','flux','app','text!components/dialogs/get_feedback.html'],function(require) {
  var flux = require('flux');
  var app = require('app');
  var tmpl = require('text!components/dialogs/get_feedback.html');

  return {
    template: tmpl,

    replace: true,

    created: function() {
      this.accountId = flux.store('account').getId();
      this.email = flux.store('account').getEmail();
      // split the url to get the Optimizely current page (dashboard, edit, account, etc.)
      this.page = window.location.href.split(/[\/?]/)[3];
    }
  };
});


define('text!components/dialogs/delete_goal.html',[],function () { return '<form id="delete-goal-dialog" class="dialog--narrow" v-on="submit: deleteGoal">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      Delete Goal\n    </div>\n  </div>\n\n  <div class="dialog__body">\n    <p class="loading" v-if="isLoading">\n      <img src="/static/img/loading.gif" />\n      Loading...\n    </p>\n\n    <div v-if="!isLoading">\n      <p>\n        <strong>"[[ goal.title ]]"</strong> will be deleted from all experiments that use it.\n        This goal will be permanently deleted and cannot be reused. This action <span class="warning-text">cannot be undone</span>.\n      </p>\n\n      <div class="experiment-list-container">\n        <div class="collapsible" v-class="collapsed: !showingMore">\n          <label class="control">\n            <span class="line"></span>\n            <span class="text">\n              Used in [[ experimentCount ]] [[ experimentCount | pluralize experiment ]]\n            </span>\n          </label>\n        </div>\n\n        <ul class="list-unstyled goal-experiments-list" v-class="showing-more: showingMore">\n          <li v-repeat="experiment: experiments" v-class="hidden-experiment: $index > 2">\n            <a href="[[ experimentEdit(experiment.id) ]]" target="optlyEdit[[experiment.id]]"\n              v-if="currentExperimentId !== experiment.id">\n              [[ experiment.description ]]\n            </a>\n            <span v-if="currentExperimentId === experiment.id">\n              [[ experiment.description ]] (current)\n            </span>\n          </li>\n        </ul>\n\n        <a class="show-more-link"\n          v-on="click: toggleShowingMore"\n          v-if="experimentCount > 3">\n          Show [[ showingMore ? \'fewer\' : \'more\' ]] experiments&hellip;\n        </a>\n      </div>\n    </div>\n  </div>\n\n  <div class="dialog__footer">\n    <button type="submit" class="button-danger">Yes, delete [[ experimentCount > 0 ? \'from all\' : \'\' ]]</button>\n    <button class="secondary-button" type="button" v-hide-dialog>Cancel</button>\n  </div>\n</form>\n';});

/**
 * Delete goal dialog
 */
define('components/dialogs/delete_goal',['require','flux','text!components/dialogs/delete_goal.html','services/router','models/goal','models/experiment'],function(require) {
  var flux = require('flux');
  var tmpl = require('text!components/dialogs/delete_goal.html');
  var router = require('services/router');
  var Goal = require('models/goal');
  var Experiment = require('models/experiment');

  return {
    template: tmpl,

    data: {
      _goalId: null,
      _deleteGoalDeferred: null,
      currentExperimentId: null,
      experimentCount: -1,
      experiments: [],
      goal: {},
      isLoading: true,
      showingMore: false
    },

    methods: {
      /**
       * Shortcut to router method
       * @param {Integer} experimentId
       * @return {String} url to experiment edit
       */
      experimentEdit: function(experimentId) {
        return router.experimentEdit({
          experimentId: experimentId
        });
      },
      /**
       * Deletes the goal and hides the dialog
       * @param {Event} event
       */
      deleteGoal: function(event) {
        event.preventDefault();
        flux.actions('goals').delete(this.goal).then(function() {
          if (this._deleteGoalDeferred) {
            this._deleteGoalDeferred.resolve(this.goal.id);
          }
          this.$dispatch('hideDialog');
        }.bind(this));
      },
      /**
       * Toggles the showingMore flag
       */
      toggleShowingMore: function() {
        this.showingMore = !this.showingMore;
      },
      /**
       * Fetches all experiment objects that use a certain goal
       *
       * @param {Array.<Integer>} experimentIds
       */
      fetchGoalExperiments: function(experimentIds) {
        var firstExperiments = [];
        var laterExperiments = [];

        // if there are more than 3 experiments fetch the first three
        // and the remaining separately
        if (experimentIds.length > 3) {
          firstExperiments = experimentIds.slice(0, 3);
          laterExperiments = experimentIds.slice(3);
        } else {
          firstExperiments = experimentIds;
        }

        // map an array of deferred Experiment objects
        var firstDeferreds = firstExperiments.map(function(id) {
          return Experiment.fetch(id);
        });

        // when all the first three experiments are loaded
        $.when.apply($, firstDeferreds).then(function() {
          var results = [].slice.call(arguments);

          this.experiments = results;
          this.isLoading = false;

          if (laterExperiments.length > 0) {
            var secondDeferreds = laterExperiments.map(function(id) {
              return Experiment.fetch(id);
            });

            $.when.apply($, secondDeferreds).then(function() {
              var results = [].slice.call(arguments);
              results.forEach(function(exp) {
                this.experiments.push(exp);
              }.bind(this))
            }.bind(this));
          }
        }.bind(this));
      }
    },

    created: function() {
      if (!this._goalId) {
        throw new Error("Must specify _goalId");
      }

      Goal.fetch(this._goalId).then(function(goal) {
        this.goal = goal;
        this.experimentCount = goal.experiment_ids.length;

        this.fetchGoalExperiments(goal.experiment_ids);
      }.bind(this));
    }
  }
});

/**
 * Component for the "Experiment Audiences" set of dialogs in the editor.
 * Provides a consistent data source and acts as a view manager for
 * subcomponents: audience-editor, experiment-audiences, saved-audiences
 *
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('components/dialogs/experiment_audiences',['require','models/audience','models/experiment','services/audience','services/confirm','services/dimension'],function(require) {
  var Audience = require('models/audience');
  var Experiment = require('models/experiment');
  var audienceService = require('services/audience');
  var confirm = require('services/confirm');
  var dimensionService = require('services/dimension');

  var VIEWS = {
    AUDIENCE_EDITOR: 'audience-editor',
    EXPERIMENT_AUDIENCES: 'experiment-audiences',
    SAVED_AUDIENCES: 'saved-audiences'
  };

  return {
    // TODO(tyler): should this be a js template?
    template: '#experiment-audiences-dialog-template',

    data: {
      /** @type {boolean} Whether to add a created audience to experiment-audiences */
      addToExperiment: true,
      /** @type {Audience} The current audience (for audience-editor) */
      audience: null,
      /** @type {Array.<Audience>} All audiences (saved and experiment) */
      audiences: [],
      /** @type {Experiment|Object} The current experiment, or an object with Experiment properties */
      experiment: {},
      /** @type {VIEWS} The last view seen (for restoring when audience editor is closed) */
      lastView: null,
      /** @type {VIEWS} The current view */
      currentView: VIEWS.EXPERIMENT_AUDIENCES,
      /** @type {boolean} */
      loadingExperimentAudiences: true,
      /** @type {boolean} */
      loadingSavedAudiences: true,
      /** @type {number} Open reporting slots in the project */
      openReportingSlots: 0,
      /** @type {Array.<number>} experiment.audience_ids when component was instantiated */
      originalAudienceIds: [],
      /**
       * Optional string to filter audiences by
       * @type {string}
       */
      query: '',
      /** @type {optly.Event} Event to fire on ready (designated by caller) */
      _openEvent: null,
      /** @type {optly.Event} Event to fire on close (designated by caller) */
      _closeEvent: null
    },

    computed: {
      currentAudiences: function() {
        var experimentAudiences = this.experimentAudiences;
        var savedAudiences = this.savedAudiences;

        return this.currentView === VIEWS.EXPERIMENT_AUDIENCES ? experimentAudiences : savedAudiences;
      },
      /**
       *
       * @returns {Array.<Audience>} Audiences which match the query
       */
      filteredAudiences: function() {
        if (this.query) {
          return this.currentAudiences.filter(function(audience) {
            // Note: if filterAudience uses any properties besides query they must be declared
            // in order to make vue "watch" them
            return this._filterAudience(audience);
          }.bind(this));
        }
        return this.currentAudiences;
      },
      loading: function() {
        var loadingExperimentAudiences = this.loadingExperimentAudiences;
        var loadingSavedAudiences = this.loadingSavedAudiences;

        return this.currentView === VIEWS.EXPERIMENT_AUDIENCES ? loadingExperimentAudiences : loadingSavedAudiences;
      },
      /**
       *
       * @returns {Array.<Audience>} audiences which have segmentation enabled
       */
      segmentationAudiences: function() {
        return this.audiences.filter(function(audience) {
          return audience.segmentation == true;
        });
      },
      /**
       * Note: the setter is needed in order to pass these computeds to child components using
       * v-with; however we don't set this property directly, instead relying on experiment.audience_ids
       *
       */
      experimentAudiences: {
        /**
         *
         * @returns {Array.<Audience>} audiences corresponding to the current experiment.audience_ids
         */
        $get: function() {
          var experimentAudienceIds = this.experiment.audience_ids;

          return this.audiences.filter(function(audience) {
            return _.contains(experimentAudienceIds, audience.id);
          });
        },
        /**
         * Set experiment.audience_ids to set of audiences listed
         * @param audiences
         */
        $set: function(audiences) {
          this.experiment.audience_ids = _.pluck(audiences, 'id');
        }
      },
      /**
       * Note: the setter is needed in order to pass these computeds to child components using
       * v-with; however we don't set this property directly, instead relying on experiment.audience_ids
       */
      savedAudiences: {
        /**
         *
         * @returns {Array.<Audience>} audiences which are not in experiment.audience_ids
         */
        $get: function() {
          var experimentAudienceIds = this.experiment.audience_ids;

          return this.audiences.filter(function(audience) {
            return !_.contains(experimentAudienceIds, audience.id) && !audience.archived;
          });
        },
        /**
         * Remove any ids in audiences from experiment.audience_ids
         * @param audiences
         */
        $set: function(audiences) {
          var audienceIds = _.pluck(audiences, 'id');

          _.remove(this.experiment.audience_ids, function(audience) {
            return _.contains(audienceIds, audience.id);
          });
        }
      }
    },

    methods: {
      /**
       * Switch to "audience-editor" view
       */
      showAudienceEditor: function() {
        this.lastView = this.currentView;
        this.currentView = VIEWS.AUDIENCE_EDITOR;
      },
      /**
       * Switch to "saved-audiences" view
       */
      showSavedAudiences: function() {
        this.addToExperiment = false;
        this.currentView = VIEWS.SAVED_AUDIENCES;
      },
      /**
       * Switch to "experiment-audiences" view
       */
      showExperimentAudiences: function() {
        this.addToExperiment = true;
        this.currentView = VIEWS.EXPERIMENT_AUDIENCES;
      },
      /**
       * Create a new Audience and show the audience-editor
       */
      newAudience: function() {
        this.audience = Audience.create({
          project_id: this.experiment.project_id
        });
        this.showAudienceEditor();
      },
      /**
       * Create a new audience which is a clone of the audience
       * @param {Audience} audience
       */
      duplicateAudience: function(audience) {
        var newAudience = _.cloneDeep(audience);
        // reset the audience id
        newAudience.id = null;

        this.editAudience(newAudience);
      },
      /**
       * Set current audience and show the audience-editor
       * @param {Audience} audience Audience to edit
       */
      editAudience: function(audience) {
        this.audience = audience;
        this.showAudienceEditor();
      },
      /**
       * Add selected audience to current experiment
       * @param {Audience} audience to add to experiment
       */
      addExperimentAudience: function(audience) {
        this.experiment.audience_ids.push(audience.id);
        this.showExperimentAudiences();
      },
      /**
       * Remove selected audience from current experiment (after confirmation)
       * @param {Audience} audience to remove from experiment
       */
      removeExperimentAudience: function(audience) {
        var warning = tr('Are you sure you want to stop targeting this experiment to "{0}"?', audience.name);

        return confirm.confirm({
          isWarning: true,
          title: tr('Remove Audience from Experiment?'),
          message: warning,
          confirmAction: tr('Remove Audience')
        }).then(function() {
          this.experiment.audience_ids.splice(_.indexOf(this.experiment.audience_ids, audience.id), 1);
        }.bind(this));
      },
      /**
       * Clear the query filter
       */
      clearFilter: function() {
        this.query = '';
      },
      /**
       * Does audience match the filter?
       * @param {Audience} audience
       * @returns {boolean}
       * @private
       */
      _filterAudience: function(audience) {
        // TODO(tyler): reimplement this as a service
        return optly.util.main.isFilterTermInItem(
          this.query.toLocaleLowerCase(),
          audience.name + " " + audience.description
        );
      },
      /**
       * Fetch dimensions, add to segmentation audiences, and subtract from total slots allowed
       * @private
       * @param {number} projectId
       * @param {Array.<Model>} audiences
       */
      _calculateReportingSlots: function(projectId, audiences) {
        dimensionService.fetchAvailableReportingSlotsCount(projectId, audiences)
          .then(function(availableSlots) {
            this.openReportingSlots = availableSlots;
          }.bind(this));
      },
      /**
       * Handler for when the audience-editor child component
       * creates an audience
       * @param {Audience} audience
       * @private
       */
      _onAudienceCreate: function(audience) {
        this.audiences.push(audience);
        if (this.addToExperiment) {
          this.experiment.audience_ids.push(audience.id);
        }
      },
      /**
       * Fetches all audiences that are attached to an experiment
       * and any audience that COULD be attached to the experiment.
       *
       * Does not fetch non `user_touched` experiments that aren't already
       * associated with the experiment
       *
       * @param {Model} experiment
       */
      _loadAudiences: function(experiment) {
        // load experiment audiences -> saved audiences serially, since only experiment audiences
        // are required to unblock the UI
        audienceService.fetchAudiencesById(experiment.audience_ids).then(function(audiences) {
          this.audiences = audiences;
          this.loadingExperimentAudiences = false;

          audienceService.fetchSavedAudiences(experiment.project_id).then(function(savedAudiences) {
            // since savedAudiences can contain audiences already attached with the experiment, filter those out
            var loadedAudienceIds = this.audiences.map(function(audience) {
              return audience.id;
            });

            savedAudiences.forEach(function(audience) {
              if (loadedAudienceIds.indexOf(audience.id) === -1) {
                this.audiences.push(audience);
              }
            }, this);
            this.loadingSavedAudiences = false;

            // once audiences are loaded we can calculate the available reporting slots
            this._calculateReportingSlots(this.experiment.project_id, this.audiences);

            // everything is done loading at this point
            if (this._openEvent) {
              this._openEvent.fire();
            }
          }.bind(this));
        }.bind(this));
      },
      /**
       * Go back to the last view shown
       * @private
       */
      _restorePreviousView: function() {
        this.currentView = this.lastView;
      }
    },

    /**
     * Check if experiment.audience_ids changed and inform caller if so
     */
    afterDestroy: function() {
      if (this._onSave) {
        var isDirty = !_.isEqual(
          _.sortBy(this.experiment.audience_ids),
          _.sortBy(this.originalAudienceIds)
        );
        this._onSave.resolve({
          experimentAudienceIds: this.experiment.audience_ids,
          isDirty: isDirty
        });
      }
    },

    ready: function() {
      // dereference experiment
      this.experiment = Experiment.create(this.experiment);
      // UI events
      this.$on('audience-editor:close', this._restorePreviousView.bind(this));

      // Model events
      this.$on('audience-editor:audienceCreated', this._onAudienceCreate.bind(this));

      // maintain the original audience ids to check if they have changed
      this.originalAudienceIds = _.clone(this.experiment.audience_ids);

      this._loadAudiences(this.experiment);
    }
  }
});


define('text!components/dialogs/duplicate_collaborators.html',[],function () { return '<div class="lego-dialog">\n  <div class="lego-dialog__header">\n    <div class="lego-dialog__title">Duplicate Collaborators</div>\n  </div>\n  <div class="lego-dialog__body">\n    <p>Invite [[[ collaboratorEmails | wrap-tag quote | list-to-readable-string ]]] to these projects:</p>\n    <fieldset>\n      <legend>Projects</legend>\n      <ul class="lego-input-list lego-matrix lego-matrix--1-3">\n        <li v-repeat="project: projects | orderBy project.project_name">\n          <input type="checkbox"\n          name="[[ project.id ]]"\n          id="[[ project.id ]]"\n          value="[[ project.id]]"\n          class="push--right"\n          v-on="click: addProject"\n          v-attr="checked: project.id === currentProjectId">\n          <label for="[[ project.id ]]">[[ project.project_name ]]</label>\n        </li>\n      </ul>\n    </fieldset>\n  </div>\n  <div class="lego-dialog__footer lego-button-row--right">\n    <button class="lego-button"\n      v-hide-dialog>Cancel</button>\n    <button class="lego-button lego-button--brand"\n      v-on="click: duplicateCollaborators">Add</button>\n  </div>\n</div>\n';});

/**
 * Function getter to get all the collaborators on the current project
 */
define('flux/getters/current_project/collaborators',['require','lodash'],function(require) {

  var _ = require('lodash');
  var PROJECT_ROLES = ['Viewer', 'Editor', 'Project Owner'];
  var ACCOUNT_ROLES = ['Administrator'];

  return [
    'currentProject',
    'account',
    'collaborators',
    function (currentProjectStore, accountStore, collaboratorsStore) {
      var currentProjectId = currentProjectStore.getId();
      var currentAccountId = accountStore.getId();
      if (currentProjectId) {
        
        // Viewers, editors, and project owners are project-level collaborators
        var projectUsers = collaboratorsStore.getAll({
          project_id: currentProjectId
        }).filter(function(user) {
          return _.contains(PROJECT_ROLES, user.role_name);
        });

        // But we also want to include admins associated with the admin account ID
        var accountUsers = collaboratorsStore.getAll({
          project_id: currentAccountId
        }).filter(function(user) {
          return _.contains(ACCOUNT_ROLES, user.role_name);
        });

        return _.uniq(_.union(projectUsers, accountUsers), 'user_id');

      } else {
        return [];
      }
    }
  ];
});

/**
 * Function getter to take currentProject + experiments store
 * and return all experiments for that project
 */
define('flux/getters/dashboard/filtered_collaborators',['lodash','flux/getters/current_project/collaborators'],function() {
  var _ = require('lodash');
  var getCurrentProjectCollaborators = require('flux/getters/current_project/collaborators');

  var tableId = 'dashboard-collaborators';

  return [
    getCurrentProjectCollaborators,
    'sortableTable',
    'dashboard/tableFilters',
    function (collaborators, sortableTableStore, filterStore) {
      var sortFn = sortableTableStore.getSortFn(tableId);
      var filtered = collaborators;
      var filterString = filterStore.getFilters('collaborators').string;

      if (filterString) {
        filterString = filterString.toLowerCase();
        filtered = collaborators.filter(function(collab) {
          var email = collab.user_id;
          var role = collab.role_name;
          var name = collab.first_name + ' ' + collab.last_name;
          filterString = filterString.toLowerCase();
          return (
            email.toLowerCase().indexOf(filterString) !== -1 ||
            role.toLowerCase().indexOf(filterString) !== -1 ||
            name.toLowerCase().indexOf(filterString) !== -1
          );
        });
      }

      if (sortFn) {
        filtered.sort(sortFn);
      }

      return filtered;
    }
  ];
});

/**
 * Gets the selected collaborators for the sidebar & dialogs on the dashboard
 *
 * @author Cheston Lee (cheston@optimizely.com)
 */
define('flux/getters/dashboard/selected_collaborators',['flux/getters/dashboard/filtered_collaborators'],function() {
  var getDashboardFilteredCollaborators = require('flux/getters/dashboard/filtered_collaborators');

  return [
    'dashboard/selectedItems',
    getDashboardFilteredCollaborators,
    function(selectedItemsStore, collaborators) {
      var selectedItems = selectedItemsStore.getSelectedIds('collaborators');
      return collaborators.filter(function(collaborator) {
        return selectedItems.indexOf(collaborator.id) !== -1;
      });
    }];
});

/**
 * Duplicate Collaborators Dialog Component
 *
 * @author Cheston Lee (cheston@optimizely.com)
 */
define('components/dialogs/duplicate_collaborators',['require','app','text!components/dialogs/duplicate_collaborators.html','flux','models/project','models/collaborator','flux/getters/dashboard/filtered_collaborators','flux/getters/dashboard/selected_collaborators'],function(require) {
  var app = require('app');
  var tmpl = require('text!components/dialogs/duplicate_collaborators.html');
  var flux = require('flux');
  var Project = require('models/project');
  var Collaborator = require('models/collaborator');

  var getDashboardFilteredCollaborators = require('flux/getters/dashboard/filtered_collaborators');
  var getDashboardSelectedCollaborators = require('flux/getters/dashboard/selected_collaborators');

  return {
    template: tmpl,
    replace: true,
    data: {
      collaborators: [],
      selectedCollaborators: [],
      projects: [],
      projectsToCopyTo: []
    },
    computed: {

      collaboratorEmails: function() {
        return _.pluck(this.selectedCollaborators, 'user_id');
      }

    },
    methods: {
      /**
       * Called on dialog form submission to duplicate collaborators.
       *
       * @param {Event} event
       */
      duplicateCollaborators: function(event) {
        event.preventDefault();
        var promises = [];
        if (this.selectedCollaborators.length > 0) {
          this.selectedCollaborators.forEach(function(collaborator) {
            this.projectsToCopyTo.forEach(function(project_id) {
              var collaboratorToSave = _.clone(collaborator);
              collaboratorToSave.project_id = project_id;

              promises.push(flux.actions('collaborators').create(collaboratorToSave));
            }.bind(this));
          }.bind(this));
        }

        $.when.apply(null, promises).then(function() {
          console.log('promises resolved for create', arguments);
        });

        app.$broadcast('hideDialog');
        this.projectsToCopyTo = [];
      },

      /**
       * Handler for checkboxes to add/remove projects to add collaborators to
       *
       * @param {Event} event
       */
      addProject: function(event) {
        var projectId = parseInt(event.target.value);
        var exists = this.projectsToCopyTo.indexOf(projectId);

        if (exists !== -1) {
          this.projectsToCopyTo.splice(exists, 1);
        } else {
          this.projectsToCopyTo.push(projectId);
        }
      }
    },
    created: function() {
      this.currentProjectId = flux.store('currentProject').getId();
      this.accountId = flux.store('account').getId();

      flux.actions('api').fetchAll(Project, {
        'account_id' : this.accountId
      }).then(function(projects) {
        //Filter out the current project which the collab is already a member of
        this.projects = projects.filter(function(project) {
          return project.id !== this.currentProjectId;
        }.bind(this));
      }.bind(this));

      flux.bindVueValues(this, {
        collaborators: getDashboardFilteredCollaborators,
        selectedCollaborators: getDashboardSelectedCollaborators,
      });
    }
  };
});


define('text!components/dialogs/invite_collaborators.html',[],function () { return '<form id="collaborators-invite-dialog" v-on="submit: onSubmit">\n  <div class="lego-dialog">\n    <div class="lego-dialog__header">\n      <div class="lego-dialog__title">Invite Collaborators</div>\n    </div>\n    <div class="lego-dialog__body">\n      <header class="collaborators-form-header lego-grid lego-grid--gutter">\n        <p class="lego-label lego-grid__cell width-2-3 muted">EMAIL ADDRESS</p>\n        <p class="lego-label lego-grid__cell width-1-3 muted">ROLE</p>\n      </header>\n      <ul class="lego-form-fields">\n        <li class="lego-form-field__item"\n          v-component="invite-collaborators-row"\n          v-repeat="collaborator: newCollaborators"\n          v-with="parentList: newCollaborators, errors: errors">\n        </li>\n        <li class="lego-form-field__item hidden">\n          <label class="lego-label muted">WELCOME MESSAGE</label>\n          <textarea name="welcome-message" class="lego-textarea height-100">Hey!\nOptimizely is awesome. Please help me run rad experiments on our awesome site!</textarea>\n        </li>\n      </ul>\n      <div class="add-existing-collaborators push--top" v-if="addableCollaborators.length">\n        <a v-on="click: showAddExisting = true"\n           v-if="!showAddExisting"\n           href="javascript:void(0)">Add collaborators from other projects</a>\n        <ul v-if="showAddExisting">\n          <li v-repeat="collaborator: addableCollaborators" class="lego-grid lego-grid--gutter push--top">\n            <div class="lego-grid__cell width-2-3">\n              [[ collaborator.user_id ]]\n            </div>\n            <div class="lego-grid__cell width-1-3">\n              <a class="lego-button" v-on="click: addExistingCollaborator(collaborator)" href="javascript:void(0)">\n                Add to project\n              </a>\n            </div>\n          </li>\n        </ul>\n      </div>\n      <div class="push--top"\n        v-component="invite-collaborator-multiproject">\n        <a v-on="click: showInviteToProjects = true"\n          v-if="!showInviteToProjects"\n          class="link"\n          href="javascript:void(0)">Invite to multiple projects</a>\n        <fieldset v-if="showInviteToProjects">\n          <header class="lego-grid lego-grid--gutter">\n            <legend class="lego-label muted lego-grid__cell width-1-8">PROJECTS</legend>\n            <a href="javascript:void(0)"\n              class="lego-grid__cell width-1-8"\n              v-on="click: showInviteToProjects = false">hide</a>\n          </header>\n          <ul class="lego-input-list lego-matrix lego-matrix--1-4">\n            <li v-repeat="project: projects | orderBy project.project_name">\n              <input type="checkbox"\n              id="[[ project.id ]]"\n              name="[[ project.id ]]"\n              value="[[ project.id]]"\n              class="push--right"\n              v-attr="checked: project.id === currentProject.id"\n              v-on="click: addProject">\n              <label for="[[ project.id ]]">[[ project.project_name ]]</label>\n            </li>\n          </ul>\n        </fieldset>\n      </div>\n      <p class="alert-box alert-box-error"\n        v-show="projectsToInviteTo.length === 0">\n        You must select at least one project to invite to.\n      </p>\n    </div>\n    <div class="lego-dialog__footer lego-button-row--right">\n      <button class="lego-button"\n        type="button"\n        v-hide-dialog>Cancel</button>\n      <button class="lego-button lego-button--brand"\n        type="submit"\n        v-lego-disabled="cantSubmit">Invite</button>\n    </div>\n  </div>\n</form>\n';});

/**
 * Function getter to get all the collaborators NOT on the current project
 */
define('flux/getters/other_project_collaborators',['require','lodash'],function(require) {
  var _ = require('lodash');
  var PROJECT_ROLES = ['Viewer', 'Editor', 'Project Owner'];
  var ACCOUNT_ROLES = ['Project Creator', 'User'];

  return [
    'currentProject',
    'account',
    'collaborators',
    function (currentProjectStore, accountStore, userStore) {
      var currentProjectId = currentProjectStore.getId();
      var currentAccountId = accountStore.getId();
      if (currentProjectId) {
        // Get all the users and project creators
        var accountUsers = userStore.getAll({
          project_id: currentAccountId
        }).filter(function(user) {
          return _.contains(ACCOUNT_ROLES, user.role_name);
        });

        // Find the viewers, editors, and project owners, who may overlap
        var projectUsers = userStore.getAll({
          project_id: currentProjectId
        }).filter(function(user) {
          return _.contains(PROJECT_ROLES, user.role_name);
        });
        var projectUserIds = _.pluck(projectUsers, 'user_id');

        // Exclude the users and project creators who are on this project
        var otherProjectUsers = _.filter(accountUsers, function(user) {
          return !_.contains(projectUserIds, user.user_id);
        });

        return otherProjectUsers;

      } else {
        return [];
      }
    }
  ];
});


define('text!components/dialogs/invite_collaborators_row.html',[],function () { return '<div class="lego-grid lego-grid--gutter condition">\n  <div class="collaborator-form-inputs lego-grid__cell width-2-3">\n    <div class="lego-text-input-control" v-class="lego-form-bad-news: validated && !validEmail">\n      <input type="text"\n             class="lego-text-input"\n             name="user_id"\n             placeholder="Enter email..."\n             required\n             v-model="collaborator.user_id"\n             v-on="blur: validate, keyup: addEmptyCollaboratorRow(parentList) | key enter">\n    </div>\n    <div class="lego-text-input-control">\n      <p class="lego-grid__cell width-2-3 lego-form-note lego-form-note--bad-news"\n         v-show="validated && !validEmail">\n        Please enter a valid email address.\n      </p>\n    </div>\n  </div>\n  <div class="collaborator-form-inputs lego-grid__cell width-1-3 condition-value-row" style="height: 26px; margin: 0px">\n    <div class="lego-text-input-control" v-class="lego-form-bad-news: validated && !validRole">\n      <select v-model="collaborator.role_name"\n              required\n              name="role_name">\n        <option v-repeat="role: roles"\n                v-attr="selected: role.name === \'Viewer\'"\n                value="[[ role.name ]]">\n          [[ role.name ]]\n        </option>\n      </select>\n\n      <div class="actions-col display--inline-block">\n        <button type="button"\n                class="delete-condition-button"\n                v-on="click: removeCollaboratorRow(parentList, $index)"\n                v-if="showDeleteButton">\n        </button>\n        <button type="button"\n                class="add-condition-button"\n                v-on="click: addEmptyCollaboratorRow(parentList)"\n                v-if="showAddButton">\n        </button>\n      </div>\n\n    </div>\n    <div class="lego-text-input-control">\n      <p class="lego-grid__cell width-1-3 lego-form-note lego-form-note--bad-news"\n         v-show="validated && !validRole">\n        Please enter a valid role.\n      </p>\n    </div>\n  </div>\n</div>\n';});

define('components/dialogs/invite_collaborators_row',['require','text!components/dialogs/invite_collaborators_row.html','utils/regex','flux','flux/getters/current_project'],function(require) {
  var tmpl = require('text!components/dialogs/invite_collaborators_row.html');
  var regex = require('utils/regex');
  var flux = require('flux');

  var getCurrentProject = require('flux/getters/current_project');

  return {
    template: tmpl,

    data: {
      // Collaborators default
      collaborator: null,
      validated: false,
      parentList: [],
      currentProject: null
    },

    computed: {
      showDeleteButton: function() {
        return (this.parentList.length > 1);
      },
      showAddButton: function() {
        return (this.$index === (this.parentList.length - 1));
      },
      roles: function() {
        return _.map(this.currentProject.collaborator_roles, function(role) {
          return {'name': role};
        });
      },
      validEmail: function() {
        return this.collaborator.valid.email = regex.email.test(this.collaborator.user_id);
      },
      validRole: function() {
        return this.collaborator.valid.role = (this.roles.indexOf(this.collaborator.role_name) === -1) ? true : false;
      },
    },
    methods: {
      addEmptyCollaboratorRow: function(collaborators) {
        collaborators.push({
          user_id: '',
          role_name: 'Viewer',
          valid: {
            email: true,
            role: true
          }
        });
      },
      removeCollaboratorRow: function(collaborators, index) {
        collaborators.splice(index, 1);
      },

      // Don't show errors until they trigger validation
      validate: function() {
        this.validated = true;
      }
    },

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
      });
    }
  };
});

/** * Invite Collaborators Dialog Component
 *
 * @author Cheston Lee
 */
define('components/dialogs/invite_collaborators',['require','app','lodash','text!components/dialogs/invite_collaborators.html','flux','models/project','services/events','flux/getters/projects','flux/getters/current_project','flux/getters/other_project_collaborators','flux/getters/dashboard/filtered_collaborators','components/dialogs/invite_collaborators_row'],function(require) {
  var app = require('app');
  var _ = require('lodash');
  var tmpl = require('text!components/dialogs/invite_collaborators.html');
  var flux = require('flux');
  var Project = require('models/project');
  var events = require('services/events');

  var getProjects = require('flux/getters/projects');
  var getCurrentProject = require('flux/getters/current_project');
  var getOtherProjectCollaborators = require('flux/getters/other_project_collaborators');
  var getDashboardFilteredCollaborators = require('flux/getters/dashboard/filtered_collaborators');

  return {
    components: {
      'invite-collaborators-row': require('components/dialogs/invite_collaborators_row')
    },
    template: tmpl,
    replace: true,
    data: {
      newCollaborators: [],
      projectsToInviteTo: []
    },
    computed: {
      /**
       * Return a usuable array of role names
       *
       * @return {Array} Roles & names
       */
      roles: function() {
        var project = this.currentProject;
        return _.map(project.collaborator_roles, function(role) {
          return {'name': role};
        });
      },

      /**
       * Control wether or not we show an active submit button.
       *
       * @return {Boolean} If there are any errors prevent submission
       */
      cantSubmit: function() {
        // return (this.errors.length > 0) ? true : false;
        var validationError = false;

        this.newCollaborators.forEach(function(collaborator) {
          if (!collaborator.valid.email || !collaborator.valid.role) {
            validationError = true;
          }
        }.bind(this));

        if (this.projectsToInviteTo.length === 0) {
          validationError = true;
        }
        return validationError;
      },

      /**
       * Include all collaborators from other projects,
       * except those that have already been added here
       */
      addableCollaborators: function() {
        var newCollabIds = _.pluck(this.newCollaborators, 'user_id');
        return _.filter(this.otherProjectCollaborators, function(collab) {
          return !_.contains(newCollabIds, collab.user_id);
        });
      }
    },
    methods: {
      /**
       * Called when dialog is submitted with new Collaboratosr
       */
      onSubmit: function(event) {
        var promises = [];
        event.preventDefault();
        var collabs = this.newCollaborators;

        if (collabs.length > 0) {
          //TODO: Test the invitation logic, we are inviting collaborators to possibly multiple projects
          //and handling an array of Deferred objects
          collabs.forEach(function(newCollaborator) {
            this.projectsToInviteTo.forEach(function(projectId) {
              var collaboratorToSave = _.clone(newCollaborator);
              collaboratorToSave.project_id = projectId;

              promises.push(flux.actions('collaborators').create(collaboratorToSave, this.currentProject));
            }.bind(this));
          }.bind(this));

          flux.actions('loading').when('inviteCollaborator', promises);

          $.when.apply(null, promises).then(function() {
            var msg = collabs.length > 1
              ? tr("{0} collaborators have been invited.", collabs.length)
              : tr("<b>{0}</b> has been invited.", collabs[0].user_id);

            app.$broadcast('notify', {
              message: msg,
            });
            events.track('dashboard2', 'invite-collaborator', null, collabs.length);

            flux.actions('dashboard').selectItem('collaborators', collabs[0]);

          }.bind(this));
        }

        app.$broadcast('hideDialog');
        this.initializeCollaborators();
      },

      /**
       * Handler for checkboxes to add/remove projects to add collaborators to
       *
       * @param {Event} event
       */
      addProject: function(event) {
        var projectId = parseInt(event.target.value);
        var exists = this.projectsToInviteTo.indexOf(projectId);

        if (exists !== -1) {
          this.projectsToInviteTo.splice(exists, 1);
        } else {
          this.projectsToInviteTo.push(projectId);
        }
      },

      /**
       * Set the state of the new collaborators to empty if we just opened
       * and add empty row to begin typing.
       */
      initializeCollaborators: function() {
        var emptyCollaborator = {
          user_id: '',
          role_name: 'Viewer',
          valid: {
            email: true,
            role: true
          }
        };
        this.errors = [];
        this.newCollaborators = [emptyCollaborator];

        //Initialize with the current projectId
        this.projectsToInviteTo = [this.currentProject.id];
      },

      /**
       * Adds a collaborator who's already on another project
       */
      addExistingCollaborator: function(collaborator) {
        collaborator.role_name = 'Viewer';
        collaborator.valid = {
          email: true,
          role: true
        };

        // If there's an empty collaborator, remove it first
        if (!_.last(this.newCollaborators).user_id) {
          this.newCollaborators.pop();
        }

        // Then add the new collaborator
        this.newCollaborators.push(collaborator);
      }
    },

    /**
     * Handle fetching project ID and projects to populate the
     * 'invite to more projects' feature.
     */
    created: function() {
      this.accountId = flux.store('account').getId();
      flux.bindVueValues(this, {
        projects: getProjects,
        currentProject: getCurrentProject,
        collaborators: getDashboardFilteredCollaborators,
        otherProjectCollaborators: getOtherProjectCollaborators,
      });

      this.initializeCollaborators();
    }
  };
});


define('text!components/dialogs/experiment_code.html',[],function () { return '<!--\n This file contains the HTML for the Experiment-level JS dialog.\n This is used as a VueJS template\n\n @author Mike Ng (mike.ng@optimizely.com)\n-->\n<div class="standard dialog--wide">\n  <div class="dialog__header">\n    <div class="dialog__title">\n        [[ codeType ]]\n    </div>\n  </div>\n  <div v-component="edit-code" v-ref="editCode" v-with="title : codeType">\n      <div class="dialog__body">\n        <p>\n          [[title]] is executed across <strong>all variations</strong>  of the experiment, including the original.\n        </p>\n        <div class="experiment_code_edit_container" v-resizable="options: resizableOptions">\n          <textarea v-component="code-mirror" v-ref="codeMirror"></textarea>\n        </div>\n      </div>\n      <div class="dialog__footer">\n        <button title="Shortcut: Ctrl-ENTER"\n           v-on="click: apply" v-disabled="!isDirty"\n           class="primary-button small">\n          Apply\n        </button>\n        <button title="Shortcut: ESC"\n           v-on="click: cancel" class="secondary-button small" v-text="cancelButtonText">\n        </button>\n      </div>\n    </div>\n</div>\n';});

/**
 * Experiment Code dialog - Allows user to create/edit JS/CSS that is
 * applied at the experiment level
 *
 * @author Mike Ng (mike.ng@optimizely.com)
 */
define('components/dialogs/experiment_code',['require','app','text!components/dialogs/experiment_code.html'],function(require) {
  var app = require('app');
  var template = require('text!components/dialogs/experiment_code.html');
  var PREFIX = 'experimentCode:';
  var CODE_MIRROR_PREFIX = 'codeMirror:';
  var EDITOR_MIN_HEIGHT = 180;

  return {
    template: template,

    data: {
      /**
       * This is used to pass in errors during instantiation to display on the code editor as soon as the dialog is shown
       * @type Object
       */
      error: null,
      /**
       * These options are passed to the resizable directuve to allow the user to resize the code editor
       * @type Object
       */
      resizableOptions: {},
      /**
       * We use this component for both the Javascript and CSS experiment code editors so this param let's us distinguish
       * which one we are dealing with
       * @type string
       */
      type: 'javascript'
    },

    computed: {
      /**
       * Either Javascript or CSS depending on the type
       * @type string
       */
      title: function() {
        return (this.type === 'javascript') ? 'Javascript' : 'CSS';
      },
      codeType: function() {
        return (this.type === 'javascript') ? tr('Experiment Javascript') : tr('Experiment CSS');
      }
    },

    methods: {
      /**
       * Handles Apply code action
       */
      applyCode: function() {
        // tell the code mirror component to lint the code
        this.$broadcast(CODE_MIRROR_PREFIX + 'lintCode');

        // @TODO: need a better way of grabbing the code from the child component
        var code = this.$.editCode.$.codeMirror.editorCode;
        // let interested parties know that code has been entered
        // (in this case its the experiment_code facade, which handles the legacy closure logic
        app.$broadcast(PREFIX + 'applyCode', code, this.$data.type);

        // this will ask the code mirror to update its own 'code' property, which is used to check
        // whether the editor is dirty or not
        this.setCode(code);

        // this will disable the apply button until the user makes a new change to the code
        this.$broadcast(CODE_MIRROR_PREFIX + 'setDirtyFlag', false);
      },

      /**
       * Closes out this dialog
       */
      close: function() {
        this.$dispatch('hideDialog');
      },

      /**
       * Sets the code value on the code editor
       * @param {string} code The JS/CSS code to set on the code editor
       */
      setCode: function(code) {
        var data = {
          mode: this.type
        };

        this.$broadcast(CODE_MIRROR_PREFIX + 'setCode', code, data);
      },

      /**
       * Add error annotation to the child code editor component
       * @param error
       */
      addErrorAnnotation: function(error) {
        this.$broadcast(CODE_MIRROR_PREFIX + 'addAnnotation', error);
      },

      /**
       * Code that runs after the dialog is shown
       */
      handleDialogShown: function() {
        // the codemirror component looks weird when first loaded so we need to do
        // a rebuild to readjust its height
        this.$broadcast(CODE_MIRROR_PREFIX + 'rebuildEditor');

        if (this.error) {
          this.addErrorAnnotation(this.error);
        }

        var maxWidth = $(this.$el).find('.experiment_code_edit_container').width();
        this.resizableOptions = {
          handles: null,
          minHeight: EDITOR_MIN_HEIGHT,
          minWidth: maxWidth, // prevent width resizing
          maxWidth: maxWidth,
          reset: true
        };
      },

      /**
       * We need to manually tell the code editor to resize to fit the parent container since the
       * user will be resizing the parent container
       */
      handleEditorResize: function() {
        this.$broadcast(CODE_MIRROR_PREFIX + 'rebuildEditor');
      }
    },

    /**
     * This function is invoked as part of the Vue component lifecycle.
     * It includes some setup logic
     */
    ready: function() {
      this.$.editCode.$on('editCode:Cancel', this.close.bind(this));
      this.$.editCode.$on('editCode:Apply', this.applyCode.bind(this));

      // @TODO: would be cool if the dialog manager would dispatch an event to us once the dialog is shown
      // need to run this after the dialog is shown so we give it a 100ms buffer
      setTimeout(this.handleDialogShown.bind(this), 100);

      // if we need to pre-fill the editor with existing code
      this.$on(PREFIX + 'setCode', this.setCode.bind(this));

      this.$on(PREFIX + 'evaluationError', this.addErrorAnnotation.bind(this));

      $(this.$el).on('optlyresizestop', this.handleEditorResize.bind(this));

      app.$broadcast(PREFIX + 'ready', this.type);
    }
  };
});


define('text!components/dialogs/integrations/integrations.html',[],function () { return '<div id="integrations-dialog" class="dialog--narrow standard">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      Integrations\n    </div>\n  </div>\n\n  <div class="dialog__body">\n    <div class="list">\n      <div>\n        <p>Track this experiment using the integrations below.</p>\n        <p>To configure integrations for this project, go to\n          <a v-attr="href: \'/projects/\' + projectId + \'/integrations\'" target="_blank">Project Integration Settings</a>.\n        </p>\n      </div>\n      <table>\n        <tbody>\n          <tr v-repeat="integration: integrations">\n            <td class="column-container">\n              <div>\n                <div class="label-container">\n                  <span class="master-label">[[ integration.masterLabel ]]</span>\n                </div>\n                <div class="enable-checkbox-container">\n                  <input type="checkbox" v-model="integration.experimentLevelData.settings.enabled" v-if="integration.experimentLevelData.onOffable">\n                </div>\n              </div>\n              <div v-show="integration.experimentLevelData.settings.enabled" class="detail-container">\n                <div>[[ integration.experimentLevelData.generalHelp.message ]]</div>\n                <form v-if="integration.experimentLevelData.fields.length" id="[[ integration.id ]]" class="standard settings-form" onsubmit="return false;">\n                  <ul class="form-fields-container">\n                    <li class="form-field-column" v-repeat="fieldConfig: integration.experimentLevelData.fields"\n                      v-component="integration-form-field"\n                      v-with="settings: integration.experimentLevelData.settings">\n                    </li>\n                  </ul>\n                </form>\n              </div>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n  <div class="dialog__footer">\n    <button class="primary-button small"\n      type="submit"\n      v-on="click: applyChanges"\n      v-hide-dialog>\n        Apply\n    </button>\n    <button class="secondary-button small"\n      type="button"\n      v-hide-dialog>\n        Cancel\n    </button>\n  </div>\n</div>\n';});

/**
 * Service holding functionality related to integrations
 *
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('services/integration',[],function() {
  /**
   * Field name mappings used to transform old experiment integration object into new one with the updated schema
   */
  var FORM_FIELD_NAME_MAP = {
    adobe_analytics: {
      eVar: 'site_catalyst_eVar',
      prop: 'site_catalyst_prop'
    },

    crazyegg: {
      expiresAt: 'crazyegg_expires_at',
      maxVisits: 'crazyegg_max_visits',
      startsAt: 'crazyegg_starts_at'
    },

    google_classic_analytics: {
      slot: 'google_analytics_slot',
      tracker: 'google_analytics_tracker'
    },

    google_universal_analytics: {
      slot: 'universal_analytics_slot',
      tracker: 'universal_analytics_tracker'
    }
  };

  /**
   * Populate reverse mappings in FORM_FIELD_NAME_MAP
   * E.g. after populating reverse mappings, the value of the adobe_analytics property becomes
   * {
   *   eVar: 'site_catalyst_eVar',
   *   prop: 'site_catalyst_prop',
   *   site_catalyst_eVar: 'eVar',
   *   site_catalyst_prop: 'prop'
   * }
   */
  _.forOwn(FORM_FIELD_NAME_MAP, function(map, key) {
    var invertedMap = _.invert(map);
    _.extend(map, invertedMap);
  });

  /**
   * Convert date to UNIX format
   * The implementation is copied from src/www/js/bundle/edit/option/heatmap_intergration.js
   *
   * @param dateTime a string representing a Date / Time to be converted
   * @returns {Number | String} a number if conversion succeeds or an empty string otherwise
   * @private
   */
  var _convertDateToUnix = function(dateTime) {
    if (dateTime) {
      return Math.round((new Date(dateTime)).getTime() / 1000);
    } else {
      return '';
    }
  };

  /**
   * Transform an integration settings object from legacy to new schema and vice versa
   *
   * @param integrationId ID of the integration whose settings object is going to be transformed
   * @param settings the source settings object to be transformed
   * @returns {Object} a transformed settings object
   */
  function transformExperimentLevelSettings(integrationId, settings) {
    var transformedSettings = {};
    var fieldNameMap = FORM_FIELD_NAME_MAP[integrationId];

    _.forOwn(settings, function(value, key) {
        if (key === 'mode') {
          transformedSettings['enabled'] = value !== 'disabled';
        } else if (key === 'enabled') {
          transformedSettings['mode'] = value ? 'enabled' : 'disabled';
        } else if (fieldNameMap && fieldNameMap[key]) {
          transformedSettings[fieldNameMap[key]] = value;
        }
    });

    return transformedSettings;
  }

  /**
   * A helper function to handle non-standard integration settings
   *
   * @param integrationId ID ot the integration to check for if custom settings shall be added
   * @param settings the settings object of the integration to which custom settings will be added
   */
  function applyCustomExperimentLevelSettings(integrationId, settings) {
    if (integrationId === 'crazyegg') {
      var expiresAt = new Date();
      expiresAt.setMonth(expiresAt.getMonth() + 6); // Set expires at to 6 months in the future.
      var maxVisits = 5000;
      var startsAt = new Date();

      settings.expiresAt = settings.expiresAt || _convertDateToUnix(expiresAt);
      settings.maxVisits = settings.maxVisits || maxVisits;
      settings.startsAt = settings.startsAt || _convertDateToUnix(startsAt);
    } else if (integrationId === 'google_classic_analytics') {
      settings.mode = 'custom_variables';
    } else if (integrationId === 'adobe_analytics') {
      settings.mode = 'custom_variables';
    }
  }

  return {
    applyCustomExperimentLevelSettings: applyCustomExperimentLevelSettings,
    transformExperimentLevelSettings: transformExperimentLevelSettings
  };
});

/**
 * Function getter to take getCurrentProjectIntegrations + integration/currentExperimentIntegrations stores
 * and return all integrations for the current experiment
 */
define('flux/getters/current_experiment_integrations',['services/integration','flux/getters/current_project/integrations'],function() {
  var integrationService = require('services/integration');
  var getCurrentProjectIntegrations = require('flux/getters/current_project/integrations');

  return [
    getCurrentProjectIntegrations,
    'integration/currentExperimentIntegrations',
    function(integrations, currentExperimentIntegrations) {
      // only return integrations that are enabled at project-level
      var enabledIntegrations = integrations.filter(function(integration) {
        return integration.projectLevelData.enabled;
      });

      var settings = currentExperimentIntegrations.getSettings();

      // transform integration settings to use the new schema
      // TODO(peng-wen): refactor experiment-level integration settings to get rid of this transformation
      enabledIntegrations.forEach(function(integration) {
        if (settings[integration.id]) {
          integration.experimentLevelData.settings = integrationService.transformExperimentLevelSettings(
            integration.id,
            settings[integration.id]
          );
        }
      });

      return enabledIntegrations;
    }
  ];
});


define('text!components/dialogs/integrations/integration_form_field.html',[],function () { return '<div>\n  <label>[[ fieldConfig.label ]]</label>\n</div>\n<div>\n  <input v-if="fieldConfig.inputType === \'text\'" v-model="fieldValue"\n    type="[[ fieldConfig.inputType ]]" name="[[ fieldConfig.name ]]"/>\n\n  <select v-if="fieldConfig.inputType === \'select\'" v-model="fieldValue" name="[[ fieldConfig.name ]]">\n    <option v-repeat="options" v-attr="selected: $value === fieldValue" value="[[ $value ]]">[[ $key ]]</option>\n  </select>\n</div>\n';});

/**
 * Experiment integration form field
 * This component is used to render an integration setting field based on fieldConfig in the experiment dialog
 *
 * @author Ali Rizvi (ali@optimizely.com)
 */
define('components/dialogs/integrations/integration_form_field',['require','text!components/dialogs/integrations/integration_form_field.html'],function(require) {
  var tmpl = require('text!components/dialogs/integrations/integration_form_field.html');

  /**
   * Utility function to generate option values based on fieldConfig
   * @param fieldConfig configuration for the field,
   * e.g. {
   *   name: 'name',
   *   label: 'label',
   *   inputType: 'select',
   *   optionLabelPrefix: 'eVar',
   *   optionValueRange: [1, 100]
   * }
   * @returns {Object}
   * @private
   */
  var _generateOptionValuesAndLabels = function(fieldConfig) {
    var options = {};

    if (fieldConfig.inputType === 'select' && fieldConfig.optionValueRange) {
      // Going to render a select element, generate its option values and labels first
      var values = _.range(fieldConfig.optionValueRange[0], fieldConfig.optionValueRange[1] + 1);

      fieldConfig.optionLabelPrefix = fieldConfig.optionLabelPrefix || '';

      values.forEach(function(value) {
        options[fieldConfig.optionLabelPrefix + value] = value;
      });
    }

    return options;
  };

  return {
    template: tmpl,

    data: {
      fieldConfig: {},
      fieldValue: '',
      options: {}
    },

    ready: function() {
      // Populate options if needed
      this.options = _generateOptionValuesAndLabels(this.fieldConfig);

      // Populate field with saved value
      if (this.fieldConfig.inputType === 'select') {
        if (this.settings && this.settings[this.fieldConfig.name] && this.settings[this.fieldConfig.name] !== -1) {
          this.fieldValue = this.settings[this.fieldConfig.name];
        } else {
          // select the first option by default
          this.fieldValue = this.fieldConfig.optionValueRange[0];
        }
      } else {
        this.fieldValue = this.settings ? this.settings[this.fieldConfig.name] : '';
      }
    }
  }
});

/**
 * Integrations dialog used to edit integration settings at experiment-level
 * This component must be used together with Integrations Dashboard
 */

define('components/dialogs/integrations/integrations',['require','flux','text!components/dialogs/integrations/integrations.html','services/integration','flux/getters/current_experiment_integrations','components/dialogs/integrations/integration_form_field'],function(require) {
  var flux = require('flux');
  var tmpl = require('text!components/dialogs/integrations/integrations.html');
  var integrationService = require('services/integration');
  var getCurrentExperimentIntegrations = require('flux/getters/current_experiment_integrations');

  /**
   * Collect settings for an integration from its form
   *
   * @param integration the integration to collect settings for
   * @returns {Object} an object containing the collected settings
   * @private
   */
  var _collectIntegrationSettings = function(integration) {
    var formElement = $('#' + integration.id);
    var settings = {};

    formElement.serializeArray().forEach(function(setting) {
      settings[setting.name] = setting.value;
    });

    settings['enabled'] = integration.experimentLevelData.settings.enabled;

    return settings;
  };

  return {
    components: {
      'integration-form-field': require('components/dialogs/integrations/integration_form_field')
    },

    template: tmpl,

    data: {
      experimentId: null,
      onChange: null,
      projectId: null,
      integrations: [],
      experimentLevelSettings: {}
    },

    methods: {
      applyChanges: function(event) {
        this.integrations.forEach(function(integration) {
            var settings = integrationService.transformExperimentLevelSettings(integration.id,
              _collectIntegrationSettings(integration));

            if (integration.experimentLevelData.settings.enabled) {
              integrationService.applyCustomExperimentLevelSettings(integration.id, settings);
            }

            // apply new settings on the backing data model
            _.extend(this.experimentLevelSettings[integration.id], settings);
        }.bind(this));

        // fire the event to notify the toolbar about the changes in integration settings
        optly.Event.prototype.fire.call(this.onChange, 'integrations');
      }
    },

    ready: function() {
      flux.bindVueValues(this, {
        integrations: getCurrentExperimentIntegrations
      });

      // populate data in stores
      flux.actions('integration').fetchIntegrationsDialogData(this.projectId);
      flux.actions('integration').updateSettingsForExperiment(this.experimentLevelSettings);
    }
  };
});


define('text!components/dialogs/mobile_editor_redirect.html',[],function () { return '<div class="dialog--narrow lego-enabled">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      Redirecting\n    </div>\n  </div>\n  <div class="dialog__body">\n    <p>\n      Optimizely iOS SDK version [[ requiredSDKVersion ]] has been released and features our new visual editor and numerous other improvements. <a href="http://developers.optimizely.com/ios/#upgrade" target="_blank">Please upgrade to version [[ requiredSDKVersion ]].</a>\n    </p>\n    <p>On 1/1/15, all versions below [[ requiredSDKVersion ]] will be deprecated.</p>\n    <p>\n      You will be <b>automatically redirected in [[ redirectTimeInSeconds ]]</b> seconds to the old editor because your app is running SDK version [[ sdkVersion ]].\n    </p>\n  </div>\n  <div class="dialog__footer">\n    <button type="submit" class="lego-button lego-button--brand" v-on="click: redirectToOldEditor">Go to the old editor</button>\n  </div>\n</div>\n';});

/**
 * Component to show a confirm dialog
 * Intended to be used with services/confirm
 *
 */
define('components/dialogs/mobile_editor_redirect',['require','text!components/dialogs/mobile_editor_redirect.html'],function(require) {
  var tmpl = require('text!components/dialogs/mobile_editor_redirect.html');

  return {
    template: tmpl,

    data: {
      redirectTimeInSeconds: 60,
      requiredSDKVersion: null,
      sdkVersion: null
    },

    methods: {
      redirectToOldEditor: function(event) {
        var experimentId = $.deparam.querystring().experiment_id;
        var params = _.extend($.deparam.querystring(), {legacy: 1});
        document.location.href = '/edit?' + $.param(params);
      }
    },

    created: function() {
      var self = this;
      // Use setInterval so we can have a countdown in the UI
      var intervalID = setInterval(function() {
        self.redirectTimeInSeconds--;
        if (self.redirectTimeInSeconds === 0) {
          clearInterval(intervalID);
          self.redirectToOldEditor(null);
        }
      }, 1000);
    }
  };
});


define('text!components/dialogs/targeting_list.html',[],function () { return '<form class="dialog--narrow standard dialog--list-targeting" v-on="submit: createList($event)">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      List Management\n    </div>\n  </div>\n\n  <div class="dialog__body">\n\n    <!-- View all Lists -->\n    <div class="list" v-if="currentPane == \'list\'">\n      <table>\n        <thead>\n          <tr>\n            <th class="align-left">\n              <span>Name</span>\n            </th>\n            <th class="list-actions align-right">\n              <span>Actions</span>\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-repeat="list: targetingLists">\n            <td class="align-left" translate="no">\n              <div class="name" v-text="list.name"></div>\n              <div class="description" v-text="list.description"></div>\n            </td>\n            <td class="align-right">\n              <button type="button" class="small-button" v-on="click: switchView(\'edit\', list)">Edit</button>\n              <button type="button" class="small-button" v-on="click: deleteList(list)">Delete</button>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n\n    </div>\n\n    <!-- Create a List -->\n    <div v-if="currentPane == \'create\'">\n\n      <div class="horizontal-form clearfix">\n        <div class="control-group">\n          <label for="list-name">Name</label>\n          <div class="controls">\n            <input id="list-name" type="text" v-model="currentList.name" required>\n          </div>\n        </div>\n\n        <div class="control-group">\n          <label for="list-description">Description (optional)</label>\n          <div class="controls">\n            <textarea id="list-description" v-model="currentList.description"></textarea>\n          </div>\n        </div>\n\n        <div class="control-group">\n          <label for="list-file">File (CSV or TSV)</label>\n          <div class="controls">\n            <input id="list-file" type="file" required>\n          </div>\n        </div>\n\n        <div class="control-group">\n          <label for="list-type">List type</label>\n          <div class="controls">\n            <select id="list-type" v-model="currentList.list_type">\n              <option value="1">Cookies</option>\n              <option value="2">Query Parameters</option>\n              <option value="3">Zip Codes</option>\n            </select>\n          </div>\n        </div>\n\n        <div class="control-group" v-show="areKeyFieldsVisible()">\n          <label for="list-key-name">Key name</label>\n          <div class="controls">\n            <input id="list-key-name" type="text" v-model="currentList.key_fields">\n          </div>\n        </div>\n      </div>\n\n    </div>\n\n    <!-- Edit a List -->\n    <div v-if="currentPane == \'edit\'">\n\n      <div class="horizontal-form clearfix">\n        <div class="control-group">\n          <label for="list-name">Name</label>\n          <div class="controls">\n            <input id="list-name"\n            style="border: none;"\n            type="text"\n            v-model="currentList.name"\n            readonly\n            v-attr="value: currentList.name">\n          </div>\n        </div>\n\n        <div class="control-group">\n          <label for="list-description">Description (optional)</label>\n          <div class="controls">\n            <textarea id="list-description"\n              v-model="currentList.description"\n              v-attr="value: currentList.description"></textarea>\n          </div>\n        </div>\n\n        <div class="control-group">\n          <p class="alert-box alert-box-warning">Warning: Choosing a new file will overwrite any previously saved list.</p>\n          <label for="list-file">File (CSV or TSV)</label>\n          <div class="controls">\n            <input id="list-file" type="file">\n          </div>\n        </div>\n\n        <div class="control-group">\n          <label for="list-type">List type</label>\n          <div class="controls">\n            <select id="list-type"\n              v-model="currentList.list_type">\n              <option value="1"\n              v-attr="selected: (currentList.list_type === 1)">Cookies</option>\n              <option value="2"\n              v-attr="selected: (currentList.list_type === 2)">Query Parameters</option>\n              <option value="3"\n              v-attr="selected: (currentList.list_type === 3)">Zip Codes</option>\n            </select>\n          </div>\n        </div>\n\n        <div class="control-group"\n          v-show="areKeyFieldsVisible()">\n          <label for="list-key-name">Key name</label>\n          <div class="controls">\n            <input id="list-key-name"\n            type="text"\n            v-model="currentList.key_fields"\n            v-attr="value: currentList.key_fields">\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div class="dialog__footer">\n    <button type="button"\n      class="secondary-button small"\n      v-if="currentPane == \'create\' || currentPane == \'edit\'"\n      v-on="click: switchView(\'list\')">\n        Back\n    </button>\n    <button class="secondary-button"\n      type="button"\n      v-if="currentPane == \'list\'"\n      v-hide-dialog>\n        Close\n    </button>\n    <button type="button"\n      class="primary-button small"\n      v-if="currentPane == \'list\'"\n      v-on="click: switchView(\'create\')">\n      Create a List\n    </button>\n    <button type="submit"\n      class="primary-button small"\n      v-if="currentPane == \'create\' || currentPane == \'edit\'">\n        Save List\n    </button>\n  </div>\n</form>\n';});

/**
 * Targeting list ("List Management") dialog
 */
define('components/dialogs/targeting_list',['require','flux','text!components/dialogs/targeting_list.html','models/targeting_list'],function(require) {
  var flux = require('flux');
  var tmpl = require('text!components/dialogs/targeting_list.html');
  var TargetingList = require('models/targeting_list');

  var ListType = {
    COOKIE: 1,
    QUERY_STRING: 2,
    ZIP_CODE: 3
  };

  return {
    template: tmpl,

    data: {
      currentPane: 'list', // Possible values: `list`, `create`, `edit`
      currentList: {},
      projectId: null,
      targetingLists: []
    },

    methods: {
      areKeyFieldsVisible: function() {
        var list_type = parseInt(this.currentList['list_type'], 10);

        if (list_type === ListType['COOKIE']
         || list_type === ListType['QUERY_STRING']) {
            return true;
        }
        return false;
      },
      createList: function(e) {
        e.preventDefault();
        // Track the number of lists with the same name so we can prevent duplication
        var instances = this.targetingLists.reduce(function(prev, curr, idx, list) {
          if (list[idx].name === this.currentList.name) {
            return prev + 1;
          }
          return prev;
        }.bind(this), 0);

        // On the edit pane we already have one list with the current name. That is okay.
        if ((this.currentPane !== 'edit' && instances > 0) ||
            (this.currentPane === 'edit' && instances > 1)) {
          alert('A list with this name already exists, please choose a new name.');
          return false;
        }

        var reader = new FileReader();
        var file = document.getElementById('list-file').files[0];

        this.currentList.list_type = parseInt(this.currentList.list_type, 10);

        if(this.currentPane !== 'edit' || file) {
          reader.readAsText(file);

          if (this.currentPane === 'edit' && file.type.indexOf(this.currentList.format) === -1) {
            alert('When uploading a new list, you must keep with the original format: ' + this.currentList.format);
            return false;
          }

          switch (file.type) {
            case 'text/csv':
              this.currentList.format = 'csv';
              break;
            case 'text/tab-separated-values':
              this.currentList.format = 'tsv';
              break;
            default:
              return false;
          }

          reader.onload = function() {
            var fileObj = { 'list_content': reader.result };
            var data = _.assign(this.currentList, fileObj);

            this.saveList(data);

          }.bind(this);

        } else {
          this.saveList(this.currentList);
        }
      },

      saveList: function(list) {
        TargetingList.save(list).then(function(response) {
          // Errors?
          if (response.error) {
            throw new Error(response.error);
          }

          if (this.currentList.id && this.currentPane === 'edit') {
            var idx = _.find(this.targetingLists, function(list) {
              return list.id === this.currentList.id;
            }.bind(this));

            this.targetingLists[idx] = response;
          } else {
            this.targetingLists.push(response);
          }

          this.switchView('list');
        }.bind(this));
      },

      deleteList: function(list) {
        var self = this;
        var result = confirm('Are you sure you wish to delete this list?');

        if (result) {
          flux.actions('api').deleteEntity(TargetingList, list);
        }
      },
      setCurrentList: function(list) {
        if (!list) {
          this.currentList = {};
          this.currentList['project_id'] = this.projectId;
        } else {
          this.currentList = list;
        }
      },
      switchView: function(pane, list) {
        if(list) {
          this.setCurrentList(list);
        } else {
          this.setCurrentList();
        }
        this.currentPane = pane;
      }
    },

    created: function() {
      // make sure the targeting lists are all fetched for this project
      flux.actions('api').fetchAll(TargetingList, {
        project_id: this.projectId,
      });

      // bind the targeting_lists for this project to this.targetingLists on VM
      this._changeStream = flux.createChangeStream()
        .onStoreChange('targeting_lists', function(targetingListStore) {
          this.targetingLists = targetingListStore.getAll({
            project_id: this.projectId
          });
        }.bind(this))
        .forceUpdate();
    },

    beforeDestroy: function()  {
      this._changeStream.destroy();
    }
  };
});


define('text!components/dialogs/send_code.html',[],function () { return '<form v-on="submit: send" class="dialog--narrow" id="send-code-dialog">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      Send Project Code\n    </div>\n  </div>\n  <div class="dialog__body">\n    <p>Does someone else on your team implement your site\'s code? Put their email address below to send them instructions on how to setup Optimizely.</p>\n    <input type="email" class="email" name="email" placeholder="Example: developer@mycompany.com" v-model="email" required />\n  </div>\n  <div class="dialog__footer">\n    <button type="submit" class="button button-primary">Send</button>\n    <button type="button" class="button secondary-button" v-hide-dialog>Cancel</button>\n  </div>\n</form>';});

/**
 * Dialog to email project code to a developer
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('components/dialogs/send_code',['require','text!components/dialogs/send_code.html','services/project'],function(require) {
  var tmpl = require('text!components/dialogs/send_code.html');
  var projectService = require('services/project');

  return {
    template: tmpl,

    data: {
      email: null,
      project: null
    },

    methods: {
      send: function(event) {
        event.preventDefault();
        projectService.sendProjectCode(this.email, this.project);
        this.$dispatch('hideDialog');
      }
    }
  };
});

/**
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('utils/ratio',[],function() {
  var Ratio = function(numerator, denominator) {
    this.numerator = numerator;
    this.denominator = denominator;
  };

  /** Finds the greatest common divisor of two integers
   *  using Euclid's algorithm: http://en.wikipedia.org/wiki/Euclidean_algorithm
   *
   *  @param {Number} a
   *  @param {Number} b
   * */
  var gcd = function(a, b){
    return b==0 ? a : gcd(b, a % b);
  };

  /**
   * Add two fractions together
   * @param {Ratio} b
   * @returns {Ratio}
   */
  Ratio.prototype.add = function(b){
    var a = this.clone();
    var lcm = a.denominator / gcd(a.denominator, b.denominator) * b.denominator;
    a.numerator = a.numerator*(lcm/a.denominator) + b.numerator*(lcm/b.denominator);
    a.denominator = lcm;
    return a.simplify();
  };

  Ratio.prototype.clone = function() {
    return new Ratio(this.numerator, this.denominator);
  };

  Ratio.prototype.equal = function(other) {
    var simplified = this.simplify();
    var otherSimplified = other.simplify();
    return simplified.numerator === otherSimplified.numerator &&
           simplified.denominator === otherSimplified.denominator;
  };

  /**
   * Invert a fraction (swap numerator/denominator)
   * @returns {Ratio}
   */
  Ratio.prototype.invert = function(){
    var a = this.clone();
    a.numerator = this.denominator;
    a.denominator = this.numerator;
    return a;
  };

  /**
   * Multiply two fractions
   * @param {Ratio} b
   * @returns {Ratio}
   */
  Ratio.prototype.mult = function(b){
    var a = this.clone();
    a.numerator *= b.numerator;
    a.denominator *= b.denominator;
    return a.simplify();
  };

  /**
   * Simplify a fraction
   * @returns {Ratio}
   */
  Ratio.prototype.simplify = function(){
    var a = this.clone();
    if (a.numerator == 0 || a.denominator == 0) {
      return a;
    }
    var frac_gcd = gcd(a.denominator, a.numerator);
    a.numerator /= frac_gcd;
    a.denominator /= frac_gcd;
    return a;
  };

  return Ratio;
});

/**
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('utils/basis',['require','utils/ratio'],function(require) {
  var Ratio = require('utils/ratio');
  // how many total points there are
  var TOTAL_POINTS = 10000;
  // what we multiply percent by to get points
  var MULTIPLIER = TOTAL_POINTS / 100;
  // log base 10 of multiplier is max precision, make sure it's an int
  var MAX_PRECISION = Math.floor(Math.log(MULTIPLIER) / Math.log(10));

  return {
    MAX_PRECISION: MAX_PRECISION,
    MULTIPLIER: MULTIPLIER,
    TOTAL_POINTS: TOTAL_POINTS,
    /**
     * .xxxx -> xxxx points
     * @param {number} ratio
     * @returns {number}
     */
    toPoints: function(ratio) {
      return Math.round(ratio * TOTAL_POINTS);
    },
    /**
     * Return points as a Ratio out of TOTAL_POINTS
     * @param {number} points
     * @returns {Ratio}
     */
    toRatio: function(points) {
      return new Ratio(points, TOTAL_POINTS);
    },
    /**
     * xxxx points -> .xxxx
     * @param points
     * @returns {number}
     */
    toFloat: function(points) {
      return points / TOTAL_POINTS;
    }
  };
});


define('text!components/traffic_allocation/include_percentage.html',[],function () { return '<span class="percentage icon" contenteditable\n  v-on="click: edit,\n        keyup: handleKeyup,\n        blur: handleBlur">\n</span>\n';});

/**
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('utils/float',[],function() {
  /**
   * Remove trailing 0's (after the decimal point) from string representation of
   * a float
   *
   * @param {string} value
   * @returns {string}
   */
  var trimTrailingZeros = function(value) {
    var trimmed = value;

    // remove any trailing zeroes
    trimmed = trimmed.replace(/(\.\d*?)(0*)$/, '$1');
    // if the last char is a '.', remove it
    trimmed = trimmed.replace(/\.$/, '');

    return trimmed;
  };

  /**
   * Given a float, return a string with that number formatted as a string
   * @param {number} value
   * @param {number} maxPrecision
   * @returns {string}
   */
  var toMaxPrecisionString = function(value, maxPrecision) {
    value = value.toFixed(maxPrecision);
    value = trimTrailingZeros(value);

    return value;
  };

  return {
    toMaxPrecisionString: toMaxPrecisionString
  }
});

/**
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('filters/percentage',['require','utils/float'],function(require) {
  var float = require('utils/float');

  /**
   * Format a floating point as a percentage with optional precision specified
   * @param {number} value
   * @param {number=} maxPrecision
   * @returns {string}
   */
  return function(value, maxPrecision) {
    return float.toMaxPrecisionString(value * 100, maxPrecision || 0) + '%';
  }
});

/**
 * A custom component to handle the contenteditable behavior
 * on the percentage of all traffic included text.
 *
 * This component provides finer grained control of the contenteditable
 * and applying the displayValue computed as well as validation
 * that was much harder to do using the v-editable-text component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/traffic_allocation/include_percentage',['require','text!./include_percentage.html','utils/basis','filters/percentage'],function(require) {
  var tmpl = require('text!./include_percentage.html');
  var basis = require('utils/basis');
  var percentage = require('filters/percentage');

  var ENTER = 13;
  var ESCAPE = 27;

  return {
    template: tmpl,

    replace: true,

    data: {
      includePoints: 0,
    },

    computed: {
      /**
       * The display text value, that has been transformed from
       * includePoints (ex: 7300 to '73%')
       * @return {string}
       */
      displayValue: function() {
        return percentage(basis.toFloat(this.includePoints), 2);
      }
    },

    methods: {
      /**
       * Keyup handler for enter/escape
       * @param {Event} event
       */
      handleKeyup: function(event) {
        var keyCode = event.keyCode;

        if (keyCode === ENTER) {
          this._saveEdit(event.target.textContent);
        } else if (keyCode === ESCAPE) {
          this._cancelEdit();
        }
      },

      /**
       * On blur save the text content
       * @param {Event} event
       */
      handleBlur: function(event) {
        this._saveEdit(event.target.textContent);
      },

      /**
       * Save function that takes the displayed text content (which is in
       * percentage form) validates it and updates the underlying includePoints
       * value
       *
       * @param {string} textContent
       */
      _saveEdit: function(textContent) {
        var percent = textContent.replace('%', '');
        var ratio = Number(percent) / 100;
        var points = basis.toPoints(ratio);
        if (isNaN(points)) {
          this._cancelEdit();
          return;
        }

        this._updateIncludePoints(points);
      },

      /**
       * Validates the new includePoints value and sets it
       * to this.includePoints and updates the textContent
       *
       * @param {number} points
       */
      _updateIncludePoints: function(points) {
        if (points > basis.TOTAL_POINTS) {
          this.includePoints = basis.TOTAL_POINTS;
        } else if (points < 0) {
          this.includePoints = 0
        } else {
          this.includePoints = points
        }

        this.$el.textContent = this.displayValue
      },

      /**
       * Cancels the edit and restores the old includePoints value
       */
      _cancelEdit: function() {
        this._updateIncludePoints(this.includePoints);
        this.$el.blur();
      },
    },

    ready: function() {
      this._updateIncludePoints(this.includePoints);
    }
  }
});


define('text!components/traffic_allocation/section.html',[],function () { return '<tr class="section" colspan="3" v-show="experimentIsMVT">\n  <td>[[ title ]]</td>\n</tr>\n<tr v-show="!isTotalValid" class="section-warning">\n  <td colspan="3">Allocation should sum to 100% for this experiment. (Current sum: [[ totalPercent | percentage 2 ]])</td>\n</tr>\n<tr>\n  <td>\n    <table>\n      <tr v-repeat="variations"\n          v-component="traffic-allocation/variation"\n          v-with="sectionTotalValid: isTotalValid,\n                  disabled: autoAllocated"></tr>\n    </table>\n  </td>\n</tr>\n';});

/**
 * Section component
 *
 * Manages pausing/unpausing variations, distributing weight among the unpaused variations,
 * and ensuring that total weight is valid (sums to basis.TOTAL_POINTS).
 *
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('components/traffic_allocation/section',['require','utils/basis','utils/float','utils/ratio','text!components/traffic_allocation/section.html'],function(require) {
  var basis = require('utils/basis');
  var float = require('utils/float');
  var Ratio = require('utils/ratio');

  var tmpl = require('text!components/traffic_allocation/section.html');

  /**
   * When converting weights to percentages there may be leftovers (the weights may not add to the desiredTotal). This function
   * fudges the percentages adding the leftovers to the largest weight. If the difference is more then
   * the tolerance the weights will not be fudged.
   * @param {Array.<number>} weights A list of numbers what you wish to add to the desired total
   * @param {number} desiredTotal The total you wish the weights to add to
   * @param {number} decimalPlaces The number of decimal places to consider (Math.round will be used)
   * @param {number} tolerance The max amount the weights will be fudged
   * @return {Array.<number>} The weights after fudgeing
   */
  var calculateFudgedPercentages = function(weights, desiredTotal, decimalPlaces, tolerance) {
    var scaleFactor = Math.pow(10, decimalPlaces);
    function scale(number){
      return Math.round(number * scaleFactor);
    }
    //scale function inputs
    weights = weights.map(scale);
    desiredTotal = scale(desiredTotal);
    tolerance = scale(tolerance);
    //fudge weights
    var total = weights.reduce(function(total, weight){ return total+weight }, 0);
    if(desiredTotal - total <= tolerance){
      //Array.sort is in place in js so copy it via slice first
      var maxWeight = weights.slice(0).sort(function(a,b){
        return a<b;
      })[0];
      weights[weights.indexOf(maxWeight)] += desiredTotal - total;
    }
    return weights.map(function(weight) {
      return weight / scaleFactor;
    });
  };

  return {
    template: tmpl,

    data: {
      id: null,
      /**
       * Whether the experiment is MVT, relevant for template only
       * @type {boolean}
       * */
      experimentIsMVT: false,
      /**
       * Whether the current total is valid
       * @type {boolean}
       */
      isTotalValid: true,
      /** @type {string} */
      title: '',
      /** @type {Array.<Variation>} */
      variations: []
    },

    computed: {
      /**
       * Sum of all variation weights
       * @returns {number}
       */
      totalPoints: function() {
        return _.reduce(this.variations, function(sum, variation) {
          return sum + variation.weight;
        }, 0);
      },
      /**
       * this.totalPoints as a float
       * @returns {number}
       */
      totalPercent: function() {
        return basis.toFloat(this.totalPoints);
      }
    },

    methods: {
      /**
       * Ensure that total is equal to expected total.
       * @private
       */
      _validate: function() {
        this.isTotalValid = this.totalPoints === basis.TOTAL_POINTS;
        this.$dispatch('traffic-allocation/section:validate');
      },
      /**
       * When converting weights to percentages there may be leftovers (the weights may not add to the desiredTotal).
       * Fudge the percentages adding the leftovers to the largest weight. If the difference is more then
       * the tolerance the weights will not be fudged.
       */
      updateFudgedPercentages: function() {
        var weights = this.variations.map(function(variation)  {
          return variation.weight / basis.MULTIPLIER;
        });
        console.debug('Updating fudged percentages');
        console.debug('Before weights', weights);

        // Ensure that the total is always 100%
        var desiredTotal = 100;
        // Allow the number of decimal places allowed by the current number system
        var decimalPlaces = basis.MAX_PRECISION;
        // Allow the minimum difference based on current number system
        var tolerance = basis.MULTIPLIER / basis.TOTAL_POINTS;

        var updatedWeights = calculateFudgedPercentages(weights, desiredTotal, decimalPlaces, tolerance);
        console.debug('After weights', updatedWeights);

        // Set variation weights to updatedWeights in points
        this.variations.forEach(function(variation, i) {
          variation.weight = Math.round(updatedWeights[i] * basis.MULTIPLIER);
        });

        this._validate();
      },
      /**
       * Pause the variation at variationIndex. Set its weight to 0 and redistribute its prior weight
       * proportionally to unapused variations.
       *
       * @param {number} variationIndex
       */
      pauseVariation: function(variationIndex) {
        var variation = this.variations[variationIndex];
        console.debug('Pause variation', variation);
        console.debug('Before variations', this.variations.map(function(variation) {
          return variation.weight;
        }));

        //calc new total
        var totalPoints = this.variations.filter(function(_, i) {
          return i !== variationIndex;
        }).reduce(function(sum, variation) {
          return sum + variation.weight;
        }, 0);

        // Multiplier is the inverse of the current total as a proportion of the expected total
        var multiplier = new Ratio(basis.TOTAL_POINTS, totalPoints);
        console.debug('Multiplier:', multiplier.numerator, '/', multiplier.denominator);

        if(multiplier.denominator == 0) {
          this.$dispatch('traffic-allocation/section:validationError', 'Cannot pause last variation!');
          return;
        }

        // Pause current variation
        variation.weight = 0;

        // Redistribute weights proportionally by multiplying each weight by multiplier
        this.variations.forEach(function(variation) {
          var ratio = basis.toRatio(variation.weight).mult(multiplier);
          variation.weight = basis.toPoints(ratio.numerator / ratio.denominator);
        });

        // Redistribute remainder
        this.updateFudgedPercentages();
        console.debug('After variations', this.variations.map(function(variation) {
          return variation.weight;
        }));
      },
      /**
       * Unpause variation at variationIndex, setting its weight to 1/(num running variations)
       * and taking from other variations proportionally.
       *
       * @param {number} variationIndex
       */
      unpauseVariation: function(variationIndex) {
        var variation = this.variations[variationIndex];
        console.debug('Unpause variation', variation);
        console.debug('Before variations', this.variations.map(function(variation) {
          return variation.weight;
        }));

        // Get the number of running variations (after unpausing)
        var runningVariations = this.variations.filter(function(variation){
          return variation.weight !== 0;
        }).length + 1; //+1 for the to be unpaused variation

        // Set the unpaused variation's weight to an even share of running variations
        variation.weight = basis.toPoints(1 / runningVariations);

        // Take from other variations proportionally
        var multiplier = new Ratio(runningVariations-1, runningVariations);
        console.debug('Multiplier', multiplier.numerator, '/', multiplier.denominator);

        this.variations.forEach(function(variation, i){
          //skip it if it's the variation we are unpausing
          if (i == variationIndex) {
            return;
          }
          var ratio = basis.toRatio(variation.weight).mult(multiplier);
          variation.weight = basis.toPoints(ratio.numerator / ratio.denominator);
        });

        // Redistribute remainder
        this.updateFudgedPercentages();
        console.debug('After variations', this.variations.map(function(variation) {
          return variation.weight;
        }));
      }
    },

    ready: function() {
      // When a variation's weight is set, check that the total is valid
      this.$on('traffic-allocation/variation:setWeight', this._validate.bind(this));

      // Trigger pause/unpause
      this.$on('traffic-allocation/variation:pause', this.pauseVariation.bind(this));
      this.$on('traffic-allocation/variation:unpause', this.unpauseVariation.bind(this));
    }
  }
});


define('text!components/traffic_allocation/variation.html',[],function () { return '<tr class="variation">\n  <td class="description" translate="no">[[ title ]]</td>\n  <td class="percentage">\n    <input type="text"\n           v-class="invalid-value: !sectionTotalValid"\n           v-disabled="disabled"\n           v-model="percentage">&nbsp;%\n  </td>\n  <td class="control">\n    <a v-show="!isPaused"\n       v-on="click: pause($index)">\n      Pause\n    </a>\n    <a v-show="isPaused"\n       v-on="click: unpause($index)">\n      Unpause\n    </a>\n  </td>\n</tr>\n\n';});

/**
 * Variation component
 *
 * This component just handles getting/setting variation weights using the UI
 *
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('components/traffic_allocation/variation',['utils/basis','utils/float','text!components/traffic_allocation/variation.html'],function() {
  var basis = require('utils/basis');
  var float = require('utils/float');

  var tmpl = require('text!components/traffic_allocation/variation.html');

  return {
    template: tmpl,

    replace: true,

    data: {
      id: null,
      /**
       * Whether to disable UI controls
       * @type {boolean}
       */
      disabled: false,
      /**
       * Whether to mark UI controls as "invalid"
       * @type {boolean}
       */
      sectionTotalValid: true,
      /** @type {string} */
      title: '',
      /** @type {number} */
      weight: 0
    },

    computed: {
      percentage: {
        /**
         * Convert weight into a percentage out of 100 with fixed precision
         * @returns {string}
         */
        $get: function() {
          return float.toMaxPrecisionString(this.weight / basis.MULTIPLIER, basis.MAX_PRECISION);
        },
        /**
         * Set weight based on input as % out of 100
         * @param {string} value
         */
        $set: function(value) {
          this.weight = Math.round(Number(value) * basis.MULTIPLIER);
          this.$dispatch('traffic-allocation/variation:setWeight');
        }
      },
      /**
       * A variation is paused if its weight is 0
       * @returns {boolean}
       */
      isPaused: function() {
        return this.weight === 0;
      }
    },

    methods: {
      /**
       * Tell the parent to pause the variation at idx
       * @param {number} idx
       */
      pause: function(idx) {
        this.$dispatch('traffic-allocation/variation:pause', idx);
      },
      /**
       * Tell the parent to unpause the variation at idx
       * @param {number} idx
       */
      unpause: function(idx) {
        this.$dispatch('traffic-allocation/variation:unpause', idx);
      }
    }
  }
});


define('text!components/dialogs/traffic_allocation.html',[],function () { return '<form id="traffic-allocation-dialog"\n      class="traffic-allocation standard dialog--medium"\n      v-on="submit: save">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      Traffic Allocation\n    </div>\n  </div>\n  <div class="dialog__body">\n    <div class="warnings" v-show="alert.show">\n      <div class="alert-box alert-box-warning">\n        [[[ alert.message ]]]\n      </div>\n    </div>\n\n    <p>\n      Specify the percentage of traffic that should be included in this\n      experiment and be tracked for conversions. Visitors that are not included\n      will not count towards your monthly quota.\n    </p>\n\n    <div class="padding">\n      <div class="percentages">\n        <div class="included editable">\n          <span v-component="traffic-allocation/include-percentage"\n                v-ref="includePercentageInput"\n                v-with="includePoints: includePoints"></span>\n          <br>\n          Included in experiment.\n        </div>\n        <div class="excluded">\n          <span class="percentage">[[ excludePercent | percentage 2 ]]</span><br />\n          Excluded from experiment.\n        </div>\n\n        <div class="slider-container">\n          <div id="traffic-allocation-slider"\n               v-component="widgets/slider"\n               v-with="value: includePoints,\n                       options: {range: \'min\', min: 0, max: TOTAL_POINTS, step: MULTIPLIER, disabled: disableSlider}"\n               class="slider">\n          </div>\n        </div>\n        <div class="feature-tooltip"\n             v-class="unavailable: tooltip.warn"\n             v-show="tooltip.show">\n          [[ tooltip.message ]]\n        </div>\n\n        <div class="alert-box alert-box-secondary"\n             v-if="enableAutoAllocation && !isMVT">\n          <span><b>Experimental Feature:</b>\n            Traffic auto-allocation will automatically adjust your traffic allocation\n            over time so that visitors who haven\'t seen this experiment see the variation\n            that does the best for your <i>primary goal</i>.\n            <a href="https://help.optimizely.com/hc/en-us/articles/200040115?auto_allocation=true#auto_allocation" target="_blank">Learn more.</a>\n          </span>\n\n          <div>\n            <input id="auto-allocation-checkbox" v-model="autoAllocated" name="auto-allocation-checkbox" type="checkbox">\n            <label class="auto-allocation" for="auto-allocation-checkbox">Enable auto-allocation for this experiment.</label>\n          </div>\n        </div>\n      </div>\n\n      <div class="traffic-data push-double--bottom">\n        <p>Percentage of experiment visitors:</p>\n\n        <div class="scrollable">\n          <table class="lego-table"\n                v-ref="sections"\n                v-repeat="sections"\n                v-component="traffic-allocation/section"\n                v-with="experimentIsMVT: isMVT">\n          </table>\n        </div>\n      </div>\n\n      <p class="last" v-if="!enableAutoAllocation || isMVT">\n        For more information, read\n        <a href="https://help.optimizely.com/hc/en-us/articles/200040115" target="_blank">How can I change the distribution of visitors for my experiment?</a>\n      </p>\n      <p class="last" v-if="enableAutoAllocation && !isMVT">\n        For more information, read\n        <a href="https://help.optimizely.com/hc/en-us/articles/200040115?auto_allocation=true" target="_blank">How can I change the distribution of visitors for my experiment?</a>\n      </p>\n\n    </div>\n    <div class="alert-box alert-box-error" v-show="!!error">[[ error ]]</div>\n  </div>\n  <div class="dialog__footer">\n    <div class="buttons">\n      <button type="submit" class="primary-button">Apply</button>\n   \t  <button type="button" class="secondary-button" v-hide-dialog>Cancel</button>\n    </div>\n  </div>\n</form>\n';});

/**
 * Main component for the Traffic Allocation Dialog
 *
 * Responsible for setting the overall experiment include percentage
 * and instantiating Section/Variation subcomponents.
 *
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('components/dialogs/traffic_allocation',['require','utils/basis','services/permissions','components/traffic_allocation/include_percentage','components/traffic_allocation/section','components/traffic_allocation/variation','text!components/dialogs/traffic_allocation.html'],function(require) {
  var basis = require('utils/basis');
  var permissions = require('services/permissions');
  var includePercentage = require('components/traffic_allocation/include_percentage');
  var section = require('components/traffic_allocation/section');
  var variation = require('components/traffic_allocation/variation');

  var tmpl = require('text!components/dialogs/traffic_allocation.html');

  return {
    components: {
      'traffic-allocation/include-percentage': includePercentage,
      'traffic-allocation/section': section,
      'traffic-allocation/variation': variation
    },

    template: tmpl,

    data: {
      /** @type {{ '{{' }}show: boolean, message: string{{ '}}' }} */
      alert: {},
      /** @type {boolean} */
      autoAllocated: false,
      /** @type {boolean} */
      disableSlider: false,
      /** @type {boolean} */
      enableAutoAllocation: false,
      error: null,
      /** @type {number} */
      includePoints: 0,
      /** @type {boolean} */
      isMVT: false,
      /**
       * @type {Array.<Section>}
       * */
      sections: [],
      /**
       * Slider warning tooltip, used for iOS unavailability of include points
       * @type {{ '{{' }}show: boolean, warn: boolean, message: string{{ '}}' }}
       * */
      tooltip: {},
      // Constants
      MULTIPLIER: basis.MULTIPLIER,
      TOTAL_POINTS: basis.TOTAL_POINTS,
      // Deferred to resolve on save
      _saveDeferred: null
    },

    computed: {
      /**
       * Complement to includePercent
       * @returns {number}
       */
      excludePercent: function() {
        return basis.toFloat(basis.TOTAL_POINTS - this.includePoints);
      }
    },

    methods: {
      save: function(event) {
        event.preventDefault();

        // Check validity for all sections
        // Clear error state, if any
        this.error = null;
        _.each(this.$.sections, function(section) {
          if (!section.isTotalValid) {
            this.error = this.isMVT ?
                         tr('Invalid total for "{0}"', section.title) :
                         tr('Invalid total points');
          }
        }.bind(this));
        if (this.error) {
          return;
        }

        if (this._saveDeferred) {
          this._saveDeferred.resolve({
            autoAllocated: this.autoAllocated,
            includePoints: this.includePoints,
            sections: this.sections
          });
        }

        this.$dispatch('hideDialog');
      }
    },

    ready: function() {
      // Clear error state on setWeight
      this.$on('traffic-allocation/variation:setWeight', function() {
        this.error = null;
      }.bind(this));

      // Clear error state on validate
      this.$on('traffic-allocation/section:validate', function() {
        this.error = null;
      }.bind(this));

      // Set error on validationError
      this.$on('traffic-allocation/section:validationError', function(err) {
        this.error = err;
      }.bind(this));

      this.enableAutoAllocation = permissions.canUseBandits();

      this.$on('slider:slide', function(points) {
        this.$.includePercentageInput._updateIncludePoints(points);
      });

      // If autoAllocation is turned off and on again, reset initial section weights
      if (this.autoAllocated) {
        var initialSections = _.cloneDeep(this.sections);

        this.$watch('autoAllocated', function(isAutoAllocated) {
          if (isAutoAllocated) {
            this.sections = initialSections;
          }
        });
      }
    }
  };
});


define('text!components/dialogs/url_targeting.html',[],function () { return '<form id="url-targeting-dialog" class="standard dialog--wide" v-on="submit: onSubmit">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      URL Targeting\n    </div>\n  </div>\n\n  <div class="dialog__body">\n    <div class="url-targeting">\n      <p class="loading" v-show="isLoading">\n        <img src="/static/img/loading.gif" />\n        Loading...\n      </p>\n\n      <div v-show="!isLoading">\n        <!--Targeting URLs-->\n        <div class="page-group"\n             v-repeat="page: pages"\n             v-with="isMultiPage: isMultiPage">\n          <div class="page-description">[[page.description]]</div>\n\n          <!--Include URLs-->\n          <div class="include-group">\n            <div class="condition">\n              <div class="condition-title-row">This experiment will run on the following URLs:</div>\n              <div class="condition-value-row"\n                   v-repeat="target: page.includeUrls"\n                   v-component="url-targeting-condition"\n                   v-with="parentList: page.includeUrls, isIncludeUrl: \'true\'">\n              </div>\n              <div class="url-error"\n                   v-show="!page.includeUrls[0].match">\n                 Please add a URL. To run your experiment on all pages, see our\n                 <a href="https://help.optimizely.com/hc/en-us/articles/200040835-URL-Targeting-Choose-where-your-experiment-runs#regular_expression" target="_blank">knowledge base</a>.\n              </div>\n            </div>\n          </div>\n\n          <!--Exclude URLs-->\n          <div class="exclude-group">\n            <div v-class="exclude-link: page.excludeUrls.length == 0"\n                 v-on="click: addInitialURLCondition(page.excludeUrls)">\n              Exclude URLs\n            </div>\n            <div class="condition"\n                 v-show="page.excludeUrls.length > 0">\n              <div class="condition-title-row">This experiment will <strong>NOT</strong> run on the following URLs:</div>\n              <div class="condition-value-row"\n                   v-repeat="target: page.excludeUrls"\n                   v-component="url-targeting-condition"\n                   v-with="parentList: page.excludeUrls, isIncludeUrl: \'false\'">\n              </div>\n              <p v-show="isMultiPage">\n                Note: in multi-page tests, visitors to excluded URLs will still be counted in the results.\n                <a href="https://help.optimizely.com/hc/en-us/articles/200040155#mpt_bucket" target="_blank">Learn more</a>\n              </p>\n            </div>\n          </div>\n        </div>\n        <!--END Targeting URLs-->\n\n        <!--URL Validator -->\n        <div class="url-validator">\n          <div class="url-validator-link twisty-container"\n               v-on="click: toggleValidator">\n             <div class="twisty"\n                  v-class="down: validatorVisible"></div>\n             <div class="twisty-content">URL Match Validator</div>\n          </div>\n          <div class="condition"\n               v-show="validatorVisible">\n            <h5 class="url-validator-text">To check your targeting conditions and ensure that your experiment will run on the expected pages, enter a URL below:</h5>\n            <div class="condition-title-row"></div>\n            <div v-repeat="test: tests"\n              v-component="url-targeting-validator"\n              v-with="\n                tests: tests,\n                pages: pages,\n                isMultiPage: isMultiPage">\n            </div>\n          </div>\n        </div>\n        <!--END URL Validator -->\n\n      </div>\n    </div>\n  </div>\n\n  <div class="dialog__footer">\n    <button type="submit" class="primary-button" v-attr="disabled: cantSubmit">[[ submitText ]]</button>\n    <button class="secondary-button" type="button" v-hide-dialog>Back</button>\n  </div>\n</form>\n\n';});


define('text!components/dialogs/url_targeting_condition.html',[],function () { return '<div class="value-col">\n  <div v-class="url-error: firstIncludeEmpty">\n    <input\n     type="text"\n     placeholder="Enter a url..."\n     v-model="target.match">\n  </div>\n</div>\n<div class="actions-col">\n  <select v-model="target.type">\n    <option value="simple">Simple match</option>\n    <option value="exact">Exact match</option>\n    <option value="substring">Substring match</option>\n    <option value="regex">Regular expression</option>\n  </select>\n</div>\n<div class="actions-col">\n  <button type="button" class="delete-condition-button"\n    v-on="click: removeURLCondition(parentList, $index)"\n    v-if="showDeleteButton">\n  </button>\n  <button type="button" class="add-condition-button"\n    v-on="click: addEmptyURLCondition(parentList)"\n    v-if="showAddButton">\n  </button>\n</div>\n';});

/**
 * url-targeting-condition component
 * This component corresponds to one url targeting condition
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/dialogs/url_targeting_condition',['require','text!components/dialogs/url_targeting_condition.html'],function(require) {
  var tmpl = require('text!components/dialogs/url_targeting_condition.html');

  return {
    template: tmpl,

    data: {
      isIncludeUrl: 'true',
      parentList: [],
    },

    computed: {
      /**
       * Returns true if the first include url of a page is empty
       *  This will show a warning and prevent submission of the dialog
       * @return {Boolean}
       */
      firstIncludeEmpty: function () {
        // Register Dependencies
        this.isIncludeUrl;
        this.$index;
        this.target;
        return (this.isIncludeUrl === 'true') && (this.$index === 0) && (!this.target.match);
      },

      /**
       * Determines whether to show the delete button
       *   Exclude URLs: Always show the delete button
       *   Include URLs: Show the delete button only when the list is greater than 1
       * @return {Boolean}
       */
      showDeleteButton: function () {
        // Register Dependencies
        this.isIncludeUrl;
        this.parentList;
        return (this.isIncludeUrl === 'false') || (this.parentList.length > 1);
      },

      /**
       * Determines whether to show the add button
       *   Show the add button only for the last url targeting condition in the list
       * @return {Boolean}
       */
      showAddButton: function () {
        // Show the add button only for the last url in the list
        return (this.$index === (this.parentList.length - 1));
      }
    },

    methods: {
      /**
       * Inserts an empty url condition into the end of the parent condition list
       * This method is called on clicking the add button
       */
      addEmptyURLCondition: function (conditions) {
        conditions.splice(conditions.length, 0, { match: '', type: 'simple' });
      },

      /**
       * Removes a url condition from the parent condition list
       * This method is called on clicking the delete button
       */
      removeURLCondition: function (conditions, index) {
        conditions.splice(index, 1);
      }
    }
  }
});


define('text!components/dialogs/url_targeting_validator.html',[],function () { return '<div class="condition-value-row">\n  <div class="value-col">\n    <div\n       v-class="\n       url-match    : hasTestUrl && hasOneMatch,\n       url-no-match : hasTestUrl && !hasOneMatch && !hasManyMatches,\n       url-warning  : hasTestUrl && hasManyMatches\n       ">\n        <input\n         type="text"\n         placeholder="Enter a URL that you would like to check..."\n         v-model="test.url">\n    </div>\n  </div>\n  <div class="actions-col">\n    <button type="button" class="delete-condition-button"\n      v-on="click: removeTestURL(tests, $index)"\n      v-if="showDeleteButton">\n    </button>\n    <button type="button" class="add-condition-button"\n      v-on="click: addTestURL(tests)"\n      v-if="showAddButton">\n    </button>\n  </div>\n</div>\n<div class="url-match url-validator-text"\n     v-show="hasTestUrl && hasOneMatch">\n   Your experiment will run<span v-show="isMultiPage"> [[ matchingPages | wrap-tag double-quote | list-to-readable-string ]]</span> on this URL!\n</div>\n<div class="url-no-match url-validator-text"\n     v-show="hasTestUrl && !hasOneMatch && !hasManyMatches">\n   Your experiment will NOT run on this URL<span v-if="isMultiPage"> for any of your pages</span>.\n</div>\n<div class="url-warning url-validator-text"\n     v-show="hasTestUrl && hasManyMatches">\n     Warning: Your experiment will run the variation code for [[ matchingPages | wrap-tag double-quote | list-to-readable-string ]] on this URL.\n     Typically, a URL should match only one page in a multi-page experiment.\n</div>\n';});

define('utils/matcher',['require'],function(require) {
  return optly.match;
});

/**
 * url-targeting-validator component
 * This component corresponds to one url test of the url-validator
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/dialogs/url_targeting_validator',['require','text!components/dialogs/url_targeting_validator.html','utils/matcher'],function(require) {
  var tmpl = require('text!components/dialogs/url_targeting_validator.html');
  var matcher = require('utils/matcher');

  return {
    template: tmpl,

    data: {
      /**
       * Url to test against the different targeting conditions
       * @var {Object}
       */
      test: {
        url: null
      },

      /**
       * List of all the urls being tested against the targeting conditions
       * @var {Array.<String>}
       */
      tests: [],

      /**
       * List of pages which contain targeting conditions to test url against
       * @var {Array.<Object>}
       */
      pages: [],
    },

    computed: {
      /**
       * Computes the list of pages whose targeting conditions match this.test.url
       * @return {Array.<String>}
       */
      matchingPages: function () {
        return this.findUrlMatches();
      },

      /**
       * Returns true if this.test.url satisfies exactly one page's targeting conditions
       * @return {Boolean}
       */
      hasOneMatch: function () {
        return (this.matchingPages.length === 1);
      },

      /**
       * Returns true if this.test.url satisfies at least two page's targeting conditions
       * @return {Boolean}
       */
      hasManyMatches: function () {
        return (this.matchingPages.length > 1);
      },

      /**
       * Returns true if the this.test.url is not the empty string
       * @return {Boolean}
       */
      hasTestUrl: function () {
        return !!this.test.url;
      },

      /**
       * Determines whether to show the add button
       *   Show the add button only for the last url of the validator
       * @return {Boolean}
       */
      showAddButton: function () {
        return (this.$index === this.tests.length - 1);
      },

      /**
       * Determines whether to show the add button
       *   Show the delete button only when there are multiple urls in the validator
       * @return {Boolean}
       */
      showDeleteButton: function () {
        return (this.tests.length > 1);
      },
    },

    methods: {
      /**
       * Adds an empty test in the url validator
       *    Corresponds to clicking the add button.
       */
      addTestURL: function (tests) {
        tests.splice(tests.length, 0, { url: null });
      },

      /**
       * Remove the test url by its index.
       *    Corresponds to clicking the delete button.
       */
      removeTestURL: function (tests, index) {
        tests.splice(index, 1);
      },

      /**
       * Returns true if this.test.url matches any targeting condition in the
       * array of url targeting conditions passed in
       * @param {Array.<Object>} urlTargetingList
       * @return {Boolean} hasMatch
       */
      doesUrlMatchAny: function (urlTargetingList) {
        var hasMatch = false;
        if (urlTargetingList && urlTargetingList.length > 0) {
          hasMatch = urlTargetingList.some(function (urlTarget) {
            return matcher.matchUrl(this.test.url, urlTarget.match, urlTarget.type);
          }, this);
        }
        return hasMatch;
      },

      /**
       * Returns an array of page names whose targeting conditions
       * match this.test.url
       * @return {Array.<String>} matches
       */
      findUrlMatches: function () {
        var matches = [];
        // This is for vue to register dependencies
        this.pages;
        if (this.test.url && this.pages) {
          // Find the pages which match
          matches = this.pages.filter(function (page, pageIndex) {
            var isExcluded = this.doesUrlMatchAny(page.excludeUrls);
            if (!isExcluded) {
              var isIncluded = this.doesUrlMatchAny(page.includeUrls);
              if (isIncluded) {
                return true;
              }
            }
            return false;
          }, this);

          // Filter the list to just the page names
          if (matches.length > 0) {
            matches = matches.map(function (page) {
              return page.description;
            });
          }
        }
        return matches;
      }
    }
  }
});

/**
 * url-targeting dialog
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/dialogs/url_targeting',['require','text!components/dialogs/url_targeting.html','services/router','models/experiment','components/dialogs/url_targeting_condition','components/dialogs/url_targeting_validator'],function(require) {
  var tmpl = require('text!components/dialogs/url_targeting.html');
  var router = require('services/router');
  var Experiment = require('models/experiment');

  return {
    components: {
      /**
       * The below components are private to the url-targeting component so they
       * are loaded here rather than being registered in optly/components.js
       */
      'url-targeting-condition': require('components/dialogs/url_targeting_condition'),
      'url-targeting-validator': require('components/dialogs/url_targeting_validator')
    },

    template: tmpl,

    data: {
      /**
       * Array of objects representing pages. Each page has a description,
       * a list of includeUrl conditions and a list of excludeUrl conditions
       *    Ex: [ { description: 'Page 1',
       *            includeUrls: [ { match: 'page1.com', type: 'simple' } ],
       *            excludeUrls: [] } ]
       * @requiredinitialData 
       * @var {Array}
       */
      pages: null,
      /**
       * True when the dialog has finished loading its data and is ready to show
       * @var {Boolean}
       */
      isLoading: true,

      /**
       * List of urls to be used by the url validator
       * @var {Array.<Object>}
       */
      tests: null,

      /**
       * Indicates whether the url validator is visible
       * @var {Boolean}
       */
      validatorVisible: false,

      /**
       * Deferred to resolve when the dialog submits
       * @var {Deferred}
       */
      _urlTargetingDeferred: null,
    },

    computed: {
      /**
       * Returns true if this experiment has multiple pages
       * @return {Boolean}
       */
      isMultiPage: function () {
        return this.pages.length > 1;
      },

      /**
       * Returns false if the user should not be able to submit the dialog
       *   because at least one of the pages do not have their first include
       *   targeting condition defined.
       * @return {Boolean}
       */
      cantSubmit: function () {
        return this.pages.some(function (page) {
          return (page.includeUrls[0].match === '');
        });
      },
    },

    methods: {
      /**
       * Adds an empty url condition if the list is empty
       * @param {Array.<Object>} urlTargetingList
       */
      addInitialURLCondition: function (urlTargetingList) {
        if (urlTargetingList.length === 0) {
          urlTargetingList.push({ match: '', type: 'simple' });
        }
      },

      /**
       * Toggles the visibility of the url validator
       */
      toggleValidator: function () {
        this.validatorVisible = !this.validatorVisible;
      },

      /**
       * Initialize pages data, we have to initialize the pages
       * data on created so we don't add references to this data
       * to the prototypical dialog component
       */
      initializePages: function () {
        this.pages = _.cloneDeep(this._pages);
        this.pages.map(function (page) {
          if (page.includeUrls) {
            this.addInitialURLCondition(page.includeUrls);
          }
        }, this);
      },

      /**
       * Initialize tests data, we have to initialize the tests
       * data on created so we don't add references to this data
       * to the prototypical dialog component
       */
      initializeTests: function () {
        if (this._tests) {
          this.tests = this._tests;
        } else {
          this.tests = [{ url: null }];
        }
      },

      /**
       * Submits the dialog
       *
       * @param {Event} event
       */
      onSubmit: function (event) {
        event.preventDefault();
        var pages = _.cloneDeep(this.pages);
        pages = this.pruneUrlConditions(pages);
        this._urlTargetingDeferred.resolve(pages);
        this.$dispatch('hideDialog');
      },

      /**
       * Prunes the pages object by removing conditions that have empty values
       *
       * @param {Object} pages
       * @return {Object} pruned_pages
       */
      pruneUrlConditions: function (pages) {
        var pruned_pages = pages.map(function (page) {
          // Prune include URLs
          if (page.includeUrls) {
            page.includeUrls = page.includeUrls.filter(function (condition) {
              return !!condition.match;
            });
          }

          // Prune exclude URLs
          if (page.excludeUrls) {
            page.excludeUrls = page.excludeUrls.filter(function (condition) {
              return !!condition.match;
            });
          }

          return page;
        });
        return pruned_pages;
      }
    },

    /**
     * Instantiates the dialog with data when it is shown
     * And controls visibility of the loading gif
     */
    created: function() {
      if (!this._pages) {
        throw new Error("Must specify _pages to instantiate url targeting dialog");
      }

      this.initializePages();
      this.initializeTests();
      this.submitText = this._submitText || tr('Apply');
      this.isLoading = false;
    }
  }
});


define('text!components/dialogs/experiment_goals.html',[],function () { return '<form class="goal-management dialog--narrow">\n  <div class="dialog__header">\n    <div class="dialog__title">\n      [[ currentView.title ]]\n    </div>\n  </div>\n  <div class="dialog__body">\n    <div v-show="currentView.id == VIEWS.CUSTOM_EVENT_GOAL.id">\n      <div v-component="goals/create-custom-event-goal"></div>\n    </div>\n    <div v-show="currentView.id == VIEWS.PAGE_VIEW_GOAL.id">\n      <div v-component="goals/create-page-view-goal"></div>\n    </div>\n    <div v-show="currentView.id == VIEWS.CLICK_GOAL.id">\n      <div v-component="goals/create-click-goal"></div>\n    </div>\n    <div v-show="currentView.id == VIEWS.CREATE_GOAL.id">\n      Select which type of goal you would like to create!\n      <ul class="lego-input-list">\n        <li v-repeat="option: goalOptions">\n        <input\n          id="[[ option.id ]]"\n          value="[[ option.id ]]"\n          v-model="selectedGoalType"\n          type="radio">\n          <label class="lego-label" for="[[ option.id ]]">\n            <h4>[[ option.name ]]</h4>\n            [[ option.description ]]\n          </label>\n        </li>\n      </ul>\n    </div>\n    <div v-show="currentView.id == VIEWS.SAVED_GOALS.id">\n      <div v-show="currentGoals.length != 0">\n        <p>Choose one of the saved goals below to add it to this experiment.</p>\n        <div class="filterbox push-double--bottom">\n          <input id="goal-filter" type="text" placeholder="Search saved goals"\n          v-model="query"\n          v-on="keyup: clearFilter | key esc,\n                keypress: stopFormSubmission | key enter">\n          <div v-on="click: clearFilter"\n            v-class="\'filterbox-clear\': query !== \'\'"\n            v-class="\'filterbox-search\': query === \'\'">\n          </div>\n        </div>\n\n        <div v-repeat="goal: filteredGoals"\n             v-component="experiment-goal"\n             v-show="!goal.deleted"\n             v-with="goal: goal,\n                     currentView: currentView,\n                     experiment: experiment,\n                     modifiable: canModifyGoals"\n            data-test-section="goals-dialog-project-goals">\n        </div>\n        <p v-show="filteredGoals.length === 0">\n          Sorry, no goals match that search term.\n          <a v-on="click: clearFilter">Clear</a>.\n        </p>\n      </div>\n      <p v-show="currentGoals.length === 0">\n        There are no more goals saved in this project.<br>\n      </p>\n    </div>\n    <div v-show="currentView.id == VIEWS.EXPERIMENT_GOALS.id">\n      <div v-show="currentGoals.length != 0">\n        <p>\n          <b>Drag goals to reorder them</b>. Your primary goal will appear on the dashboard, and the rest will be tracked on your results page.\n        </p>\n        <div class="goal__primary__header">\n          <b>Primary Goal</b>\n          <div class="help-button"\n            v-poptip data-dir="top" data-content="The conversion rate for the primary goal will be shown on the dashboard">\n          </div>\n        </div>\n        <ul v-rearrange="currentGoals"\n            class="push-double--bottom"\n            data-placeholder="goal__drop__target"\n            data-vm-property="goalOrder"\n            data-test-section="goals-dialog-experiment-goals">\n          <li v-repeat="goal: currentGoals"\n              v-component="experiment-goal"\n              v-show="!goal.deleted"\n              v-with="goal: goal,\n                      currentView: currentView,\n                      experiment: experiment,\n                      modifiable: canModifyGoals"\n              v-attr="data-rearrange-id: goal.id">\n          </li>\n        </ul>\n      </div>\n      <p v-show="currentGoals.length === 0">\n        There are no goals attached to this experiment.<br>\n      </p>\n\n      <div class="lego-attention lego-attention--warning" v-show="!canModifyGoals">\n        Goals can only be added to experiments less than 4 weeks old.\n        <a href="https://help.optimizely.com/hc/en-us/articles/200011659" target="_blank">Learn more</a>.\n      </div>\n      <div class="button-pair push-double--bottom" v-show="canModifyGoals">\n        <button class="button-icon-add white-button white-button-secondary"\n          type="button"\n          v-on="click: switchView(VIEWS.SAVED_GOALS)"\n          data-test-section="goals-dialog-add-goal">\n          Add a Saved Goal\n        </button>\n        <button class="button-icon-create-goal white-button"\n          type="button"\n          v-on="click: switchView(VIEWS.CREATE_GOAL)"\n          data-test-section="goals-dialog-create-goal"\n          disabled>\n          Create a New Goal\n        </button>\n      </div>\n    </div>\n\n  </div>\n  <div class="dialog__footer">\n    <a class="secondary-button"\n      v-if="currentView.id != VIEWS.EXPERIMENT_GOALS.id";\n      v-on="click: previousView"\n      data-test-section="goals-dialog-back">\n      Back\n    </a>\n    <a class="secondary-button"\n      v-if="currentView.id == VIEWS.EXPERIMENT_GOALS.id"\n      v-hide-dialog\n      data-test-section="goals-dialog-close">\n      Close\n    </a>\n    <a class="primary-button"\n      v-if="currentView.id == VIEWS.EXPERIMENT_GOALS.id"\n      v-on="click: saveChanges"\n      data-test-section="goals-dialog-save">\n      Save\n    </a>\n    <a class="primary-button"\n      v-if="currentView.id == VIEWS.CREATE_GOAL.id"\n      v-on="click: switchToCreateGoalView(selectedGoalType)">\n      Create\n    </a>\n    <a class="primary-button"\n      v-if="currentView.id == VIEWS.PAGE_VIEW_GOAL.id || currentView.id == VIEWS.CUSTOM_EVENT_GOAL.id || currentView.id == VIEWS.CLICK_GOAL.id"\n      v-on="click: createGoal()">\n      Create\n    </a>\n    <a class="primary-button"\n      v-if="currentView.id == VIEWS.SAVED_GOALS.id"\n      v-on="click: saveChanges">\n      Save\n    </a>\n  </div>\n</form>\n';});

/**
 * Javascript filtering helpers
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('utils/filter',['require'],function(require) {
  /**
   * Searches a string for an occurrence of a filtering string (case insensitive)
   * @param {string} stringToFind    The term to find
   * @param {string} stringToSearch  The string to search for the filter term
   * @return {boolean}
   */
  function isFilterTermInItem(stringToFind, stringToSearch) {

    if (!stringToSearch) {
      return false;
    }

    var filters = stringToFind.match(/\S+/g) || [];

    for (var i = 0; i < filters.length; i++) {
      if (stringToSearch.toLocaleLowerCase().indexOf(filters[i].toLocaleLowerCase()) === -1) {
        return false;
      }
    }
    return true;
  };

  /**
   * Creates and returns a single function that returns true/false
   * whether an item meets all of the filters
   *
   * Supports filters that are an array of values:
   * filter: { status: [ 'Running', 'Paused', 'Not started'] }
   *
   * This translates to a logical OR. Experiments filtered
   * will have a status of 'Running' OR 'Paused' OR 'Not started'
   *
   * @param {object} filters
   */
  function createFetchFilterFn(filters) {
    // map the current filters to filterFns
    var filterFns = _.map(filters, function(val, field) {
      if (_.isArray(val)) {
        return function(item) {
          return _.contains(val, item[field]);
        }
      } else {
        return function(item) {
          return item[field] === val;
        }
      }
    });

    return function(item) {
      return filterFns.every(function(fn) {
        return fn(item);
      });
    }
  };

  return {
    isFilterTermInItem: isFilterTermInItem,
    createFetchFilterFn: createFetchFilterFn,
  };
});


define('text!components/dialogs/experiment_goal.html',[],function () { return '<div class="goal"\n     v-class="rearrange: currentView.id == VIEWS.EXPERIMENT_GOALS.id">\n  <div class="goal__body">\n    <div class="goal__info">\n      <div class="goal__title">[[ goal.title ]]</div>\n      <div class="goal__description">[[[ goalDescription(goal) ]]]</div>\n    </div>\n    <div v-show="currentView.id == VIEWS.SAVED_GOALS.id">\n      <div class="goal__controls">\n        <button type="button"\n          class="white-button white-secondary-button"\n          v-on="click: addGoalToExperiment(goal, experiment)"\n          title="Add this goal to this experiment"\n          v-show="modifiable">Add</button>\n        <button type="button"\n          class="white-button white-secondary-button"\n          v-show="editableGoal"\n          disabled>View</button>\n        <button type="button"\n          class="white-button white-secondary-button"\n          v-on="click: deleteGoal(goal)"\n          v-show="editableGoal">Delete</button>\n      </div>\n    </div>\n    <div v-show="currentView.id == VIEWS.EXPERIMENT_GOALS.id">\n      <div class="goal__controls">\n        <button type="button"\n          class="white-button white-secondary-button"\n          v-show="editableGoal"\n          disabled>Edit</button>\n        <button type="button"\n          class="white-button white-secondary-button"\n          v-show="modifiable"\n          v-on="click: removeGoalFromExperiment(goal, experiment)">Remove</button>\n        <button type="button"\n          class="white-button white-secondary-button"\n          v-on="click: deleteGoal(goal)"\n          v-show="editableGoal">Delete</button>\n      </div>\n    </div>\n  </div>\n  <div class="goal__footer">\n    <div class="goal__footer__title" >\n      <b>[[ goalTypeString(goal) ]]</b>\n    </div>\n    <div class="goal__footer__data">\n      <div class="goal__footer__item">Used in <b>[[ goal.experiment_ids.length ]]</b> experiments</div>\n      <div class="goal__footer__item">Modified on <b>[[ goal.last_modified | shortdate ]]</b></div>\n    </div>\n  </div>\n</div>\n';});

/**
 * Experiment goal component
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/dialogs/experiment_goal',['require','app','text!components/dialogs/experiment_goal.html','services/goal','services/confirm'],function(require) {
  var app = require('app');
  var template = require('text!components/dialogs/experiment_goal.html');
  var goalService = require('services/goal');
  var confirm = require('services/confirm');

  return {
    template: template,

    data: {
      goal: null,
      experiment: null,
      inExperiment: false,
      modifiable: false
    },

    computed: {
      editableGoal: function () {
        return (this.goal.goal_type !== goalService.TypeCodes.ENGAGEMENT &&
                this.goal.goal_type !== goalService.TypeCodes.REVENUE);
      },
    },

    methods: {
      /**
       * Return the goal description for a given goal
       * @param {Object} goal
       */
      goalDescription: function (goal) {
        return goalService.generateGoalDescription(goal);
      },

      /**
       * Return the goal type
       */
      goalTypeString: function (goal) {
        return goalService.goalTypeToString(goal.goal_type);
      },

      /**
       * Mark the goal for deletion
       * @param {Object} goal
       */
      deleteGoal: function (goal) {
        var deleteGoalDeferred = $.Deferred();

        // when resolved call deleteGoalFromList function
        deleteGoalDeferred.then(function () {
          goal.deleted = true;
        });

        // show the dialog
        app.$broadcast('showConfirmDialog', {
          component: 'dialogs/delete-goal',
          data: {
            _deleteGoalDeferred: deleteGoalDeferred,
            _goalId: goal.id
          }
        });
      },

      /**
       * Remove a goal from a given experiment
       * @param {Object} goal
       * @param {Object} experiment
       */
      removeGoalFromExperiment: function (goal, experiment) {
        var warning = tr('Are you sure you want to remove the goal <b>{0}</b> from the experiment <b>{1}</b>?', goal.title, experiment.description);

        return confirm.confirm({
          title: tr('Remove Goal from Experiment?'),
          message: warning,
          confirmAction: tr('Remove Goal')
        }).then(function(){
          goal.experiment_ids.splice(_.indexOf(goal.experiment_ids, experiment.id), 1);
        });
      },

      /**
       * Add a goal to a given experiment
       * @param {Object} goal
       * @param {Object} experiment
       */
      addGoalToExperiment: function (goal, experiment) {
        goal.experiment_ids.push(experiment.id);
        if (experiment.display_goal_order_lst) {
          experiment.display_goal_order_lst.push(goal.id);
        }
      },
    },
  }
});

/**
 * Experiment goals dialog
 *
 * @author Neha Singla (neha@optimizely.com)
 */
define('components/dialogs/experiment_goals',['require','app','services/router','services/goal','services/experiment','models/experiment','text!components/dialogs/experiment_goals.html','utils/filter','components/dialogs/experiment_goal'],function(require) {
  var app = require('app');
  var router = require('services/router');
  var goalService = require('services/goal');
  var experimentService = require('services/experiment');
  var Experiment = require('models/experiment');
  var template = require('text!components/dialogs/experiment_goals.html');
  var isFilterTermInItem = require('utils/filter').isFilterTermInItem;
  var VIEWS = {
    EXPERIMENT_GOALS: {
      id: 'experiment-goals',
      title: tr('Experiment Goals'),
    },
    SAVED_GOALS: {
      id: 'saved-goals',
      title: tr('Saved Goals'),
    },
    CREATE_GOAL: {
      id: 'create-goal',
      title: tr('Create Goal')
    },
    PAGE_VIEW_GOAL: {
      id: 'page-view-goal',
      title: tr('Create: Page View Goal'),
    },
    CUSTOM_EVENT_GOAL: {
      id: 'custom-event-goal',
      title: tr('Create: Custom Event Goal'),
    },
    CLICK_GOAL: {
      id: 'click-goal',
      title: tr('Create: Click Goal'),
    }
  };

  return {
    template: template,

    components: {
      'experiment-goal': require('components/dialogs/experiment_goal')
    },

    data: {
      VIEWS: VIEWS,
      goals : [],
      experiment: null,
      currentView: null,
      viewStack: [],
      /**
       * Optional string to filter goals by
       * @type {String}
       */
      query: '',
      originalExperimentGoalList : [],
      selectedGoalType: null,
      goalOptions: [
        {
          id: 'PAGE_VIEW_GOAL',
          name: tr('Page View'),
          description: tr('The number of times a user views a page.'),
        },
        {
          id: 'CLICK_GOAL',
          name: tr('Click'),
          description: tr('The number of times a user clicks/taps a specific element on the page.'),
        },
        {
          id: 'CUSTOM_EVENT_GOAL',
          name: tr('Custom Event'),
          description: tr('The number of times a user performs a custom action (signup, submit, doc upload, etc.)'),
        },
      ],
    },

    computed: {

      /**
       * Computed list of the current view of goals
       * Depending on the current view, the list is either
       * the list of experiment goals or the list of saved goals
       * @return {Array}
       */
      currentGoals: function() {
        // declare computed dependency
        this.experimentGoals;
        this.savedGoals;
        return this.currentView.id === this.VIEWS.EXPERIMENT_GOALS.id ? this.experimentGoals : this.savedGoals;
      },

      /**
       * Computed list of goals belonging to the experiment
       * ordered by display_goal_order_lst and the primary_goal_id
       * @return {Array}
       */
      experimentGoals: function() {
        // declare computed dependency
        var experimentId = this.experiment.id;

        // filter out the goals for this experiment
        var filteredGoals = this.goals.filter(function(goal) {
          return _.contains(goal.experiment_ids, experimentId);
        });

        return goalService.generateOrderedGoals(this.experiment, filteredGoals);
      },

      /**
       * Computed list of saved goals
       * @return {Array}
       */
      savedGoals: function() {
        // declare computed dependency
        this.experiment.id;
        return this.goals.filter(function(goal) {
          return !_.contains(goal.experiment_ids, this.experiment.id);
        }.bind(this));
      },

      /**
       * Computed list of filtered goals
       * @return {Array}
       */
      filteredGoals: function() {
        // declare computed dependency
        this.currentGoals;
        if (this.query) {
          return this.currentGoals.filter(function(goal) {
            return isFilterTermInItem(this.query.toLocaleLowerCase(), goal.title);
          }.bind(this));
        }
        return this.currentGoals;
      },

       canModifyGoals: function() {
        return experimentService.canModifyGoals(this.experiment);
       }
    },

    methods: {
      /**
       * Edit page url
       * @param {Number} experimentId
       * @return {String}
       */
      editUrl: function(experimentId) {
        return router.experimentEdit({
          experimentId: experimentId
        });
      },

      /**
       * Change the current view to the "saved-goals" view
       */
      switchView: function(view) {
        this.viewStack.push(this.currentView);
        this.currentView = view;
      },

      /**
       * Switch to previous view
       */
      previousView: function() {
        this.currentView = this.viewStack.pop();
      },

      /**
       * Based on the goal selected, change
       * the goal dialog view to create that goal
       */
      switchToCreateGoalView: function(goalView) {
        this.viewStack.push(this.currentView);
        this.currentView = this.VIEWS[goalView];
      },

      /**
       * Create the goal
       */
      createGoal: function() {
        // TODO (asa): hook into flux saving
        debugger;
      },

      /**
       * Save the changes made in the dialog
       */
      saveChanges: function() {
        var goalOrder = this.goalOrder.map(function (goalId) {
          return parseInt(goalId, 10);
        });

        var data = {
          goals: _.cloneDeep(this.goals),
          goalOrder: goalOrder
        };

        this._goalsDialogDeferred.resolve(data);
        this.$dispatch('hideDialog');
      },

      /**
       * Clear the query filter
       */
      clearFilter: function() {
        this.query = '';
      }
    },

    created: function() {
      this.experiment = _.cloneDeep(this._experiment);
      this.goals = _.cloneDeep(this._goals) || [];
      // Some users have bad goal data and have duplicate default goals
      // Filter these duplicates as their should only be 1 of each default goal type
      // TODO: Remove this logic once root cause bad data is fixed.
      this.goals = goalService.filterDuplicateDefaultGoals(this.goals);
      this.goalOrder = _.cloneDeep(this.experiment.display_goal_order_lst);
      this.currentView = this.VIEWS.EXPERIMENT_GOALS;
    },
  }
});


define('text!components/dialog_frame.html',[],function () { return '<div class="dialog-backdrop" v-class="shown: shown" v-style="z-index: zIndex">\n  <div class="dialog-frame">\n    <div class="closer" v-if="!noEscape" v-hide-dialog></div>\n  </div>\n</div>\n';});

/**
 * Reusable Dialog Frame Component
 *
 * Represents the outer frame of a dialog window
 * To be used in conjunction with the dialog-manager component
 */
define('components/dialog_frame',['require','app','text!components/dialog_frame.html'],function(require) {
  var app = require('app');
  var tmpl = require('text!components/dialog_frame.html');

  return {
    template: tmpl,

    replace: true,

    data: {
      id: null,
      zIndex: 0,
      /**
       * @var {Boolean} dont allow escaping via closer button
       */
      noEscape: false,
      shown: false,
      _currentComponent: null
    },

    methods: {
      /**
       * Shows a dialog to the user. The content of the dialog is specified by the
       * requested component, which MUST be requested by name as part of the config.
       *
       * @param {String} componentId
       * @param {{ '{{' }}component: string{{ '}}' }} componentConfig
       * @private
       */
      showDialog: function(componentId, componentConfig) {
        var instance = this._createDialogComponent(componentId, componentConfig);

        var dialogFrame = this._getDialogFrameEl();
        // Append it to the DOM
        instance.$appendTo(dialogFrame);
        // And allow us to keep track of the visible component
        this._currentComponent = instance;

        this.shown = true;
      },
      /**
       * Hides the visible dialog, destroying the currently contained component so that
       * there's a clean shut-down.
       *
       * @private
       */
      hideDialog: function() {
        if (this._currentComponent) {
          // Destroy the child component
          this._currentComponent.$destroy();
          this._currentComponent = null;
        }
        this.shown = false;
      },
      /**
       * Stubbable method wrapping .find('.dialog-frame')
       * @private
       * @return {DOMElement}
       */
      _getDialogFrameEl: function() {
        return $(this.$el).find('.dialog-frame').get(0);
      },
      /**
       * Instantiates the Component for the dialog's content
       * @param {String} componentId
       * @param {Object} config
       * @return {Vue}
       */
      _createDialogComponent: function(componentId, config) {
        // Get the component
        var Component = app.getComponent(componentId);
        // Instantiate the component. Make sure it knows that we're the parent
        var DEFAULTS = {
          parent: this
        };
        return new Component($.extend(DEFAULTS, config));
      },
      /**
       * Centers the dialog vertically
       */
      _centerDialog: function() {
        var $frame = $(this._getDialogFrameEl());
        var dialogHeight = $frame.height();
        var windowHeight = $(window).height();

        var top = (windowHeight / 2) - (dialogHeight / 2);

        $frame.css('top', top);
      }
    },

    ready: function() {
      this.$on('centerDialog', this._centerDialog.bind(this));
    }
  };
});

/**
 * Overlay service
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/overlay_factory',[],function() {
  var OVERLAY_TMPL = '<div class="page-overlay"></div>';

  function OverlayService(tmpl) {
    this.template = tmpl || OVERLAY_TMPL;
    this.overlay;
  }

  /**
   * Shows the overlay
   * If the overlay is already shown it will update it's zIndex
   *
   * @param {Integer} zIndex
   */
  OverlayService.prototype.show = function(zIndex) {
    if (!this.overlay) {
      this.overlay = $(OVERLAY_TMPL).appendTo(document.body);
    }

    this.overlay.css('zIndex', zIndex);
  };

  /**
   * Hides the overlay
   */
  OverlayService.prototype.hide = function() {
    if (this.overlay) {
      this.overlay.remove();
      this.overlay = null;
    }
  };

  return {
    create: function(tmpl) {
      return new OverlayService(tmpl);
    }
  };
});

/**
 * Dialog Manager component
 *
 * Responsible for listening for show/hide dialog events
 * and controlling the ordering/layering of dialogs shown on the page
 *
 * Usage:
 * Showing a dialog
 * ==================================================================================================
 * There are three types of dialogs that can be shown at the same time.
 * 1. Form Dialogs (most dialogs are these)
 * 2. Confirm Dialogs (presenting the user with a message and then submit/cancel buttons)
 * 3. Error Dialogs (These are purely informational, ex: on uncaught ajax error)
 *
 * Each type of dialog has it's own `showEvent` that, when triggered, causes the dialog-manager
 * to show that type of dialog.
 *
 * ```js
 * app.$broadcast('showDialog', {
 *   component: 'dialogs/create-experiment',
 *   data: {
 *     projectId: 4001
 *   }
 * }
 * ```
 * Will show a form dialog and instantiate a `dialogs/create-experiment` component
 * as the dialog contents, and will pass the projectId to the components $data
 *
 *
 * Hiding Dialogs:
 * ==================================================================================================
 * Triggering the `hideDialog` event will cause the top most shown dialog to be hidden
 * and the overlay to be repositioned behind the new top most dialog (or hidden if no
 * dialogs are shown)
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dialog_manager',['require','lodash','app','vue','window','services/overlay_factory'],function(require) {
  var _ = require('lodash');
  var app = require('app');
  var Vue = require('vue');
  var $window = require('window');
  var overlayFactory = require('services/overlay_factory');

  var SHOWN_CLASS = 'dialog-shown';
  var ESCAPE_KEY = 27;

  return {
    data: {
      /**
       * Array of all the types of dialogs that can be shown on the page
       * at a single time.  Each dialog frame responds to it's own show event
       * and `hideDialog` hides the shown dialog with the highest zINdex
       */
      dialogFrameRegistry: {
        formDialog: {
          showEvent: 'showDialog',
          zIndex: 3000
        },
        confirmDialog: {
          showEvent: 'showConfirmDialog',
          zIndex: 3002
        },
        errorDialog: {
          showEvent: 'showErrorDialog',
          zIndex: 3004
        }
      },
      /**
       * @var {OverlayService}
       */
      _overlay: null,
      /**
       * Array of all child dialog-frame components
       * @var {Array.<Vue>}
       */
      dialogFrameVMs: []
    },

    computed: {
      /**
       * Array of all dialogFrameVMs that are shown
       * @return {Array.<Vue>}
       */
      shownDialogs: function() {
        return this.dialogFrameVMs.filter(function(vm) {
          return vm.shown;
        });
      },
      /**
       * Get the shown dialog with the highest zIndex
       * @return {Vue}
       */
      topShownDialog: function() {
        return _.last(_.sortBy(this.shownDialogs, 'zIndex'));
      }
    },

    methods: {
      /**
       * Shows a dialog in a specific dialog frame
       *
       * @param {Component} dialogFrame
       * @param { {component: string} } config
       */
      showDialog: function(dialogFrameVM, config) {
        dialogFrameVM.showDialog(config.component, {
          // pass config.data as the child components data
          data: config.data || {}
        });
        // sets the dialogFrameVM.$data.noEscape
        dialogFrameVM.noEscape = !!config.noEscape;
        this._updateOverlay();
      },
      /**
       * Hides the top dialog shown
       */
      hideDialog: function() {
        //var topShownDialog = this._getTopShownDialog();
        if (this.topShownDialog) {
          this.topShownDialog.hideDialog();
          this._updateOverlay();
        }
      },
      /**
       * Event handler for document level keyup
       *
       * @param {Event} event
       */
      handleKeyup: function(event) {
        // Ignore when active element is input/textarea, since user is typing
        var activeElementTagName = this._getDocumentActiveElement().tagName.toLowerCase();
        if (activeElementTagName === "textarea" || activeElementTagName === "input" || activeElementTagName === "select") {
          return;
        }

        if (event.keyCode === ESCAPE_KEY) {
          // only hide the dialog on escape key is the noEscape option is false
          if (this.topShownDialog && !this.topShownDialog.noEscape) {
            this.hideDialog();
          }
        }
      },
      /**
       * Stubbable method to get the document's active element
       * @return {DOMElement}
       */
      _getDocumentActiveElement: function() {
        return document.activeElement;
      },
      /**
       * Updates the overlay to be the zIndex directly below the top dialog
       * @private
       */
      _updateOverlay: function() {
        //var topShownDialog = this._getTopShownDialog();
        if (this.topShownDialog) {
          this._overlay.show(this.topShownDialog.zIndex - 1);
        } else {
          this._overlay.hide();
        }
        $('html').toggleClass(SHOWN_CLASS, !!this.topShownDialog);
      },
      /**
       * Registers a dialogFrame config as a dialog-frame ViewModel
       *
       * @param {Object} def
       * @param {String} key
       */
      _registerDialogFrame: function(def, key) {
        var DialogFrame = app.getComponent('dialog-frame');
        var dialogFrameVM = new DialogFrame({
          parent: this,
          data: {
            id: key,
            zIndex: def.zIndex
          }
        });

        dialogFrameVM.$appendTo(this.$el);
        this.dialogFrameVMs.push(dialogFrameVM);

        // register the dialog's show event and bind the VM to the showDialog method
        this.$on(def.showEvent, this.showDialog.bind(this, dialogFrameVM));

        // in debug mode save reference to all dialog frames
        if (Vue.config('debug')) {
          if (!$window.optly.dialogFrame) {
            $window.optly.dialogFrames = {};
          }
          $window.optly.dialogFrames[key] = dialogFrameVM;
        }
      }
    },

    afterDestroy: function() {
      this.dialogFrameVMs = [];
      this._updateOverlay();
      // cleanup event listeners
      $($window.document).off('keyup.dialog-manager-component');
    },

    created: function() {
      this._overlay = overlayFactory.create();
      // JS Arrays are pass by reference -- ensure each component instance has it's own unique array
      this.dialogFrameVMs = [];
    },

    ready: function() {
      // iterate over all the registered dialogFrames and register the showEvent
      _.each(this.dialogFrameRegistry, function(def, key) {
        this._registerDialogFrame(def, key);
      }.bind(this));

      this.$on('hideDialog', this.hideDialog.bind(this));

      $($window.document).on('keyup.dialog-manager-component', this.handleKeyup.bind(this));
    }
  }
});


define('text!components/goals/create_click_goal.html',[],function () { return 'CREATE CLICK GOAL COMPONENT\n';});

/**
 * Create Click Goal Component
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/goals/create_click_goal',['require','exports','module','text!components/goals/create_click_goal.html'],function(require, module, exports) {
  var tmpl = require('text!components/goals/create_click_goal.html');

  return {
    template: tmpl,
    data: {

    },
    computed: {

    },
    methods: {

    },
    created: function() {

    },
    beforeDestroy: function() {

    }
  };
});


define('text!components/goals/create_custom_event_goal.html',[],function () { return 'CREATE CUSTOM EVENT COMPONENT\n';});

/**
 * Create Custom Event Goal Component
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/goals/create_custom_event_goal',['require','exports','module','text!components/goals/create_custom_event_goal.html'],function(require, module, exports) {
  var tmpl = require('text!components/goals/create_custom_event_goal.html');

  return {
    template: tmpl,
    data: {

    },
    computed: {

    },
    methods: {

    },
    created: function() {

    },
    beforeDestroy: function() {

    }
  };
});


define('text!components/goals/create_page_view_goal.html',[],function () { return 'CREATE PAGE VIEW COMPONENT\n';});

/**
 * Create Page View Component
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('components/goals/create_page_view_goal',['require','exports','module','text!components/goals/create_page_view_goal.html'],function(require, module, exports) {
  var tmpl = require('text!components/goals/create_page_view_goal.html');

  return {
    template: tmpl,
    data: {

    },
    computed: {

    },
    methods: {

    },
    created: function() {
    },
    beforeDestroy: function() {
    }
  };
});


define('text!components/editable.html',[],function () { return '<span v-if="!editing" v-class="editable: pencil && permission" v-on="click: handleDisplayClick">\n  [[[ displayText ]]]\n</span>\n\n<textarea class="editable-input lego-textarea"\n          v-if="editing && multiline"\n          v-on="blur: handleBlur"\n          v-model="content"\n          v-on="keyup: handleKeyup">\n</textarea>\n<input class="editable-input lego-text-input"\n       v-if="editing && pencil"\n       v-on="blur: handleBlur, keyup: handleKeyup"\n       v-model="content">\n</input>\n\n\n<div class="lego-button-row--left push--top" v-if="editing && multiline">\n  <button type="button" class="lego-button lego-button--small" v-on="click: _cancelEdit">\n    Cancel\n  </button>\n  <button type="submit" class="lego-button lego-button--small lego-button--brand" v-on="click: _saveEdit">\n    Save\n  </button>\n</div>\n';});

/**
 * Component that displays rich HTML but can be clicked to edit
 * the underlying raw text. Parent components interact with it
 * using utils/editable, which handles dispatching/capturing events.
 *
 * Supports two styles currently
 * - Pencil: single line, click to edit, enter/blur to save
 * - Multiline: textarea, broadcast event to edit, has built-in save/cancel buttons
 *
 * Call it with these arguments in v-with:
 * - content: The raw text to edit
 * - id: A unique identifier, used for dispatching events and listening for save.
 * - display (optional): Formatted HTML to display. Will use content if not provided.
 * - permission (optional): A boolean for whether the user can edit. Default is always.
 * - style (optional): Can be 'pencil' or 'multiline'. Default is pencil.
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */

define('components/editable',['require','text!./editable.html','vue'],function(require) {
  var tmpl = require('text!./editable.html');
  var Vue = require('vue');

  var ENTER = 13;
  var ESCAPE = 27;
  
  return {
    template: tmpl,

    data: {
      editing: false,
      originalContent: "",
      content: "",
      display: "",
      id: null,
      style: 'pencil',
      permission: true
    },

    computed: {
      multiline: function() {
        return this.style === 'multiline';
      },

      pencil: function() {
        return this.style === 'pencil';
      },

      displayText: function() {
        return this.display || this.content;
      }
    },

    methods: {

      /*
       * Save on blur.
       */
      handleBlur: function() {
        if (this.pencil) {
          this._saveEdit();
        }
      },

      /*
       * Save on enter (unless multiline), cancel on escape.
       */
      handleKeyup: function(event) {
        var keyCode = event.keyCode;
        if (!this.multiline && keyCode === ENTER) {
          this._saveEdit();
        } else if (keyCode === ESCAPE) {
          this._cancelEdit();
        }
      },

      /*
       * In pencil mode, start editing when the user clicks.
       */
      handleDisplayClick: function() {
        if (this.pencil && this.permission) {
          this._startEdit();
        }
      },

      /*
       * Initiate editing mode
       * Saves the original value in case the user cancels.
       */
      _startEdit: function() {
        this.editing = true;
        this.originalContent = this.content;
        var el = this.$el;
        
        Vue.nextTick(function() {
          $(el).find('.editable-input').focus()
        });
      },

      /*
       * Save changes by dispatching a message up to the parent component
       * Parents should listen via editable.onSaved in utils/editable.
       */
      _saveEdit: function() {
        if (this.content != this.originalContent) {
          this.$dispatch('editable-saved', this.id, this.content, this.originalContent);
        }
        this.editing = false;
      },

      /*
       * Abort editing and go back to the original value.
       */
      _cancelEdit: function() {
        this.content = this.originalContent;
        this.editing = false;
      },
    },

    ready: function() {
      // Listen for the edit event from parent components
      this.$on('editable-edit', function(id) {
        if(id === this.id) {
          this._startEdit();
        }
      });
    }

  }

});

/**
 * Geotargeting Service
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/geotargeting',['require'],function(require) {
  /**
   * Object that batches locations to fetch and makes a single AJAX request
   * @constructor
   */
  function LocationFetcher(geotargetingService) {
    this.MAXIMUM_QUEUE = 15;
    /**
     * State of all queue'd location keys to fetch and their corresponding Deferreds
     * @param {Array.<{ location: string, deferred: Deferred }>}
     */
    this.locationsToFetch = [];

    /**
     * @type {GeotargetingService}
     */
    this.geotargetingService = geotargetingService;
  }

  /**
   * Queues a location to fetch
   * @param {String} location key
   * @param {Deferred} deferred
   */
  LocationFetcher.prototype.queue = function(location, deferred) {
    this.locationsToFetch.push({
      location: location,
      deferred: deferred
    });
  };

  /**
   * Returns whether the is full on queued on locations to fetch
   * @return {Boolean}
   */
  LocationFetcher.prototype.isFull = function() {
    return (this.locationsToFetch.length >= this.MAXIMUM_QUEUE);
  };

  /**
   * Fetches the labels for all the location keys queued on the object
   * and resolves each deferred.  Also caches and removes the locationFetcher
   * from the parent GeotargetingService stack
   *
   * @return {Deferred}
   */
  LocationFetcher.prototype.fetch = function() {
    // extract the location keys from the map
    var keysToFetch = this.locationsToFetch.map(function(item) {
      return item.location;
    });

    return this.doFetch(keysToFetch).then(function(rslt) {
      // Resolve all deferreds with their label values
      this.locationsToFetch.forEach(function(item) {
        if (rslt[item.location]) {
          item.deferred.resolve(rslt[item.location])
        } else {
          item.deferred.reject();
        }
      }, this);

      this.geotargetingService.cacheLocationsToLabels(rslt);
      // reset
      this.locationsToFetch = [];
      // remove itself from the locationFetchers stack
      var index = this.geotargetingService.locationFetchers.indexOf(this);
      this.geotargetingService.locationFetchers.splice(index, 1);
    }.bind(this));
  }

  /**
   * Make an XHR request to get a label for a location string
   * @private
   * @param {Array.<String>} location (ex: City|State|Country)
   * @return {Deferred}
   */
  LocationFetcher.prototype.doFetch = function(locations) {
    var url =  '/api/location_labels.json';

    var queryString = locations.map(function(loc) {
      return 'keys=' + loc;
    }, '').join('&');

    url += '?' + queryString

    return $.ajax({
      url: url,
      type: 'GET'
    });
  };


  /**
   * @constructor
   */
  function GeotargetingService() {
    /**
     * Cached mapping of locations -> labels
     * @param {Object}
     */
    this.locationsToLabels = {};

    /**
     * Reference to setTimeout for fetching location labels
     */
    this.timeoutRef = null;

    /**
     * @type {Array.<LocationFetcher>}
     */
    this.locationFetchers = [];
  }

  /**
   * Creates a LocationFetcher and pushes it on the LocationFetcher's stack
   * @private
   */
  GeotargetingService.prototype.createLocationFetcher = function() {
    this.locationFetchers.push(new LocationFetcher(this));
  };

  /**
   * Extends the locationsToLabels cache with the passed map
   * @param {Object} results - a JSON response from the autocomplete endpoint
   */
  GeotargetingService.prototype.cacheLocationsToLabels = function(locationsToLabels) {
    $.extend(this.locationsToLabels, locationsToLabels);
  };

  /**
   * Takes a location string and returns the readable label
   * If the label isn't cached it will batch the requested labels and make a single
   * XHR request to get all the labels at once and resolve all the deferreds
   *
   * @param {String} location (ex: City|State|Country)
   * @return {Deferred}
   */
  GeotargetingService.prototype.getLabel = function(location) {
    var deferred = $.Deferred();
    if (this.locationsToLabels[location]) {
      deferred.resolve(this.locationsToLabels[location]);
    } else {
      // if executed in the same context cancel the timeout
      // add a key to fetch and requeue deferred fetch
      if (this.timeoutRef) {
        clearTimeout(this.timeoutRef);
      }

      // create a LocationFetcher object
      if (!_.last(this.locationFetchers)) {
        this.createLocationFetcher();
      }

      // if the last LocationFetcher is full, call fetch and create a new one
      if (_.last(this.locationFetchers).isFull()) {
        // if the current LocationFetcher is full queue up the fetch
        _.last(this.locationFetchers).fetch();
        this.createLocationFetcher();
      }

      var lastLocationFetcher = _.last(this.locationFetchers);

      // queue up the location to fetch
      lastLocationFetcher.queue(location, deferred);

      // defer the fetch request
      this.timeoutRef = setTimeout(function() {
        lastLocationFetcher.fetch().then(function() {
          // clear the timeout ref
          this.timeoutRef = null;
        });
      }.bind(this), 0);
    }

    return deferred;
  };

  return new GeotargetingService();
});

/**
 * Geotargeting Autocomplete
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/geotargeting/geotargeting_autocomplete',['require','services/geotargeting'],function(require) {
  var geotargetingService = require('services/geotargeting');

  return {
    methods: {
      clear: function() {
        $(this.$el).typeahead('setQuery', '');
      },
      /**
       * Transforms results into a list and caches
       * the results in the geotargeting service
       *
       * @param {Object} response
       * @return {Array}
       */
      _autocompleteFilter: function(response) {
        if (!response.succeeded) {
          return [];
        }

        return response.labels.map(function(label) {
          return {
            value: label,
            location: response.labelsToLocations[label]
          }
        });
      }
    },

    beforeDestroy: function() {
      $(this.$el).typeahead('destroy');
    },

    ready: function() {
      var typeaheadOptions = {
        name: 'Locations',
        limit: 32,
        remote: {
          url: '/api/locations.json?term=%QUERY',
          filter: this._autocompleteFilter
        }
      };

      $(this.$el)
        .typeahead(typeaheadOptions)
        .on('typeahead:selected', function(event, datum) {
          var toCache = {};
          toCache[datum.location] = datum.value;

          geotargetingService.cacheLocationsToLabels(toCache);

          this.$dispatch('geotargetingLocationSelected', {
            location: datum.location,
            label: datum.value
          });
        }.bind(this));

      this.$on('geotargetingAutocompleteClear', this.clear.bind(this));
    }
  };
});

/**
 * Abstraction of window.location for testability
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('location',['require','window'],function(require) {
  var $window = require('window');

  function pathname() {
    return $window.location.pathname;
  }

  return {
    pathname: pathname
  };
});

/**
 * Function getter to get account info
 */
define('flux/getters/account',[],function() {
  return [
    'account',
    function (accountStore) {
      return accountStore.getAccountInfo();
    }
  ];
});

/**
 * Navbar Controller
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/navbar',['require','lodash','app','utils/enums','location','services/auth','services/router','services/experiment','flux','flux/getters/account','flux/getters/current_project'],function(require) {
  var _                 = require('lodash');
  var app               = require('app');
  var enums             = require('utils/enums');
  var location          = require('location');
  var auth              = require('services/auth');
  var router            = require('services/router');
  var experimentService = require('services/experiment');
  var flux = require('flux');

  var getAccount = require('flux/getters/account');
  var getCurrentProject = require('flux/getters/current_project');

  return {
    data: {
      account: null,
      activeProjects: [],
      experimentsMessage: '',
      /**
       * @var {Array.<{
       *  id: <number>,
       *  can_edit: <boolean>,
       *  description: <string>,
       *  has_started: <boolean>
       * }>}
       */
      experiments: [],
    },

    computed: {
      dashboardLink: function() {
        if (this.currentProject && this.currentProject.id) {
          return router.dashboard(this.currentProject.id);
        }
        return router.dashboard();
      },
      /**
       * Determines whether the currently active account has an active web projects.
       * @returns {boolean}
       */
      hasActiveWebProject: function() {
        var filteredProjects = _.filter(this.activeProjects, function(project) {
          // An empty project_platforms list we treat as a web project (it just hasn't been migrated yet)
          return (
            project.project_platforms.length === 0 ||
            project.project_platforms.indexOf(enums.ProjectPlatformType.WEB) !== -1
          )
        });
        return filteredProjects.length > 0;
      },
      showSignInLink: function() {
        return location.pathname() !== router.signIn();
      },
      showDashboardLink: function() {
        return !this._isOnboarding() && location.pathname() !== router.dashboard();
      },
      isNewDashboard: function() {
        return location.pathname().indexOf('projects') !== -1;
      },
      showExperimentsDropdown: function() {
        return !this._isOnboarding() && !this.isNewDashboard;
      }
    },

    methods: {
      // expose logout functionality
      logout: auth.logout,
      /**
       * Takes an experiment and returns the edit url
       */
      editUrl: function(experiment) {
        return router.experimentEdit({
          experimentId: experiment.id
        });
      },
      dashboardUrl: function(account){
        return router.dashboard()
      },
      /**
       * Shows the dialogs/get-feedback component.
       */
      showGetFeedbackDialog: function() {
        var config = {
          component: 'dialogs/get-feedback'
        };
        app.$broadcast('showDialog', config);
      },
      /**
       * Takes an experiment and returns the results url
       */
      resultsUrl: function(experiment) {
        return router.experimentResults(experiment.id);
      },
      /**
       * Shows the dialogs/create-experiment component. Since we don't know the project platform
       * we pass in the main project ID and let create-experiment figure it out
       */
      showCreateExperimentDialog: function() {
        var config = {
          component: 'dialogs/create-experiment',
          data: {
            project_id: this.account.accountId
          }
        };
        app.$broadcast('showDialog', config);
      },

      _loadExperiments: function() {
        // load experiment data
        this.experimentsMessage = tr('Loading...');

        experimentService.loadRecent(5)
          .done(function(experiments) {
            this.experiments = experiments;
            this.experimentsMessage = (experiments.length > 0) ? '' : tr('There are no experiments.');
          }.bind(this))
          .fail(function() {
            this.experimentsMessage = tr('Error loading your experiments.');
          }.bind(this));
      },
      /**
       * Helper function for updating the set of active projects. Filters down to the properties we care about.
       *
       * @param newActiveProjectsSet The new set of active projects
       * @private
       */
      _handleActiveProjectsChanged: function(newActiveProjectsSet) {
        this.activeProjects = _.map(newActiveProjectsSet, function(project) {
          return _.pick(project, 'id', 'project_platforms');
        });
      },
      /**
       * Helper function for detecting if we're in the mobile onboarding flow
       */
      _isMobileOnboarding: function() {
        return location.pathname().lastIndexOf("/mobile/", 0) === 0;
      },
      /**
       * Helper function for detecting if we're in the onboarding flow
       */
      _isOnboarding: function() {
        return this._isMobileOnboarding() || this._isWebOnboarding() || location.pathname().lastIndexOf("/welcome", 0) === 0;
      },
      /**
       * Helper function for detecting if we're in the web onboarding flow
       */
      _isWebOnboarding: function() {
        return location.pathname().lastIndexOf("/web/", 0) === 0;
      }
    },

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        account: getAccount,
      });
    },

    ready: function() {
      if (this.account.isSignedIn) {
        this._loadExperiments();
      }
      // Copy and modify the activeProjects property of optly/account.js so that we can keep track of
      // artice projects in this component.
      this.activeProjects = _.map(_.keys(this.account.activeProjects), (function(project_id) {
        return {
          id: project_id,
          project_platforms: this.account.activeProjects[project_id].project_platforms
        }
      }).bind(this));

      // whenever account info changes reload experiments
      this.$watch('account', function(account) {
        if (flux.store('account').isSignedIn()) {
          this._loadExperiments();
        }
      });
      // when an experiment is saved update recent experiments
      this.$on('experimentSaved', this._loadExperiments);
      // when a project is archived
      this.$on('activeProjectsChanged', this._handleActiveProjectsChanged.bind(this));
    },
  };
});


define('text!components/notification_manager.html',[],function () { return '<div class="lego-notification--wrap">\n  <div class="lego-notification [[notificationClass]]" \n       v-class="lego-notification--active: shown"\n       v-repeat="notifications">\n      [[[ message ]]]\n  </div>\n</div>';});

/**
 * Notification Manager component
 *
 * Responsible for listening for notification events
 *
 * Usage:
 * Showing a notification message over the page
 * ==================================================================================================
 *
 * ```js
 * app.$broadcast('notify', {
 *  message: tr("The project <b>{0}</b> has been archived.", project.project_name),
 *  type: 'success'
 * });
 * ```
 * The type field is optional, and will default to 'default'.
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('components/notification_manager',['require','vue','lodash','app','text!components/notification_manager.html'],function(require) {
  var Vue = require('vue');
  var _ = require('lodash');
  var app = require('app');
  var tmpl = require('text!components/notification_manager.html');

  var LIFETIME = 3000;
  var FADE_TIME = 300;

  return {
  
    template: tmpl,
    replace: true,

    data: {
      notificationTypes: {
        default: 'lego-attention--brand',
        success: 'lego-attention--good-news',
        warning: 'lego-attention--warning',
        error: 'lego-attention--bad-news'
      },
      notifications: []
    },

    methods: {
      /*
       * Shows a notification on the page, then hides it after timeout.
       * Pass in an object with .message and .type (the class to be used).
       */
      _showNotification: function(config) {
        if (!config.type) {
          config.type = 'default';
        }
        config.timestamp = Date.now();
        config.notificationClass = this.notificationTypes[config.type];
        this.notifications.push(config);
       
        // Fade in notification
        Vue.nextTick(function() {
          config.shown = true
        });

        // Fade out notification
        window.setTimeout(function() {
          config.shown = false
        }, LIFETIME);

        // Remove it when done fading
        window.setTimeout(function() {
          this.notifications = _.drop(this.notifications, {timestamp: config.timestamp});
        }.bind(this), LIFETIME + FADE_TIME);
      },
    },

    ready: function() {
      this.$on('notify', function(config) {
        this._showNotification(config);
      });
    }
  }
});


define('text!components/pages/dashboard.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n  <!-- Tab Parents -->\n  <div class="lego-pane">\n\n    <div class="flex align-items--center lego-fence--soft push-double--ends">\n      <div class="gamma truncate flex-1">\n        <span v-component="editable"\n              v-with="id: \'project_name\',\n                      content: currentProject.project_name,\n                      permission: canEditProject">\n        </span>\n      </div>\n    </div>\n\n    <!-- Main Tabs -->\n    <div class="lego-tabs">\n      <ul class="lego-tabs-nav soft-double--left">\n        <li class="lego-tabs-nav__item"\n          v-on="click: switchTab(\'experiments\')"\n          v-class="tab-active: activeTab === \'projects\'">\n          <svg class="lego-icon"><use xlink:href="#projects"></use></svg> Overview\n        </li>\n        <li class="lego-tabs-nav__item"\n          v-if="shouldSeeIntegrations"\n          v-on="click: switchTab(\'integrations\')"\n          v-class="tab-active: activeTab === \'integrations\'">\n          <svg class="lego-icon"><use xlink:href="#integrations"></use></svg> Integrations\n        </li>\n        <li class="lego-tabs-nav__item"\n          v-if="shouldSeeCollaborators"\n          v-on="click: switchTab(\'collaborators\')"\n          v-class="tab-active: activeTab === \'collaborators\'">\n          <svg class="lego-icon"><use xlink:href="#collaborators"></use></svg> Collaborators\n        </li>\n        <li class="lego-tabs-nav__item"\n          v-on="click: switchTab(\'implementation\')"\n          v-class="tab-active: activeTab === \'settings\'">\n          <svg class="lego-icon"><use xlink:href="#settings"></use></svg> Settings\n        </li>\n      </ul>\n    </div>\n  </div>\n  <div v-view="activeTab"></div>\n</div>\n';});

/**
 * User service
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('services/user',[],function() {
  /**
   * Turns on/off a feature for this user. Send true for opt in, false for opt out.
   * Will execute the callback on success
   * @param {String} featureName
   * @param {Boolean} isOptIn
   * @param {Function} callback
   **/
  function setOptInFeature(feature, isOptIn, callback) {
    var requestOptions = {
      url: '/account/set_opt_in_feature',
      contentType: 'application/json',
      dataType: 'json',
      data: {
        feature: feature,
        isOptIn: isOptIn
      },
      optimizelyRetryLimit: 3,
      success: callback,
      error: function() {
        console.log("ERROR SETTING OPTIN FOR FEATURE", feature);
      }
    };
    $.ajax(requestOptions);
  }

  return {
    setOptInFeature: setOptInFeature
  };
});


define('text!components/dashboard/collaborators/collaborators_tab.html',[],function () { return '<div class="lego-pane lego-pane-group lego-pane-group--column lego-pane--flex-1">\n  <div class="tab-contents lego-pane lego-pane--flex-1 lego-pane-group">\n    <div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column push--top">\n      <div class="lego-pane lego-fence--soft">\n\n        <div class="lego-attention push-double--top" v-if="!canUseCollaborators">\n          <p>Collaboration is only available for Silver plans and above. The collaborators feature lets you invite colleagues to view results and work together on experiments. With an Enterprise plan, you can also control roles and permissions for your collaborators. Please <a href="/pricing" target="_blank">upgrade or contact sales to use this feature</a>.</p>\n          <p>If you\'ve already upgraded, reload this page and you\'ll be able to use collaborators!</p>\n        </div>\n\n        <!-- Toolbar -->\n        <div class="push-double--top" v-if="canUseCollaborators">\n          <ul class="flex push-double--bottom" data-ui-component="dashboard-toolbar">\n            <li class="push-triple--right">\n                <input type="text"\n                class="lego-text-input lego-text-input--search width-200"\n                placeholder="Filter by Name"\n                v-on="keyup: setStringFilter"\n                v-value="filterString" >\n            </li>\n            <li class="push--right hidden">\n              <div class="lego-button-group">\n                <button class="lego-button lego-button--secondary"\n                  v-lego-disabled="selectedCollaborators.length === 0"\n                  v-on="click: showDuplicateCollaborators(selectedCollaborators)">\n                  <svg class="lego-icon">\n                    <use xlink:href="#duplicate"></use>\n                  </svg>\n                </button>\n              </div>\n            </li>\n            <li class="anchor--right">\n              <button class="lego-button lego-button--highlight"\n                v-loading="inviteCollaborator" spinner-size="small"\n                v-on="click: showInviteCollaborators(currentProject.id)"\n                v-lego-disabled="!canAddCollaborator">New Collaborator\n              </button>\n            </li>\n          </ul>\n      </div>\n    </div>\n\n    <div class="lego-pane lego-pane--flex-1 lego-pane--scroll-y" v-if="canUseCollaborators"\n      v-loading="inviteCollaborator"\n      v-loading="dashboard.collaborators">\n        <table class="lego-table lego-table--dashboard"\n          id="dashboard-collaborators"\n          v-prevent-shift-selection\n          v-if="collaborators.length > 0">\n          <thead>\n            <tr>\n              <th class="nowrap" v-component="sortable-th" field="user_id">User</th>\n              <th class="nowrap" v-component="sortable-th" field="role_name">Role</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr v-repeat="collaborator: collaborators"\n              v-component="collaborators-table-row">\n            </tr>\n          </tbody>\n        </table>\n        <div v-if="collaborators.length === 0 && hasFilters" class="lego-fence--soft">\n          No collaborators match your search. Try <a href="javascript:void(0)" v-on="click: clearFilters">clearing your filters</a> to see all the collaborators on this project.\n        </div>\n      </div>\n    </div>\n\n    <div class="lego-pane lego-data-sidebar lego-pane--flex"\n      v-component="collaborators-sidebar">\n    </div>\n  </div>\n</div>\n';});


define('text!components/dashboard/collaborators/collaborators_table_row.html',[],function () { return '<tr v-on="click: clickCollaborator($event, collaborator)"\n    v-loading-entity="collaborator.id" entity="collaborators" spinner-size="small"\n    v-class="lego-table-row--active: isSelected">\n    <td class="cell-truncate">\n      <div class="cell-truncate__text">\n        [[ title ]]\n      </div>\n      <div class="cell-truncate__title">\n        <span v-if="collaborator.first_name">\n          [[ collaborator.first_name ]] [[collaborator.last_name]] ([[ collaborator.user_id ]])\n        </span>\n        <span v-if="!collaborator.first_name">\n          [[ collaborator.user_id ]]\n        </span>\n      </div>\n    </td>\n    <td class="nowrap" v-text="collaborator.role_name | capitalize"></td>\n</tr>\n';});

/**
 * Collaborator table row
 *
 * @author Cheston Lee (cheston@optimizely.com)
 */
define('components/dashboard/collaborators/collaborators_table_row',['require','text!components/dashboard/collaborators/collaborators_table_row.html','flux'],function(require) {
  var tmpl = require('text!components/dashboard/collaborators/collaborators_table_row.html');
  var flux = require('flux');

  return {
    template: tmpl,

    replace: true,

    data: {
      isSelected: false,
      collaborator: {},
    },

    methods: {
      /**
       * @param {Event} event
       * @param {Object} collaborator
       */
      clickCollaborator: function(event, collaborator) {
        flux.actions('dashboard').clickItem('collaborators', collaborator, event.shiftKey);
        flux.actions('dashboard').replaceUrl();
      },
    },

    ready: function() {
      var collaborator = this.collaborator;
      flux.bindVueValues(this, {
        isSelected: ['dashboard/selectedItems', function(selectedItemsStore) {
          return selectedItemsStore.isSelected('collaborators', collaborator.id);
        }.bind(this)]
      });
    },

    beforeDestroy: function() {
      if (this.isSelected) {
        flux.actions('dashboard').deselectItem('collaborators', this.collaborator);
      }
    },
  };
});


define('text!components/dashboard/collaborators/collaborators_sidebar.html',[],function () { return '<ul class="accordion" v-accordion>\n  <li class="accordion__item accordion__item--active"  v-class="accordion__item--empty : selectedCollaborators.length != 1">\n    <a class="accordion__link" href="#">Collaborator Details</a>\n\n    <div class="accordion__content-wrap" v-if="selectedCollaborators.length === 0">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large">\n            <use xlink:href="#collaborators"></use>\n          </svg>\n          <div>Select a user for details</div>\n        </div>\n      </div>\n    </div>\n    <div class="accordion__content-wrap" v-if="selectedCollaborators.length > 1">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large"><use xlink:href="#collaborators"></use></svg>\n          <div>[[ selectedCollaborators.length ]] collaborators selected.</div>\n        </div>\n      </div>\n    </div>\n    <div class="accordion__content-wrap"\n      v-if="selectedCollaborators.length === 1">\n      <div class="accordion__content" v-loading-entity="selectedCollaborator.id" entity="collaborators">\n        <ul class="lego-sections">\n          <li class="lego-sections__item"\n            v-if="selectedCollaborator.first_name && selectedCollaborator.last_name">\n            <div class="lego-label">Name</div>\n            <p>[[ selectedCollaborator.first_name]] [[ selectedCollaborator.last_name]]</p>\n          </li>\n          <li class="lego-sections__item"\n            v-if="selectedCollaborator.title">\n            <div class="lego-label">Title</div>\n            <p>[[ selectedCollaborator.title ]]</p>\n          </li>\n          <li class="lego-sections__item">\n            <div class="lego-label">Email</div>\n            <p>[[ selectedCollaborator.user_id ]]</p>\n          </li>\n          <li class="lego-sections__item">\n            <div class="lego-label">Role</div>\n            <p>\n              <select name="roleList"\n                class="lego-select"\n                v-model="selectedCollaborator.role_name"\n                v-on="change: confirmChangeRole(selectedCollaborator)"\n                v-if="canEditCollaborator">\n                <option v-repeat="role: roles"\n                  v-attr="selected: selectedCollaborator.role_name === role.name"\n                  v-text="role.name"></option>\n              </select>\n              <span v-if="!canEditCollaborator">\n                [[ selectedCollaborator.role_name ]]\n              </span>\n            </p>\n          </li>\n          <li class="lego-sections__item">\n            <div class="lego-button-row--left">\n              <button class="lego-button"\n              v-poptip data-dir="top" data-content="Remove from this project"\n              v-if="canEditCollaborator"\n              v-on="click: confirmRemoveCollaborator(selectedCollaborator, false)">Remove</button>\n              <button class="lego-button lego-button--danger"\n              v-poptip data-dir="top" data-content="Remove from all projects in this account"\n              v-if="canRemoveCollaboratorFromAccount"\n              v-on="click: confirmRemoveCollaborator(selectedCollaborator, true)">Delete</button>\n            </div>\n          </li>\n    </div>\n  </li>\n  <li class="accordion__item">\n    <a class="accordion__link" href="#">Help</a>\n    <div class="accordion__content-wrap">\n      <div class="accordion__content">\n        <h3>Collaborators</h3>\n        <p>Optimizely users are called collaborators. You can control your collaborators access through four different types of user roles.</p>\n\n        <p><b>Administrators</b> have full access to all projects and account billing information. They can add and remove other administrators.</p>\n\n        <p><b>Project Owners</b> can create, edit, start, and stop experiments; preview variations; and view results. There can be more than one project owner for each project.</p>\n\n        <p><b>Editors</b> can create and edit non-running experiments, preview variations, and view results.</p>\n\n        <p><b>Viewers</b> can preview variations and view results.</p>\n\n        <p>You can add collaborators to multiple projects at once. You can also add collaborators from outside of your domain (for instance, if you work with an agency or Solutions Partner).</p>\n\n        </p>Find out more in our Knowledge Base - <a href="https://help.optimizely.com/hc/en-us/articles/200040775" target="_blank">Learn more</a>\n      </div>\n    </div>\n  </li>\n</ul>\n';});

/**
 * Collaborator Service
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('services/collaborator',['flux'],function() {
  var flux = require('flux');


  function getCurrentRole(collaborator) {
    return flux.store('collaborators').get(collaborator.id).role_name;
  }

  return {
    getCurrentRole: getCurrentRole,
  };
});

/**
 * Collaborators Side Panel Component
 *
 * @author Cheston Lee
 */
define('components/dashboard/collaborators/collaborators_sidebar',['require','text!components/dashboard/collaborators/collaborators_sidebar.html','flux','app','utils/handle_ajax_error','services/confirm','services/collaborator','services/events','flux/getters/current_project','flux/getters/dashboard/selected_collaborators','flux/getters/dashboard/filtered_collaborators'],function(require) {
  var tmpl = require('text!components/dashboard/collaborators/collaborators_sidebar.html');
  var flux = require('flux');
  var app = require('app');
  var handleAjaxError = require('utils/handle_ajax_error');
  var confirm = require('services/confirm');
  var collabService = require('services/collaborator');
  var events = require('services/events');

  var getCurrentProject = require('flux/getters/current_project');
  var getDashboardSelectedCollaborators = require('flux/getters/dashboard/selected_collaborators');
  var getDashboardFilteredCollaborators = require('flux/getters/dashboard/filtered_collaborators');

  /**
   * Retrieve a single collaborator for the side bar display or empty
   * so as not to upset the watcher
   */
  var getSingleSelectedCollaborator = [
    getDashboardSelectedCollaborators,
    function(collaborators) {
      if (collaborators.length !== 1) {
        return {};
      }
      return collaborators[0];
    }
  ];

  return {
    template: tmpl,
    data: {
      collaborators: [],
      selectedCollaborators: [],
      isSaving: false
    },
    computed: {
      /**
      * Can change a collaborator's role/projects. You can't edit a collaborator if
      * a) It's yourself
      * b) You don't have permission to edit collaborators
      * c) The collaborator is more powerful than you (their role isn't in your editable roles)
      * @return {boolean}
      */
      canEditCollaborator: function() {
        var project = this.currentProject;
        var collaborator = this.selectedCollaborator;
        
        return (!this.isCollaboratorSelf &&
                flux.actions('permissions').canEditCollaborator(project) &&
                _.contains(project.collaborator_roles, collaborator.role_name));
      },

      canRemoveCollaboratorFromAccount: function() {
        var project = this.currentProject;
        return !this.isCollaboratorSelf && flux.actions('permissions').canRemoveCollaboratorFromAccount(project);
      },

      isCollaboratorSelf: function() {
        var myEmail = flux.store('account').getEmail();
        var collab = this.selectedCollaborator;
        return collab && collab.user_id === myEmail;
      }
    },
    methods: {
      /**
       * Handle changing the role of the collaborator, called from confirmChangeRole
       */
      changeRole: function(collab) {
        this.isSaving = true;

        flux.actions('collaborators').save(collab)
          .done(function(newCollab) {
            // Collaborators are deleted and recreated on save, so we need to reselect it
            flux.actions('dashboard').selectItem('collaborators', newCollab);
            app.$broadcast('notify', {
              message: tr("<b>{0}</b>'s role has been changed to {1}", newCollab.user_id, newCollab.role_name),
            });
            events.track('dashboard2', 'edit-collaborator', 'role');
          })
          .fail(handleAjaxError(function(reason) {
            app.$broadcast('notify', {
              message: tr("Error changing <b>{0}</b>'s role: {1}", newCollab.user_id, reason),
              type: 'error'
            });
          }.bind(this)))
          .always(function() {
            this.isSaving = false;
            // saving a collab can return a new collab with different id
            // prevent loading spinner from never disappearing
            flux.actions('loading').setEntityLoaded('collaborators');
          }.bind(this));
      },

      /**
       * Handle checking if we are dealing with transitioning to or from an Administrator role
       *
       * @param {Collaborator} collaborator
       */
      confirmChangeRole: function(collaborator) {
        if (collaborator && this.canEditCollaborator) {
          
          var currentRole = collabService.getCurrentRole(collaborator);

          if (currentRole === 'Administrator') {
            confirm.confirm({
              title: tr('Remove Administrator'),
              message: tr("Changing {0}\'s role from {1} to {2} will remove them from <b>all other projects</b>. Are you sure you want to continue?", collaborator.user_id, currentRole, collaborator.role_name),
              confirmText: tr('Remove from other projects'),
              cancelText: tr('Cancel'),
              isWarning: true,
            })
            .done(function() {
              this.changeRole(collaborator);
            }.bind(this))
            .fail(function() {
              // Reset the role in dropdown if they cancel
              this.selectedCollaborator.role_name = currentRole;
            }.bind(this));
          } else if (collaborator.role_name === 'Administrator') {
            confirm.confirm({
              title: tr('Add Administrator'),
              message: tr('Making {0} an Administrator will add them to <b>all projects</b>. To add them to just this project, use the Project Owner role instead. Are you sure you want to continue?', collaborator.user_id),
              confirmText: tr('Add to all projects'),
              cancelText: tr('Cancel'),
            })
            .done(function() {
              this.changeRole(collaborator);
            }.bind(this))
            .fail(function() {
              // Reset the role in dropdown if they cancel
              this.selectedCollaborator.role_name = currentRole;
            }.bind(this));
          } else {
            this.changeRole(collaborator);
          }
        }
      },

      /**
       * Handle checking if we are dealing with an Admin and prompt appropriatly
       *
       * @param {Collaborator} collaborator
       * @param {Boolean} fromAccount
       */
      confirmRemoveCollaborator: function(collaborator, fromAccount) {
        if (collaborator && this.canEditCollaborator) {

          // Removing an administrator always removes them from the whole account, so handle these two cases together
          if (collaborator.role_name === 'Administrator' || fromAccount) {
            confirm.confirm({
              title: tr('Remove From Account'),
              message: tr("This will remove {0}\'s access to <b>all projects</b>. Are you sure you want to continue?", collaborator.user_id),
              confirmText: tr('Remove from all projects'),
              cancelText: tr('Cancel'),
              isWarning: true
            }).then(function() {
              this.removeCollaborator(collaborator, fromAccount);
            }.bind(this));

          // Otherwise, we're just dealing with a single project
          } else {
            confirm.confirm({
              title: tr('Remove from Project'),
              message: tr("This will remove {0}\'s access to this project. Are you sure you want to continue?", collaborator.user_id),
              confirmText: tr('Remove from this project'),
              cancelText: tr('Cancel'),
              isWarning: true
            }).then(function() {
              this.removeCollaborator(collaborator, fromAccount);
            }.bind(this));
          }
        }
      },

      /**
       * Delete the selected collaborator from the entire account
       */
      deleteCollaborator: function(collaborator) {
        return flux.actions('collaborators')
          .deleteFromAccount(collaborator, this.currentProject)
          .done(function() {
            app.$broadcast('notify', {
              message: tr("<b>{0}</b> has been deleted from this account", collaborator.user_id),
            });
            events.track('dashboard2', 'remove-collaborator', 'from-account');
          })
          .fail(handleAjaxError(function(reason) {
            this.error = reason;
            app.$broadcast('notify', {
              message: tr("Error deleting <b>{0}</b> from this account: {1}", collaborator.user_id, reason),
              type: 'error'
            });
          }.bind(this)))
          .always(function() {
            this.isSaving = false;
          }.bind(this))

      },
      /**
       * Handle removing the collaborator, called from confirmRemoveRole
       * @param {Boolean} fromAccount Whether to remove the collaborator from the entire account
       */
      removeCollaborator: function(collaborator, fromAccount) {
        if (collaborator && this.canEditCollaborator) {
          this.isSaving = true;
          if (fromAccount) {
            return this.deleteCollaborator(collaborator);
          } else {
            return flux.actions('collaborators')
              .delete(collaborator, this.currentProject)
              .done(function() {
                app.$broadcast('notify', {
                  message: tr("<b>{0}</b> has been removed from this project", collaborator.user_id),
                });
                events.track('dashboard2', 'remove-collaborator', 'from-project');
              })
              .fail(handleAjaxError(function(reason) {
                app.$broadcast('notify', {
                  message: tr("Error removing <b>{0}</b> from this project: {1}", collaborator.user_id, reason),
                  type: 'error'
                });
              }.bind(this)))
              .always(function() {
                this.isSaving = false;
              }.bind(this));

            return deferred;
          }
        }
      }
    },
    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        collaborators: getDashboardFilteredCollaborators,
        selectedCollaborators: getDashboardSelectedCollaborators,
        selectedCollaborator: getSingleSelectedCollaborator,
      });
    }
  };
});

/**
 * Collaborators tab view component
 *
 * @author Cheston Lee (cheston@optimizely.com)
 */
define('components/dashboard/collaborators/collaborators_tab',['require','app','text!components/dashboard/collaborators/collaborators_tab.html','flux','flux/getters/current_project','flux/getters/dashboard/filtered_collaborators','flux/getters/dashboard/selected_collaborators','components/dashboard/collaborators/collaborators_table_row','components/dashboard/collaborators/collaborators_sidebar'],function(require) {
  var app = require('app');
  var tmpl = require('text!components/dashboard/collaborators/collaborators_tab.html');
  var flux = require('flux');

  var getCurrentProject = require('flux/getters/current_project');
  var getDashboardFilteredCollaborators = require('flux/getters/dashboard/filtered_collaborators');
  var getDashboardSelectedCollaborators = require('flux/getters/dashboard/selected_collaborators');

  return {
    components: {
      'collaborators-table-row': require('components/dashboard/collaborators/collaborators_table_row'),
      'collaborators-sidebar': require('components/dashboard/collaborators/collaborators_sidebar')
    },
    template: tmpl,

    replace: true,

    data: {
      collaborators: [],
      selectedCollaborators: [],
      deletedCollaborators: [],
      nameFilter: '',
    },

    computed: {

      roles: function() {
        var project = this.currentProject;
        return _.map(project.collaborator_roles, function(role) {
          return {'name': role};
        });
      },

      /**
      * Can invite a new collaborator
      * @return {boolean}
      */
      canAddCollaborator: function() {
        var project = this.currentProject;
        return flux.actions('permissions').canAddCollaborator(project);
      },

      /**
      * Can use collaborators
      * @return {boolean}
      */
      canUseCollaborators: function() {
        var project = this.currentProject;
        return flux.actions('permissions').canUseCollaborators(project);
      },

      /**
       * Checks whether any filters are applied
       * @return {boolean}
       */
      hasFilters: function() {
        return this.filterString;
      },
    },

    methods: {
      /**
       * Show the dialog for duplicating collaborators.
       */
      showDuplicateCollaborators: function() {
        app.$broadcast('showDialog', {
          component: 'dialogs/duplicate-collaborators',
        });
      },

      /**
       * Shows the invite dialog for collaborators
       */
      showInviteCollaborators: function() {
        app.$broadcast('showDialog', {
          component: 'dialogs/invite-collaborators'
        });
      },

      /**
       * Set the filter string to filter the table results
       * @param {Event} event Coming from the collaborator filter input
       */
      setStringFilter: _.debounce(function(event) {
        var value = event.target.value;
        flux.actions('dashboard').filterCollaboratorsByString(value);
        Vue.nextTick(function() {
          // wait until next tick to replace the url this allows
          // any filtered experiments to be deselected
          flux.actions('dashboard').replaceUrl();
        });
      }, 200),

      clearFilters: function() {
        flux.actions('dashboard').resetCollaboratorFilters();
        Vue.nextTick(function() {
          // wait until next tick to replace the url this allows
          // any filtered experiments to be deselected
          flux.actions('dashboard').replaceUrl();
        });
      },
    },
    created: function() {
      this.selectedCollaborators = [];
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        collaborators: getDashboardFilteredCollaborators,
        selectedCollaborators: getDashboardSelectedCollaborators,
        filterString: ['dashboard/tableFilters', function(filterStore) {
          return filterStore.getFilters('collaborators').string;
        }],
      });

      var tableId = 'dashboard-collaborators';
      if (!flux.store('sortableTable').isSorted(tableId)) {
        flux.actions('sortableTable').sortTable({
          tableId: tableId,
          sortBy: [{ field: 'role_name', type: 'string' }]
        });
      }
    },
  };
});


define('text!components/dashboard/integrations/integrations_tab.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group">\n  <div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n    <div class="lego-pane lego-pane--flex-1 lego-pane--scroll-y soft-double--top" v-loading="dashboard.integrations">\n      <table class="lego-table lego-table--dashboard" id="dashboard-integrations">\n        <thead>\n          <tr>\n            <th class="nowrap">\n              Name\n            </th>\n            <th class="nowrap">\n              Category\n            </th>\n            <th class="nowrap">\n              Usage\n            </th>\n            <th class="nowrap cell-collapse">\n              Status\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-repeat="integration: integrations"\n            v-component="integration-table-row">\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n  <div class="lego-pane lego-data-sidebar lego-pane--flex" v-component="integration-sidebar"></div>\n</div>\n';});


define('text!components/dashboard/integrations/integration_table_row.html',[],function () { return '<tr v-on="click: selectIntegration($event, integration)"\n  v-class="lego-table-row--active: isSelected" v-loading-entity="integration.id"\n  entity="integrations" spinner-size="small" data-table-row-id="[[ integration.id ]]">\n\n  <td>\n    <b>[[ integration.masterLabel ]]</b>\n  </td>\n\n  <td>\n    [[ integration.categories | join ]]\n  </td>\n\n  <td>\n    <span v-if="integration.projectLevelData.enabled">[[ integration.projectLevelData.usageCount ]] [[ integration.projectLevelData.usageCount | pluralize experiment ]]</span>\n    <span v-if="!integration.projectLevelData.enabled">--</span>\n  </td>\n\n  <td>\n    <b v-if="integration.status === \'ON\'" class="good-news">[[ integration.status ]]</b>\n    <span v-if="integration.status !== \'ON\'" class="muted">[[ integration.status ]]</span>\n  </td>\n</tr>\n';});

/**
 * Integration Table Row on Dashboard
 *
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('components/dashboard/integrations/integration_table_row',['require','text!components/dashboard/integrations/integration_table_row.html','flux'],function(require) {
  var tmpl = require('text!components/dashboard/integrations/integration_table_row.html');
  var flux = require('flux');

  return {
    template: tmpl,

    replace: true,

    data: {
      integration: {},
      selectedIntegrationId: ''
    },

    computed: {
      isSelected: function() {
        return this.selectedIntegrationId === this.integration.id;
      }
    },

    methods: {
      /**
       * @param {Event} event
       * @param {Object} integration
       */
      selectIntegration: function(event, integration) {
        flux.actions('dashboard').selectItem('integrations', integration);
      }
    },

    ready: function() {
      flux.bindVueValues(this, {
        selectedIntegrationId: ['dashboard/selectedItems', function(selectedItemStore) {
          return selectedItemStore.getSelectedIds('integrations')[0];
        }]
      });
    }
  };
});


define('text!components/dashboard/integrations/integration_sidebar.html',[],function () { return '<ul class="accordion" v-accordion>\n  <li class="accordion__item accordion__item--active"  v-class="accordion__item--empty : !integrationSelected">\n    <a class="accordion__link" href="#">Integration Details</a>\n    <div class="accordion__content-wrap">\n      <div class="accordion__content" v-show="!integrationSelected">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large"><use xlink:href="#integrations"></use></svg>\n          <div>Select an Integration to manage.</div>\n        </div>\n      </div>\n\n      <div class="accordion__content" v-show="integrationSelected">\n        <ul class="lego-sections">\n          <li class="lego-sections__item" v-if="!canUseIntegration">\n            <div class="lego-attention text--center">\n              Your plan does not include this Integration.\n            </div>\n          </li>\n          <li class="lego-sections__item">\n            <div class="lego-media">\n              <div class="[[ \'lego-media__img integration-logo integration-logo-item-\' + integration.id ]]"></div>\n              <div class="lego-media__body">\n                <h3 class="push-half--bottom soft-triple--top">[[ integration.masterLabel ]]</h3>\n              </div>\n            </div>\n          </li>\n          <li class="lego-sections__item">\n            <h6>Description</h6>\n            <p>[[ integration.projectLevelData.description ]] <a href="[[ integration.projectLevelData.generalHelp.kbLink ]]" target="_blank">Learn more.</a></p>\n          </li>\n          <li class="lego-sections__item" v-if="!integration.projectLevelData.onOffable">\n            <p>This integration is supported by [[ integration.masterLabel ]]. To use this integration, please visit the [[ integration.masterLabel ]] integration support page.</p>\n            <button class="lego-button lego-button--brand" v-on="click: openLearnMorePage">Learn more</button>\n          </li>\n          <li class="lego-sections__item" v-if="!canUseIntegration">\n            <button class="lego-button lego-button--brand" v-on="click: openUpgradePlanPage">Upgrade Plan</button>\n          </li>\n          <li class="lego-sections__item" v-if="showOnOffButtons">\n            <div class="lego-button-group">\n              <button class="lego-button" v-class="lego-button--brand: integration.projectLevelData.enabled" v-on="click: turnOnIntegration">On</button>\n              <button class="lego-button" v-class="lego-button--brand: !integration.projectLevelData.enabled" v-on="click: turnOffIntegration">Off</button>\n            </div>\n          </li>\n          <li class="lego-sections__item push-quad--top" v-if="showSettingsForm">\n            <form id="integration-settings-form">\n              <label class="lego-label lego-label--rule">\n                <div class="flex">\n                  <div class="flex-1">Settings</div>\n                  <a href="javascript:void(0)" class="anchor--right" v-show="!inEditMode" v-on="click: editSettings">Edit</a>\n                </div>\n              </label>\n              <fieldset>\n                <ul class="lego-form-fields">\n                  <li v-repeat="fieldConfig: integration.projectLevelData.fields"\n                      v-component="integration-form-field"\n                      v-with="settings: integration.projectLevelData.settings,\n                              inEditMode: inEditMode,\n                              errorMessages: errorMessages"\n                      class="lego-form-field__item">\n                  </li>\n                </ul>\n              </fieldset>\n              <p v-if="integration.projectLevelData.settingsHelp">\n                [[ integration.projectLevelData.settingsHelp.message ]]\n                <a v-if="integration.projectLevelData.settingsHelp.kbLink" href="[[ integration.projectLevelData.settingsHelp.kbLink ]]" target="_blank">click here.</a>\n              </p>\n              <div class="lego-form__footer lego-button-row lego-button-row--left" v-show="inEditMode">\n                <button class="lego-button lego-button--brand" v-on="click: saveSettings">Save</button>\n                <button class="lego-button" v-show="hasAllRequiredProjectLevelSettings" v-on="click: cancelEditSettings">Cancel</button>\n              </div>\n            </form>\n          </li>\n          <li v-show="integration.experimentLevelData.onOffable && integration.projectLevelData.enabled && hasAllRequiredProjectLevelSettings">\n            <div class="lego-attention lego-attention--good-news">\n              <p>\n                This integration is now enabled. <br/>\n                Go to the editor to customize settings for each experiment.\n              </p>\n            </div>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </li>\n  <li class="accordion__item">\n    <a class="accordion__link" href="#">Help</a>\n    <div class="accordion__content-wrap">\n      <div class="accordion__content">\n        <h3>What are Integrations?</h3>\n        <p>Optimizely integrates with other best-of-breed platforms to enhance your experiments.</p>\n        <ul class="lego-list lego-list--bullet">\n          <li>Find out more in our Knowledge Base - <a href="https://help.optimizely.com/hc/en-us/sections/200007975" target="_blank">Learn more</a></li>\n          <li>Google Analytics Integration - <a href="https://help.optimizely.com/hc/en-us/articles/200039995" target="_blank">Learn more</a></li>\n          <li>Meet Optimizelys Technology Partners - <a href="https://www.optimizely.com/partners/technology/" target="_blank">Learn more</a></li>\n        </ul>\n\n        <h3>What integrations are available?</h3>\n        <ul class="lego-list lego-list--bullet">\n          <li><b>Analytics integrations</b> - See the impact of Optimizely experiments on common analytics data like visit duration and bounce rate.</li>\n          <li><b>Heatmap integrations</b> - See the impact of Optimizely experiments on visitor engagement based on where they click.</li>\n          <li><b>Audience integrations</b> - Create custom Optimizely Audiences directly from a third-party tool, so you can target and personalize experiments. (May require some manual setup)</li>\n          <li><b>Call tracking integrations</b> - Track phone calls as experiment goals. (May require some manual setup)</li>\n        </ul>\n      </div>\n    </div>\n  </li>\n</ul>\n';});

/**
 * Integration Settings Validation Service
 * The centralized place to define form validation logic for every editable integration in the Integration Tab.
 *
 * TODO(peng-wen): import each integration's JS module via require() when integration module system is in place
 *
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('services/integration_settings_validation',[],function() {
  var REQUIRED_FIELD_MESSAGE = 'This field is required.';

  /**
   * Instance of this type represents a validation error for a set of integration settings
   * @param messages an object containing field-level info on why the validation fails
   * @constructor
   */
  function IntegrationSettingValidationError(messages) {
    this.messages = messages;
  }

  /**
   * Validate settings for an integration
   *
   * @param settings an object containing settings in name / value pairs collected from an HTML form
   *        e.g. {
   *          at_internet_acct_no: 123,
   *          at_internet_log_server_url: 'http://www.at_internet.com/log',
   *          enable_for_new_experiments: 'on'
   *        }
   * @returns Deferred
   */
  var at_internet = function validateAtInternetSettings(settings) {
    // extract settings
    var accountNumber = settings['at_internet_acct_no'];
    var logServerUrl = settings['at_internet_log_server_url'];
    var deferred = $.Deferred();

    // validation
    if (accountNumber && logServerUrl && !_.isNaN(parseInt(accountNumber))) {
      deferred.resolve();
    } else {
      var messages = {};

      if (_.isNaN(parseInt(accountNumber))) {
        messages['at_internet_acct_no'] = 'Must be a number.';
      }

      if (!accountNumber) {
        messages['at_internet_acct_no'] = REQUIRED_FIELD_MESSAGE;
      }

      if (!logServerUrl) {
        messages['at_internet_log_server_url'] = REQUIRED_FIELD_MESSAGE;
      }

      deferred.reject(new IntegrationSettingValidationError(messages));
    }

    return deferred;
  };

  var crazyegg = function validateCrazyEggSettings(settings) {
    // extract settings
    var apiKey = settings['crazyegg_api_key'];
    var secretKey = settings['crazyegg_secret_key'];

    // validation
    if (apiKey && secretKey) {
      var deferred = $.ajax(sprintf("/crazyegg/verify_api_key?api_key=%s&secret_key=%s", apiKey, secretKey),
        {type: 'GET'});

      // TODO(peng-wen): fix the endpoint 'crazyegg/verify_api_key'.
      // That endpoint currently always returns HTTP 200 no matter the validation succeeds or not.
      // Should return an error status code in case of validation failure so that
      // the error handling can go through Deferred's fail handler properly.
      return deferred.pipe(function(result) {
        if (result.response && result.response.indexOf('error') > -1) {
          var messages = {};
          messages['crazyegg_api_key'] = 'Bad API Key and Secret Key.';
          messages['crazyegg_secret_key'] = 'Bad API Key and Secret Key.';
          return $.Deferred().reject(new IntegrationSettingValidationError(messages));
        }
      });
    } else {
      var messages = {};
      if (!apiKey) {
        messages['crazyegg_api_key'] = REQUIRED_FIELD_MESSAGE;
      }

      if (!secretKey) {
        messages['crazyegg_secret_key'] = REQUIRED_FIELD_MESSAGE;
      }

      return $.Deferred().reject(new IntegrationSettingValidationError(messages));
    }
  };

  return {
    at_internet: at_internet,
    crazyegg: crazyegg,
  };
});

/**
 * Function getter to take getCurrentProjectIntegrations + dashboard/selectedItems stores
 * and return the selected integration for that project
 */
define('flux/getters/dashboard/selected_integration',['flux/getters/current_project/integrations'],function() {
  var getCurrentProjectIntegrations = require('flux/getters/current_project/integrations');

  return [
    getCurrentProjectIntegrations,
    'dashboard/selectedItems',
    function(integrations, selectedItemStore) {
      var selectedIntegrationId = selectedItemStore.getSelectedIds('integrations')[0];

      return _.find(integrations, {
        id: selectedIntegrationId
      }) || {};
    }
  ];
});


define('text!components/dashboard/integrations/integration_form_field.html',[],function () { return '<ul v-class="lego-input-list: !showLabelAtFront,\n             lego-form-bad-news: hasError">\n  <li>\n    <label v-show="showLabelAtFront" class="lego-label">\n      [[ fieldConfig.label ]]<span v-show="fieldConfig.required"> (required)</span>\n    </label>\n\n    <input v-if="fieldConfig.inputType === \'text\'" v-model="fieldValue" v-attr="disabled: !inEditMode"\n           class="lego-text-input" type="[[ fieldConfig.inputType ]]" name="[[ fieldConfig.name ]]"\n           placeholder="[[ fieldConfig.placeholderText ]]"/>\n\n    <input v-if="fieldConfig.inputType === \'checkbox\'"\n           v-attr="checked: fieldValue === \'on\',\n                   disabled: !inEditMode"\n           value="on" type="[[ fieldConfig.inputType ]]" name="[[ fieldConfig.name ]]"/>\n\n    <label v-show="!showLabelAtFront" class="lego-label">\n      [[ fieldConfig.label ]]<span v-show="fieldConfig.required"> (required)</span>\n    </label>\n\n    <div v-if="hasError" class="lego-form-note lego-form-note--bad-news">[[ errorMessages[fieldConfig.name] ]]</div>\n  </li>\n</ul>\n';});

/**
 * Integration Form Field Component
 * This component is used to render an integration setting field based on fieldConfig
 *
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('components/dashboard/integrations/integration_form_field',['require','text!components/dashboard/integrations/integration_form_field.html'],function(require) {
  var tmpl = require('text!components/dashboard/integrations/integration_form_field.html');

  return {
    template: tmpl,

    data: {
      errorMessages: {},
      fieldConfig: {},
      fieldValue: '',
      inEditMode: false,
      settings: null,
    },

    computed: {
      showLabelAtFront: function() {
        // For checkbox the label shall be displayed after the form control
        return this.fieldConfig.inputType !== 'checkbox';
      },

      hasError: function() {
        return !!this.errorMessages[this.fieldConfig.name];
      }
    },

    ready: function() {
      // Populate field with saved value
      this.fieldValue = this.settings ? this.settings[this.fieldConfig.name] : '';
    }
  }
});

/**
 * Integration Sidebar Component
 *
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('components/dashboard/integrations/integration_sidebar',['require','text!components/dashboard/integrations/integration_sidebar.html','flux','services/confirm','services/integration_settings_validation','flux/getters/current_project','flux/getters/dashboard/selected_integration','components/dashboard/integrations/integration_form_field'],function(require) {
  var tmpl = require('text!components/dashboard/integrations/integration_sidebar.html');
  var flux = require('flux');
  var confirm = require('services/confirm');

  var integrationSettingsValidation = require('services/integration_settings_validation');

  var getCurrentProject = require('flux/getters/current_project');
  var getDashboardSelectedIntegration = require('flux/getters/dashboard/selected_integration');

  /**
   * Helper function to compose the confirmation message used in "Turn off Integration" dialog
   * @param integration the integration to be turned off
   * @returns {string}
   * @private
   */
  var _getIntegrationTurnOffConfirmMessage = function(integration) {
    var isPlural = integration.projectLevelData.usageCount != 1;
    var usageText = (isPlural ? 'are ' : 'is ') +
      integration.projectLevelData.usageCount +
      ' experiment' + (isPlural ? 's' : '');

    return tr('There {0} using this integration. Make sure this integration is not turned on for any experiment.',
              usageText);
  };

  return {
    components: {
      'integration-form-field': require('components/dashboard/integrations/integration_form_field')
    },

    template: tmpl,

    data: {
      errorMessages: {},
      inEditMode: false
    },

    computed: {
      /**
       * whether the user role has the permission to configure integration for this project
       * @returns {boolean}
       */
      canEditIntegrationForProject: function() {
        return flux.actions('permissions').canEditIntegrationForProject(this.currentProject);
      },

      /**
       * whether the account plan type includes the feature permission to use this integration
       * @returns {boolean}
       */
      canUseIntegration: function() {
        this.integration.minPlanLevel;
        this.currentProject;
        this.integration.id;

        // TODO(peng-wen): define integration features in the new plan models
        // return this.integration.minPlanLevel === 'bronze' ||
        //   flux.actions('permissions').canUseIntegration(this.currentProject, this.integration.id);
        return true;
      },

      /**
       * whether the user has selected an integration to show in this sidebar or not
       * @returns {boolean}
       */
      integrationSelected: function() {
        return !!this.integration.id;
      },

      /**
       * Whether the on/off button shall be displayed
       * @returns {boolean}
       */
      showOnOffButtons: function() {
        this.integration.projectLevelData;
        this.canUseIntegration;
        this.canEditIntegrationForProject;

        return this.integration.projectLevelData &&
          this.integration.projectLevelData.onOffable &&
          this.canUseIntegration &&
          this.canEditIntegrationForProject;
      },

      /**
       * Whether the settings form shall be displayed
       * @returns {boolean}
       */
      showSettingsForm: function() {
        this.integration.projectLevelData;
        this.canUseIntegration;
        this.canEditIntegrationForProject;

        return this.integration.projectLevelData &&
          this.integration.projectLevelData.enabled &&
          this.integration.projectLevelData.fields.length > 0 &&
          this.canUseIntegration &&
          this.canEditIntegrationForProject;
      },

      /**
       * Whether all required project-level settings of this integration are provided
       * @returns {boolean}
       */
      hasAllRequiredProjectLevelSettings: function() {
        var projectLevelData = this.integration.projectLevelData || {};
        var fields = projectLevelData.fields || [];
        var settings = projectLevelData.settings || {};

        return fields.every(function(fieldConfig) {
          return !fieldConfig.required || settings[fieldConfig.name];
        });
      }
    },

    methods: {
      turnOnIntegration: function() {
        if (this.integration.projectLevelData.enabled) {
          return;
        }

        this.integration.projectLevelData.enabled = true;

        if (this.hasAllRequiredProjectLevelSettings) {
          var updateSettingsForProjectDeferred = flux.actions('integration').updateSettingsForProject(
            this.currentProject.id,
            this.integration.id,
            true,
            this.integration.projectLevelData.settings
          );
          flux.actions('loading').entityUpdated('integrations', this.integration, updateSettingsForProjectDeferred);
        } else {
          // enable edit mode so that user can input required settings immediately
          this.inEditMode = true;
        }
      },

      turnOffIntegration: function() {
        if (!this.integration.projectLevelData.enabled) {
          return;
        }

        if (this.integration.projectLevelData.usageCount > 0) {
          confirm.confirm({
            title: tr('Turn off Integration'),
            message: _getIntegrationTurnOffConfirmMessage(this.integration),
            confirmText: tr('OK')
          });
        } else {
          this.integration.projectLevelData.enabled = false;

          if (this.hasAllRequiredProjectLevelSettings) {
            var updateSettingsForProjectDeferred = flux.actions('integration').updateSettingsForProject(
              this.currentProject.id,
              this.integration.id,
              false,
              this.integration.projectLevelData.settings
            );
            flux.actions('loading').entityUpdated('integrations', this.integration, updateSettingsForProjectDeferred);
          }
        }
      },

      saveSettings: function(event) {
        event.preventDefault();

        // collect form input values
        var formSettings = $('#integration-settings-form').serializeArray();
        var projectIntegrationSettings = {};

        formSettings.forEach(function(setting) {
          projectIntegrationSettings[setting.name] = setting.value;
        });

        if (integrationSettingsValidation[this.integration.id]) {
          // validate the settings
          var onValidationSuccess = function() {
            this.errorMessages = {};

            var updateSettingsForProjectDeferred = flux.actions('integration')
              .updateSettingsForProject(
                this.currentProject.id,
                this.integration.id,
                this.integration.projectLevelData.enabled,
                projectIntegrationSettings)
              .then(function() {
                this.inEditMode = false;
              }.bind(this));

            flux.actions('loading').entityUpdated('integrations', this.integration, updateSettingsForProjectDeferred);
          }.bind(this);

          var onValidationFailure = function(e) {
            this.errorMessages = e.messages;
          }.bind(this);

          integrationSettingsValidation[this.integration.id](projectIntegrationSettings)
            .then(onValidationSuccess, onValidationFailure);
        } else {
          var updateSettingsForProjectDeferred = flux.actions('integration')
            .updateSettingsForProject(
              this.currentProject.id,
              this.integration.id,
              this.integration.projectLevelData.enabled,
              projectIntegrationSettings)
            .then(function() {
              this.inEditMode = false;
            }.bind(this));

          flux.actions('loading').entityUpdated('integrations', this.integration, updateSettingsForProjectDeferred);
        }
      },

      editSettings: function() {
        this.inEditMode = true;
      },

      cancelEditSettings: function(event) {
        event.preventDefault();

        // force restoring back existing settings
        this.integration = _.cloneDeep(this.integration);

        this.errorMessages = {};
        this.inEditMode = false;
      },

      openLearnMorePage: function() {
        window.open(this.integration.partnerDirectoryUrl);
      },

      openUpgradePlanPage: function() {
        window.open('/pricing');
      }
    },

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        integration: getDashboardSelectedIntegration
      });
    },
  }
});

/**
 * Integrations tab view component
 *
 * @author Peng-Wen Chen (peng-wen@optimizely.com)
 */
define('components/dashboard/integrations/integrations_tab',['require','flux','text!components/dashboard/integrations/integrations_tab.html','flux/getters/current_project/integrations','components/dashboard/integrations/integration_table_row','components/dashboard/integrations/integration_sidebar'],function(require) {
  var flux = require('flux');
  var tmpl = require('text!components/dashboard/integrations/integrations_tab.html');
  var getCurrentProjectIntegrations = require('flux/getters/current_project/integrations');

  var STATUS_TEXTS = {
    ON: 'ON',
    OFF: 'OFF',
    UNAVAILABLE: '--'
  };

  return {
    components: {
      'integration-table-row': require('components/dashboard/integrations/integration_table_row'),
      'integration-sidebar': require('components/dashboard/integrations/integration_sidebar')
    },

    template: tmpl,

    replace: true,

    created: function() {
      flux.bindVueValues(this, {
        integrations: [getCurrentProjectIntegrations, function(integrations) {
          return integrations.map(function(integration) {
            // Add project-level status text which will be rendered as a column in integrations table
            if (integration.projectLevelData.onOffable) {
              integration.status = integration.projectLevelData.enabled ? STATUS_TEXTS.ON : STATUS_TEXTS.OFF;
            } else {
              integration.status = STATUS_TEXTS.UNAVAILABLE;
            }

            return integration;
          });
        }]
      });
    }
  };
});


define('text!components/dashboard/settings/settings_tab.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n  <!-- Sub Tabs -->\n  <div class="lego-tabs lego-tabs--small lego-tabs--sub push-half--top" data-test-section="settings-subtabs">\n    <ul class="lego-tabs-nav soft-double--left">\n      <li class="lego-tabs-nav__item"\n        v-on="click: switchSubtab(\'implementation\')"\n        v-class="tab-active: activeSubtab === \'implementation\'">\n        Implementation\n      </li>\n      <li class="lego-tabs-nav__item"\n        v-if="showLabs"\n        v-on="click: switchSubtab(\'labs\')"\n        v-class="tab-active: activeSubtab === \'labs\'">\n        Labs\n      </li>\n    </ul>\n  </div>\n  <div v-view="activeSubtab"></div>\n</div>\n';});

define('flux/getters/current_project/enabled_labs',['require','flux/getters/current_project'],function(require) {
  var getCurrentProject = require('flux/getters/current_project');

  return [
    getCurrentProject,
    'dashboard/labsData',
    function(currentProject, labsDataStore) {
      return labsDataStore.getData(currentProject.project_permissions);
    }
  ]
})
;

define('text!components/dashboard/settings/implementation/implementation_tab.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group" data-test-section="settings-tab">\n  <div class="lego-pane lego-pane--flex-1 lego-pane--scroll-y">\n    <div class="soft-double max-width--large">\n      <div class="lego-form__header">\n        <div class="lego-form__title">Snippet Implementation</div>\n      </div>\n      <div v-component="project-code-new-dashboard" v-loading="projectCode"></div>\n      <div v-if="isWebProject">\n        <form v-on="submit: saveSettings"\n          v-loading-entity="currentProject.id" entity="projects">\n          <div class="lego-form__header">\n            <div class="lego-form__title">Advanced Configuration</div>\n          </div>\n          <fieldset data-test-section="library-settings">\n            <div class="lego-label">jQuery Settings</div>\n            <ol class="lego-form-fields">\n              <li class="lego-form-field__item">\n                <ul class="lego-input-list">\n                  <li>\n                    <input id="none" type="radio" value="none"\n                      v-model="settings.library">\n                    <label for="none">\n                      Do not include jQuery in project code\n                    </label>\n                  </li>\n                  <li>\n                    <input id="jquery-1.6.4-trim" type="radio" value="jquery-1.6.4-trim"\n                      v-model="settings.library">\n                    <label for="jquery-1.6.4-trim">\n                      Include trimmed jQuery in project code (recommended)\n                    </label>\n                  </li>\n                  <li>\n                    <input id="jquery-1.6.4-full" type="radio" value="jquery-1.6.4-full"\n                      v-model="settings.library">\n                    <label for="jquery-1.6.4-full">\n                      Include full jQuery in project code\n                    </label>\n                  </li>\n                </ul>\n              </li>\n            </ol>\n          </fieldset>\n          <fieldset data-test-section="advanced-settings">\n            <div class="lego-label">Privacy Settings</div>\n            <ol class="lego-form-fields">\n              <li class="lego-form-field__item">\n                <ul class="lego-input-list">\n                  <li>\n                    <input id="exclude_names" type="checkbox"\n                      v-model="settings.exclude_names">\n                    <label for="exclude_names">\n                      Mask descriptive names in project code and third-party integrations\n                    </label>\n                  </li>\n                  <li>\n                    <input id="disable_force_variation" type="checkbox"\n                      v-model="disableForceVariation">\n                    <label for="disable_force_variation">\n                      Disable the force variation parameter\n                    </label>\n                  </li>\n                  <li>\n                    <input id="exclude_disabled_experiments" type="checkbox"\n                      v-model="settings.exclude_disabled_experiments">\n                    <label for="exclude_disabled_experiments">\n                      Exclude draft and paused experiments\n                    </label>\n                  </li>\n                  <li>\n                    <input id="ip_anon" type="checkbox"\n                      v-model="settings.ip_anonymization">\n                    <label for="ip_anon">\n                      Anonymize IP addresses for this project and remove the last octet of IP addresses prior to logging\n                    </label>\n                  </li>\n                  <li>\n                    <label for="ip_filter">\n                      Exclude traffic from these IP addresses:\n                    </label>\n                    <input id="ip_filter" type="text" class="lego-text-input push--top"\n                      v-model="settings.ip_filter"/>\n                    <div class="lego-form-note">\n                      Filter Pattern (regular expression, max 500 characters)\n                    </div>\n                    <div class="lego-form-note lego-form-note--error"\n                      v-show="!isRegexValid">\n                      Invalid regular expression.\n                    </div>\n                    <div class="lego-form-note muted"\n                      v-show="settings.ip_anonymization">\n                      If you also anonymize IP addresses, your regular expression should also match IP addresses without their last octet.\n                    </div>\n                  </li>\n                </ul>\n              </li>\n            </ol>\n          </fieldset>\n          <fieldset data-test-section="significance-settings" v-if="canViewStatisticalSignificance">\n            <div class="lego-label">Statistical Significance Setting</div>\n            <ol class="lego-form-fields">\n              <li class="lego-form-field__item">\n                <ul class="lego-input-list">\n                  <li>\n                    <label for="statistical_significance">\n                      Winning varaitions will be declared after reaching this statistical significance threshold <b>(95% is recommended)</b>:\n                    </label>\n                    <div class="push--top">\n                      <input id="statistical_significance"\n                        class="lego-text-input width-50"\n                        type="number" min="70" max="100"\n                        v-model="statisticalSignificance"></input><span> %</span>\n                      <span>Statistical Significance with an </span>\n                      <span v-style="color: \'hsl(0, 50%,\' + (Math.log(errorRate) * 15) + \'%)\'">\n                        <b>error rate of <span v-text="errorRate">5</span>%</b>.\n                      </span>\n                      <span>This will apply to all experiments in this project.</span>\n                      <a href="https://help.optimizely.com/hc/en-us/articles/200039895-Chance-to-beat-baseline">\n                        Learn more\n                      </a>\n                    </div>\n                  </li>\n                </ul>\n              </li>\n            </ol>\n          </fieldset>\n          <p>Once you save these changes, please allow a few minutes for the new settings to take effect.</p>\n          <div class="lego-form__footer lego-button-row--left push-double--bottom">\n            <button type="button" class="lego-button"\n              v-lego-disabled="areSettingsClean || !canEditProject"\n              v-on="click: discardSettings">\n              Cancel\n            </button>\n            <button type="submit" class="lego-button lego-button--brand"\n              v-lego-disabled="!isRegexValid || areSettingsClean || !canEditProject"\n              data-test-section="save-button">\n              Save\n            </button>\n          </div>\n        </form>\n      </div>\n    </div>\n  </div>\n  <div class="lego-pane lego-data-sidebar lego-pane--flex"\n    v-component="implementation-sidebar">\n  </div>\n</div>\n';});


define('text!components/dashboard/project_code_new_dashboard.html',[],function () { return '<fieldset>\n  <ol class="lego-form-fields">\n    <li class="lego-form-field__item">\n      <table class="lego-table">\n        <tr>\n          <td>\n            <label class="lego-label"\n            for="platformSelect">Platform:</label>\n          </td>\n          <td>\n            <p class="display--inline-block"\n            v-if="projectPlatforms.length === 1">\n              [[ selectedDisplayName ]]\n            </p>\n            <select id="platformSelect"\n            v-model="selectedPlatform"\n            v-if="projectPlatforms.length > 1">\n              <option v-repeat="platform: projectPlatforms"\n              value="[[ platform.value ]]">\n                [[ platform.text ]]\n              </option>\n            </select>\n          </td>\n        </tr>\n        <tr v-show="selectedPlatform === \'web\'">\n          <td class="cell-collapse nowrap">\n            <p class="lego-label">Snippet Size:</p>\n          </td>\n          <td>\n            <div v-loading-show="projectCode">\n              updating...\n            </div>\n            <div v-loading-hide="projectCode">[[ webCodeFileSize ]]</div>\n          </td>\n        </tr>\n        <tr v-show="selectedPlatform === \'ios\'">\n          <td>\n            <div v-loading-show="projectiOSCode">\n              updating...\n            </div>\n          </td>\n        </tr>\n        <tr v-show="selectedPlatform === \'android\'">\n          <td>\n            <div v-loading-show="projectAndroidCode">\n              updating...\n            </div>\n          </td>\n        </tr>\n        <tr>\n          <td class="cell-collapse nowrap">\n            <p class="lego-label">Project ID:</p>\n          </td>\n          <td>[[ project.id ]]</td>\n        </tr>\n      </table>\n    </li>\n    <li class="lego-form-field__item">\n      <div class="lego-grid">\n        <div class="lego-grid__cell">\n          <input id="project-code" type="text" class="lego-text-input monospace"\n          value="[[ projectCode ]]"\n          data-test-section="snippet-code"\n          readonly />\n        </div>\n        <div class="push--left">\n          <button\n            class="lego-button"\n            data-clipboard-target="project-code"\n            v-component="copier">\n            <i class="fa fa-clipboard"></i>\n          </button>\n        </div>\n        <div class="push--left">\n          <button\n            class="lego-button"\n            v-on="click: showEmailDialog">\n            Email This Code\n          </button>\n        </div>\n      </div>\n      <div class="push--top" v-if="selectedPlatform === \'web\'">\n        <b>Copy the code and paste it immediately after your opening <code>&lt;head&gt;</code> tag.</b> Include this snippet on every page that should run this project\'s experiments or be tracked as a goal.\n      </div>\n      <div class="push--top" v-if="selectedPlatform === \'ios\'">\n        <p>1. <a href="http://developers.optimizely.com/ios/" target="_blank">Download</a> and install the SDK (<a href="http://developers.optimizely.com/ios/" target="_blank">instructions</a>).</p>\n        <p>2. Add this snippet in your app delegate at the beginning of <code>application:didFinishLaunchingWithOptions</code>.</p>\n      </div>\n      <div class="push--top" v-if="selectedPlatform === \'android\'">\n        <ol class="lego-list lego-list--numbered">\n          <li>\n            <p><a href="http://developers.optimizely.com/android/" title="Optimizely for Android documentation" target="_blank">Download and install the SDK</a>.</p>\n          </li>\n          <li>\n            <p>Create a new resource file: <code>res/raw/optimizely.json</code> with the following contents:</p>\n            <div class="lego-code-copy">\n              <pre class="lego-pre"><code id="project-config-android">[[ projectConfig ]]</code></pre>\n              <button data-clipboard-target="project-config-android"\n                      v-component="copier"\n                      class="lego-button"\n                      v-poptip\n                      data-dir="top-center"\n                      data-content="Copy">\n                <svg class="lego-icon">\n                  <use xlink:href="#clipboard"></use>\n                </svg>\n              </button>\n            </div>\n          </li>\n          <li>\n            <p>Add the following in your main activity at the end of <code>protected void onCreate(Bundle savedInstanceState)</code>:</p>\n            <div class="lego-code-copy">\n              <pre class="lego-pre"><code id="project-code-android">[[ projectCode ]]</code></pre>\n              <button data-clipboard-target="project-code-android"\n                      v-component="copier"\n                      class="lego-button"\n                      v-poptip\n                      data-dir="top-center"\n                      data-content="Copy">\n                <svg class="lego-icon">\n                  <use xlink:href="#clipboard"></use>\n                </svg>\n              </button>\n            </div>\n          </li>\n        </ol>\n      </div>\n    </li>\n  </ol>\n</fieldset>\n';});

/**
 * Library to help with manipulating Vue modules
 *
 * @author Sam Jackson (sam@optimizely.com)
 */
define('utils/vue_helpers',['require','lodash'],function(require) {

  var _ = require('lodash');

  /**
   * Extend Vue Component definitions
   *
   * @param   originalComponent    {Object} Original component definition
   * @param   instantiationOptions {Object} Object with which to augment the parent component
   * @returns {Object}
   */
  function extendComponent(originalComponent, instantiationOptions) {
    var component = originalComponent || {};

    // When calling Vue.extend({...}); the original object supplied is modified, and
    // data is mapped to defaultData. For consistencies sake, reset it if we see this has
    // happened so that we can supply the "data" parameter as expected
    if (component.defaultData) {
      component = _.cloneDeep(component);
      component.data = component.defaultData;
      delete component.defaultData;
    }
    return $.extend(true, {}, component, instantiationOptions);
  }

  return {
    extendComponent: extendComponent
  };
});


define('text!components/project_code.html',[],function () { return '<div class="projectcode-dropdown"\n  v-if="!loading">\n\n  <label for="platformSelect">Platform:</label>\n  <p v-if="projectPlatforms.length === 1">\n    [[ selectedDisplayName ]]\n  </p>\n  <select id="platformSelect"\n  v-model="selectedPlatform"\n  v-if="projectPlatforms.length > 1">\n    <option v-repeat="platform: projectPlatforms"\n    value="[[ platform.value ]]">\n      [[ platform.text ]]\n    </option>\n  </select>\n\n\n  <div id="projectcode-conatiner">\n\n    <div v-show="selectedPlatform === \'web\'">\n      <p>Include this snippet\n  on every page that should run this project\'s experiments or be tracked as\n      a goal.</p>\n      <p>\n        <strong>Copy the code and paste it immediately after your opening\n        <code>&lt;head&gt;</code> tag.</strong>\n      </p>\n      <pre id="project-code-web"\n      class="code-block"><code>[[ projectCode ]]</code></pre>\n      <ul class="button-group">\n        <li>\n          <button\n          class="secondary-button small"\n          data-clipboard-target="project-code-web"\n          data-clipboard-successText="Copied!"\n          v-component="copier">\n            Copy to clipboard\n          </button>\n        </li>\n        <li>\n          <button\n          class="secondary-button small"\n          v-on="click: showEmailDialog">\n            Send via email\n          </button>\n        </li>\n      </ul>\n      <p>Your Project ID is <code>[[ project.id ]]</code></p>\n      <p>Snippet File Size: [[ webCodeFileSize ]]</p>\n  </div>\n\n\n  <div v-show="selectedPlatform === \'ios\'">\n    <p>1. <a href="http://developers.optimizely.com/ios/" target="_blank">Download</a> and install the SDK (<a href="http://developers.optimizely.com/ios/" target="_blank">instructions</a>).</p>\n    <p>2. Add the following in your app delegate at the beginning of <code>application:didFinishLaunchingWithOptions:</code></p>\n    <pre id="project-code-ios"\n    class="code-block"><code>[[ projectCode ]]</code></pre>\n    <ul class="button-group">\n      <li>\n        <button\n        class="secondary-button small"\n        data-clipboard-target="project-code-ios"\n        data-clipboard-successText="Copied!"\n        v-component="copier">\n          Copy to clipboard\n        </button>\n      </li>\n      <li>\n        <button\n        class="secondary-button small"\n        v-on="click: showEmailDialog">\n          Send via email\n        </button>\n      </li>\n    </ul>\n    <p>Your Project ID is <code>[[ project.id ]]</code></p>\n  </div>\n\n  <div v-show="selectedPlatform === \'android\'">\n    <p>1. <a href="http://developers.optimizely.com/android/" title="Optimizely for Android documentation" target="_blank">Download and install the SDK</a>.</p>\n    <p>2. Create a new resource file: <code>res/raw/optimizely.json</code> with the following contents:</p>\n    <pre id="project-config-android"\n         class="code-block"><code>[[ projectConfig ]]</code></pre>\n    <button class="secondary-button small"\n            data-clipboard-target="project-config-android"\n            data-clipboard-successText="Copied!"\n            v-component="copier">\n      Copy to clipboard\n    </button>\n    <p>3. Add the following in your main activity at the end of <code>protected void onCreate(Bundle savedInstanceState)</code>:</p>\n    <pre id="project-code-android"\n         class="code-block"><code>[[ projectCode ]]</code></pre>\n    <button class="secondary-button small"\n            data-clipboard-target="project-code-android"\n            data-clipboard-successText="Copied!"\n            v-component="copier">\n      Copy to clipboard\n    </button>\n    </ul>\n    <p>Your Project ID is <code>[[ project.id ]]</code></p>\n</div>\n\n<div v-if="loading">\n  Loading...\n</div>\n';});

/**
 * Project Code component
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('components/project_code',['require','exports','module','lodash','flux','text!components/project_code.html','services/project','app'],function(require, module, exports) {
  var _ = require('lodash');
  var flux = require('flux');
  var tmpl = require('text!components/project_code.html');
  var projectService = require('services/project');
  var app = require('app');

  return {
    template: tmpl,
    data: {
      project: {},
      loading: true,
      selectedPlatform: 'web',
      supportedPlatforms: [
        {
          text: tr('Web'),
          value: 'web'
        },
        {
          text: 'iOS',
          value: 'ios'
        },
        {
          text: 'Android',
          value: 'android'
        }
      ]
    },
    computed: {
      preferredPlatform: function() {
        if (!this.project.project_platforms) {
          return false;
        }
        return this.project.project_platforms[0];
      },

      projectPlatforms: function() {
        if (!this.project.project_platforms) {
          return [];
        }
        return this.project.project_platforms.map(function(platform) {
          return _.find(this.supportedPlatforms, { value: platform });
        }, this);
      },

      /**
       * Return formatted file size as string
       *
       * @return {String} Formatted string i.e. '1 KB'
       */
      webCodeFileSize: function() {
        if (!this.project.js_file_size) {
          return 0;
        }
        return $.formatFileSize(this.project.js_file_size, 1);
      },

      /**
       * Return the code snippet for the platform selected
       * @return {String} Code snippet for the platform
       */
      projectCode: function() {
        // Reference property to bind to computed
        this.selectedPlatform;
        if (_.isEmpty(this.project)) {
          return '';
        }
        return projectService.projectCode(this.project, this.selectedPlatform);
      },

      /**
       * Return the configuration JSON snippet for the platform selected
       * @return {String} Configuration JSON snippet for the platform
       */
      projectConfig: function() {
        if (_.isEmpty(this.project) || !projectService.isAndroidProject(this.project)) {
          return '';
        }

        return projectService.androidProjectConfig(this.project.socket_token);
      },

      /**
       * Return the properly formatted display string for a given platform
       *
       * @param {String} platform The platform value usually lower cased
       * @return {String} The properly formatted display string
       */
      selectedDisplayName: function() {
        return _.find(this.supportedPlatforms, { value: this.selectedPlatform }).text;
      },
    },
    methods: {
      /**
       * Fetch the project that we are finding the code for and handle a loading semiphore
       * @param {Number} projectId The ProjectId
       */
      fetchProject: function (projectId) {
        // Get fields from legacy API
        projectService.fetchProject(projectId).then(function(project) {
          this.project = project;
          this.selectedPlatform = this.preferredPlatform;
          this.loading = false;
        }.bind(this));
      },
      showEmailDialog: function() {
        app.$broadcast('showDialog', {
          component: 'dialogs/send-code',
          data: {
            project: this.project
          }
        });
      }
    },
    created: function() {
      this._changeStream = flux.createChangeStream()
        .onStoreChange('currentProject', function(currentProjectStore) {
          var projectId = currentProjectStore.getId();
          if (projectId) {
            this.fetchProject(projectId);
          }
        }.bind(this))
        // force update to bind values to VM immediately
        .forceUpdate();
    },
    beforeDestroy: function() {
      this._changeStream.destroy();
    }
  };
});

/**
 * Project code component for the new dashboard
 *
 * @author Andrew Delikat
 */
define('components/dashboard/project_code_new_dashboard',['require','exports','module','text!components/dashboard/project_code_new_dashboard.html','flux','utils/vue_helpers','components/project_code','flux/getters/current_project'],function(require, exports, module) {
  var tmpl = require('text!components/dashboard/project_code_new_dashboard.html');
  var flux = require('flux');
  var vueHelpers = require('utils/vue_helpers');
  var projectCodeComponent = require('components/project_code');

  var getCurrentProject = require('flux/getters/current_project');

  return vueHelpers.extendComponent(projectCodeComponent, {
    template: tmpl,

    computed: {
      fileSize: function() {
        if (this.project && this.project.js_file_size) {
          return $.formatFileSize(this.project.js_file_size, 1)          
        }
      },
    },

    created: function() {
      flux.bindVueValues(this, {
        project: getCurrentProject,
      })
      this.selectedPlatform = this.preferredPlatform;
    },

    beforeDestroy: function() {
      // override base project_code method so this._changeStream.destroy() isnt called
      // TODO: fix this with Vue 0.11 mixin
    }
  });
});


define('text!components/dashboard/settings/implementation/implementation_sidebar.html',[],function () { return '<ul class="accordion" data-test-section="settings-sidebar">\n  <li class="accordion__item accordion__item--active">\n    <a class="accordion__link" href="#">Help With Settings</a>\n    <div class="accordion__content-wrap">\n      <div class="accordion__content">\n        <div v-if="isWebProject">\n          <h3>Settings</h3>\n          <h4>Snippet Implementation</h4>\n          <p><b>For Web Projects:</b> To implement Optimizely, paste a small snippet of code into the <head> tag of your site on all pages where you want to run an experiment or track a goal. Click the copy button to access your snippet or Email This Code to send it directly to your developer. <a href="https://help.optimizely.com/hc/en-us/articles/200040095" target="_blank">Learn more</a></p>\n\n          <p><b>For Mobile Projects:</b> To implement Optimizely, download and install the SDK, then add it to your app delegate at the beginning of application:didFinishLaunchingWithOptions. Click the copy button to access your snippet. <a href="http://developers.optimizely.com/ios/" target="_blank">Learn more</a></p>\n\n          <h4>JQuery Settings</h4>\n          <p>Optimizely uses jQuery to make variations to your site and thus requires a jQuery library to function. There are three jQuery settings available to you:</p>\n          <ul>\n          <ul class="lego-list lego-list--bullet">\n            <li><b>Do not include jQuery in project code:</b> This is used if you already have version 1.4.2 or later of jQuery on your site.</li>\n            <li><b>Include trimmed jQuery in project code (Default):</b> Optimizely will include a trimmed and lightweight version of JQuery to give you exactly what you need for Optimizely to work.</li>\n            <li><b>Include full jQuery in project code:</b> Use this if your require additional jQuery functionality (like .show() or.hide())</li>\n          </ul>\n          <p>If youre not including the default options, find out more in our Knowledge Base - <a href="https://help.optimizely.com/hc/en-us/articles/202480860#jquery_settings" target="_blank">Learn more</a></p>\n\n          <h4>Privacy Settings</h4>\n          <p>Optimizely contains data and functionality that make it easier to QA, debug, and integrate with other systems. If you prefer a higher level of privacy, you may restrict these functions (just note that this can affect your integrations and QA processes) - <a href="https://help.optimizely.com/hc/en-us/articles/202480860#masking_descriptive_names" target="_blank">Learn more</a></p>\n\n           <p><strong>Masking Descriptive Names:</strong> Optimizely includes the full names of experiments, variations, and other data in a <a href="http://developers.optimizely.com/javascript/#data-object">JavaScript Data Object</a> where third parties can read them. You can hide the names and replace them with numerical IDs, but this may impact third-party integrations that rely on these names.</p>\n\n          <p><strong>Force Variations:</strong> Optimizely provides a URL parameter to <a href="https://help.optimizely.com/hc/en-us/articles/200107480">force a specific variation to run</a>, which helps you test a variation and share it with collaborators but also allows third parties to link to your variations. Disabling this could impact other integrations that rely on variation links.</p>\n\n          <p><strong>Exclude Draft and Paused Experiments:</strong> By default, Optimizely includes the code for your draft and paused experiments on every page. This offers several benefits for QA. Excluding them will make your project code smaller but also disables forcing variations for your draft and paused experiments.</p>\n\n          <p><b>IP Addresses:</b> You can anonymize or exclude traffic from certain IP addresses from your experiment results. If you anonymize IP addresses, your regular expression should match IP addresses without their last octet.</p>\n        </div>\n      </div>\n    </div>\n  </li>\n</ul>\n';});

/**
 * Settings Sidebar Component
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/dashboard/settings/implementation/implementation_sidebar',['require','text!./implementation_sidebar.html','flux','flux/getters/current_project'],function(require) {
  var tmpl = require('text!./implementation_sidebar.html');
  var flux = require('flux');
  var getCurrentProject = require('flux/getters/current_project');

  return {
    template: tmpl,

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
      });
    },
  }
});

/**
 * Settings tab view component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/settings/implementation/implementation_tab',['require','flux','app','text!./implementation_tab.html','services/project','models/project','services/events','flux/getters/current_project','components/dashboard/project_code_new_dashboard','./implementation_sidebar'],function(require) {
  var flux = require('flux');
  var app = require('app');
  var tmpl = require('text!./implementation_tab.html');
  var projectService = require('services/project');
  var Project = require('models/project');
  var events = require('services/events');

  var getCurrentProject = require('flux/getters/current_project');

  var SETTINGS = [
    'enable_force_variation',
    'exclude_disabled_experiments',
    'exclude_names',
    'experiment_confidence_threshold',
    'ip_anonymization',
    'ip_filter',
    'library'
  ];

  var COMPONENTS = {
    'project-code-new-dashboard': require('components/dashboard/project_code_new_dashboard'),
    'implementation-sidebar': require('./implementation_sidebar')
  };

  return {
    template: tmpl,

    replace: true,

    components: COMPONENTS,

    data: {
      currentProject: {},
      settings: {}
    },

    computed: {
      /**
      * Whether the user has changed the IP settings
      * @return {boolean}
      */
      areSettingsClean: function() {
        this.currentProject;
        return !_.some(this.settings, function(val, key) {
          return val !== this.currentProject[key];
        }, this);
      },

      /**
      * The validity of the IP filtering regex
      * @return {boolean}
      */
      isRegexValid: function() {
        if (this.settings.ip_filter) {
          try {
            var regex = new RegExp(this.settings.ip_filter);
          }
          catch (err) {
            return false;
          }
        }
        return true;
      },

      isWebProject: function() {
        if (!this.currentProject) {
          return false;
        }
        return projectService.isWebProject(this.currentProject);
      },

      canEditProject: function() {
        return this.currentProject && flux.actions('permissions').canEditProject(this.currentProject);
      },

      /**
      * Can View Statistical Significance (SEQUENTIAL_STATISTICS).
      * @return {boolean}
      */
      canViewStatisticalSignificance: function() {
        return flux.actions('permissions').canViewStatisticalSignificance(this.currentProject);
      },

      /**
      * Error rate derived from statistical significance setting.
      * @return {Number}
      */
      errorRate: function() {
        return 100 - this.statisticalSignificance;
      },

      /**
      * Statistical significance setting.
      * @return {Number}
      */
      statisticalSignificance: {
        $get: function() {
          return this.settings.experiment_confidence_threshold / 100;
        },
        $set: function(val) {
          this.settings.experiment_confidence_threshold = val * 100;
        }
      },

      /**
      * Use getter and setter to ensure checking the 'disable force variation'
      * box sets the correct value for Project.enable_force_variation
      */
      disableForceVariation: {
        $get: function() {
          return !this.settings.enable_force_variation;
        },
        $set: function(val) {
          this.settings.enable_force_variation = !val;
        }
      },
    },

    methods: {
      /**
      * Persist privacy settings changes on the current project
      */
      saveSettings: function(event) {
        event.preventDefault();
        events.track('dashboard2', 'save-settings');

        var projectData = _.extend({
          id: this.currentProject.id,
        }, this.settings);

        flux.actions('loading').start('projectCode');
        flux.actions('projects').save(projectData).then(function() {
          app.$broadcast('notify', {
            message: tr("Your settings have been saved."),
          });

          // wait for the snippet to be uploaded
          // TODO: do this in a less janky way
          setTimeout(function() {
            flux.actions('api').fetch(Project, this.currentProject.id, true).then(function() {
              flux.actions('loading').stop('projectCode');
            });
          }.bind(this), 2000);
        }.bind(this));
      },
      /**
      * Discard privacy settings changes to the current project
      */
      discardSettings: function() {
        this.settings = _.pick(this.currentProject, SETTINGS);
      },
    },

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        settings: [getCurrentProject, function(currentProject) {
          return _.pick(currentProject, SETTINGS);
        }]
      });
    },
  };
});


define('text!components/dashboard/settings/labs/labs_tab.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group">\n  <div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n    <div class="lego-pane lego-pane--flex-1 lego-pane--scroll-y">\n      <div class="soft-double--sides soft-double--top">\n        <h3>Optimizely Labs</h3>\n        <p>\n          Optimizely Labs is where we test out experimental new features. These features are usually in beta testing: they may change, stop working, or go away at any time. To try a labs feature, just select it below and then try it out in the sidebar.\n        </p>\n      </div>\n\n      <table class="lego-table lego-table--dashboard" v-if="labsData.length > 0">\n        <thead>\n          <tr>\n            <th class="nowrap" v-component="sortable-th" field="name">\n              Name\n            </th>\n            <th class="nowrap cell-collapse" v-component="sortable-th" field="category">\n              Category\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-repeat="entry: labsData" v-component="labs-table-row"></tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n  <div class="lego-pane lego-data-sidebar lego-pane--flex">\n    <div v-view="sidebarComponent"></div>\n  </div>\n</div>\n';});


define('text!components/dashboard/settings/labs/list_management_sidebar.html',[],function () { return '<div class="soft-double">\n  <h3>List management</h3>\n\n  <p>\n    List Targeting allows you to upload lists of users to Optimizely for targeting.\n    Once you create a list, it will appear in the audiences dialog under the "List Management" condition.\n  </p>\n\n  <div class="lego-button-row--left">\n    <button class="lego-button lego-button--brand"\n      v-on="click: showListManagement">\n      Manage Lists\n    </button>\n  </div>\n\n</div>\n';});

/**
 * List management sidebar component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/settings/labs/list_management_sidebar',['require','app','flux','text!./list_management_sidebar.html'],function(require) {
  var app = require('app');
  var flux = require('flux');

  return {
    template: require('text!./list_management_sidebar.html'),

    replace: true,

    methods: {
      showListManagement: function() {
        app.$broadcast('showDialog', {
          component: 'dialogs/targeting-list',
          data: {
            projectId: flux.store('currentProject').getId(),
          }
        })
      }
    }
  };
});


define('text!components/dashboard/settings/labs/executive_summary_sidebar.html',[],function () { return '<div class="soft-double">\n  <h3>Executive Summary</h3>\n\n  <h5>Description</h5>\n\n  <p>\n    Examine your A/B testing strategy on Optimizely over the past year via this report. The report highlights statistically significant winning and losing variations across your Experiments and benchmarks your Optimizely product usage with respect to your peers.\n  </p>\n\n  <div class="lego-button-row--left">\n    <button class="lego-button lego-button--brand"\n      v-on="click: showExecutiveSummary">\n      Executive Summary\n    </button>\n  </div>\n</div>\n';});

/**
 * Executive summary sidebar
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/settings/labs/executive_summary_sidebar',['require','app','flux','text!./executive_summary_sidebar.html'],function(require) {
  var app = require('app');
  var flux = require('flux');

  return {
    template: require('text!./executive_summary_sidebar.html'),

    replace: true,

    methods: {
      showExecutiveSummary: function() {
        // implement
      }
    }
  };
});


define('text!components/dashboard/settings/labs/labs_table_row.html',[],function () { return '<tr v-on="click: clickEntry($event, entry)"\n    v-class="lego-table-row--active: isSelected"\n    data-table-row-id="[[ entry.id ]]">\n  <td>\n    [[ entry.name ]]\n  </td>\n  <td>\n    [[ entry.category ]]\n  </td>\n</tr>\n';});

/**
 * Labs table row
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/settings/labs/labs_table_row',['require','text!./labs_table_row.html','flux'],function(require) {
  var tmpl = require('text!./labs_table_row.html');
  var flux = require('flux');

  return {
    template: tmpl,

    replace: true,

    data: {
      isSelected: false,
      entry: {},
    },

    methods: {
      /**
       * @param {Event} event
       * @param {Object} entry
       */
      clickEntry: function(event, entry) {
        flux.actions('dashboard').clickItem('labs', entry);
      },
    },

    ready: function() {
      flux.bindVueValues(this, {
        isSelected: ['dashboard/selectedItems', function(selectedItems) {
          return selectedItems.isSelected('labs', this.entry.id);
        }.bind(this)]
      })
    },
  };
});

/**
 * Labs Tab (it rhymes!)
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/settings/labs/labs_tab',['require','flux','text!components/dashboard/settings/labs/labs_tab.html','flux/getters/current_project','flux/getters/current_project/enabled_labs','components/dashboard/settings/labs/list_management_sidebar','components/dashboard/settings/labs/executive_summary_sidebar','components/dashboard/settings/labs/labs_table_row'],function(require) {
  var flux = require('flux');
  var tmpl = require('text!components/dashboard/settings/labs/labs_tab.html');
  var getCurrentProject = require('flux/getters/current_project');
  var getEnabledLabs = require('flux/getters/current_project/enabled_labs');

  var COMPONENTS = {
    'list-management-sidebar': require('components/dashboard/settings/labs/list_management_sidebar'),
    'executive-summary-sidebar': require('components/dashboard/settings/labs/executive_summary_sidebar'),
    'labs-table-row': require('components/dashboard/settings/labs/labs_table_row'),
  };

  return {
    components: COMPONENTS,

    template: tmpl,

    replace: true,

    computed: {
      sidebarComponent: function() {
        var entry = this.selectedEntry;
        if (entry && entry.sidebarComponent) {
          return entry.sidebarComponent;
        }
      },
    },

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,

        labsData: getEnabledLabs,

        selectedEntry: [
          'dashboard/selectedItems',
          function(selectedItemsStore) {
            var selectedIds = selectedItemsStore.getSelectedIds('labs');
            if (selectedIds.length === 1) {
              return _.find(this.labsData, {
                id: selectedIds[0]
              });
            }
            // return empty object here so Vue component can observe it later
            // since `undefined` breaks the computed observation
            return {};
          }.bind(this)
        ],
      });

      if (this.labsData.length > 0) {
        flux.actions('dashboard').clickItem('labs', this.labsData[0]);
      }
    },
  };
});

/**
 * Settings Main Tab Component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/dashboard/settings/settings_tab',['require','flux','text!./settings_tab.html','services/events','utils/page','services/router','flux/getters/current_project','flux/getters/current_project/enabled_labs','components/dashboard/settings/implementation/implementation_tab','components/dashboard/settings/labs/labs_tab'],function(require) {
  var flux = require('flux');
  var tmpl = require('text!./settings_tab.html');
  var events = require('services/events');
  var page = require('utils/page');
  var router = require('services/router');

  var getCurrentProject = require('flux/getters/current_project');
  var getEnabledLabs = require('flux/getters/current_project/enabled_labs');

  var COMPONENTS = {
    'implementation': require('components/dashboard/settings/implementation/implementation_tab'),
    'labs': require('components/dashboard/settings/labs/labs_tab'),
  };

  return {
    components: COMPONENTS,

    template: tmpl,

    replace: true,

    methods: {
      /**
       * Switches the active subtab and sets up the tab contents component
       * @param {String} tab
       */
      switchSubtab: function(tab) {
        events.track('dashboard2','switch-subtab', tab);
        if (this.activeSubtab !== tab) {
          page(router.dashboardTab(this.currentProject.id, tab));
        }
      },
    },

    created: function() {
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,

        showLabs: [getEnabledLabs, function(labs) {
          return labs.length > 0;
        }],

        activeSubtab: ['dashboard', function(dashboard) {
          return dashboard.getActiveSubTab();
        }]
      });
    },
  };
});

/**
 * Dashboard Page Controller
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/pages/dashboard',['require','app','flux','utils/page','services/router','text!./dashboard.html','flux/factories/store_change_stream_factory','services/user','services/events','services/project','flux/getters/projects','flux/getters/current_project','utils/editable','components/dashboard/projects/projects_tab','components/dashboard/collaborators/collaborators_tab','components/dashboard/integrations/integrations_tab','components/dashboard/settings/settings_tab'],function(require) {
  var app = require('app');
  var flux = require('flux');
  var page = require('utils/page');
  var router = require('services/router');
  var tmpl = require('text!./dashboard.html');
  var storeChangeStream = require('flux/factories/store_change_stream_factory');
  var userService = require('services/user');
  var events = require('services/events');
  var projectService = require('services/project');

  // flux getter functions
  var getProjects = require('flux/getters/projects');
  var getCurrentProject = require('flux/getters/current_project');
  var editable = require('utils/editable');

  /**
   * Sub components of the dashboard page
   */
  var COMPONENTS = {
    // tab contents components
    'projects': require('components/dashboard/projects/projects_tab'),
    'collaborators': require('components/dashboard/collaborators/collaborators_tab'),
    'integrations': require('components/dashboard/integrations/integrations_tab'),
    'settings': require('components/dashboard/settings/settings_tab'),
  };

  return {
    template: tmpl,

    replace: true,
    // declare dashboard page components
    components: COMPONENTS,

    data: {
      activeTab: null,
      currentProject: {},
      projects: [],
    },

    computed: {
      shouldSeeIntegrations: function() {
        return projectService.isWebProject(this.currentProject);
      },

      shouldSeeCollaborators: function() {
        var project = this.currentProject;
        return flux.actions('permissions').canViewCollaborators(project);
      }
    },

    methods: {
      /**
       * Switches the active tab and sets up the tab constents component
       * @param {String} tab
       */
      switchTab: function(tab) {
        if (this.activeTab !== tab) {
          page(router.dashboardTab(this.currentProject.id, tab));
          events.track('dashboard2','switch-tab', tab);
        }
      },

      saveProperty: function(property, value, oldValue) {
        var changes = {
          id: this.currentProject.id,
        };
        changes[property] = value;
        return flux.actions('projects').save(changes)
          .fail(function() {
              // On fail, revert to the old value
              this.currentProject[property] = oldValue;
            }.bind(this));
      },

      saveProjectName: function(name, oldName) {
        if (!name.length) {
          this.currentProject.project_name = oldName;
          app.$broadcast('notify', {
            type: 'error',
            message: tr("Empty project names are not allowed."),
          });
        } else {
          this.saveProperty('project_name', name, oldName).then(function() {
            app.$broadcast('notify', {
              message: tr("The project <b>{0}</b> has been renamed.", name),
            });
            events.track('dashboard2','edit-project', 'name');  
          }); 
        }
      },

      optOut: function() {
        var redirectToOldDashboard = function(data) {
          var url = window.location.origin + '/dashboard';
          window.location = url;
        };
        events.track('dashboard2', 'opt-out');
        userService.setOptInFeature('VIEW_DASHBOARD2', false, redirectToOldDashboard);
      },

      /**
       * Shows the dialogs/get-feedback component.
       */
      showFeedbackDialog: function() {
        events.track('dashboard2', 'feedback');
        var config = {
          component: 'dialogs/get-feedback'
        };
        app.$broadcast('showDialog', config);
      },
    },

    created: function() {
      flux.bindVueValues(this, {
        projects: getProjects,
        currentProject: getCurrentProject,
        activeTab: ['dashboard', function(dashboard) {
          return flux.store('dashboard').getActiveMainTab();
        }],
        canEditProject: [getCurrentProject, function(project) {
          return project && flux.actions('permissions').canEditProject(project);
        }]
      })

      editable.onSaved(this, 'project_name', this.saveProjectName);
    },
  };
});


define('text!components/pages/manage_projects/manage_projects.html',[],function () { return '<div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n  <!-- Tab Parents -->\n  <div class="lego-pane border--bottom">\n    <div class="flex align-items--center soft-double gamma">\n        Manage Projects\n    </div>\n  </div>\n\n  <div class="lego-pane lego-pane--flex-1 lego-pane-group">\n    <div class="lego-pane lego-pane--flex-1 lego-pane-group lego-pane-group--column">\n\n      <div class="lego-fence--push">\n        <!-- Toolbar -->\n        <ul class="flex push-double--ends" data-ui-component="dashboard-toolbar">\n          <li class="push-triple--right">\n            <form>\n              <div class="lego-button-group">\n                <input type="text"\n                  class="lego-text-input lego-text-input--search width-200"\n                  placeholder="Filter by Name"\n                  v-model="filterString"\n                  data-test-section="projects-filter-input" />\n              </div>\n            </form>\n          </li>\n          <li class="anchor--right">\n            <button class="lego-button lego-button--highlight"\n              v-on="click: showCreateProject()"\n              v-lego-disabled="!canCreateProject">New Project\n            </button>\n          </li>\n        </ul>\n\n        <div class="lego-attention push-double--top push-double--bottom" v-if="atProjectLimit">\n          <p>You\'ve reached your plan\'s project limit. To create another project or unarchive an existing project, please <a href="/pricing" target="_blank">upgrade or contact sales</a>.</p>\n        </div>\n      </div>\n\n      <div class="lego-pane lego-pane--flex-1 lego-pane--scroll-y" >\n        <table class="lego-table lego-table--dashboard" id="dashboard-manage-projects">\n          <thead>\n            <tr>\n              <th class="nowrap" v-component="sortable-th" field="project_name">Name</th>\n              <th class="nowrap" v-component="sortable-th" field="project_status">Status</th>\n            </tr>\n          </thead>\n          <tbody v-prevent-shift-selection>\n            <tr v-repeat="project: projects | filterBy filterString in \'project_name\'"\n              v-component="project-table-row">\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n    <div class="lego-pane lego-data-sidebar lego-pane--flex"\n      v-component="project-sidebar">\n    </div>\n  </div>\n</div>\n';});


define('text!components/pages/manage_projects/project_table_row.html',[],function () { return '<tr v-on="click: clickProject($event, project)"\n    v-class="lego-table-row--active: isSelected"\n    data-table-row-id="[[ project.id ]]">\n  <td class="cell-truncate">\n    <span class="cell-truncate__title">[[ project.project_name ]]</span>\n    <span class="tagger">for [[ project.project_platforms[0] ]]</span>\n  </td>\n  <td>\n    <span v-class="good-news: isProjectActive,\n                   muted: isProjectArchived">\n      [[ project.project_status ]]\n    </span>\n  </td>\n</tr>\n';});

/**
 * Project table row
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/pages/manage_projects/project_table_row',['require','text!components/pages/manage_projects/project_table_row.html','flux','utils/enums'],function(require) {
  var tmpl = require('text!components/pages/manage_projects/project_table_row.html');
  var flux = require('flux');
  var enums = require('utils/enums');

  return {
    template: tmpl,

    replace: true,

    data: {
      isSelected: false,
      project: {},
    },

    computed: {
      isProjectActive: function() {
        return this.project.project_status === enums.ProjectStatusType.ACTIVE;
      },
      isProjectArchived: function() {
        return this.project.project_status === enums.ProjectStatusType.ARCHIVED;
      },
    },

    methods: {
      /**
       * @param {Event} event
       * @param {Object} project
       */
      clickProject: function(event, project) {
        flux.actions('dashboard').clickItem('projects', project, event.shiftKey);
      },
    },

    ready: function() {
      var project = this.project;
      flux.bindVueValues(this, {
        isSelected: ['dashboard/selectedItems', function(selectedItems) {
          return selectedItems.isSelected('projects', project.id);
        }.bind(this)]
      });
    },

    beforeDestroy: function() {
      if (this.isSelected) {
        flux.actions('dashboard').deselectItem('projects', this.project);
      }
    },
  };
});


define('text!components/pages/manage_projects/project_sidebar.html',[],function () { return '<ul class="accordion" v-accordion data-test-section="project-sidebar">\n  <li class="accordion__item accordion__item--active" v-class="accordion__item--empty : !project">\n    <a class="accordion__link" href="#">Project Details</a>\n    <div class="accordion__content-wrap" v-if="!project">\n      <div class="accordion__content">\n        <div class="empty-state-message">\n          <svg class="lego-icon lego-icon--large"><use xlink:href="#projects"></use></svg>\n          <div>Select a project.</div>\n        </div>\n      </div>\n    </div>\n    <div class="accordion__content-wrap" v-if="project">\n      <div class="accordion__content">\n        <ul class="lego-sections">\n          <li class="lego-sections__item" v-if="isProjectArchived">\n            <button class="lego-button"\n                    v-on="click: unarchiveProject(project)"\n                    v-lego-disabled="!(canEditProject && !atProjectLimit)"\n                    data-test-section="unarchive-button">Unarchive</button>\n          </li>\n          <li class="lego-sections__item" v-if="!isProjectArchived">\n            <a class="lego-button"\n               href="/projects/[[ project.id ]]"\n               v-push-state\n               data-test-section="go-to-button">\n               Go to Project\n            </a>\n            <button class="lego-button"\n                    v-on="click: archiveProject(project)"\n                    v-lego-disabled="!canEditProject"\n                    data-test-section="archive-button">\n                    Archive\n            </button>\n          </li>\n          <li class="lego-sections__item">\n            <h3 v-component="editable"\n                v-with="id: \'project_name\',\n                        content: project.project_name,\n                        permission: canEditProject">\n            </h3>\n            <span class="tagger">for [[ project.project_platforms[0] ]]</span>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </li>\n</ul>\n';});

/**
 * Gets the selected project for the manage projects sidebar on the dashboard
 */
define('flux/getters/dashboard/selected_project',[],function() {
  return [
    'dashboard/selectedItems',
    'projects',
    function (selectedItems, projects) {
      var selectedIds = selectedItems.getSelectedIds('projects');
      if (selectedIds.length === 1) {
        return projects.get(selectedIds[0]);
      }
    }
  ];
});

/**
 * Manage Project Sidebar Component
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/pages/manage_projects/project_sidebar',['require','app','text!components/pages/manage_projects/project_sidebar.html','flux','utils/enums','models/project','utils/editable','services/events','flux/getters/dashboard/selected_project'],function(require) {
  var app = require('app');
  var tmpl = require('text!components/pages/manage_projects/project_sidebar.html');
  var flux = require('flux');
  var enums = require('utils/enums');
  var Project = require('models/project');
  var editable = require('utils/editable');
  var events = require('services/events');

  var getDashboardSelectedProject = require('flux/getters/dashboard/selected_project');

  return {
    template: tmpl,

    computed: {
      /*
      * Checks if the current project's status is archived.
      * @return {boolean}
      */
      isProjectArchived: function() {
        if (!this.project) {
          return false;
        }
        return this.project.project_status === enums.ProjectStatusType.ARCHIVED;
      },
    },

    methods: {
      archiveProject: function(project) {
        flux.actions('projects').archive(project).then(function() {
          app.$broadcast('notify', {
            message: tr("The project <b>{0}</b> has been archived.", project.project_name),
          }); 
        });
        events.track('dashboard2','archive-project');
      },

      saveProperty: function(property, value, oldValue) {
        var changes = {
          id: this.project.id,
        };
        changes[property] = value;
        return flux.actions('projects').save(changes)
          .fail(function() {
            // On fail, revert to the old value
            this.project[property] = oldValue;
          }.bind(this));
      },

      saveProjectName: function(name, oldName) {
        if (!name.length) {
          this.project.project_name = oldName;
          app.$broadcast('notify', {
            type: 'error',
            message: tr("Empty project names are not allowed."),
          });
        } else {
          this.saveProperty('project_name', name, oldName).then(function() {
            app.$broadcast('notify', {
              message: tr("The project <b>{0}</b> has been renamed.", name),
            });  
          });
          events.track('dashboard2','edit-project', 'name');
        }
      },

      unarchiveProject: function(project) {
        flux.actions('projects').unarchive(project).then(function() {
          app.$broadcast('notify', {
            message: tr("The project <b>{0}</b> has been unarchived.", project.project_name),
          });
        });
        this.saveProperty('project_name', name);
        events.track('dashboard2','unarchive-project');
      },
    },

    created: function() {
      flux.bindVueValues(this, {
        project: getDashboardSelectedProject,

        canEditProject: [getDashboardSelectedProject, function(project) {
          if (!project) {
            return false;
          }
          return flux.actions('permissions').canEditProject(project);
        }],

        atProjectLimit: ['account', function(account) {
          return account.getProjectCount() >= account.getMaxProjects();
        }]
      });

      editable.onSaved(this, 'project_name', this.saveProjectName);
    },
  }
});

/**
 * Manage projects page component
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/pages/manage_projects/manage_projects',['require','app','flux','text!components/pages/manage_projects/manage_projects.html','utils/enums','models/project','services/events','flux/getters/projects','components/pages/manage_projects/project_table_row','components/pages/manage_projects/project_sidebar'],function(require) {
  var app = require('app');
  var flux = require('flux');
  var tmpl = require('text!components/pages/manage_projects/manage_projects.html');
  var enums = require('utils/enums');
  var Project = require('models/project');
  var events = require('services/events');
  var getProjects = require('flux/getters/projects');

  var COMPONENTS = {
    'project-table-row': require('components/pages/manage_projects/project_table_row'),
    'project-sidebar': require('components/pages/manage_projects/project_sidebar'),
  };

  return {
    template: tmpl,

    components: COMPONENTS,

    replace: true,

    methods: {
      showCreateProject: function() {
        events.track('dashboard2','create-project','from-manage-projects');
        app.$broadcast('showDialog', {
          component: 'dialogs/create-project',
        });
      },
    },

    created: function() {
      this.ActiveType = enums.ProjectStatusType.ACTIVE;
      this.ArchivedType = enums.ProjectStatusType.ARCHIVED;

      var tableId = 'dashboard-manage-projects';
      flux.bindVueValues(this, {
        projects: [
          getProjects,
          'sortableTable',
          function(projects, sortableTableStore) {
            var sortFn = sortableTableStore.getSortFn(tableId);
            if (sortFn) {
              projects.sort(sortFn);
            }
            return projects;
          }
        ],

        canCreateProject: [
          'projects',
          'account',
          function(projects, account) {
            var adminProject = projects.get(account.getId());
            return adminProject && flux.actions('permissions').canCreateProject(adminProject, account);
          }
        ],

        atProjectLimit: ['account', function(account) {
          return account.getProjectCount() >= account.getMaxProjects();
        }]
      })
    },
  };
});


define('text!components/project_switcher.html',[],function () { return '<li class="lego-dropdown-group" v-dropdown>\n  <a class="dropdown-arrow" href="javascript:void(0)" data-show-dropdown>\n    Projects\n  </a>\n  <ul id="project-switcher-dropdown" class="lego-dropdown">\n    <li class="lego-dropdown__item">\n      <div class="soft-half--ends">\n        <input type="text"\n          class="lego-text-input lego-text-input--search"\n          placeholder="Filter Projects by Name"\n          v-model="projectFilter">\n      </div>\n    </li>\n    <li class="lego-dropdown__item max-scroll--large" v-if="activeProjects.length">\n      <a href="/projects/[[ project.id ]]" class="lego-dropdown__block-link"\n        v-repeat="project: activeProjects | filterBy projectFilter in \'project_name\' | orderBy \'project_name\'"\n        v-class="lego-dropdown__item--active: project.id === currentProject.id"\n        v-push-state\n        data-hide-dropdown>\n        [[ project.project_name ]]\n      </a>\n    </li>\n    <li class="lego-dropdown__item">\n      <a href="/projects/manage" class="lego-dropdown__block-link"\n        v-push-state\n        data-hide-dropdown>\n        <b>Manage Projects</b>\n      </a>\n    </li>\n    <li class="lego-dropdown__item" v-if="canCreateProject">\n      <a href="#" class="lego-dropdown__block-link"\n        v-on="click: showCreateProject"\n        data-hide-dropdown>\n        <b>Create New Project</b>\n      </a>\n    </li>\n  </ul>\n</li>\n';});

/**
 * Project Switcher Component
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('components/project_switcher',['require','exports','module','app','flux','text!components/project_switcher.html','services/events','utils/page','services/router','flux/getters/current_project','flux/getters/active_projects'],function(require, exports, module) {
  var app = require('app');
  var flux = require('flux');
  var tmpl = require('text!components/project_switcher.html');
  var events = require('services/events');
  var page = require('utils/page');
  var router = require('services/router');

  var getCurrentProject = require('flux/getters/current_project');
  var getActiveProjects = require('flux/getters/active_projects');

  return {
    template: tmpl,

    replace: true,

    methods: {
      showCreateProject: function() {
        events.track('dashboard2', 'create-project', 'from-nav');

        var onSave = $.Deferred();

        onSave.then(function(newProject) {
          page(router.dashboardTab(newProject.id));
        });

        app.$broadcast('showDialog', {
          component: 'dialogs/create-project',
          data: {
            _onSave: onSave,
          },
        });
      },
    },

    created: function() {
      this.projectFilter = '';
      flux.bindVueValues(this, {
        currentProject: getCurrentProject,
        activeProjects: getActiveProjects,
        canCreateProject: [
          getCurrentProject,
          'account',
          function(project, account) {
            return project && flux.actions('permissions').canCreateProject(project, account);
          }
        ]
      });
    },
  };
});


define('text!components/spinner.html',[],function () { return '<div class="lego-spinner-wrap">\n  <div class="lego-spinner" v-attr="class: sizeClass"></div>\n</div>\n';});

/**
 * Spinner UI component
 *
 * Usage <div v-component="spinner" size="small"></div>
 *
 * @author Jordan Garcia
 */
define('components/spinner',['require','exports','module','text!./spinner.html'],function(require, exports, module) {
  var tmpl = require('text!./spinner.html')
  var SIZE_CLASSES = {
    small: 'lego-spinner--small',
  }

  module.exports = {
    template: tmpl,

    replace: true,

    data: {
      sizeClass: 'lego-spinner',
    },

    ready: function() {
      var size = this.$el.getAttribute('size');
      if (size && SIZE_CLASSES[size]) {
        this.sizeClass += ' ' + SIZE_CLASSES[size];
      }
    }
  }
});


define('text!components/sortable_table_header.html',[],function () { return '<th v-on="click: sortField">\n  <content>[[ field ]]</content>\n  <span v-if="field"\n    v-class="lego-arrow-inline--down: isSortedAsc,\n             lego-arrow-inline--up: isSortedDesc">\n  </span>\n</th>\n';});

/**
 * A data table Table Header <th>
 *
 * This is a subcomponent of data-table
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/sortable_table_header',['require','flux','text!components/sortable_table_header.html','utils/sort'],function(require) {
  var flux = require('flux');
  var tmpl = require('text!components/sortable_table_header.html');
  var sort = require('utils/sort');

  return {
    template: tmpl,

    replace: true,

    paramAttributes: ['field', 'type'],

    data: {
      // initialize to null since we cant read store value until the dom is ready
      // since it relies on the parent table and the computed will get run immediately,
      // thus not picking up the dependency.
      dir: null
    },

    ready: function() {
      this.tableId = $(this.$el).parents('table').attr('id');
      if (!this.type) {
        // default to string
        this.type = 'string';
      }

      flux.bindVueValues(this, {
        dir: ['sortableTable', function(sortableTableStore) {
          return sortableTableStore.getFieldSortDir(this.tableId, this.field);
        }.bind(this)],
      });
    },

    computed: {
      isSortedAsc: function() {
        return this.dir === sort.ASC;
      },

      isSortedDesc: function() {
        return this.dir === sort.DESC;
      },
    },

    methods: {
      sortField: function() {
        flux.actions('sortableTable').toggleField({
          tableId: this.tableId,
          field: this.field,
          type: this.type,
        });
      },
    },
  };
});

/**
 * Basic tab management component. It accepts an array describing each tab and the component it maps to.
 * When switching between tabs, it sets the active component/text appropriately
 *
 * @author Sam Jackson (sam@optimizely.com)
 */

define('components/tab_manager',['require','exports','module','lodash'],function(require, module, exports) {

  var _ = require('lodash');

  return {
    data: {
      activeTabComponent: '',
      activeTabText: '',
      defaultTabName: '',

      // Array listing tab components to instantiate -- this object is just an example of the expected format,
      // it should be overriden in extending components
      tabs: [
        {
          component: '',
          name: '',
          label: ''
        }
      ]
    },
    methods: {

      /**
       * Set the active component + text
       *
       * @param tabName String Name of the tab to switch to
       */
      switchTab: function (tabName) {
        var tab = _.filter(this.tabs, function (tabObject) {
          return tabObject.component === tabName;
        }, this)[0];
        if (tab) {
          // check if we are opening a tab that is currently open
          var isTabCurrentlyOpen = this.activeTabComponent && this.activeTabComponent === tab.component;
          this.activeTabComponent = tab.component;
          this.activeTabText = tab.label;

          // we use $emit so that the component extending this base component can catch the generic 'tabOpened'
          // event and process it accordingly
          this.$emit('tabOpened', isTabCurrentlyOpen);
        } else {
          this.activeTabComponent = null;
          this.activeTabText = '';
        }
      }
    },
    created: function () {
      if (this.defaultTab) {
        this.switchTab(this.defaultTab);
      }
    }
  };
});

/**
 * Targeting list dropdown
 *
 * @author Daniel O'Connor (daniel@optimizely.com)
 */
define('components/targeting_list_dropdown',['require','flux','models/targeting_list'],function(require) {
  var flux = require('flux')
  var TargetingList = require('models/targeting_list');

  return {
    data: {
      lists: []
    },

    created: function() {
      var byProject = {
        project_id: flux.store('currentProject').getId()
      };

      flux.actions('api').fetchAll(TargetingList, byProject).then(function(results) {
        this.lists = results;
      }.bind(this));
    }
  };
});

/**
 * Component wrapper around optly.conditions.TimeAndDay
 *
 * This component is a bridge between the old jQuery style component
 * and integrating it into the and-or-targeting component
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components/time_and_day_picker',['require'],function(require) {
  return {
    data: {
      // holds reference to outside condition
      serialized: null
    },

    methods: {
      /**
       * Handler for custom event triggered by the timeAndDay jQuery
       * component
       *
       * @param {Event} event
       * @param {String} data - serialized time/day data
       */
      _handleChange: function(event, data) {
        this.serialized = data;
      }
    },

    ready: function() {
      var timeAndDayComponent = new optly.conditions.TimeAndDay(this.$el);
      // if passed serialized data, load into time/day picker
      if (this.serialized) {
        timeAndDayComponent.loadData(this.serialized);
      }

      // subscribe to jQuery component change event
      $(this.$el).on(optly.conditions.TimeAndDay.CHANGE_EVENT, this._handleChange.bind(this));

      this.$on('validateConditions', function() {
        this.$dispatch('validateConditionsResponse', {
          valid: timeAndDayComponent.validate()
          // no need to supply a message here since the timeAndDayComponent has validation in UI
        });
      }.bind(this));
    }
  };
});


define('text!components/mib/view_selector.html',[],function () { return '<div class="view-selector">\n  <div class="lego-search">\n    <input type="text" class="lego-text-input lego-text-input--search width-200" placeholder="Search Views"\n        v-on="focus: show"\n        v-model="filter">\n  </div>\n\n  <ul class="lego-dropdown width-300"\n      v-show="isActive && filteredViews.length > 0"\n      v-style="max-height: viewContainerMaxH + \'px\'">\n    <li class="lego-dropdown__item truncate"\n      v-repeat="view: filteredViews"\n      trackby="view.id"\n      v-text="view.id"\n      v-on="click: selectionClicked(view),\n        mouseover: selectionHovered(view),\n        mouseout: selectionUnhovered(view)"\n    ></li>\n  </ul>\n</div>\n';});

/**
 * Component for holding a list of selectable view in MIB
 * todo:after release - organize broadcast and dispatch better. Dispatch messages to the editor_manager and eventually broadcast from there if needed.
 */
define('components/mib/view_selector',['require','app','services/events','text!components/mib/view_selector.html'],function(require) {
  var DEVICE_CONTAINER_PREFIX = 'device-container:';
  var VIEW_SELECTOR_PREFIX = 'view-selector:';

  var app = require('app');
  var events = require('services/events');
  var tmpl = require('text!components/mib/view_selector.html');

  return {
    template: tmpl,

    replace: true,

    data: {
      isActive: false,          // is the component active
      filter: '',
      viewContainerMaxH: 300,   // Max height of view list container. This is adapted when the window is resized
      views: []                // List of views available. This is filtered by unique IDs
    },

    computed: {
      filteredViews: function() {
        var filteredViews;
        if (this.filter && this.filter.length) {
          var filter = this.filter.toLowerCase();
          filteredViews = _.filter(this.views, function(view) {
            return view.id.toLowerCase().indexOf(filter) >= 0;
          });
        }
        else {
          filteredViews = this.views;
        }
        return filteredViews;
      }
    },
    
    methods: {
      /**
       * Hide the view list
       */
      hide: function() {
        this.isActive = false;
      },

      /**
       * Set the list of views to show and filter them removing duplicate IDs
       * @param views
       */
      setViews: function(views) {
        // Remove duplicate ids
        this.views = _.uniq(views, 'id');
      },

      /**
       * A view item was selected
       * @param view
       */
      selectionClicked: function(view) {
        app.$broadcast(DEVICE_CONTAINER_PREFIX + 'selectionClicked', view);
      },

      /**
       * A view item was hovered
       * @param view
       */
      selectionHovered: function(view) {
        app.$broadcast(VIEW_SELECTOR_PREFIX + 'selectionHovered', view);
      },

      /**
       * A view item was unhovered
       * @param view
       */
      selectionUnhovered: function(view) {
        app.$broadcast(VIEW_SELECTOR_PREFIX + 'selectionUnhovered', view);
      },

      show: function() {
        this.isActive = true;
      },

      /**
       * Toggle the view list visibility
       */
      toggleViewContainer: function() {
        this.isActive = !this.isActive;
      },

      /**
       * Handle window resize to calculate the view list max height
       * @private
       */
      _onWindowResize: function() {
        var containerSize = this.$parent.getContainerSize;
        this.viewContainerMaxH = containerSize.height - 100;
      }

    },

    ready: function() {
      var self = this;
      app.$on(VIEW_SELECTOR_PREFIX + 'setViews', self.setViews.bind(this));
      app.$on('device-container:selectionClicked', self.hide.bind(this));
      this.$on('editorManager:click', self.hide.bind(this));

      // Stop the click propagation in order to prevent the device-container from deselecting the view
      $(this.$el).on('click', function (e) {
        e.stopPropagation();
      });

      $(window).on('resize', this._onWindowResize.bind(this));
      this._onWindowResize();
    }
  };
});

/**
 * A thin wrapper around jQuery UI's slider
 * http://api.jqueryui.com/slider
 *
 * @author Tyler Brandt (tyler@optimizely.com)
 */
define('components/widgets/slider',[],function() {
  var slider;

  return {
    data: {
      value: 0,
      options: {
        disabled: false,
        range: false,
        min: 0,
        max: 0,
        step: 1
      }
    },

    methods: {
      _onSlide: function(event, ui) {
        this.value = ui.value;
        this.$dispatch('slider:slide', this.value);
      }
    },

    ready: function() {
      var options = _.extend({}, {
        slide: this._onSlide.bind(this),
        value: this.value
      }, this.options);
      slider = $(this.$el).slider(options);
      this.$watch('value', function(value) {
        slider.slider('value' ,value);
      });

      // for some reason the slider doesn't get the correct "disabled" classes just from being instantiated
      // disabled
      if (this.options.disabled) {
        slider.slider('option', 'disabled', true);
      }

      // Watch for changes to values
      Object.keys(this.options).forEach(function(option) {
        this.$watch('options.' + option, function(value) {
          slider.slider('option', option, value);
        });
      }.bind(this));
    }
  }
});

/**
 * This file exports a map of component ids to component definitions
 *
 * All global components should be defined here
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('components',['require','components/and_or_targeting','components/and_or_targeting_code_editor','components/and_or_targeting_ui','components/audience_editor','components/code_mirror','components/copier','components/dashboard/projects/projects_tab','components/dialogs/analytics_integrations','components/dialogs/audiences_disabled','components/dialogs/change_account_name','components/dialogs/changed_code','components/dialogs/confirm','components/dialogs/create_experiment','components/dialogs/duplicate_experiment','components/dialogs/create_project','components/dialogs/dimension_editor','components/dialogs/get_feedback','components/dialogs/delete_goal','components/dialogs/experiment_audiences','components/dialogs/duplicate_collaborators','components/dialogs/invite_collaborators','components/dialogs/experiment_code','components/dialogs/integrations/integrations','components/dialogs/mobile_editor_redirect','components/dialogs/targeting_list','components/dialogs/send_code','components/dialogs/traffic_allocation','components/dialogs/url_targeting','components/dialogs/experiment_goals','components/dialog_frame','components/dialog_manager','components/goals/create_click_goal','components/goals/create_custom_event_goal','components/goals/create_page_view_goal','components/editable','components/geotargeting/geotargeting_autocomplete','components/navbar','components/notification_manager','components/pages/dashboard','components/pages/manage_projects/manage_projects','components/project_code','components/project_switcher','components/spinner','components/sortable_table_header','components/tab_manager','components/targeting_list_dropdown','components/time_and_day_picker','components/mib/view_selector','components/widgets/slider'],function(require) {
  /**
   * @var {Object} map of component ids to their definitions
   *
   * File Naming Convention
   *
   * All component ids must be hyphenated
   * ex: 'condition-picker' corresponds to require('components/condition_picker') => src/www/optly/js/components/condition_picker.js
   *
   * Component ids should reflect the directory structure after `components/
   * ex: 'audiences/audience-editor' corresponds to require('components/audiences/audience_editor.js')
   *
   * Note: All javascript file names use underscores (_) and no hyphens (-) or camelCase
   *
   * Usage:
   * Always attach components by setting `v-component` attribute to the component id
   * <div v-component="audiences/audience-editor"></div>
   */
  return {
    'and-or-targeting': require('components/and_or_targeting'),
    'and-or-targeting-code-editor': require('components/and_or_targeting_code_editor'),
    'and-or-targeting-ui': require('components/and_or_targeting_ui'),
    'audience-editor': require('components/audience_editor'),
    'code-mirror': require('components/code_mirror'),
    'copier': require('components/copier'),
    'dashboard/overview': require('components/dashboard/projects/projects_tab'),
    'dialogs/analytics-integrations': require('components/dialogs/analytics_integrations'),
    'dialogs/audiences-disabled': require('components/dialogs/audiences_disabled'),
    'dialogs/change-account-name': require('components/dialogs/change_account_name'),
    'dialogs/changed-code': require('components/dialogs/changed_code'),
    'dialogs/confirm': require('components/dialogs/confirm'),
    'dialogs/create-experiment': require('components/dialogs/create_experiment'),
    'dialogs/duplicate-experiment': require('components/dialogs/duplicate_experiment'),
    'dialogs/create-project': require('components/dialogs/create_project'),
    'dialogs/dimension-editor': require('components/dialogs/dimension_editor'),
    'dialogs/get-feedback': require('components/dialogs/get_feedback'),
    'dialogs/delete-goal': require('components/dialogs/delete_goal'),
    'dialogs/experiment-audiences': require('components/dialogs/experiment_audiences'),
    'dialogs/duplicate-collaborators': require('components/dialogs/duplicate_collaborators'),
    'dialogs/invite-collaborators': require('components/dialogs/invite_collaborators'),
    'dialogs/experiment-code': require('components/dialogs/experiment_code'),
    'dialogs/integrations/integrations': require('components/dialogs/integrations/integrations'),
    'dialogs/mobile-editor-redirect': require('components/dialogs/mobile_editor_redirect'),
    'dialogs/targeting-list': require('components/dialogs/targeting_list'),
    'dialogs/send-code': require('components/dialogs/send_code'),
    'dialogs/traffic-allocation': require('components/dialogs/traffic_allocation'),
    'dialogs/url-targeting': require('components/dialogs/url_targeting'),
    'dialogs/experiment-goals': require('components/dialogs/experiment_goals'),
    'dialog-frame': require('components/dialog_frame'),
    'dialog-manager': require('components/dialog_manager'),
    'goals/create-click-goal': require('components/goals/create_click_goal'),
    'goals/create-custom-event-goal': require('components/goals/create_custom_event_goal'),
    'goals/create-page-view-goal': require('components/goals/create_page_view_goal'),
    'editable': require('components/editable'),
    'geotargeting/geotargeting-autocomplete': require('components/geotargeting/geotargeting_autocomplete'),
    'navbar': require('components/navbar'),
    'notification-manager': require('components/notification_manager'),
    'pages/dashboard': require('components/pages/dashboard'),
    'pages/manage-projects': require('components/pages/manage_projects/manage_projects'),
    'project-code': require('components/project_code'),
    'project-switcher': require('components/project_switcher'),
    'spinner': require('components/spinner'),
    'sortable-th': require('components/sortable_table_header'),
    'tab-manager': require('components/tab_manager'),
    'targeting-list-dropdown': require('components/targeting_list_dropdown'),
    'time-and-day-picker': require('components/time_and_day_picker'),
    'view-selector': require('components/mib/view_selector'),
    'widgets/slider': require('components/widgets/slider')
  };
});

/**
 * Service for simple accordion directive
 *
 * @author Cheston Lee
 */

define('services/accordion',[],function() {

   var ACTIVE_ACCORDION_CLASS = 'accordion__item--active';

  function activate(el, target) {
    var $el = $(el);
    var $target = $(target);

    var contentPane = $target.parent('.accordion__item');
    var currentActive = $el.find('.' + ACTIVE_ACCORDION_CLASS);
    var contentHeight = currentActive.outerHeight();

    contentPane.animate({
      height: contentHeight
    }, {
      duration: 200,
      queue: false
    });

    currentActive.animate({
      height: $target.outerHeight()
    }, {
      duration: 200,
      queue: false,
      complete: function() {
        contentPane.parent().children().css('height', '');
      }
    });

    if (currentActive.length > 0) {
      currentActive.removeClass(ACTIVE_ACCORDION_CLASS);
    }

    $target.parent().addClass(ACTIVE_ACCORDION_CLASS);
  }

  return {
    activate: activate
  };
});

/**
 * Directive for simple accordion
 *
 * @author Cheston Lee
 */
define('directives/accordion',['services/accordion'],function() {
  var accordionService = require('services/accordion');

  return {
    data: {
      show: true
    },
    bind: function() {
      var $el = $(this.el);

      $el.find('> li > a').on('click', function(e) {
        e.preventDefault();
        accordionService.activate(this.el, e.target);
      }.bind(this));
    }
  };
});

/**
 * Disabled directive
 * Shortcut to add the disabled attribute and add the `disabled` class
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/disabled',[],function() {
  return function(disabled) {
    var $el = $(this.el);

    $el.attr('disabled', disabled)
      .toggleClass('disabled', disabled);
  };
});

/*! Hammer.JS - v1.1.3 - 2014-05-20
 * http://eightmedia.github.io/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(window, undefined) {
  

/**
 * @main
 * @module hammer
 *
 * @class Hammer
 * @static
 */

/**
 * Hammer, use this to create instances
 * ````
 * var hammertime = new Hammer(myElement);
 * ````
 *
 * @method Hammer
 * @param {HTMLElement} element
 * @param {Object} [options={}]
 * @return {Hammer.Instance}
 */
var Hammer = function Hammer(element, options) {
    return new Hammer.Instance(element, options || {});
};

/**
 * version, as defined in package.json
 * the value will be set at each build
 * @property VERSION
 * @final
 * @type {String}
 */
Hammer.VERSION = '1.1.3';

/**
 * default settings.
 * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
 * by setting it's name (like `swipe`) to false.
 * You can set the defaults for all instances by changing this object before creating an instance.
 * @example
 * ````
 *  Hammer.defaults.drag = false;
 *  Hammer.defaults.behavior.touchAction = 'pan-y';
 *  delete Hammer.defaults.behavior.userSelect;
 * ````
 * @property defaults
 * @type {Object}
 */
Hammer.defaults = {
    /**
     * this setting object adds styles and attributes to the element to prevent the browser from doing
     * its native behavior. The css properties are auto prefixed for the browsers when needed.
     * @property defaults.behavior
     * @type {Object}
     */
    behavior: {
        /**
         * Disables text selection to improve the dragging gesture. When the value is `none` it also sets
         * `onselectstart=false` for IE on the element. Mainly for desktop browsers.
         * @property defaults.behavior.userSelect
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Specifies whether and how a given region can be manipulated by the user (for instance, by panning or zooming).
         * Used by Chrome 35> and IE10>. By default this makes the element blocking any touch event.
         * @property defaults.behavior.touchAction
         * @type {String}
         * @default: 'pan-y'
         */
        touchAction: 'pan-y',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @property defaults.behavior.touchCallout
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @property defaults.behavior.contentZooming
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents.
         * Mainly for desktop browsers.
         * @property defaults.behavior.userDrag
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in Safari on iPhone. This property obeys the alpha value, if specified.
         *
         * If you don't specify an alpha value, Safari on iPhone applies a default alpha value
         * to the color. To disable tap highlighting, set the alpha value to 0 (invisible).
         * If you set the alpha value to 1.0 (opaque), the element is not visible when tapped.
         * @property defaults.behavior.tapHighlightColor
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

/**
 * hammer document where the base events are added at
 * @property DOCUMENT
 * @type {HTMLElement}
 * @default window.document
 */
Hammer.DOCUMENT = document;

/**
 * detect support for pointer events
 * @property HAS_POINTEREVENTS
 * @type {Boolean}
 */
Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

/**
 * detect support for touch events
 * @property HAS_TOUCHEVENTS
 * @type {Boolean}
 */
Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

/**
 * detect mobile browsers
 * @property IS_MOBILE
 * @type {Boolean}
 */
Hammer.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

/**
 * detect if we want to support mouseevents at all
 * @property NO_MOUSEEVENTS
 * @type {Boolean}
 */
Hammer.NO_MOUSEEVENTS = (Hammer.HAS_TOUCHEVENTS && Hammer.IS_MOBILE) || Hammer.HAS_POINTEREVENTS;

/**
 * interval in which Hammer recalculates current velocity/direction/angle in ms
 * @property CALCULATE_INTERVAL
 * @type {Number}
 * @default 25
 */
Hammer.CALCULATE_INTERVAL = 25;

/**
 * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
 * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
 * @property EVENT_TYPES
 * @private
 * @writeOnce
 * @type {Object}
 */
var EVENT_TYPES = {};

/**
 * direction strings, for safe comparisons
 * @property DIRECTION_DOWN|LEFT|UP|RIGHT
 * @final
 * @type {String}
 * @default 'down' 'left' 'up' 'right'
 */
var DIRECTION_DOWN = Hammer.DIRECTION_DOWN = 'down';
var DIRECTION_LEFT = Hammer.DIRECTION_LEFT = 'left';
var DIRECTION_UP = Hammer.DIRECTION_UP = 'up';
var DIRECTION_RIGHT = Hammer.DIRECTION_RIGHT = 'right';

/**
 * pointertype strings, for safe comparisons
 * @property POINTER_MOUSE|TOUCH|PEN
 * @final
 * @type {String}
 * @default 'mouse' 'touch' 'pen'
 */
var POINTER_MOUSE = Hammer.POINTER_MOUSE = 'mouse';
var POINTER_TOUCH = Hammer.POINTER_TOUCH = 'touch';
var POINTER_PEN = Hammer.POINTER_PEN = 'pen';

/**
 * eventtypes
 * @property EVENT_START|MOVE|END|RELEASE|TOUCH
 * @final
 * @type {String}
 * @default 'start' 'change' 'move' 'end' 'release' 'touch'
 */
var EVENT_START = Hammer.EVENT_START = 'start';
var EVENT_MOVE = Hammer.EVENT_MOVE = 'move';
var EVENT_END = Hammer.EVENT_END = 'end';
var EVENT_RELEASE = Hammer.EVENT_RELEASE = 'release';
var EVENT_TOUCH = Hammer.EVENT_TOUCH = 'touch';

/**
 * if the window events are set...
 * @property READY
 * @writeOnce
 * @type {Boolean}
 * @default false
 */
Hammer.READY = false;

/**
 * plugins namespace
 * @property plugins
 * @type {Object}
 */
Hammer.plugins = Hammer.plugins || {};

/**
 * gestures namespace
 * see `/gestures` for the definitions
 * @property gestures
 * @type {Object}
 */
Hammer.gestures = Hammer.gestures || {};

/**
 * setup events to detect gestures on the document
 * this function is called when creating an new instance
 * @private
 */
function setup() {
    if(Hammer.READY) {
        return;
    }

    // find what eventtypes we add listeners to
    Event.determineEventTypes();

    // Register all gestures inside Hammer.gestures
    Utils.each(Hammer.gestures, function(gesture) {
        Detection.register(gesture);
    });

    // Add touch events on the document
    Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);
    Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);

    // Hammer is ready...!
    Hammer.READY = true;
}

/**
 * @module hammer
 *
 * @class Utils
 * @static
 */
var Utils = Hammer.utils = {
    /**
     * extend method, could also be used for cloning when `dest` is an empty object.
     * changes the dest object
     * @method extend
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge=false]  do a merge
     * @return {Object} dest
     */
    extend: function extend(dest, src, merge) {
        for(var key in src) {
            if(!src.hasOwnProperty(key) || (dest[key] !== undefined && merge)) {
                continue;
            }
            dest[key] = src[key];
        }
        return dest;
    },

    /**
     * simple addEventListener wrapper
     * @method on
     * @param {HTMLElement} element
     * @param {String} type
     * @param {Function} handler
     */
    on: function on(element, type, handler) {
        element.addEventListener(type, handler, false);
    },

    /**
     * simple removeEventListener wrapper
     * @method off
     * @param {HTMLElement} element
     * @param {String} type
     * @param {Function} handler
     */
    off: function off(element, type, handler) {
        element.removeEventListener(type, handler, false);
    },

    /**
     * forEach over arrays and objects
     * @method each
     * @param {Object|Array} obj
     * @param {Function} iterator
     * @param {any} iterator.item
     * @param {Number} iterator.index
     * @param {Object|Array} iterator.obj the source object
     * @param {Object} context value to use as `this` in the iterator
     */
    each: function each(obj, iterator, context) {
        var i, len;

        // native forEach on arrays
        if('forEach' in obj) {
            obj.forEach(iterator, context);
        // arrays
        } else if(obj.length !== undefined) {
            for(i = 0, len = obj.length; i < len; i++) {
                if(iterator.call(context, obj[i], i, obj) === false) {
                    return;
                }
            }
        // objects
        } else {
            for(i in obj) {
                if(obj.hasOwnProperty(i) &&
                    iterator.call(context, obj[i], i, obj) === false) {
                    return;
                }
            }
        }
    },

    /**
     * find if a string contains the string using indexOf
     * @method inStr
     * @param {String} src
     * @param {String} find
     * @return {Boolean} found
     */
    inStr: function inStr(src, find) {
        return src.indexOf(find) > -1;
    },

    /**
     * find if a array contains the object using indexOf or a simple polyfill
     * @method inArray
     * @param {String} src
     * @param {String} find
     * @return {Boolean|Number} false when not found, or the index
     */
    inArray: function inArray(src, find) {
        if(src.indexOf) {
            var index = src.indexOf(find);
            return (index === -1) ? false : index;
        } else {
            for(var i = 0, len = src.length; i < len; i++) {
                if(src[i] === find) {
                    return i;
                }
            }
            return false;
        }
    },

    /**
     * convert an array-like object (`arguments`, `touchlist`) to an array
     * @method toArray
     * @param {Object} obj
     * @return {Array}
     */
    toArray: function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    },

    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    hasParent: function hasParent(node, parent) {
        while(node) {
            if(node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    },

    /**
     * get the center of all the touches
     * @method getCenter
     * @param {Array} touches
     * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
     */
    getCenter: function getCenter(touches) {
        var pageX = [],
            pageY = [],
            clientX = [],
            clientY = [],
            min = Math.min,
            max = Math.max;

        // no need to loop when only one touch
        if(touches.length === 1) {
            return {
                pageX: touches[0].pageX,
                pageY: touches[0].pageY,
                clientX: touches[0].clientX,
                clientY: touches[0].clientY
            };
        }

        Utils.each(touches, function(touch) {
            pageX.push(touch.pageX);
            pageY.push(touch.pageY);
            clientX.push(touch.clientX);
            clientY.push(touch.clientY);
        });

        return {
            pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
            pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
            clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
            clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
        };
    },

    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @method getVelocity
     * @param {Number} deltaTime
     * @param {Number} deltaX
     * @param {Number} deltaY
     * @return {Object} velocity `x` and `y`
     */
    getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
        return {
            x: Math.abs(deltaX / deltaTime) || 0,
            y: Math.abs(deltaY / deltaTime) || 0
        };
    },

    /**
     * calculate the angle between two coordinates
     * @method getAngle
     * @param {Touch} touch1
     * @param {Touch} touch2
     * @return {Number} angle
     */
    getAngle: function getAngle(touch1, touch2) {
        var x = touch2.clientX - touch1.clientX,
            y = touch2.clientY - touch1.clientY;

        return Math.atan2(y, x) * 180 / Math.PI;
    },

    /**
     * do a small comparision to get the direction between two touches.
     * @method getDirection
     * @param {Touch} touch1
     * @param {Touch} touch2
     * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
     */
    getDirection: function getDirection(touch1, touch2) {
        var x = Math.abs(touch1.clientX - touch2.clientX),
            y = Math.abs(touch1.clientY - touch2.clientY);

        if(x >= y) {
            return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    },

    /**
     * calculate the distance between two touches
     * @method getDistance
     * @param {Touch}touch1
     * @param {Touch} touch2
     * @return {Number} distance
     */
    getDistance: function getDistance(touch1, touch2) {
        var x = touch2.clientX - touch1.clientX,
            y = touch2.clientY - touch1.clientY;

        return Math.sqrt((x * x) + (y * y));
    },

    /**
     * calculate the scale factor between two touchLists
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @method getScale
     * @param {Array} start array of touches
     * @param {Array} end array of touches
     * @return {Number} scale
     */
    getScale: function getScale(start, end) {
        // need two fingers...
        if(start.length >= 2 && end.length >= 2) {
            return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
        }
        return 1;
    },

    /**
     * calculate the rotation degrees between two touchLists
     * @method getRotation
     * @param {Array} start array of touches
     * @param {Array} end array of touches
     * @return {Number} rotation
     */
    getRotation: function getRotation(start, end) {
        // need two fingers
        if(start.length >= 2 && end.length >= 2) {
            return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
        }
        return 0;
    },

    /**
     * find out if the direction is vertical   *
     * @method isVertical
     * @param {String} direction matches `DIRECTION_UP|DOWN`
     * @return {Boolean} is_vertical
     */
    isVertical: function isVertical(direction) {
        return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
    },

    /**
     * set css properties with their prefixes
     * @param {HTMLElement} element
     * @param {String} prop
     * @param {String} value
     * @param {Boolean} [toggle=true]
     * @return {Boolean}
     */
    setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
        var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
        prop = Utils.toCamelCase(prop);

        for(var i = 0; i < prefixes.length; i++) {
            var p = prop;
            // prefixes
            if(prefixes[i]) {
                p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
            }

            // test the style
            if(p in element.style) {
                element.style[p] = (toggle == null || toggle) && value || '';
                break;
            }
        }
    },

    /**
     * toggle browser default behavior by setting css properties.
     * `userSelect='none'` also sets `element.onselectstart` to false
     * `userDrag='none'` also sets `element.ondragstart` to false
     *
     * @method toggleBehavior
     * @param {HtmlElement} element
     * @param {Object} props
     * @param {Boolean} [toggle=true]
     */
    toggleBehavior: function toggleBehavior(element, props, toggle) {
        if(!props || !element || !element.style) {
            return;
        }

        // set the css properties
        Utils.each(props, function(value, prop) {
            Utils.setPrefixedCss(element, prop, value, toggle);
        });

        var falseFn = toggle && function() {
            return false;
        };

        // also the disable onselectstart
        if(props.userSelect == 'none') {
            element.onselectstart = falseFn;
        }
        // and disable ondragstart
        if(props.userDrag == 'none') {
            element.ondragstart = falseFn;
        }
    },

    /**
     * convert a string with underscores to camelCase
     * so prevent_default becomes preventDefault
     * @param {String} str
     * @return {String} camelCaseStr
     */
    toCamelCase: function toCamelCase(str) {
        return str.replace(/[_-]([a-z])/g, function(s) {
            return s[1].toUpperCase();
        });
    }
};


/**
 * @module hammer
 */
/**
 * @class Event
 * @static
 */
var Event = Hammer.event = {
    /**
     * when touch events have been fired, this is true
     * this is used to stop mouse events
     * @property prevent_mouseevents
     * @private
     * @type {Boolean}
     */
    preventMouseEvents: false,

    /**
     * if EVENT_START has been fired
     * @property started
     * @private
     * @type {Boolean}
     */
    started: false,

    /**
     * when the mouse is hold down, this is true
     * @property should_detect
     * @private
     * @type {Boolean}
     */
    shouldDetect: false,

    /**
     * simple event binder with a hook and support for multiple types
     * @method on
     * @param {HTMLElement} element
     * @param {String} type
     * @param {Function} handler
     * @param {Function} [hook]
     * @param {Object} hook.type
     */
    on: function on(element, type, handler, hook) {
        var types = type.split(' ');
        Utils.each(types, function(type) {
            Utils.on(element, type, handler);
            hook && hook(type);
        });
    },

    /**
     * simple event unbinder with a hook and support for multiple types
     * @method off
     * @param {HTMLElement} element
     * @param {String} type
     * @param {Function} handler
     * @param {Function} [hook]
     * @param {Object} hook.type
     */
    off: function off(element, type, handler, hook) {
        var types = type.split(' ');
        Utils.each(types, function(type) {
            Utils.off(element, type, handler);
            hook && hook(type);
        });
    },

    /**
     * the core touch event handler.
     * this finds out if we should to detect gestures
     * @method onTouch
     * @param {HTMLElement} element
     * @param {String} eventType matches `EVENT_START|MOVE|END`
     * @param {Function} handler
     * @return onTouchHandler {Function} the core event handler
     */
    onTouch: function onTouch(element, eventType, handler) {
        var self = this;

        var onTouchHandler = function onTouchHandler(ev) {
            var srcType = ev.type.toLowerCase(),
                isPointer = Hammer.HAS_POINTEREVENTS,
                isMouse = Utils.inStr(srcType, 'mouse'),
                triggerType;

            // if we are in a mouseevent, but there has been a touchevent triggered in this session
            // we want to do nothing. simply break out of the event.
            if(isMouse && self.preventMouseEvents) {
                return;

            // mousebutton must be down
            } else if(isMouse && eventType == EVENT_START && ev.button === 0) {
                self.preventMouseEvents = false;
                self.shouldDetect = true;
            } else if(isPointer && eventType == EVENT_START) {
                self.shouldDetect = (ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev));
            // just a valid start event, but no mouse
            } else if(!isMouse && eventType == EVENT_START) {
                self.preventMouseEvents = true;
                self.shouldDetect = true;
            }

            // update the pointer event before entering the detection
            if(isPointer && eventType != EVENT_END) {
                PointerEvent.updatePointer(eventType, ev);
            }

            // we are in a touch/down state, so allowed detection of gestures
            if(self.shouldDetect) {
                triggerType = self.doDetect.call(self, ev, eventType, element, handler);
            }

            // ...and we are done with the detection
            // so reset everything to start each detection totally fresh
            if(triggerType == EVENT_END) {
                self.preventMouseEvents = false;
                self.shouldDetect = false;
                PointerEvent.reset();
            // update the pointerevent object after the detection
            }

            if(isPointer && eventType == EVENT_END) {
                PointerEvent.updatePointer(eventType, ev);
            }
        };

        this.on(element, EVENT_TYPES[eventType], onTouchHandler);
        return onTouchHandler;
    },

    /**
     * the core detection method
     * this finds out what hammer-touch-events to trigger
     * @method doDetect
     * @param {Object} ev
     * @param {String} eventType matches `EVENT_START|MOVE|END`
     * @param {HTMLElement} element
     * @param {Function} handler
     * @return {String} triggerType matches `EVENT_START|MOVE|END`
     */
    doDetect: function doDetect(ev, eventType, element, handler) {
        var touchList = this.getTouchList(ev, eventType);
        var touchListLength = touchList.length;
        var triggerType = eventType;
        var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
        var changedLength = touchListLength;

        // at each touchstart-like event we want also want to trigger a TOUCH event...
        if(eventType == EVENT_START) {
            triggerChange = EVENT_TOUCH;
        // ...the same for a touchend-like event
        } else if(eventType == EVENT_END) {
            triggerChange = EVENT_RELEASE;

            // keep track of how many touches have been removed
            changedLength = touchList.length - ((ev.changedTouches) ? ev.changedTouches.length : 1);
        }

        // after there are still touches on the screen,
        // we just want to trigger a MOVE event. so change the START or END to a MOVE
        // but only after detection has been started, the first time we actualy want a START
        if(changedLength > 0 && this.started) {
            triggerType = EVENT_MOVE;
        }

        // detection has been started, we keep track of this, see above
        this.started = true;

        // generate some event data, some basic information
        var evData = this.collectEventData(element, triggerType, touchList, ev);

        // trigger the triggerType event before the change (TOUCH, RELEASE) events
        // but the END event should be at last
        if(eventType != EVENT_END) {
            handler.call(Detection, evData);
        }

        // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
        if(triggerChange) {
            evData.changedLength = changedLength;
            evData.eventType = triggerChange;

            handler.call(Detection, evData);

            evData.eventType = triggerType;
            delete evData.changedLength;
        }

        // trigger the END event
        if(triggerType == EVENT_END) {
            handler.call(Detection, evData);

            // ...and we are done with the detection
            // so reset everything to start each detection totally fresh
            this.started = false;
        }

        return triggerType;
    },

    /**
     * we have different events for each device/browser
     * determine what we need and set them in the EVENT_TYPES constant
     * the `onTouch` method is bind to these properties.
     * @method determineEventTypes
     * @return {Object} events
     */
    determineEventTypes: function determineEventTypes() {
        var types;
        if(Hammer.HAS_POINTEREVENTS) {
            if(window.PointerEvent) {
                types = [
                    'pointerdown',
                    'pointermove',
                    'pointerup pointercancel lostpointercapture'
                ];
            } else {
                types = [
                    'MSPointerDown',
                    'MSPointerMove',
                    'MSPointerUp MSPointerCancel MSLostPointerCapture'
                ];
            }
        } else if(Hammer.NO_MOUSEEVENTS) {
            types = [
                'touchstart',
                'touchmove',
                'touchend touchcancel'
            ];
        } else {
            types = [
                'touchstart mousedown',
                'touchmove mousemove',
                'touchend touchcancel mouseup'
            ];
        }

        EVENT_TYPES[EVENT_START] = types[0];
        EVENT_TYPES[EVENT_MOVE] = types[1];
        EVENT_TYPES[EVENT_END] = types[2];
        return EVENT_TYPES;
    },

    /**
     * create touchList depending on the event
     * @method getTouchList
     * @param {Object} ev
     * @param {String} eventType
     * @return {Array} touches
     */
    getTouchList: function getTouchList(ev, eventType) {
        // get the fake pointerEvent touchlist
        if(Hammer.HAS_POINTEREVENTS) {
            return PointerEvent.getTouchList();
        }

        // get the touchlist
        if(ev.touches) {
            if(eventType == EVENT_MOVE) {
                return ev.touches;
            }

            var identifiers = [];
            var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
            var touchList = [];

            Utils.each(concat, function(touch) {
                if(Utils.inArray(identifiers, touch.identifier) === false) {
                    touchList.push(touch);
                }
                identifiers.push(touch.identifier);
            });

            return touchList;
        }

        // make fake touchList from mouse position
        ev.identifier = 1;
        return [ev];
    },

    /**
     * collect basic event data
     * @method collectEventData
     * @param {HTMLElement} element
     * @param {String} eventType matches `EVENT_START|MOVE|END`
     * @param {Array} touches
     * @param {Object} ev
     * @return {Object} ev
     */
    collectEventData: function collectEventData(element, eventType, touches, ev) {
        // find out pointerType
        var pointerType = POINTER_TOUCH;
        if(Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
            pointerType = POINTER_MOUSE;
        } else if(PointerEvent.matchType(POINTER_PEN, ev)) {
            pointerType = POINTER_PEN;
        }

        return {
            center: Utils.getCenter(touches),
            timeStamp: Date.now(),
            target: ev.target,
            touches: touches,
            eventType: eventType,
            pointerType: pointerType,
            srcEvent: ev,

            /**
             * prevent the browser default actions
             * mostly used to disable scrolling of the browser
             */
            preventDefault: function() {
                var srcEvent = this.srcEvent;
                srcEvent.preventManipulation && srcEvent.preventManipulation();
                srcEvent.preventDefault && srcEvent.preventDefault();
            },

            /**
             * stop bubbling the event up to its parents
             */
            stopPropagation: function() {
                this.srcEvent.stopPropagation();
            },

            /**
             * immediately stop gesture detection
             * might be useful after a swipe was detected
             * @return {*}
             */
            stopDetect: function() {
                return Detection.stopDetect();
            }
        };
    }
};


/**
 * @module hammer
 *
 * @class PointerEvent
 * @static
 */
var PointerEvent = Hammer.PointerEvent = {
    /**
     * holds all pointers, by `identifier`
     * @property pointers
     * @type {Object}
     */
    pointers: {},

    /**
     * get the pointers as an array
     * @method getTouchList
     * @return {Array} touchlist
     */
    getTouchList: function getTouchList() {
        var touchlist = [];
        // we can use forEach since pointerEvents only is in IE10
        Utils.each(this.pointers, function(pointer) {
            touchlist.push(pointer);
        });
        return touchlist;
    },

    /**
     * update the position of a pointer
     * @method updatePointer
     * @param {String} eventType matches `EVENT_START|MOVE|END`
     * @param {Object} pointerEvent
     */
    updatePointer: function updatePointer(eventType, pointerEvent) {
        if(eventType == EVENT_END || (eventType != EVENT_END && pointerEvent.buttons !== 1)) {
            delete this.pointers[pointerEvent.pointerId];
        } else {
            pointerEvent.identifier = pointerEvent.pointerId;
            this.pointers[pointerEvent.pointerId] = pointerEvent;
        }
    },

    /**
     * check if ev matches pointertype
     * @method matchType
     * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
     * @param {PointerEvent} ev
     */
    matchType: function matchType(pointerType, ev) {
        if(!ev.pointerType) {
            return false;
        }

        var pt = ev.pointerType,
            types = {};

        types[POINTER_MOUSE] = (pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE));
        types[POINTER_TOUCH] = (pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH));
        types[POINTER_PEN] = (pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN));
        return types[pointerType];
    },

    /**
     * reset the stored pointers
     * @method reset
     */
    reset: function resetList() {
        this.pointers = {};
    }
};


/**
 * @module hammer
 *
 * @class Detection
 * @static
 */
var Detection = Hammer.detection = {
    // contains all registred Hammer.gestures in the correct order
    gestures: [],

    // data of the current Hammer.gesture detection session
    current: null,

    // the previous Hammer.gesture session data
    // is a full clone of the previous gesture.current object
    previous: null,

    // when this becomes true, no gestures are fired
    stopped: false,

    /**
     * start Hammer.gesture detection
     * @method startDetect
     * @param {Hammer.Instance} inst
     * @param {Object} eventData
     */
    startDetect: function startDetect(inst, eventData) {
        // already busy with a Hammer.gesture detection on an element
        if(this.current) {
            return;
        }

        this.stopped = false;

        // holds current session
        this.current = {
            inst: inst, // reference to HammerInstance we're working for
            startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
            lastEvent: false, // last eventData
            lastCalcEvent: false, // last eventData for calculations.
            futureCalcEvent: false, // last eventData for calculations.
            lastCalcData: {}, // last lastCalcData
            name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
        };

        this.detect(eventData);
    },

    /**
     * Hammer.gesture detection
     * @method detect
     * @param {Object} eventData
     * @return {any}
     */
    detect: function detect(eventData) {
        if(!this.current || this.stopped) {
            return;
        }

        // extend event data with calculations about scale, distance etc
        eventData = this.extendEventData(eventData);

        // hammer instance and instance options
        var inst = this.current.inst,
            instOptions = inst.options;

        // call Hammer.gesture handlers
        Utils.each(this.gestures, function triggerGesture(gesture) {
            // only when the instance options have enabled this gesture
            if(!this.stopped && inst.enabled && instOptions[gesture.name]) {
                gesture.handler.call(gesture, eventData, inst);
            }
        }, this);

        // store as previous event event
        if(this.current) {
            this.current.lastEvent = eventData;
        }

        if(eventData.eventType == EVENT_END) {
            this.stopDetect();
        }

        return eventData;
    },

    /**
     * clear the Hammer.gesture vars
     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
     * to stop other Hammer.gestures from being fired
     * @method stopDetect
     */
    stopDetect: function stopDetect() {
        // clone current data to the store as the previous gesture
        // used for the double tap gesture, since this is an other gesture detect session
        this.previous = Utils.extend({}, this.current);

        // reset the current
        this.current = null;
        this.stopped = true;
    },

    /**
     * calculate velocity, angle and direction
     * @method getVelocityData
     * @param {Object} ev
     * @param {Object} center
     * @param {Number} deltaTime
     * @param {Number} deltaX
     * @param {Number} deltaY
     */
    getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
        var cur = this.current,
            recalc = false,
            calcEv = cur.lastCalcEvent,
            calcData = cur.lastCalcData;

        if(calcEv && ev.timeStamp - calcEv.timeStamp > Hammer.CALCULATE_INTERVAL) {
            center = calcEv.center;
            deltaTime = ev.timeStamp - calcEv.timeStamp;
            deltaX = ev.center.clientX - calcEv.center.clientX;
            deltaY = ev.center.clientY - calcEv.center.clientY;
            recalc = true;
        }

        if(ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
            cur.futureCalcEvent = ev;
        }

        if(!cur.lastCalcEvent || recalc) {
            calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
            calcData.angle = Utils.getAngle(center, ev.center);
            calcData.direction = Utils.getDirection(center, ev.center);

            cur.lastCalcEvent = cur.futureCalcEvent || ev;
            cur.futureCalcEvent = ev;
        }

        ev.velocityX = calcData.velocity.x;
        ev.velocityY = calcData.velocity.y;
        ev.interimAngle = calcData.angle;
        ev.interimDirection = calcData.direction;
    },

    /**
     * extend eventData for Hammer.gestures
     * @method extendEventData
     * @param {Object} ev
     * @return {Object} ev
     */
    extendEventData: function extendEventData(ev) {
        var cur = this.current,
            startEv = cur.startEvent,
            lastEv = cur.lastEvent || startEv;

        // update the start touchlist to calculate the scale/rotation
        if(ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
            startEv.touches = [];
            Utils.each(ev.touches, function(touch) {
                startEv.touches.push({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            });
        }

        var deltaTime = ev.timeStamp - startEv.timeStamp,
            deltaX = ev.center.clientX - startEv.center.clientX,
            deltaY = ev.center.clientY - startEv.center.clientY;

        this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

        Utils.extend(ev, {
            startEvent: startEv,

            deltaTime: deltaTime,
            deltaX: deltaX,
            deltaY: deltaY,

            distance: Utils.getDistance(startEv.center, ev.center),
            angle: Utils.getAngle(startEv.center, ev.center),
            direction: Utils.getDirection(startEv.center, ev.center),
            scale: Utils.getScale(startEv.touches, ev.touches),
            rotation: Utils.getRotation(startEv.touches, ev.touches)
        });

        return ev;
    },

    /**
     * register new gesture
     * @method register
     * @param {Object} gesture object, see `gestures/` for documentation
     * @return {Array} gestures
     */
    register: function register(gesture) {
        // add an enable gesture options if there is no given
        var options = gesture.defaults || {};
        if(options[gesture.name] === undefined) {
            options[gesture.name] = true;
        }

        // extend Hammer default options with the Hammer.gesture options
        Utils.extend(Hammer.defaults, options, true);

        // set its index
        gesture.index = gesture.index || 1000;

        // add Hammer.gesture to the list
        this.gestures.push(gesture);

        // sort the list by index
        this.gestures.sort(function(a, b) {
            if(a.index < b.index) {
                return -1;
            }
            if(a.index > b.index) {
                return 1;
            }
            return 0;
        });

        return this.gestures;
    }
};


/**
 * @module hammer
 */

/**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 *
 * @class Instance
 * @constructor
 * @param {HTMLElement} element
 * @param {Object} [options={}] options are merged with `Hammer.defaults`
 * @return {Hammer.Instance}
 */
Hammer.Instance = function(element, options) {
    var self = this;

    // setup HammerJS window events and register all gestures
    // this also sets up the default options
    setup();

    /**
     * @property element
     * @type {HTMLElement}
     */
    this.element = element;

    /**
     * @property enabled
     * @type {Boolean}
     * @protected
     */
    this.enabled = true;

    /**
     * options, merged with the defaults
     * options with an _ are converted to camelCase
     * @property options
     * @type {Object}
     */
    Utils.each(options, function(value, name) {
        delete options[name];
        options[Utils.toCamelCase(name)] = value;
    });

    this.options = Utils.extend(Utils.extend({}, Hammer.defaults), options || {});

    // add some css to the element to prevent the browser from doing its native behavoir
    if(this.options.behavior) {
        Utils.toggleBehavior(this.element, this.options.behavior, true);
    }

    /**
     * event start handler on the element to start the detection
     * @property eventStartHandler
     * @type {Object}
     */
    this.eventStartHandler = Event.onTouch(element, EVENT_START, function(ev) {
        if(self.enabled && ev.eventType == EVENT_START) {
            Detection.startDetect(self, ev);
        } else if(ev.eventType == EVENT_TOUCH) {
            Detection.detect(ev);
        }
    });

    /**
     * keep a list of user event handlers which needs to be removed when calling 'dispose'
     * @property eventHandlers
     * @type {Array}
     */
    this.eventHandlers = [];
};

Hammer.Instance.prototype = {
    /**
     * bind events to the instance
     * @method on
     * @chainable
     * @param {String} gestures multiple gestures by splitting with a space
     * @param {Function} handler
     * @param {Object} handler.ev event object
     */
    on: function onEvent(gestures, handler) {
        var self = this;
        Event.on(self.element, gestures, handler, function(type) {
            self.eventHandlers.push({ gesture: type, handler: handler });
        });
        return self;
    },

    /**
     * unbind events to the instance
     * @method off
     * @chainable
     * @param {String} gestures
     * @param {Function} handler
     */
    off: function offEvent(gestures, handler) {
        var self = this;

        Event.off(self.element, gestures, handler, function(type) {
            var index = Utils.inArray({ gesture: type, handler: handler });
            if(index !== false) {
                self.eventHandlers.splice(index, 1);
            }
        });
        return self;
    },

    /**
     * trigger gesture event
     * @method trigger
     * @chainable
     * @param {String} gesture
     * @param {Object} [eventData]
     */
    trigger: function triggerEvent(gesture, eventData) {
        // optional
        if(!eventData) {
            eventData = {};
        }

        // create DOM event
        var event = Hammer.DOCUMENT.createEvent('Event');
        event.initEvent(gesture, true, true);
        event.gesture = eventData;

        // trigger on the target if it is in the instance element,
        // this is for event delegation tricks
        var element = this.element;
        if(Utils.hasParent(eventData.target, element)) {
            element = eventData.target;
        }

        element.dispatchEvent(event);
        return this;
    },

    /**
     * enable of disable hammer.js detection
     * @method enable
     * @chainable
     * @param {Boolean} state
     */
    enable: function enable(state) {
        this.enabled = state;
        return this;
    },

    /**
     * dispose this hammer instance
     * @method dispose
     * @return {Null}
     */
    dispose: function dispose() {
        var i, eh;

        // undo all changes made by stop_browser_behavior
        Utils.toggleBehavior(this.element, this.options.behavior, false);

        // unbind all custom event handlers
        for(i = -1; (eh = this.eventHandlers[++i]);) {
            Utils.off(this.element, eh.gesture, eh.handler);
        }

        this.eventHandlers = [];

        // unbind the start event listener
        Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

        return null;
    }
};


/**
 * @module gestures
 */
/**
 * Move with x fingers (default 1) around on the page.
 * Preventing the default browser behavior is a good way to improve feel and working.
 * ````
 *  hammertime.on("drag", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Drag
 * @static
 */
/**
 * @event drag
 * @param {Object} ev
 */
/**
 * @event dragstart
 * @param {Object} ev
 */
/**
 * @event dragend
 * @param {Object} ev
 */
/**
 * @event drapleft
 * @param {Object} ev
 */
/**
 * @event dragright
 * @param {Object} ev
 */
/**
 * @event dragup
 * @param {Object} ev
 */
/**
 * @event dragdown
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function(name) {
    var triggered = false;

    function dragGesture(ev, inst) {
        var cur = Detection.current;

        // max touches
        if(inst.options.dragMaxTouches > 0 &&
            ev.touches.length > inst.options.dragMaxTouches) {
            return;
        }

        switch(ev.eventType) {
            case EVENT_START:
                triggered = false;
                break;

            case EVENT_MOVE:
                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(ev.distance < inst.options.dragMinDistance &&
                    cur.name != name) {
                    return;
                }

                var startCenter = cur.startEvent.center;

                // we are dragging!
                if(cur.name != name) {
                    cur.name = name;
                    if(inst.options.dragDistanceCorrection && ev.distance > 0) {
                        // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
                        // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
                        // It might be useful to save the original start point somewhere
                        var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
                        startCenter.pageX += ev.deltaX * factor;
                        startCenter.pageY += ev.deltaY * factor;
                        startCenter.clientX += ev.deltaX * factor;
                        startCenter.clientY += ev.deltaY * factor;

                        // recalculate event data using new start point
                        ev = Detection.extendEventData(ev);
                    }
                }

                // lock drag to axis?
                if(cur.lastEvent.dragLockToAxis ||
                    ( inst.options.dragLockToAxis &&
                        inst.options.dragLockMinDistance <= ev.distance
                        )) {
                    ev.dragLockToAxis = true;
                }

                // keep direction on the axis that the drag gesture started on
                var lastDirection = cur.lastEvent.direction;
                if(ev.dragLockToAxis && lastDirection !== ev.direction) {
                    if(Utils.isVertical(lastDirection)) {
                        ev.direction = (ev.deltaY < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                    } else {
                        ev.direction = (ev.deltaX < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    }
                }

                // first time, trigger dragstart event
                if(!triggered) {
                    inst.trigger(name + 'start', ev);
                    triggered = true;
                }

                // trigger events
                inst.trigger(name, ev);
                inst.trigger(name + ev.direction, ev);

                var isVertical = Utils.isVertical(ev.direction);

                // block the browser events
                if((inst.options.dragBlockVertical && isVertical) ||
                    (inst.options.dragBlockHorizontal && !isVertical)) {
                    ev.preventDefault();
                }
                break;

            case EVENT_RELEASE:
                if(triggered && ev.changedLength <= inst.options.dragMaxTouches) {
                    inst.trigger(name + 'end', ev);
                    triggered = false;
                }
                break;

            case EVENT_END:
                triggered = false;
                break;
        }
    }

    Hammer.gestures.Drag = {
        name: name,
        index: 50,
        handler: dragGesture,
        defaults: {
            /**
             * minimal movement that have to be made before the drag event gets triggered
             * @property dragMinDistance
             * @type {Number}
             * @default 10
             */
            dragMinDistance: 10,

            /**
             * Set dragDistanceCorrection to true to make the starting point of the drag
             * be calculated from where the drag was triggered, not from where the touch started.
             * Useful to avoid a jerk-starting drag, which can make fine-adjustments
             * through dragging difficult, and be visually unappealing.
             * @property dragDistanceCorrection
             * @type {Boolean}
             * @default true
             */
            dragDistanceCorrection: true,

            /**
             * set 0 for unlimited, but this can conflict with transform
             * @property dragMaxTouches
             * @type {Number}
             * @default 1
             */
            dragMaxTouches: 1,

            /**
             * prevent default browser behavior when dragging occurs
             * be careful with it, it makes the element a blocking element
             * when you are using the drag gesture, it is a good practice to set this true
             * @property dragBlockHorizontal
             * @type {Boolean}
             * @default false
             */
            dragBlockHorizontal: false,

            /**
             * same as `dragBlockHorizontal`, but for vertical movement
             * @property dragBlockVertical
             * @type {Boolean}
             * @default false
             */
            dragBlockVertical: false,

            /**
             * dragLockToAxis keeps the drag gesture on the axis that it started on,
             * It disallows vertical directions if the initial direction was horizontal, and vice versa.
             * @property dragLockToAxis
             * @type {Boolean}
             * @default false
             */
            dragLockToAxis: false,

            /**
             * drag lock only kicks in when distance > dragLockMinDistance
             * This way, locking occurs only when the distance has become large enough to reliably determine the direction
             * @property dragLockMinDistance
             * @type {Number}
             * @default 25
             */
            dragLockMinDistance: 25
        }
    };
})('drag');

/**
 * @module gestures
 */
/**
 * trigger a simple gesture event, so you can do anything in your handler.
 * only usable if you know what your doing...
 *
 * @class Gesture
 * @static
 */
/**
 * @event gesture
 * @param {Object} ev
 */
Hammer.gestures.Gesture = {
    name: 'gesture',
    index: 1337,
    handler: function releaseGesture(ev, inst) {
        inst.trigger(this.name, ev);
    }
};

/**
 * @module gestures
 */
/**
 * Touch stays at the same place for x time
 *
 * @class Hold
 * @static
 */
/**
 * @event hold
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function(name) {
    var timer;

    function holdGesture(ev, inst) {
        var options = inst.options,
            current = Detection.current;

        switch(ev.eventType) {
            case EVENT_START:
                clearTimeout(timer);

                // set the gesture so we can check in the timeout if it still is
                current.name = name;

                // set timer and if after the timeout it still is hold,
                // we trigger the hold event
                timer = setTimeout(function() {
                    if(current && current.name == name) {
                        inst.trigger(name, ev);
                    }
                }, options.holdTimeout);
                break;

            case EVENT_MOVE:
                if(ev.distance > options.holdThreshold) {
                    clearTimeout(timer);
                }
                break;

            case EVENT_RELEASE:
                clearTimeout(timer);
                break;
        }
    }

    Hammer.gestures.Hold = {
        name: name,
        index: 10,
        defaults: {
            /**
             * @property holdTimeout
             * @type {Number}
             * @default 500
             */
            holdTimeout: 500,

            /**
             * movement allowed while holding
             * @property holdThreshold
             * @type {Number}
             * @default 2
             */
            holdThreshold: 2
        },
        handler: holdGesture
    };
})('hold');

/**
 * @module gestures
 */
/**
 * when a touch is being released from the page
 *
 * @class Release
 * @static
 */
/**
 * @event release
 * @param {Object} ev
 */
Hammer.gestures.Release = {
    name: 'release',
    index: Infinity,
    handler: function releaseGesture(ev, inst) {
        if(ev.eventType == EVENT_RELEASE) {
            inst.trigger(this.name, ev);
        }
    }
};

/**
 * @module gestures
 */
/**
 * triggers swipe events when the end velocity is above the threshold
 * for best usage, set `preventDefault` (on the drag gesture) to `true`
 * ````
 *  hammertime.on("dragleft swipeleft", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Swipe
 * @static
 */
/**
 * @event swipe
 * @param {Object} ev
 */
/**
 * @event swipeleft
 * @param {Object} ev
 */
/**
 * @event swiperight
 * @param {Object} ev
 */
/**
 * @event swipeup
 * @param {Object} ev
 */
/**
 * @event swipedown
 * @param {Object} ev
 */
Hammer.gestures.Swipe = {
    name: 'swipe',
    index: 40,
    defaults: {
        /**
         * @property swipeMinTouches
         * @type {Number}
         * @default 1
         */
        swipeMinTouches: 1,

        /**
         * @property swipeMaxTouches
         * @type {Number}
         * @default 1
         */
        swipeMaxTouches: 1,

        /**
         * horizontal swipe velocity
         * @property swipeVelocityX
         * @type {Number}
         * @default 0.6
         */
        swipeVelocityX: 0.6,

        /**
         * vertical swipe velocity
         * @property swipeVelocityY
         * @type {Number}
         * @default 0.6
         */
        swipeVelocityY: 0.6
    },

    handler: function swipeGesture(ev, inst) {
        if(ev.eventType == EVENT_RELEASE) {
            var touches = ev.touches.length,
                options = inst.options;

            // max touches
            if(touches < options.swipeMinTouches ||
                touches > options.swipeMaxTouches) {
                return;
            }

            // when the distance we moved is too small we skip this gesture
            // or we can be already in dragging
            if(ev.velocityX > options.swipeVelocityX ||
                ev.velocityY > options.swipeVelocityY) {
                // trigger swipe events
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
            }
        }
    }
};

/**
 * @module gestures
 */
/**
 * Single tap and a double tap on a place
 *
 * @class Tap
 * @static
 */
/**
 * @event tap
 * @param {Object} ev
 */
/**
 * @event doubletap
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function(name) {
    var hasMoved = false;

    function tapGesture(ev, inst) {
        var options = inst.options,
            current = Detection.current,
            prev = Detection.previous,
            sincePrev,
            didDoubleTap;

        switch(ev.eventType) {
            case EVENT_START:
                hasMoved = false;
                break;

            case EVENT_MOVE:
                hasMoved = hasMoved || (ev.distance > options.tapMaxDistance);
                break;

            case EVENT_END:
                if(!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
                    // previous gesture, for the double tap since these are two different gesture detections
                    sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
                    didDoubleTap = false;

                    // check if double tap
                    if(prev && prev.name == name &&
                        (sincePrev && sincePrev < options.doubleTapInterval) &&
                        ev.distance < options.doubleTapDistance) {
                        inst.trigger('doubletap', ev);
                        didDoubleTap = true;
                    }

                    // do a single tap
                    if(!didDoubleTap || options.tapAlways) {
                        current.name = name;
                        inst.trigger(current.name, ev);
                    }
                }
                break;
        }
    }

    Hammer.gestures.Tap = {
        name: name,
        index: 100,
        handler: tapGesture,
        defaults: {
            /**
             * max time of a tap, this is for the slow tappers
             * @property tapMaxTime
             * @type {Number}
             * @default 250
             */
            tapMaxTime: 250,

            /**
             * max distance of movement of a tap, this is for the slow tappers
             * @property tapMaxDistance
             * @type {Number}
             * @default 10
             */
            tapMaxDistance: 10,

            /**
             * always trigger the `tap` event, even while double-tapping
             * @property tapAlways
             * @type {Boolean}
             * @default true
             */
            tapAlways: true,

            /**
             * max distance between two taps
             * @property doubleTapDistance
             * @type {Number}
             * @default 20
             */
            doubleTapDistance: 20,

            /**
             * max time between two taps
             * @property doubleTapInterval
             * @type {Number}
             * @default 300
             */
            doubleTapInterval: 300
        }
    };
})('tap');

/**
 * @module gestures
 */
/**
 * when a touch is being touched at the page
 *
 * @class Touch
 * @static
 */
/**
 * @event touch
 * @param {Object} ev
 */
Hammer.gestures.Touch = {
    name: 'touch',
    index: -Infinity,
    defaults: {
        /**
         * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
         * but it improves gestures like transforming and dragging.
         * be careful with using this, it can be very annoying for users to be stuck on the page
         * @property preventDefault
         * @type {Boolean}
         * @default false
         */
        preventDefault: false,

        /**
         * disable mouse events, so only touch (or pen!) input triggers events
         * @property preventMouse
         * @type {Boolean}
         * @default false
         */
        preventMouse: false
    },
    handler: function touchGesture(ev, inst) {
        if(inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
            ev.stopDetect();
            return;
        }

        if(inst.options.preventDefault) {
            ev.preventDefault();
        }

        if(ev.eventType == EVENT_TOUCH) {
            inst.trigger('touch', ev);
        }
    }
};

/**
 * @module gestures
 */
/**
 * User want to scale or rotate with 2 fingers
 * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
 * `preventDefault` option.
 *
 * @class Transform
 * @static
 */
/**
 * @event transform
 * @param {Object} ev
 */
/**
 * @event transformstart
 * @param {Object} ev
 */
/**
 * @event transformend
 * @param {Object} ev
 */
/**
 * @event pinchin
 * @param {Object} ev
 */
/**
 * @event pinchout
 * @param {Object} ev
 */
/**
 * @event rotate
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function(name) {
    var triggered = false;

    function transformGesture(ev, inst) {
        switch(ev.eventType) {
            case EVENT_START:
                triggered = false;
                break;

            case EVENT_MOVE:
                // at least multitouch
                if(ev.touches.length < 2) {
                    return;
                }

                var scaleThreshold = Math.abs(1 - ev.scale);
                var rotationThreshold = Math.abs(ev.rotation);

                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(scaleThreshold < inst.options.transformMinScale &&
                    rotationThreshold < inst.options.transformMinRotation) {
                    return;
                }

                // we are transforming!
                Detection.current.name = name;

                // first time, trigger dragstart event
                if(!triggered) {
                    inst.trigger(name + 'start', ev);
                    triggered = true;
                }

                inst.trigger(name, ev); // basic transform event

                // trigger rotate event
                if(rotationThreshold > inst.options.transformMinRotation) {
                    inst.trigger('rotate', ev);
                }

                // trigger pinch event
                if(scaleThreshold > inst.options.transformMinScale) {
                    inst.trigger('pinch', ev);
                    inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
                }
                break;

            case EVENT_RELEASE:
                if(triggered && ev.changedLength < 2) {
                    inst.trigger(name + 'end', ev);
                    triggered = false;
                }
                break;
        }
    }

    Hammer.gestures.Transform = {
        name: name,
        index: 45,
        defaults: {
            /**
             * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
             * @property transformMinScale
             * @type {Number}
             * @default 0.01
             */
            transformMinScale: 0.01,

            /**
             * rotation in degrees
             * @property transformMinRotation
             * @type {Number}
             * @default 1
             */
            transformMinRotation: 1
        },

        handler: transformGesture
    };
})('transform');

/**
 * @module hammer
 */

// AMD export
if(typeof define == 'function' && define.amd) {
    define('hammer',[],function() {
        return Hammer;
    });
// commonjs export
} else if(typeof module !== 'undefined' && module.exports) {
    module.exports = Hammer;
// browser export
} else {
    window.Hammer = Hammer;
}

})(window);
/**
 * Drag and drop service
 *
 * Provides non directive specific functionality for drag and drop
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/drag_and_drop',[],function() {
  /**
   * Key used to store the drag data on $(el).data()
   */
  var DATA_KEY = 'optlyDragData';

  /**
   * Gets data that was stored on the element
   *
   * @param {Element} el
   * @return {Object|null}
   */
  function getDragData(el) {
    return $(el).data(DATA_KEY);
  }

  /**
   * Sets the drop data on el
   *
   * @param {Element} el
   * @param {*} data
   */
  function setDragData(el, data) {
    $(el).data(DATA_KEY, data);
  }

  /**
   * Clears drop data from el
   *
   * @param {Element} el
   */
  function removeDragData(el) {
    $(el).removeData(DATA_KEY);
  }

  return {
    getDragData: getDragData,
    setDragData: setDragData,
    removeDragData: removeDragData
  };
});

/**
 * CSS javascript helpers
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('utils/css',['require'],function(require) {
  /**
   * Returns {
   *  '-moz-transform': val,
   *  '-webkit-transform': val,
   *  '-ms-transform': val,
   *  'transform': val
   * }
   * @param {string} val
   * @return {Object}
   */
  function transform(val) {
    var obj = {};
    ['-moz-', '-webkit-', '-ms-', ''].forEach(function(prefix) {
      obj[prefix + 'transform'] = val;
    });
    return obj;
  }

  /**
   * Helper function to create translate string
   *
   * @param {number} x
   * @param {number} y
   * @return {string}
   */
  function translate(x, y) {
    return transform(sprintf('translate(%spx, %spx)', x, y));
  }

  /**
   * Helper function to create the translate3d string
   *
   * @param {number} x
   * @param {number} y
   * @param {number} z
   * @return {string}
   */
  function translate3d(x,y,z) {
    return transform(sprintf('translate3d(%s, %s, %s)', x, y, z));
  }

  return {
    translate: translate,
    translate3d: translate3d,
    transform: transform
  };
});

/**
 * Draggable directive
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/draggable',['hammer','services/drag_and_drop','utils/css'],function() {
  var Hammer = require('hammer');
  var dragAndDropService = require('services/drag_and_drop');
  var translate = require('utils/css').translate;

  var DRAGING_CLASS = 'dragging';

  return {
    isEmpty: true,

    /**
     * Event handler for Hammer drag event
     * @param {Event} event
     */
    _onDrag: function(event) {
      // only act on the element which has the directive applied
      $target = $(event.target).closest('.' + DRAGING_CLASS);

      $target.css(translate(
        event.gesture.deltaX,
        event.gesture.deltaY
      ));

      // hide the dragged element so we can find the element underneath
      $target.hide();
      var hoverEl = document.elementFromPoint(
        event.gesture.center.clientX,
        event.gesture.center.clientY
      );
      $target.show();
      // trigger dragging event on currently hovered element
      $(hoverEl).trigger('optlydraghover')
    },

    /**
     * Event handler for Hammer `dragend` event
     * @param {Event} event
     */
    _onDragEnd: function(event) {
      // reset the translation
      $(this.el).css(translate(0, 0));
      // remove the DRAGGING class
      $(this.el).removeClass(DRAGING_CLASS);

      // TODO(jordan): should this use $document service
      var dropEl = document.elementFromPoint(
        event.gesture.center.clientX,
        event.gesture.center.clientY
      );

      $(this.el).trigger('optlydragend', this.el);

      // TODO(jordan): will we always have dropEl
      if (dropEl) {
        $(dropEl).trigger('optlydrop', this.el);
      }
    },

    /**
     * Triggers custom dragstart event other drag & drop directives can listen to
     *
     * @param {Event} event
     */
    _onDragStart: function(event) {
      $(this.el).trigger('optlydragstart', this.el);
      $(this.el).addClass(DRAGING_CLASS);
    },

    bind: function() {
      Hammer(this.el).on('drag', this._onDrag.bind(this));
      Hammer(this.el).on('dragstart', this._onDragStart.bind(this));
      Hammer(this.el).on('dragend', this._onDragEnd.bind(this));
    },

    unbind: function() {
      Hammer(this.el).off('drag', this._onDrag);
      Hammer(this.el).off('dragstart', this._onDragStart.bind(this));
      Hammer(this.el).off('dragend', this._onDragEnd);
    }
  };
});

/**
 * Event helper functions
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('utils/events',[],function() {

  /**
   * Finds the first element that matches the provided selector
   * between the event.currentTarget (delegate node) and the
   * event.target (event was dispatched from)
   *
   * @param {Event} event
   * @param {string} selector
   * @return {Element=}
   */
  function resolveEventDelegate(event, selector) {
    var target = event.target;
    var root = event.currentTarget;
    var matches = $.find(selector, root);
    while (target && (target !== root)) {
      if (matches.indexOf(target) !== -1) {
        return target;
      }
      target = target.parentNode;
    }
    return null;
  }

  return {
    resolveEventDelegate: resolveEventDelegate
  };
});

/**
 * Drag Container directive
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/drag_container',['services/drag_and_drop','utils/events'],function() {
  var dragAndDropService = require('services/drag_and_drop');
  var events = require('utils/events');

  var DRAGGING_CLASS = 'dragging-active';

  /**
   * Class that given to the drop target when a draggable element
   * is hovered over it
   */
  var HOVER_CLASS = 'drag-hover';

  var DROP_TARGET_SELECTOR = '.v-drop-target';

  return {
    isEmpty: true,

    _onDragStart: function(event) {
      $(this.el).addClass(DRAGGING_CLASS);
    },

    _onDragEnd: function() {
      $(this.el).removeClass(DRAGGING_CLASS);
    },

    /**
     * Event handler for when a dragged element is hovered anywhere on the
     * drag-container
     *
     * @param {Event} event
     */
    _onHover: function(event) {
      $(this.el).find(DROP_TARGET_SELECTOR).removeClass(HOVER_CLASS);
      // check if the event propagated through a drop target
      var delegateTarget = events.resolveEventDelegate(event, DROP_TARGET_SELECTOR);
      if (delegateTarget) {
        $(delegateTarget).addClass(HOVER_CLASS);
      }
    },

    bind: function() {
      $(this.el).on('optlydraghover', this._onHover.bind(this));
      $(this.el).on('optlydragstart', this._onDragStart.bind(this));
      $(this.el).on('optlydragend', this._onDragEnd.bind(this));
    },

    unbind: function() {
      $(this.el).off('optlydraghover');
      $(this.el).off('optlydragstart');
      $(this.el).off('optlydragend');
    }
  };
});

/**
 * drag-data directive
 *
 * Attaches data to the element such that when it is dragged and dropped
 * on a `v-drop-target` element it will pass the data to the configured drop function
 *
 * It accepts three formats of data
 * ====================================
 * String literal: <div v-drag-data="some string">
 * View model key: <div v-drag-data="key: someProp"> will pass vielModel['someProp'] to the drop function
 * JSON: <div v-drag-data='json: {"foo": "bar", "arr": [1,2,3]}'> will pass the json parsed data to the drop function
 *    note: the string must be a valid json string and will be run through JSON.parse()
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/drag_data',['services/drag_and_drop'],function() {
  var dragAndDropService = require('services/drag_and_drop');

  return {
    bind: function(value) {
      dragAndDropService.setDragData(this.el, value);
    },

    update: function(value) {
      dragAndDropService.setDragData(this.el, value);
    },

    unbind: function() {
      dragAndDropService.removeDragData(this.el);
    }
  };
});

/**
 * drop-target directive
 *
 * Make the element a drag target, when a v-draggable
 * element is dropped on the element call the function with the data
 * specified by the draggable element's `v-drag-data` directive
 * <div v-drop-target="someFn"></div>
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/drop_target',['services/drag_and_drop'],function() {
  var dragAndDropService = require('services/drag_and_drop');
  var DROP_EVENT = dragAndDropService.DROP_EVENT;
  var DRAG_EVENT = dragAndDropService.DRAG_EVENT;

  return {
    isFn: true,

    /**
     * Event handler for the artificial drop event
     *
     * @param {Event} event
     * @param {Element} draggedEl - element that is being dragged to event.target
     */
    _handleDrop: function(event, draggedEl) {
      var dragData = dragAndDropService.getDragData(draggedEl);
      // invoke the passed function with drag data
      this.value.call(this.vm, dragData);
    },

    bind: function() {
      // add '.v-drop-target'
      $(this.el).addClass('v-' + this.name);
      $(this.el).on('optlydrop', this._handleDrop.bind(this));
    },

    unbind: function() {
      $(this.el).off('optlydrop');
    }
  };
});

/**
 * Abstracts the DOM behavior for showing/hiding a dropdown
 * so it can be used in the dropdown directive or directly
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('services/dropdown',[],function() {
  var SHOWN_CLASS = 'shown';
  var ESCAPE_KEY = 27;
  var MENU_OVERLAY_CLASS = "menu-overlay";

  var service = {};


  /**
   * Shows a dropdown
   * @param {HTMLElement} el the dropdown container
   */
  service.show = function(el) {
    // If the element has the disabled attribute, then the dropdown won't show
    if ($(el).attr('disabled')) {
      return;
    }
    var eventNS = ".dropdown-" + (new Date()).valueOf();
    var useOverlay = el.hasAttribute('data-use-overlay');

    $(el)
      .addClass(SHOWN_CLASS)
      .data('eventNS', eventNS);

    if (useOverlay) {
      this._overlay = $('<div/>')
        .prependTo(document.body)
        .addClass(MENU_OVERLAY_CLASS);
    }

    $(document).on("click" + eventNS, function(event) {
      if ($(el).has(event.target).length === 0) {
        this.hide(el);
      }
    }.bind(this));

    $(document).on("keyup" + eventNS, function(event) {
      if (event.keyCode === ESCAPE_KEY) {
        this.hide(el);
      }
    }.bind(this));
  };

  /**
   * Hides a dropdown
   * @param {HTMLElement} el the dropdown container
   */
  service.hide = function(el) {
    var eventNS = $(el).data('eventNS');

    if (eventNS) {
      $(document).off(eventNS);
      $(el).removeData('eventNS');
    }
    $(el).removeClass(SHOWN_CLASS);

    if (this._overlay) {
      this._overlay.remove();
      this._overlay = null;
    }
  };

  /**
   * Toggles the dropdown
   * @param {HTMLElement} el the dropdown container
   */
  service.toggle = function(el) {
    if ($(el).hasClass(SHOWN_CLASS)) {
      this.hide(el);
    } else {
      this.show(el);
    }
  }

  return service;
});

/**
 * Dropdown directive
 * This directive is a port of optly.Dropdown
 * optly.Dropdown is deprecated and should be removed once all instances are refactored
 *
 * This is an empty directive, meaning it is attached via:
 * <div v-dropdown>
 * no value is needed
 *
 * Tagging a child element with `data-show-dropdown` will show the dropdown
 * when that element is clicked
 *
 * Tagging a child element with `data-hide-dropdown` will hide the dropdown
 * when that element is clicked
 *
 * If a transparent menu overlay is needed on the page, tagging the `.dropdown`
 * with `data-use-overlay` will enable it.
 *
 * Ex markup:
 * <div class="dropdown" v-dropdown data-use-overlay>
 *  <a class="dropdown-activator" data-show-dropdown>Show dropdown</a>
 *  <ul class="dropdown-body">
 *    <li>item 1</li>
 *    <li>item 2</li>
 *    <li data-hide-dropdown>I hide the dropdown when clicked</li>
 *  </ul>
 * </div>
 */
define('directives/dropdown',['lodash','services/dropdown'],function() {
  var ACTIVATOR_SELECTOR = '[data-show-dropdown]';
  var TOGGLE_SELECTOR    = '[data-toggle-dropdown]';
  var HIDE_SELECTOR      = '[data-hide-dropdown]';

  var _ = require('lodash');
  var dropdownService = require('services/dropdown');

  return {
    isEmpty: true,

    bind: function() {
      var $el = $(this.el);
      $el.on('click', ACTIVATOR_SELECTOR, dropdownService.show.bind(dropdownService, this.el));
      $el.on('click', TOGGLE_SELECTOR, dropdownService.toggle.bind(dropdownService, this.el));
      $el.on('click', HIDE_SELECTOR, dropdownService.hide.bind(dropdownService, this.el));
    }
  }
});

/**
 * In order to get the cursor position / selection for a contenteditable HTML element, we need to do some
 * fancy stuff. This is necessary for the editable-text directive (and possibly others in the future). This code comes
 * from the following stack overflow post:
 *
 * http://stackoverflow.com/questions/13949059/persisting-the-changes-of-range-objects-after-selection-in-html/13950376#13950376
 * Example here:
 * http://jsfiddle.net/WeWy7/3/
 *
 */
define('utils/contenteditable_selection',[],function () {

  /**
   * Given an html element (with contenteditable="true"), returns the current cursor selection.
   * @param containerEl
   * @returns {{ '{{' }}start: Number, end: number{{ '}}' }}
   */
  function saveSelection(containerEl) {
    // If a jQuery object got passed in, get the raw HTML element
    if (containerEl instanceof jQuery) {
      containerEl = containerEl.get(0);
    }
    if (window.getSelection && document.createRange) {
      var range = window.getSelection().getRangeAt(0);
      var preSelectionRange = range.cloneRange();
      preSelectionRange.selectNodeContents(containerEl);
      preSelectionRange.setEnd(range.startContainer, range.startOffset);
      var start = preSelectionRange.toString().length;

      return {
        start: start,
        end: start + range.toString().length
      }
    } else if (document.selection && document.body.createTextRange) {
      // This is for IE...
      var selectedTextRange = document.selection.createRange();
      var preSelectionTextRange = document.body.createTextRange();
      preSelectionTextRange.moveToElementText(containerEl);
      preSelectionTextRange.setEndPoint("EndToStart", selectedTextRange);
      var start = preSelectionTextRange.text.length;

      return {
        start: start,
        end: start + selectedTextRange.text.length
      }
    }
  }

  /**
   * Given an html element, resets the selection to the start/end specified in savedSel. Expectation
   * is that savedSel was generated by the saveSelection function.
   *
   * @param containerEl
   * @param savedSel {{ '{{' }}start: Number, end: number{{ '}}' }}
   */
  function restoreSelection(containerEl, savedSel) {
    // If a jQuery object got passed in, get the raw HTML element
    if (containerEl instanceof jQuery) {
      containerEl = containerEl.get(0);
    }
    if (window.getSelection && document.createRange) {
      var charIndex = 0, range = document.createRange();
      range.setStart(containerEl, 0);
      range.collapse(true);
      var nodeStack = [containerEl], node, foundStart = false, stop = false;

      // This while loop is super confusing. This part of DOM exploration is greek to me though and
      // I trust stack overflow more than trying to figure this out from first principles.
      // Here's the w3 article on nodeType http://www.w3schools.com/jsref/prop_node_nodetype.asp
      // nodeType == 3 is text. Basically it's taking the element and trying to find the text part of the element
      // Once it has that, it moves one chunk of text at a time until it finds the beginning / end
      // of the desired selection, and then creates that range.
      while (!stop && (node = nodeStack.pop())) {
        if (node.nodeType == 3) {
          var nextCharIndex = charIndex + node.length;
          if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {
            range.setStart(node, savedSel.start - charIndex);
            foundStart = true;
          }
          if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {
            range.setEnd(node, savedSel.end - charIndex);
            stop = true;
          }
          charIndex = nextCharIndex;
        } else {
          var i = node.childNodes.length;
          while (i--) {
            nodeStack.push(node.childNodes[i]);
          }
        }
      }

      var sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (document.selection && document.body.createTextRange) {
      // This is for IE...
      var textRange = document.body.createTextRange();
      textRange.moveToElementText(containerEl);
      textRange.collapse(true);
      textRange.moveEnd("character", savedSel.end);
      textRange.moveStart("character", savedSel.start);
      textRange.select();
    }
  }

  return {
    restoreSelection: restoreSelection,
    saveSelection: saveSelection
  }
});

/**
 *  Turns any non-form element into a contenteditable
 *  HTML element with a two-way data binding to the key passed in
 *  as an argument. Takes exactly one argument.
 *
 *  Roughly equivalent to (and modelled after) the v-model directive
 *  when applied to form elements.
 *  IMPORTANT: This will not work on form elements! Use v-model instead.
 */
define('directives/editable_text',['utils/contenteditable_selection'],function() {

  var selectionHelper = require('utils/contenteditable_selection');

  var ESCAPE_KEY = 27;
  var ENTER_KEY = 13;
  var attrToChange = 'textContent';

  return {

    _savedSelection: null, // Default Value

    bind: function () {

      var self = this,
        el = self.el;

      // Make the content editable
      $(el).attr('contenteditable', true);

      // On escape, reset to the initial value and deselect (blur)
      self.onEsc = function(e) {
        if (e.keyCode == ESCAPE_KEY) {
          el[attrToChange] = self.initialValue || '';
          self._set();
          el.blur();
        }
      };
      el.addEventListener('keyup', this.onEsc);

      self.onEnter = function(e) {
        if (e.keyCode == ENTER_KEY) {
          e.preventDefault();
          el.blur();
        }
      };
      el.addEventListener('keydown', this.onEnter);

      // On focus, store the initial value so it can be reset on escape
      self.onFocus = function() {
        self.initialValue = el[attrToChange];
      };
      el.addEventListener('focus', this.onFocus);

      self.onInput = function () {
        // if this directive has filters
        // we need to let the vm.$set trigger
        // update() so filters are applied.
        // therefore we have to record cursor position (selection)
        // so that after vm.$set changes the input
        // value we can put the cursor back at where it is
        this._savedSelection = selectionHelper.saveSelection(el);

        self._set();
      };

      el.addEventListener('input', self.onInput)
    },

    _set: function () {
      this.vm.$set(this.key, this.el[attrToChange]);
    },

    update: function (value, init) {
      // sync back inline value if initial data is undefined
      if (init && value === undefined) {
        return this._set()
      }

      this.el[attrToChange] = !_.isString(value) ? '' : value;

      // Since updates are async, we need to reset the position of the cursor after it fires
      // v-model tries to do this with setTimeout(cb, 0) but if there's a filter and you type
      // too fast, there's a race condition where the timeout can fire before
      // update, moving the cursor back to the front. Having this here guarantees the cursor
      // is reset after update.
      // See the comment in self.set for additional context
      if (this._savedSelection) {
        selectionHelper.restoreSelection(this.el, this._savedSelection);
      }
    },

    unbind: function () {
      var el = this.el;
      el.removeEventListener('input', this.onInput);
      el.removeEventListener('keyup', this.onEsc);
      el.removeEventListener('keydown', this.onEnter);
      el.removeEventListener('focus', this.onFocus);
    }
  }
});

/**
 * Element Slide directive
 * this directive allows a drawer to be animated in a larger context (allowing
 * the overarching directive, slide_manager.js, to inversely slide sibling elements)
 *
 * @author Will Falk-Wallace (will.falk-wallace@optimizely.com)
 */
 define('directives/element_slide',[],function() {
  return {
    _element: null,
    _openComplete: null,
    _closeComplete: null,
    /**
     * Initialize the slidable element
     *
     * @param value
     */
    bind: function(value) {
      this._openComplete = value.openCallback ? value.openCallback : $.noop;
      this._closeComplete = value.closeCallback ? value.closeCallback : $.noop;
      this._element = $(this.el);
     },

    /**
     * if the value (isOpen) changes, trigger appropriate events
     *
     * @param value
     */
     update: function (value) {
      if (value.open) {
        // if isOpen is true, element should slide to open.
        this._element.trigger('slideOpen', {
          // passing "self" in trigger to decouple from slide manager and
          // allow for multiple drawers sliding against the same element,
          // say, a left and a right drawer
          firstElement: this._element,
          callback: this._openComplete,
        });
      } else {
        // if isOpen is false, element should slide to close.
        this._element.trigger('slideClose', {
          firstElement: this._element,
          callback: this._closeComplete,
        });
      }
    }
  };
});

/**
 * Directive to ensure that all editor links for a particular experiment will open in the same
 * window/tab.  
 *
 * Usage:
 * <a href="..." v-experiment-edit-link="experiment.id">Edit</a>
 */
define('directives/experiment_edit_link',[],function() {
  return function(id) {
    this.el.setAttribute('target', 'optlyEdit' + id);
  }
});

/**
 * Farbtastic (color picker -- dumb name) directive
 *
 * Expected DOM structure is something like:
 *   <div v-farbtastic="{callback: myFunction,
 *                       inputSelector: 'input',
 *                       pickerSelector: '.color-picker',
 *                       toggleSelector: '.color-picker-toggle'}">
 *     <div>
 *       <input type="text" />
 *       <div class="color-picker"></div>
 *     </div>
 *   </div>
 *
 * @author Sam Jackson (sam@optimizely.com)
 */
define('directives/farbtastic',[],function() {

  var SELECTED_CLASS = 'selected';
  var UI_EFFECT_DURATION = 300;
  var UI_EFFECT_EASING_IN = "easeInExpo";
  var UI_EFFECT_EASING_OUT = "easeOutExpo";

  return {
    _callback: null,
    _inputElement: null,
    _isOpen: false,
    _pickerElement: null,
    _toggleElement: null,
    _toggleHandler: null,


    /**
     * Show hide the color picker
     *
     * @private
     */
    _toggleColorPicker: function () {
      if (this._isOpen) {
        this._toggleElement.removeClass(SELECTED_CLASS);
        this._pickerElement.slideUp(UI_EFFECT_DURATION, UI_EFFECT_EASING_OUT);
      } else {
        this._toggleElement.addClass(SELECTED_CLASS);

        // This callback is only necessary because Vue doesnt seem to recognize when
        // farbtastic (I truly hate this name) sets the input element value, so
        // we alert it explicitly.
        this._pickerElement.farbtastic(this._inputElement, this._callback);
        this._pickerElement.slideDown(UI_EFFECT_DURATION, UI_EFFECT_EASING_IN);
      }
      this._isOpen = !this._isOpen;
    },


    /**
     * Initialize the color picker
     *
     * @param value
     */
    bind: function(value) {
      var element = $(this.el);

      // Callback is invoked whenever the user picks a new color
      this._callback = value.callback || $.noop;

      // Input element field that we want to add the hex value to
      this._inputElement = element.find(value.inputSelector);

      // Div in which to instantiate the picker
      this._pickerElement = element.find(value.pickerSelector);

      // Button to toggle the picker
      this._toggleElement = element.find(value.toggleSelector);
      this._toggleHandler = this._toggleElement.on('click', this._toggleColorPicker.bind(this));
    },

    /**
     * Unbind click handlers we set up
     *
     */
    unbind: function() {
      this._toggleElement.off('click', this._toggleHandler);
    }
  };
});

/**
 * Relative Date Filter
 *
 * Using this filter will take the value passed in
 * and then replace that with a string expressing the time between that value's date and now.
 * The value passed in should be the number of milliseconds since 1970, gotten by doing Date.getTime();
 *
 */
define('filters/relative_date',[],function relativeDate() {

  // Constants for # seconds in various time periods
  var MINUTE = 60;
  var HOUR = MINUTE * 60;
  var DAY = HOUR * 24;
  var WEEK = DAY * 7;

  /**
   * Takes a number of seconds and returns a string expressing that difference in time, in decreasing resolution
   * as the difference increases.
   *
   * @param duration {Number}
   * @returns {string}
   */
  var generateDurationString = function(duration) {
    var number;
    var unit;

    if (duration > WEEK - DAY) {
      return null;
    }
    else if (duration > DAY - HOUR) {
      number = Math.round(duration / DAY);
      unit = 'day';
    }
    else if (duration > HOUR - MINUTE) {
      number = Math.round(duration / HOUR);
      unit = 'hour';
    }
    // give a buffer of 5 seconds for minute
    else if (duration > MINUTE - 5) {
      number = Math.round(duration / MINUTE);
      unit = 'minute';
    }
    else {
      unit = 'second';
    }

    return (number ? number + ' ' : '') + unit + (number == 1 ? '' : 's') + ' ago';
  };

  /**
   * Return a time string representing the difference in time between datetime and now.
   * @param {Date} datetime
   * @returns {string}
   */
  var generateRelativeDateString = function(datetime) {
    var now = new Date().getTime();
    var diff = (now - datetime.getTime()) / 1000; // seconds
    return generateDurationString(diff) || datetime.toDateString();
  };

  /**
   * datetime should be an number, resulting from calling getTime on a Date object
   * @param {Date|string|Number} either a Date object, or a string or number which can be passed to new Date()
   */
  return function(datetime) {
    if (!(datetime instanceof Date)) {
      datetime = new Date(datetime);

    }

    if (isNaN(datetime.getTime())) {
      throw new Error('Not convertible to Date: ' + datetime);
    }

    return generateRelativeDateString(datetime);
  };
});

/*
 * Relative Date Directive
 *
 * Takes one argument (which is a property that's the number of milliseconds since 1970)
 * for the date that should be converted to a relative date. This can be gotten from Date.getTime()
 * You can also set the interval that the relative date directive refreshes
 * by providing the relative-date-interval attribute
 *
 * Valid ways of using this directive include:
 * <span v-relative-date="lastModified"></span>
 * <span v-relative-date="lastModified" relative-date-interval="30000"></span>
 */
define('directives/relative_date',['filters/relative_date','window'],function() {

  var relativeDateHelper = require('filters/relative_date');
  var DEFAULT_INTERVAL = 60000;
  var INTERVAL_ATTR_NAME = 'relative-date-interval';
  var $window = require('window');

  return {

    _interval: null,

    bind: function(value) {
      var interval = $(this.el).attr(INTERVAL_ATTR_NAME);
      this._setUpInterval(interval || DEFAULT_INTERVAL);
    },

    update: function(value) {
      this._update(value);
    },

    unbind: function() {
      if (this._interval !== null) {
        $window.clearInterval(this._interval);
      }
    },

    _setUpInterval: function(interval) {
      var self = this;
      // Clear any existing interval
      if (self._interval !== null) {
        $window.clearInterval(self._interval);
      }
      this._interval = $window.setInterval(function() {
        self._update(self.vm[self.key])
      }, interval);
    },

    _update: function(timestamp) {
      var relativeDateText = relativeDateHelper(timestamp);
      $(this.el).text(relativeDateText);
    }
  }
});

/**
 * Spinner directive
 *
 * This is an empty directive, meaning it is attached via:
 * <div v-spinner="watchedVar"></div>
 *
 * @author Cheston Lee
 */
define('directives/spinner',[],function() {
  var $spinner = $('<div class="spinner-overlay"><div class="lego-spinner-wrap"><div class="lego-spinner"></div></div></div>');
  var STYLE_ATTR_NAME = 'data-spinner-style';

  return {
    bind: function() {
      var $el = $(this.el);
      $el.append($spinner);
      if ($el.attr(STYLE_ATTR_NAME)) {
        $spinner.addClass('spinner--overlaid')
      }
    },
    unbind: function() {
      $spinner.remove();
    },
    update: function(val) {
      var HIDDEN_CLASS= 'spinner--hidden';
      if (val) {
        $spinner.removeClass(HIDDEN_CLASS);
      } else {
        $spinner.addClass(HIDDEN_CLASS);
      }
    }
  };
});

/**
 * Geotargeting Label Directive
 *
 * Translates a location key (CITY|STATE|COUNTRY) into a readable location
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/geotargeting_label',['services/geotargeting'],function() {
  var geotargetingService = require('services/geotargeting');

  return {
    update: function(val) {
      if (!val) {
        return '';
      }
      geotargetingService.getLabel(val).then(function(label) {
        $(this.el).val(label);
      }.bind(this));
    }
  };
});

/**
 * Hide Dialog Directive
 *
 * Adding this directive to an element causes a click on that element to hide the visible dialog
 *
 */
define('directives/help_tooltip',['lodash'],function() {
  var _ = require('lodash');

  var HELP_CLASS = 'help-button v-help-tooltip';

  /**
   * data-* attributes that should be passed to $.tooltip
   */
  var dataAttrs = [
    'placement',
    'trigger'
  ];

  return {
    isEmpty: true,

    bind: function() {
      var $el = $(this.el).addClass(HELP_CLASS);

      // defer the binding so that any child vue components/directives get rendered
      setTimeout(function() {
        var html = this.el.innerHTML;
        this.el.innerHTML = '';

        var config = $.extend({
          html: true,
          title: html
        }, this._parseAttrs());

        $(this.el).tooltip(config);
      }.bind(this), 0);
    },

    unbind: function() {
      $(this.el)
        .tooltip('destroy')
        .removeClass(HELP_CLASS);
    },

    /**
     * parses valid data-* attribtues that can be applied to $.tooltip
     */
    _parseAttrs: function() {
      return _.pick($(this.el).data(), function(val, name) {
        return dataAttrs.indexOf(name) !== -1;
      });
    }
  }
});

/**
 * Hide Dialog Directive
 *
 * Adding this directive to an element causes a click on that element to hide the visible dialog
 *
 */
define('directives/hide_dialog',[],function() {

  return {

    isEmpty: true,

    bind: function() {
      var $el = $(this.el);
      $el.on('click.hide-dialog-directive', this._handleClick.bind(this));
    },

    unbind: function() {
      var $el = $(this.el);
      $el.off('click.hide-dialog-directive');
    },

    _handleClick: function() {
      this.vm.$dispatch('hideDialog');
    }
  }
});

/**
 * Directive to add the behavior of selecting all text in an input box.
 *
 * Used on Tokens page.
 *
 * @author Cheston Lee cheston@optimizely.com
 */
define('directives/highlight_input',[],function() {
  return {

    isEmpty: true,

    bind: function() {
      var $el = $(this.el);
      $el.on('click', function() {
        this.select();
      });
    },

    unbind: function() {
      var $el = $(this.el);
      $el.off('click');
    }
  };
});

/**
 * LEGO disabled directive
 * Shortcut to add the disabled attribute and the `lego-button--disabled` class
 *
 * @author Andrew Delikat (andrew@optimizely.com)
 */
define('directives/lego_disabled',[],function() {
  return function(disabled) {
    var $el = $(this.el);

    $el.attr('disabled', disabled)
      .toggleClass('lego-button--disabled', disabled);
  };
});

/**
 * A directive that will put an overlay + spinner over an element if the
 * a certain `loadingId` is true in the flux system.
 *
 * Usage:
 *
 * <div v-loading="dashboard.experiments" spinner-size="small">
 *
 * Where `dashboard.experiments` corresponds to flux.store('loading').isLoading('dashboard.experiments')
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/loading',['require','exports','module','lodash','flux'],function(require, exports, module) {
  var _ = require('lodash');
  var flux = require('flux');

  var spinnerWithOverlay = '<div class="lego-overlay"><div class="lego-spinner"></div></div>';

  var LOADING_STORE_ID = 'loading';

  var SIZES = {
    'small': 'lego-spinner--small'
  };

    var MIN_TIME = 300;
    
  module.exports = {

    isLiteral: true,

    showTime: null,

    toggleSpinner: function(show){
      if (show && !this.shown) {
        var $el = $(this.el);

        if ($el.is('tr')) {
          // special case table rows since the overlay positioning
          // works differently
          this.spinner.appendTo($el.parents('table'));
          this.showTime = Date.now();
          Vue.nextTick(function() {
            var rowPos = $el.position();
            this.spinner.css({
              position: 'absolute',
              top: rowPos.top,
              left: rowPos.left,
              width: this.el.clientWidth,
              height: this.el.clientHeight,
            });
          }.bind(this));
        } else {
          this.spinner.appendTo(this.el);
          this.showTime = Date.now();
        }
      } else if (!show && this.shown) {
      // execute if we should hide and it is shown
        var diff = Date.now() - this.showTime;
        // if the minimum duration has occurred immediately hide
        if (diff > MIN_TIME) {
          this.spinner.remove();
        } else if (!this.timeout) {
          // otherwise set timeout to the remaining time to hide
          this.timeout = setTimeout(function() {
            this.spinner.remove();
            this.timeout = null;
          }.bind(this), (MIN_TIME - diff))
        }
      }
      this.shown = show;
    },

    bind: function() {
      this.shown = false;
      var $el = $(this.el);
      var pos = $el.css('position');
      if (!pos || pos === 'static') {
        $(this.el).css('position', 'relative')
      }
      this.spinner = $(spinnerWithOverlay);

      // add a class for a custom size
      var spinnerSize = this.el.getAttribute('spinner-size');
      if (spinnerSize) {
        this.spinner.find('.lego-spinner').addClass('lego-spinner--' + spinnerSize);
      }

      // subscribe to changes on the loading store
      this.changeStream = flux.createChangeStream()
        .onStoreChange([LOADING_STORE_ID], function(loadingStore) {
          this.toggleSpinner(this.getIsLoading());
        }.bind(this))
        .forceUpdate();
    },

    /**
     * Overridable method to get the loading section id
     */
    getIsLoading: function() {
      return flux.store('loading').isLoading(this.key);
    },

    unbind: function() {
      this.changeStream.destroy();
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      delete this.timeout;
      delete this.showTime;
      delete this.spinner;
      delete this.changeStream;
    }
  }
});

/**
 * Directive that extends the `v-loading` directive and allows
 * the specification of a dynamic entity id
 *
 * Usage:
 *
 * <div v-loading-entity="experiment.id" entity="experiments">
 *
 * Where `experiment.id` is a ViewModel property and thus dynamic
 *
 * This integrates with the API layer of flux which will mark an entity
 * as "loading" whenever it is saved by the key `<entityName>.<entityId>`
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/loading_entity',['require','exports','module','lodash','flux','./loading'],function(require, exports, module) {
  var _ = require('lodash');
  var flux = require('flux');
  var loadingDirective = require('./loading');

  module.exports = _.extend({}, loadingDirective, {
    isLiteral: false,

    getIsLoading: function() {
      var id = this.vm.$get(this.key);
      var entity = this.el.getAttribute('entity');
      return flux.store('loading').isEntityLoading(entity, id);
    }
  });
})
;
/**
 * A directive that will hide an element if a certain loadingId is true
 *
 * Usage:
 *
 * <div v-loading-hide="dashboard.audiences.reportableCount">
 *
 * Where `dashboard.audiences.reportableCount` corresponds to flux.store('loading').isLoading('dashboard.experiments')
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/loading_hide',['require','exports','module','flux'],function(require, exports, module) {
  var flux = require('flux');
  var LOADING_STORE_ID = 'loading';

  module.exports = {
    isLiteral: true,

    bind: function() {
      // subscribe to changes on the loading store
      this.changeStream = flux.createChangeStream()
        .onStoreChange([LOADING_STORE_ID], function(loadingStore) {
          var isLoading = loadingStore.isLoading(this.key);
          $(this.el).toggle(!isLoading);
        }.bind(this))
        .forceUpdate();
    },

    unbind: function() {
      this.changeStream.destroy();
      delete this.changeStream;
    }
  };
});

/**
 * A directive that will show an element if a certain loadingId is true
 *
 * Usage:
 *
 * <div v-loading-hide="dashboard.audiences.reportableCount">
 *
 * Where `dashboard.audiences.reportableCount` corresponds to flux.store('loading').isLoading('dashboard.experiments')
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives/loading_show',['require','exports','module','flux'],function(require, exports, module) {
  var flux = require('flux');
  var LOADING_STORE_ID = 'loading';

  module.exports = {
    isLiteral: true,

    bind: function() {
      // subscribe to changes on the loading store
      this.changeStream = flux.createChangeStream()
        .onStoreChange([LOADING_STORE_ID], function(loadingStore) {
          var isLoading = loadingStore.isLoading(this.key);
          $(this.el).toggle(!!isLoading);
        }.bind(this))
        .forceUpdate();
    },

    unbind: function() {
      this.changeStream.destroy();
      delete this.changeStream;
    }
  };
});

/**
 * Vue directive for creating a pop-tip
 *
 * @author Cheston Lee
 */
define('directives/poptip',[],function() {

  var tmpl = '<div class="lego-pop-tip"></div>';
  var ARROW_CLASS_TEMPLATE = 'lego-pop-tip--arrow-';
  /**
   * Parse the readable name and translate it into the appropriate lego classname.
   *
   * @param {String} direction data-dir from the tip directive
   * @return {String} The appropriate lego class name to apply to the poptip
   */
  function getArrowDirection (direction) {
    if (!direction) {
      return 'bottom-center';
    }
    // Create array of the direction.
    var arrowParts = direction.split('-');
    var arrowLocation = '';

    // We have to swap the text given in 'direction' so that the arrow class is correct.
    // Testing here to see if we have two values, e.g. 'top-left', if so only change the first.
    if ( arrowParts.length > 1) {
      if (arrowParts[0] === "top") {
        arrowParts[0] = "bottom";
      } else {
        arrowParts[0] = "top";
      }
      // Recombine the directions to create the class.
      arrowLocation = arrowParts.join('-');

    } else {
      switch(direction) {
        case 'right':
          arrowLocation = 'left';
          break;
        case 'left':
          arrowLocation = 'right';
          break;
        case 'bottom':
          arrowLocation = 'top-center';
          break;
        // Fallthrough and default to top
        case 'top':
        default:
          arrowLocation = 'bottom-center';
      }
    }
    return arrowLocation;
  }

  return {

    isEmpty: true,

    data: {
      tip: null
    },
    bind: function() {
      var $el = $(this.el);
      var direction = $el.attr('data-dir');
      var content = $el.attr('data-content');
      var arrowLocation = getArrowDirection(direction);

      this.tip = $(tmpl);
      this.tip.addClass(ARROW_CLASS_TEMPLATE + arrowLocation);
      this.tip.html(content);

      this.tip.css({
        'display' : 'none',
        'position' : 'absolute',
        'top' : 0,
        'left' : 0
      });

      $el.on('mouseenter', function() {
        //TODO: Break all of this out, it is gross
        var $el = $(this.el);

        //Place the this.tip in the DOM to measure it
        this.tip.css({
          'display' : 'block',
          'visibility' : 'hidden'
        });

        var offset = $el.offset();

        //Determine the size of the CSS arrow
        var arrowWidth = parseInt(window.getComputedStyle(this.tip.get(0), ':before').getPropertyValue('width'));
        var arrowHeight = parseInt(window.getComputedStyle(this.tip.get(0), ':before').getPropertyValue('height'));

        // Hack for FF/IE that reports computed values as 'auto' not px values and divide by 2 to get the actual offset
        arrowWidth = (isNaN(arrowWidth) ? '12' : arrowWidth) / 2;
        arrowHeight = (isNaN(arrowHeight) ? '12' : arrowHeight) / 2;

        var left = offset.left;
        var top = offset.top;

        //For non orientation specific directions(right,left) we want to
        if (direction.indexOf('-') === -1) {
          switch(direction) {
            case 'right':
              left += ($el.outerWidth(true) + arrowWidth);
              top += (($el.outerHeight(true) / 2) - (this.tip.innerHeight() / 2));
              break;
            case 'left':
              left -= (this.tip.outerWidth(true) + arrowWidth);
              top += (($el.outerHeight(true) / 2) - (this.tip.innerHeight() / 2));
              break;
            case 'top':
              top -= (this.tip.outerHeight(true)) + arrowHeight;
              left += (($el.outerWidth(true) / 2) - (this.tip.innerWidth() / 2));
              break;
            case 'bottom':
              top += $el.outerHeight(true) + arrowHeight;
              left += (($el.outerWidth(true) / 2) - (this.tip.innerWidth() / 2));
              break;
          }
        } else {
          var parts = direction.split('-');

          if (parts[0] === 'top') {
            top -= (this.tip.outerHeight(true)) + arrowHeight;
          } else {
            top += $el.outerHeight(true) + arrowHeight;
          }

          switch(parts[1]) {
            case 'right':
              left -= (this.tip.outerWidth(true) - $el.outerWidth(true));
              break;
            case 'center':
              left += (($el.outerWidth(true) / 2) - (this.tip.innerWidth() / 2));
              break;
          }
        }

        this.tip.css({
          'left': left,
          'top': top,
          'visibility' : 'visible'
        });

      }.bind(this));

      $el.on('mouseleave click', function() {
        this.tip.hide();
      }.bind(this));

      $('body').append(this.tip);
    },

    unbind: function() {
      $(this.el).off('mouseenter mouseout');
      this.tip.detach();
    },
  };
});

/**
* Prevents text from being highlighted in an element by holding shift
* and clicking
*
* @author Jordan Garcia (jordan@optimizely.com)
*/
define('directives/prevent_shift_selection',['require'],function(require) {
  return {
    isEmpty: true,

    bind: function() {
      $(this.el).on('mousedown', function(event) {
        if (event.shiftKey) {
          $(event.currentTarget).one('selectstart', function(e) {
            // prevent the next selectstart
            return false;
          });
        }
      });
    }
  };
});

/**
* Push state directive
*
* @author Andrew Delikat (andrew@optimizely.com)
*/

define('directives/push_state',['require','utils/page'],function(require) {
  var page = require('utils/page');

  return {
    isLiteral: true,

    bind: function() {
      $(this.el).on('click', function(e) {
        var path = $(this.el).attr('href');
        e.preventDefault();
        page(path);
      }.bind(this));
    },
  };
});

/**
 * Resizable directive
 *
 * @author Sam Jackson (sam@optimizely.com)
 */
define('directives/resizable',[],function() {
  var EVENT_PREFIX = 'resizable:';
  var DEFAULT_OPTIONS = {
    handles: {},
    maxHeight: 0,
    minHeight: 0
  };

  return {
    _options: {},

    /**
     * Add resize start + stop handlers so we can set up our own events
     *
     * @private
     */
    _addResizeHandlers: function () {
      $(this.el)
          .on('resize', this._resizeHandler.bind(this))
          .on('resizestart', this._resizeStartHandler.bind(this))
          .on('resizestop', this._resizeStopHandler.bind(this));
    },

    /**
     * Extend the options object with an arbitrary set of objects
     *
     */
    _extendOptions: function () {
      var args = Array.prototype.slice.call(arguments);
      args.splice(0, 0, this._options);
      _.extend.apply(null, args);
    },

    /**
     * Called on resize event -- http://api.jqueryui.com/resizable/#event-resize
     *
     * @private
     */
    _resizeHandler: function (event, ui) {
      $(this.el).trigger('optlyresize', ui);
    },

    /**
     * Called on resizestart event -- http://api.jqueryui.com/resizable/#event-start
     *
     * @private
     */
    _resizeStartHandler: function (event, ui) {
      $(this.el).trigger('optlyresizestart', ui);
    },

    /**
     * Called on resizestop event -- http://api.jqueryui.com/resizable/#event-stop
     *
     * @private
     */
    _resizeStopHandler: function (event, ui) {
      $(this.el).trigger('optlyresizestop', ui);
    },

    /**
     * Initialize the resizable element
     *
     * @param value
     */
    bind: function(value) {
      this._addResizeHandlers();
      this._extendOptions(DEFAULT_OPTIONS, value);
      $(this.el).resizable(this._options);
    },

    /**
     * Destroy the jQuery UI component
     *
     */
    unbind: function() {
      $(this.el).resizable('destroy');
    },

    /**
     * If the options change, pass the new set along to the jQuery UI component
     *
     * @param value
     */
    update: function (value) {
      this._extendOptions(value);
      // sometimes we need to complete reset the resizable plugin because it needs to be lazy initialized (wait for DOM
      // element to actually be displayed) and the way we lazy initialize it is by updating the value and telling it to reset
      if (!value.reset) {
        $(this.el).resizable('option', this._options);
      } else {
        $(this.el).resizable('destroy')
                  .resizable(this._options);
      }
    }
  };
});
/**
 * Rearrange directive
 *
 * Uses jquery-ui's sortable function to make child elements of the directive
 * to be rearrangable. Consult the jquery-ui docs for constraints and
 * other options that can be passed to sortable():
 *
 * http://jqueryui.com/sortable/#default
 *
 * data-placeholder: holds the css for the drop target
 * data-vm-property: indicates the name on the view model
 *    which should get the ordered list of ids
 *
 * Also necessary to place data-rearrange-ids on the actual elements
 * being rearranged
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('directives/rearrange',[],function() {
  return {
    unbind: function() {
      this.vm.$off('hook:ready', this.onSortUpdate);
      $(this.el).off('sortupdate', this.onSortUpdate);
    },

    update: function(value) {
      this.onSortUpdate();
    },

    bind: function(options) {
      this.options = {
        placeholder: $(this.el).attr('data-placeholder'),
        property: $(this.el).attr('data-vm-property'),
      }

      $(this.el).sortable({
        placeholder: this.options.placeholder,
      });

      this.onSortUpdate = function () {
        var children = $(this.el).children();
        var orderedList = children.map(function (index, child) {
          return $(child).attr('data-rearrange-id');
        });
        var list = orderedList.toArray();
        this.vm.$set(this.options.property, _.cloneDeep(list));
      }.bind(this);

      this.vm.$on('hook:ready', this.onSortUpdate);
      $(this.el).on('sortupdate', this.onSortUpdate);
    },
  };
});

/**
 * Slide manager directive
 * this directive allows a drawer to be animated (triggered by element_slide.js)
 * and its specified sibling to be inversely animated (eg. the iFrame).
 *
 * @author Will Falk-Wallace (will.falk-wallace@optimizely.com)
 */
 define('directives/slide_manager',['require','utils/enums'],function(require) {
  var enums = require('utils/enums');
  var COLLAPSED_CLASS = 'collapsed';
  return {
    _secondElement: null,
    /**
     * Stops animations on an element
     * @param  Object element
     */
    _stopAnimation: function (element) {
      if (element.is(":animated")) {
        element.stop();
      }
    },

    /**
     * Add open/close start + stop handlers so we can set up our own events
     *
     * @private
     */
    _addOpenCloseHandlers: function () {
      $(this.el)
        .on('slideClose', this._animateClose.bind(this))
        .on('slideOpen', this._animateOpen.bind(this));
    },

    /**
     * remove open/close start + stop handlers
     *
     * @private
     */
    _removeOpenCloseHandlers: function () {
      $(this.el)
        .off('slideClose')
        .off('slideOpen');
    },

    /**
     * Slide open (animate) an element and reverse animate its specified sibling
     * @param  Object event event triggered by element-slide directive update
     * @param  Object data element and sibling data provided by element-slide directive
     */
    _animateOpen: function (event, data) {
      var firstElement = data.firstElement;
      var callback = data.callback;

      firstElement.removeClass(COLLAPSED_CLASS);

      this._stopAnimation(firstElement);
      this._stopAnimation(this._secondElement);

      // If the drawer is not open already, start the animation
      if (firstElement.css("bottom") !== "0px") {
        firstElement.animate({bottom: "0"},
                             enums.UITransitionEffects.UI_EFFECT_DURATION,
                             enums.UITransitionEffects.UI_EFFECT_EASING_OUT);
        this._secondElement.animate({"margin-bottom": firstElement.outerHeight() + "px"},
                                    enums.UITransitionEffects.UI_EFFECT_DURATION,
                                    enums.UITransitionEffects.UI_EFFECT_EASING_OUT);
      }
      callback();
    },

    /**
     * Slide closed (animate) an element and reverse animate its specified sibling
     * @param  Object event event triggered by element-slide directive update
     * @param  Object data element and sibling data provided by element-slide directive
     */
    _animateClose: function (event, data) {
      var firstElement = data.firstElement;
      var callback = data.callback;

      this._stopAnimation(firstElement);
      this._stopAnimation(this._secondElement);

      // if element is open (bottom == 0), animate close
      // if height == 0, collapsed class is applied and el is closed
      if (firstElement.css("bottom") === "0px" &&
          firstElement.css("height") !== "0px") {
        this._secondElement.animate({"margin-bottom": "0"},
                                    enums.UITransitionEffects.UI_EFFECT_DURATION,
                                    enums.UITransitionEffects.UI_EFFECT_EASING_OUT);
        firstElement.animate({"bottom": -firstElement.outerHeight() + "px"},
                             enums.UITransitionEffects.UI_EFFECT_DURATION,
                             enums.UITransitionEffects.UI_EFFECT_EASING_OUT);
      }
      else {
        firstElement.addClass(COLLAPSED_CLASS);
      }
      $("body").focus();
      callback();
    },

    /**
     * Initialize the slidable manager
     *
     * @param value
     */
    bind: function(value) {
      this._secondElement = $(value).first();
      this._addOpenCloseHandlers();
    },

    /**
     *
     *
     */
    unbind: function() {
      this._removeOpenCloseHandlers();
    },

  };
});

/**
 * Spectrum color picker directive. Expects to bind to an object of the format:
 *
 * {r: 255, g: 255, b: 255, a: .1}
 *
 * @author Sam Jackson (sam@optimizely.com)
 */
define('directives/spectrum',['lodash'],function() {
  var SPECTRUM_PREFIX = 'spectrum:';
  var _ = require('lodash');

  // Default options -- these can be overridden by setting a json string in the
  // data-options attribute of the element
  var DEFAULT_OPTIONS = {
    allowEmpty: false,
    clickoutFiresChange: true,
    containerClassName: "optly-color-picker popover",
    preferredFormat: "hex6",
    replacerClassName: "optly-color-picker__trigger",
    showAlpha: true,
    showButtons: false,
    showInitial: false,
    showInput: true
  };

  return {

    /**
     * This is sent to the parent component along with the update so that the parent
     * knows which property to update with the selected color value
     *
     * @param {String}
     */
    _propertyName: null,

    /**
     * Lets parent component know that the color value has changed and sends the color value along with the update
     *
     * @param {Object} value Spectrum provided parameter
     * @private
     */
    _handleSpectrumUpdate: function (value) {
      value = value.toRgb();
      this.vm.$dispatch(SPECTRUM_PREFIX + 'update', this._propertyName, value);
    },

    /**
     * Hide the component if the parent drawer was clicked
     *
     * @private
     */
    _hide: function() {
      $(this.el).spectrum('hide');
    },

    /**
     * Sync color values with the color value from the selected element
     *
     * @param {Object} properties
     * @private
     */
    _handlePropertiesChanged: function(properties) {
      // we are only interested in one property
      $(this.el).spectrum('set', properties[this._propertyName]);
    },

    /**
     * Set up directive listeners and bind data model
     *
     * @param {Object} value The color value this directive is being bound to
     */
    bind: function (value) {
      // for dynamic components where we don't know the property name during compile time, we pass the property name
      // in via the value because Vue doesn't like dynamic argument bindings. Examples:
      // 1) if passed in as an arg the directive should look like this v-spectrum="argName: value" where arg is just a
      //    string and value is an object with the rgba properties
      // 2) if no arg is provided then directive should look like this v-spectrum="value" where value is
      //    { a: 0, r: 0, g: 0, b: 0, propertyName: '' }
      this._propertyName = this.arg || value.propertyName;

      // Grab any instance specfic options from the DOM
      var options = $(this.el).attr('data-options');

      // Coerce options to object
      if (options) {
        options = JSON.parse(options);
      }

      // Extend user supplied options with the defaults
      options = _.extend({ move: this._handleSpectrumUpdate.bind(this)},
                        DEFAULT_OPTIONS,
                        options || {});

      // Instantiate spectrum
      $(this.el).spectrum(options);
      $(this.el).spectrum('set', value);

      this.vm.$on(SPECTRUM_PREFIX + 'hide', this._hide.bind(this));
      this.vm.$on(SPECTRUM_PREFIX + 'propertiesChanged', this._handlePropertiesChanged.bind(this));
    },

    /**
     * Destroy spectrum plugin when directive is destroyed
     *
     */
    unbind: function() {
      $(this.el).spectrum('destroy');
    }
  };
});

/**
 * Scroll utilities
 *
 * jQuery UI license included for the scrollParent function

  Copyright 2007, 2014 jQuery Foundation and other contributors,
  https://jquery.org/

  This software consists of voluntary contributions made by many
  individuals. For exact contribution history, see the revision history
  available at https://github.com/jquery/jquery-ui

  The following license applies to all parts of this software except as
  documented below:

  ====

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  ====

  Copyright and related rights for sample code are waived via CC0. Sample
  code is defined as all source code contained within the demos directory.

  CC0: http://creativecommons.org/publicdomain/zero/1.0/

  ====

  All files located in the node_modules and external directories are
  externally maintained libraries used by this software which have their
  own licenses; we recommend you read them, as their terms may differ from
  the terms above.
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('utils/scroll',[],function() {
  /**
   * Finds the nearest parent element that allows scrolling
   *
   * Taken from jQuery UI
   * https://github.com/jquery/jquery-ui/blob/master/ui/core.js
   *
   * @param {HTMLElement} el
   * @return {HTMLElement}
   */
  function scrollParent(el) {
    var $el = $(el);
    var position = $el.css( "position" ),
    excludeStaticParent = position === "absolute",
    scrollParent = $el.parents().filter( function() {
      var parent = $( this );
      if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
        return false;
      }
      return (/(auto|scroll)/).test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
    }).eq( 0 );

    return position === "fixed" || !scrollParent.length ? $el[ 0 ].ownerDocument || document : scrollParent.get(0);
  }


  /**
   * Gets the offsetTop of an ancestor element
   *
   * @param {HTMLElement} el
   * @param {HTMLElement} ancestor
   * @return {Integer}
   */
  function offsetTop(el, ancestor) {
    var ancestorOffset = $(ancestor).offset();
    return $(el).offset().top - (ancestorOffset ? ancestorOffset.top : 0);
  }

  return {
    scrollParent: scrollParent,
    offsetTop: offsetTop
  }
});

/**
 * Directive that sticks an element to the top of the page
 * when it scrolls out of view
 *
 * Usage
 * ================================================
 * <div v-sticky>
 *
 * or
 *
 * <div v-sticky="10">
 * will cause the element to stick to the top of the page
 * 10px from the top
 *
 * @author Jordan Garcia
 */
define('directives/sticky',['require','vue','utils/css','utils/scroll'],function(require) {
  var Vue = require('vue');
  var translate = require('utils/css').translate;
  var scroll = require('utils/scroll');

  /**
   * @param {HTMLElement} el
   * @param {Integer} deltaY
   */
  function translateY(el, deltaY) {
    $(el).css(translate(0, deltaY));
  }

  /**
   * Create a scroll handler based on whether the scroll parent
   * is document or not
   * @param {Boolean} isDocument
   * @return {Function}
   */
  function createHandler(isDocument, padding) {
    return function() {
      var offsets   = getOffsets(this.el, this._handlerEl, isDocument, padding);
      var top       = offsets.top;
      var scrollTop = offsets.scrollTop;

      if (top === scrollTop) {
        return;
      }

      if (scrollTop > this._top) {
        // the scroll position is farther down than the elements offset top from it's scroll parent
        // translate the element so it remains at the top of the scroll parent
        translateY(this.el, (scrollTop - this._top));
        this._isTranslated = true;
      }
      else if (this._isTranslated && scrollTop < this._top) {
        // the scroll position is above the elements original offset top -- reset translate
        translateY(this.el, 0);
        this._isTranslated = false;
      }
      else {
        // reset the translation (some browsers seem to fire two scroll events before the translate
        // occurs)
        translateY(this.el, 0);
        this._isTranslated = false;
        // cache the offset top of the element in question
        // so that it does not take into account the translate happening during this event
        // handler
        this._top = top;
      }
    }
  }

  /**
   * Gets the offset from the el to ancestor
   * @param {HTMLElement} el the element that is sticky
   * @param {HTMLElement} scrollParent
   * @param {Boolean} isDocument
   * @param {Integer} padding
   *
   * @return { {
   *   top: <Integer>,
   *   scrollTop: <Integer>,
   * } }
   */
  function getOffsets(el, scrollParent, isDocument, padding) {
    var offsetTop = scroll.offsetTop(el, scrollParent);
    var scrollTop = $(scrollParent).scrollTop();

    var top = offsetTop - padding;
    if (!isDocument) {
      // if the scroll parent isn't the document add the scrollTop
      top += scrollTop;
    }

    return {
      top: top,
      scrollTop: scrollTop
    };
  }

  return {
    isLiteral: true,

    _top: null,

    _isTranslated: false,

    bind: function() {
      // this will get run when compiling the component DOM but before attaching
      // to the page, wait for nextTick to ensure the component is attached to the DOM
      Vue.nextTick(function() {
        // find the scroll handler element in which the scroll event will be emitted
        // uses the util/scroll module
        this._handlerEl = scroll.scrollParent(this.el);
        // parse the padding value in `<div v-sticky="10">`
        var padding     = parseInt(this.key, 10) || 0;
        // is the scroll handler document
        var isDocument  = (this._handlerEl === document);
        // determine the offset top and scroll offset of the element in question
        var offsets     = getOffsets(this.el, this._handlerEl, isDocument, padding);
        // create the scroll handler function
        var handlerFn = createHandler(isDocument, padding);
        // event namespace to easily `.off`
        this._eventNS   = ".v-sticky-" + (+new Date());
        // initialize the offset top of the elemnt in question
        this._top = offsets.top;
        // invoke the handlerFn to account for the browser remembering the scroll position
        handlerFn.call(this);
        // attach the scroll handler
        $(this._handlerEl).on('scroll' + this._eventNS, handlerFn.bind(this));
      }.bind(this));
    },

    unbind: function() {
      $(this._handlerEl).off(this._eventNS);
    }
  };
});

/**
 * Abstract controller for the event flow managing which tab is showing in a tab panel
 *
 * @author Cheston Lee
 */

define('services/tab',[],function() {

  var service = {};

  service.ACTIVE_CLASS = 'tab-active';
  service.TAB_RELATION_ATTR = 'data-tab-related';

  /**
   * Take in a navigation element & tab content element
   * and make them active while disabling the previous active tab
   *
   * @param nav {HTMLElement} The <li> element representing the newly active tab
   * @param tab {HTMLElement} The <div> element representing the newly active tab content
   */
  service.activate = function(nav, tab) {
    var $nav = $(nav);
    var $tab = $(tab);

    if ($nav.hasClass(this.ACTIVE_CLASS)) {
      return;
    }

    var currActiveNav = $nav.siblings('.' + this.ACTIVE_CLASS);
    var currActiveTab = $tab.siblings('.' + this.ACTIVE_CLASS);

    if (currActiveNav.length === 1 && currActiveTab.length === 1) {
      currActiveNav.removeClass(this.ACTIVE_CLASS);
      currActiveTab.removeClass(this.ACTIVE_CLASS);
    }

    $nav.addClass(this.ACTIVE_CLASS);
    $tab.addClass(this.ACTIVE_CLASS);
  };

  return service;
});

/**
 * Tab directive to handle finding relationship between tabs & content and
 * activating nav/content elements.
 *
 * Relationships can be made via data attribute('data-tab-realted')
 * or by the order of the nav element and it's assoicated tab content block.
 *
 * Example of data attribute relationship
 *
 * <div v-tabs="tabsContainer2">
 *   <ul>
 *     <li class="tab-active" data-tab-related="two">Tab Two</li>
 *     <li data-tab-related="one">Tab One</li>
 *     <li data-tab-related="three">Tab Three</li>
 *   </ul>
 * </div>
 *
 *  <div class="lego-tab-content" id="tabsContainer2">
 *    <div class="tab-active" data-tab-related="one">One</div>
 *    <div data-tab-related="three">Three</div>
 *    <div data-tab-related="two">Two</div>
 *  </div>
 *
 * Example of order based relationship
 *
 *   <div v-tabs="tabsContainer">
 *    <ul>
 *      <li class="tab-active">Tab One</li>
 *      <li>Tab Two</li>
 *      <li>Tab Three</li>
 *    </ul>
 *  </div>
 *
 *  <div id="tabsContainer">
 *    <div class="tab-active">One</div>
 *    <div>Two</div>
 *    <div>Three</div>
 *  </div>
 *
 * @author Cheston Lee
 */

define('directives/tabs',['services/tab'],function() {
  var tabService = require('services/tab');

  return {
    isEmpty: true,
    bind: function() {

      this.tabContainer = $('#' + this.expression);

      if (this.tabContainer.length === 0) {
        return;
      }

      $(this.el).on('click', function(e) {
        var tab = null;
        var $el = $(this.el);
        var $target = $(e.target);
        var relation = $target.attr(tabService.TAB_RELATION_ATTR);

        if (relation)  {
          tab = this.tabContainer.children('div[' + tabService.TAB_RELATION_ATTR + '=' + relation + ']')[0];
        } else {
          //Determine the target's position in the nav list in order to 'show'
          //the proper tab.
          var lis = $.makeArray($el.find('li'));
          var idx = lis.indexOf(e.target);

          // Bail if we cannot find the list item
          if (idx === -1) {
            return;
          }
          tab = this.tabContainer.children('div')[idx];
       }

       tabService.activate(e.target, tab);

      }.bind(this));
    }
  };
});

/**
 * value directive that provides a 1-way data binding
 *
 * @author Cheston Lee
 */
define('directives/value',[],function() {
  return function(val) {
    this.el.value = val;
  }
});

/**
 * This file exports a map of directive ids to directive definitions
 *
 * All global directives should be defined here
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('directives',['require','directives/accordion','directives/disabled','directives/draggable','directives/drag_container','directives/drag_data','directives/drop_target','directives/dropdown','directives/editable_text','directives/element_slide','directives/experiment_edit_link','directives/farbtastic','directives/relative_date','directives/spinner','directives/geotargeting_label','directives/help_tooltip','directives/hide_dialog','directives/highlight_input','directives/lego_disabled','directives/loading','directives/loading_entity','directives/loading_hide','directives/loading_show','directives/poptip','directives/prevent_shift_selection','directives/push_state','directives/resizable','directives/rearrange','directives/slide_manager','directives/spectrum','directives/sticky','directives/tabs','directives/value'],function(require) {
  /**
   * @var {Object} map of directive ids to their definitions
   *
   * File Naming Convention
   *
   * All directives ids must be hyphenated
   * ex: 'drop-target' woudl correspond to require('directives/drop_target') => src/www/optly/js/directives/drop_target.js
   *
   * Note: All javascript file names use underscores (_) and no hyphens (-) or camelCase
   *
   * Usage:
   * Directives are attached via <div v-{directiveid}>
   * <div v-dropdown></div>
   * or
   * <span v-drop-target="dropFn"></span>
   */
  return {
    'accordion': require('directives/accordion'),
    'disabled': require('directives/disabled'),
    'draggable': require('directives/draggable'),
    'drag-container': require('directives/drag_container'),
    'drag-data': require('directives/drag_data'),
    'drop-target': require('directives/drop_target'),
    'dropdown': require('directives/dropdown'),
    'editable-text': require('directives/editable_text'),
    'element-slide': require('directives/element_slide'),
    'experiment-edit-link': require('directives/experiment_edit_link'),
    'farbtastic': require('directives/farbtastic'),
    'relative-date': require('directives/relative_date'),
    'spinner' : require('directives/spinner'),
    'geotargeting-label': require('directives/geotargeting_label'),
    'help-tooltip': require('directives/help_tooltip'),
    'hide-dialog': require('directives/hide_dialog'),
    'highlight-input' : require('directives/highlight_input'),
    'lego-disabled' : require('directives/lego_disabled'),
    'loading' : require('directives/loading'),
    'loading-entity' : require('directives/loading_entity'),
    'loading-hide' : require('directives/loading_hide'),
    'loading-show' : require('directives/loading_show'),
    'poptip' : require('directives/poptip'),
    'prevent-shift-selection' : require('directives/prevent_shift_selection'),
    'push-state' : require('directives/push_state'),
    'resizable' : require('directives/resizable'),
    'rearrange' : require('directives/rearrange'),
    'slide-manager': require('directives/slide_manager'),
    'spectrum': require('directives/spectrum'),
    'sticky': require('directives/sticky'),
    'tabs': require('directives/tabs'),
    'value': require('directives/value'),
  };
});

/**
 * Format a description into HTML with links and hashtags activated
 *
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('filters/format_description',['utils/regex'],function() {
  var regex = require('utils/regex');

  return function(text) {
    var html = text
      .replace(/\n/g, '<br />')
      .replace(regex.urls, '<a href="$&" target="_blank">$&</a>')
      .replace(regex.hashtags, '<a class="hashtag" href="javascript:void(0)">$&</a>');
    return html;
  };
});

/**
 * Filter for formatting time from a date string
 *
 * @author Asa Schachar (asa@optimizely.com)
 */
define('filters/format_time',[],function() {
  return function(dateString) {
    return (new Date(dateString)).toLocaleTimeString();
  };
});

define('filters/join',[],function() {
  /**
   * Join multiple strings into one using the specified delimiter.
   * @param {Array} value an array of strings to concatenate
   * @param {String} delimiter delimiter used to concatenate strings, default to ', '
   * @return {String}
   */
  return function(value, delimiter) {
    delimiter = (delimiter !== undefined) ? delimiter : ', ';
    return value.join(delimiter);
  };
});

define('filters/list_to_readable_string',['require'],function(require) {
  /**
   * Converts an array list of items to a human readable list:
   *  Example:
   *    Input : [ 1, 2, 3 ]
   *    Output: 1, 2, and 3
   *
   * @param {Array} list
   * @return {String}
   */
  return function(list) {
    var string = ''
    var num_items = list.length;
    if (num_items > 0) {
      list = list.map(function (element, index) {
        var isLastElement = (index === num_items - 1);

        // Append commas to the end of every element except for the last
        if (num_items > 2 && !isLastElement) {
          element = element + ',';

        // Prepend 'and ' to the last element in the array
        } else if (num_items >= 2 && isLastElement) {
          element = 'and ' + element;
        }

        return element;
      });

      string = list.join(' ');
    }

    return string;
  };

});

/**
 * Filter for formatting numbers with commas
 */
define('filters/number_with_commas',['require','exports','module'],function(require, exports, module) {
  module.exports = function(val) {
    if (!_.isNumber(val) && !_.isString(val)) {
      return val;
    }

    if (_.isNumber(val)) {
      val = val.toString();
    }

    return val.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
});

/**
 * Filter for dates to be simplified.
 *
 * Used on the Tokens page
 * @author Cheston Lee
 */
define('filters/shortdate',[],function() {
  return function(value) {
    return formatShortDate(new Date(value));
  };
});

/**
 * A filter to convert a variation point value to a percentage
 * used to display traffic allocation points on a variation
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('filters/traffic_allocation_percentage',['require','exports','module','utils/basis','filters/percentage'],function(require, exports, module) {
  var basis = require('utils/basis');
  var percentage = require('filters/percentage');

  module.exports = function(val) {
    return percentage(basis.toFloat(val), 2);
  }
})
;
define('filters/truncate',['require'],function(require) {

  /**
   * Truncates string and adds ellipses. Must be used in v-html for &hellip; to be escaped.
   * @param {String} value
   * @param {Integer} length
   * @return {String}
   */
  return function(value, length) {
    if (value.length > length){
      return value.substring(0, length) + "...";
    }
    return value;
  };

});
/**
 * @author Jon Noronha (jon.noronha@optimizely.com)
 */
define('filters/wrap_tag',['require','lodash'],function(require) {

  var _ = require('lodash');

  /**
   * Wrap all the elements in a list with an HTML tag.
   * Also accepts "double-quote" to wrap in double quotes instead
   * @param {Array} list
   * @param {String} tag
   * @return {Array}
   */
  return function(list, tag) {
    var out = _.map(list, function(elt) {
      if (elt != null) {
        if (tag == 'double-quote') {
          return sprintf('"%s"', elt);
        } else {
          return sprintf('<%s>%s</%s>', tag, elt, tag);
        }
      }
      return elt;
    });
    return out;
  }
});

/**
 * This file exports a map of the vue filters
 *
 * Define all filters in this file.
 *
 * @author Cheston Lee (cheston@optimizely.com)
 */
define('filters',['require','filters/activity_string','filters/format_date','filters/format_description','filters/format_time','filters/join','filters/list_to_readable_string','filters/number_with_commas','filters/percentage','filters/relative_date','filters/shortdate','filters/traffic_allocation_percentage','filters/truncate','filters/wrap_tag'],function(require) {
  /**
   * @var {Object} map of directive filters to their definitions
   */
  return {
    'activity-string': require('filters/activity_string'),
    'format-date': require('filters/format_date'),
    'format-description': require('filters/format_description'),
    'format-time': require('filters/format_time'),
    'join': require('filters/join'),
    'list-to-readable-string': require('filters/list_to_readable_string'),
    'number-with-commas': require('filters/number_with_commas'),
    'percentage': require('filters/percentage'),
    'relative-date' : require('filters/relative_date'),
    'shortdate': require('filters/shortdate'),
    'traffic-allocation-percentage': require('filters/traffic_allocation_percentage'),
    'truncate': require('filters/truncate'),
    'wrap-tag': require('filters/wrap_tag'),
  };
});


define('text!partials/drag_handle.html',[],function () { return '<span class="drag-handle">\n  <svg viewBox="0 0 10 20" version="1.1" xmlns="http://www.w3.org/2000/svg" style="fill: #d5d5d5;">\n    <circle cx="3.25" cy="4.75" r="1"></circle>\n    <circle cx="6.75" cy="4.75" r="1"></circle>\n    <circle cx="3.25" cy="8.25" r="1"></circle>\n    <circle cx="6.75" cy="8.25" r="1"></circle>\n    <circle cx="3.25" cy="11.75" r="1"></circle>\n    <circle cx="6.75" cy="11.75" r="1"></circle>\n    <circle cx="3.25" cy="15.25" r="1"></circle>\n    <circle cx="6.75" cy="15.25" r="1"></circle>\n  </svg>\n</span>\n';});

/**
 * This file exports a map of vue partial (templates) ids to an html string
 *
 * All global partials should be defined here
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('partials',['require','text!partials/drag_handle.html'],function(require) {
  /**
   * @var {Object} map of directive ids to their definitions
   *
   * File Naming Convention
   *
   * All partial ids should be hyphenated
   *
   * Note: All javascript file names use underscores (_) and no hyphens (-) or camelCase
   *
   * Usage:
   * [[> my-partial ]]
   */
  return {
    'drag-handle': require('text!partials/drag_handle.html')
  };
});

/**
 * This is where all vue components/directives/filters/effects/partials get
 * registered in a map that is passed to the document level Vue ViewModel
 * in bundle/page.js
 *
 * The two main entry points are `app` and `app_config`.  `app` by itself does not
 * include any other modules besides Vue.  All dependencies should go through `app_config`
 *
 * @author Jordan Garcia (jordan@optimizely.com)
 */
define('app_config',['require','exports','module','facades','routes','flux/config','components','directives','filters','partials'],function(require, exports, module) {
  Vue.config({
    // use `[[ prop ]]` style delimiters since django uses {{
    delimiters: ['[', ']']
  });

  // Facades are not registered with the document level Vue Model and should never be referenced from
  // our Vue framework. However, as the facades rely on Vue and are bundled into the app_bundle package,
  // we have to require them for dependency resolution.
  require('facades');

  return {
    // account info needs to be available when the app starts
    accountInfo: module.config()['account_info'],
    routes: require('routes'),
    flux: require('flux/config'),
    vue: {
      component: require('components'),
      directive: require('directives'),
      filter: require('filters'),
      partial: require('partials')
    }
  };
});

/**
 * The main requirejs entry point, it set requirejs.config
 * and exposes a function to run the app on page ready
 */
if (window.optlyConfig && window.optlyConfig.requirejs_module_config) {
  // take the config json passed down the server and load
  // into requirejs module configs
  requirejs.config({
    config: window.optlyConfig.requirejs_module_config
  });
}

window.optlyRunApp = function() {
  require(['app', 'app_config', 'flux'], function(app, appConfig, flux) {
    app.run(appConfig)
    window.webapp = {
      flux: flux,
      app: app,
    }
    return app;
  }, null, true); // require this synchronously
};

window.optlyRunApp();

var Router = require('utils/page');
Router('/projects/2097891184');

var mountComponent = require('routing/mount_component')

window.flux = window.webapp.flux;
window.actionTypes = require('flux/constants/action_types');

window.webapp.router = Router;

window.webapp.mountComponent = function(selector, componentId) {
  mountComponent(window.webapp.app, selector, componentId)();
};

window.webapp.unmountComponent = function(selector) {
  var mountedComponent = $(selector).data('mountedComponent');
  if (mountedComponent) {
    $(selector).removeData('mountedComponent');
    // we want to mount a different component
    mountedComponent.instance.$destroy();
  }
};

define("main", function(){});


window.optly.Cleanse.finish();
if (window.optlyOnLoad) {
  window.optlyOnLoad();
  delete window.optlyOnLoad;
}
})();

